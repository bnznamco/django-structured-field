(function () {
  'use strict';

  function makeMap(str, expectsLowerCase) {
    const set = new Set(str.split(","));
    return expectsLowerCase ? (val) => set.has(val.toLowerCase()) : (val) => set.has(val);
  }

  const EMPTY_OBJ = {};
  const EMPTY_ARR = [];
  const NOOP = () => {
  };
  const NO = () => false;
  const isOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // uppercase letter
  (key.charCodeAt(2) > 122 || key.charCodeAt(2) < 97);
  const isModelListener = (key) => key.startsWith("onUpdate:");
  const extend = Object.assign;
  const remove = (arr, el) => {
    const i = arr.indexOf(el);
    if (i > -1) {
      arr.splice(i, 1);
    }
  };
  const hasOwnProperty$d = Object.prototype.hasOwnProperty;
  const hasOwn = (val, key) => hasOwnProperty$d.call(val, key);
  const isArray$2 = Array.isArray;
  const isMap = (val) => toTypeString(val) === "[object Map]";
  const isSet = (val) => toTypeString(val) === "[object Set]";
  const isFunction$1 = (val) => typeof val === "function";
  const isString = (val) => typeof val === "string";
  const isSymbol$1 = (val) => typeof val === "symbol";
  const isObject$1 = (val) => val !== null && typeof val === "object";
  const isPromise = (val) => {
    return (isObject$1(val) || isFunction$1(val)) && isFunction$1(val.then) && isFunction$1(val.catch);
  };
  const objectToString$1 = Object.prototype.toString;
  const toTypeString = (value) => objectToString$1.call(value);
  const toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
  const isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  const isReservedProp = /* @__PURE__ */ makeMap(
    // the leading comma is intentional so empty string "" is also included
    ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
  );
  const cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  const camelizeRE = /-(\w)/g;
  const camelize = cacheStringFunction((str) => {
    return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : "");
  });
  const hyphenateRE = /\B([A-Z])/g;
  const hyphenate = cacheStringFunction(
    (str) => str.replace(hyphenateRE, "-$1").toLowerCase()
  );
  const capitalize$1 = cacheStringFunction((str) => {
    return str.charAt(0).toUpperCase() + str.slice(1);
  });
  const toHandlerKey = cacheStringFunction((str) => {
    const s = str ? `on${capitalize$1(str)}` : ``;
    return s;
  });
  const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
  const invokeArrayFns = (fns, arg) => {
    for (let i = 0; i < fns.length; i++) {
      fns[i](arg);
    }
  };
  const def = (obj, key, value) => {
    Object.defineProperty(obj, key, {
      configurable: true,
      enumerable: false,
      value
    });
  };
  const looseToNumber = (val) => {
    const n = parseFloat(val);
    return isNaN(n) ? val : n;
  };
  const toNumber$1 = (val) => {
    const n = isString(val) ? Number(val) : NaN;
    return isNaN(n) ? val : n;
  };
  let _globalThis;
  const getGlobalThis = () => {
    return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
  };

  function normalizeStyle(value) {
    if (isArray$2(value)) {
      const res = {};
      for (let i = 0; i < value.length; i++) {
        const item = value[i];
        const normalized = isString(item) ? parseStringStyle(item) : normalizeStyle(item);
        if (normalized) {
          for (const key in normalized) {
            res[key] = normalized[key];
          }
        }
      }
      return res;
    } else if (isString(value) || isObject$1(value)) {
      return value;
    }
  }
  const listDelimiterRE = /;(?![^(]*\))/g;
  const propertyDelimiterRE = /:([^]+)/;
  const styleCommentRE = /\/\*[^]*?\*\//g;
  function parseStringStyle(cssText) {
    const ret = {};
    cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
      if (item) {
        const tmp = item.split(propertyDelimiterRE);
        tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
      }
    });
    return ret;
  }
  function normalizeClass(value) {
    let res = "";
    if (isString(value)) {
      res = value;
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        const normalized = normalizeClass(value[i]);
        if (normalized) {
          res += normalized + " ";
        }
      }
    } else if (isObject$1(value)) {
      for (const name in value) {
        if (value[name]) {
          res += name + " ";
        }
      }
    }
    return res.trim();
  }

  const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
  const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
  function includeBooleanAttr(value) {
    return !!value || value === "";
  }

  const toDisplayString = (val) => {
    return isString(val) ? val : val == null ? "" : isArray$2(val) || isObject$1(val) && (val.toString === objectToString$1 || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
  };
  const replacer = (_key, val) => {
    if (val && val.__v_isRef) {
      return replacer(_key, val.value);
    } else if (isMap(val)) {
      return {
        [`Map(${val.size})`]: [...val.entries()].reduce(
          (entries, [key, val2], i) => {
            entries[stringifySymbol(key, i) + " =>"] = val2;
            return entries;
          },
          {}
        )
      };
    } else if (isSet(val)) {
      return {
        [`Set(${val.size})`]: [...val.values()].map((v) => stringifySymbol(v))
      };
    } else if (isSymbol$1(val)) {
      return stringifySymbol(val);
    } else if (isObject$1(val) && !isArray$2(val) && !isPlainObject$1(val)) {
      return String(val);
    }
    return val;
  };
  const stringifySymbol = (v, i = "") => {
    var _a;
    return isSymbol$1(v) ? `Symbol(${(_a = v.description) != null ? _a : i})` : v;
  };

  let activeEffectScope;
  class EffectScope {
    constructor(detached = false) {
      this.detached = detached;
      /**
       * @internal
       */
      this._active = true;
      /**
       * @internal
       */
      this.effects = [];
      /**
       * @internal
       */
      this.cleanups = [];
      this.parent = activeEffectScope;
      if (!detached && activeEffectScope) {
        this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(
          this
        ) - 1;
      }
    }
    get active() {
      return this._active;
    }
    run(fn) {
      if (this._active) {
        const currentEffectScope = activeEffectScope;
        try {
          activeEffectScope = this;
          return fn();
        } finally {
          activeEffectScope = currentEffectScope;
        }
      }
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    on() {
      activeEffectScope = this;
    }
    /**
     * This should only be called on non-detached scopes
     * @internal
     */
    off() {
      activeEffectScope = this.parent;
    }
    stop(fromParent) {
      if (this._active) {
        let i, l;
        for (i = 0, l = this.effects.length; i < l; i++) {
          this.effects[i].stop();
        }
        for (i = 0, l = this.cleanups.length; i < l; i++) {
          this.cleanups[i]();
        }
        if (this.scopes) {
          for (i = 0, l = this.scopes.length; i < l; i++) {
            this.scopes[i].stop(true);
          }
        }
        if (!this.detached && this.parent && !fromParent) {
          const last = this.parent.scopes.pop();
          if (last && last !== this) {
            this.parent.scopes[this.index] = last;
            last.index = this.index;
          }
        }
        this.parent = void 0;
        this._active = false;
      }
    }
  }
  function recordEffectScope(effect, scope = activeEffectScope) {
    if (scope && scope.active) {
      scope.effects.push(effect);
    }
  }
  function getCurrentScope() {
    return activeEffectScope;
  }

  let activeEffect;
  class ReactiveEffect {
    constructor(fn, trigger, scheduler, scope) {
      this.fn = fn;
      this.trigger = trigger;
      this.scheduler = scheduler;
      this.active = true;
      this.deps = [];
      /**
       * @internal
       */
      this._dirtyLevel = 3;
      /**
       * @internal
       */
      this._trackId = 0;
      /**
       * @internal
       */
      this._runnings = 0;
      /**
       * @internal
       */
      this._queryings = 0;
      /**
       * @internal
       */
      this._depsLength = 0;
      recordEffectScope(this, scope);
    }
    get dirty() {
      if (this._dirtyLevel === 1) {
        this._dirtyLevel = 0;
        this._queryings++;
        pauseTracking();
        for (const dep of this.deps) {
          if (dep.computed) {
            triggerComputed(dep.computed);
            if (this._dirtyLevel >= 2) {
              break;
            }
          }
        }
        resetTracking();
        this._queryings--;
      }
      return this._dirtyLevel >= 2;
    }
    set dirty(v) {
      this._dirtyLevel = v ? 3 : 0;
    }
    run() {
      this._dirtyLevel = 0;
      if (!this.active) {
        return this.fn();
      }
      let lastShouldTrack = shouldTrack;
      let lastEffect = activeEffect;
      try {
        shouldTrack = true;
        activeEffect = this;
        this._runnings++;
        preCleanupEffect(this);
        return this.fn();
      } finally {
        postCleanupEffect(this);
        this._runnings--;
        activeEffect = lastEffect;
        shouldTrack = lastShouldTrack;
      }
    }
    stop() {
      var _a;
      if (this.active) {
        preCleanupEffect(this);
        postCleanupEffect(this);
        (_a = this.onStop) == null ? void 0 : _a.call(this);
        this.active = false;
      }
    }
  }
  function triggerComputed(computed) {
    return computed.value;
  }
  function preCleanupEffect(effect2) {
    effect2._trackId++;
    effect2._depsLength = 0;
  }
  function postCleanupEffect(effect2) {
    if (effect2.deps && effect2.deps.length > effect2._depsLength) {
      for (let i = effect2._depsLength; i < effect2.deps.length; i++) {
        cleanupDepEffect(effect2.deps[i], effect2);
      }
      effect2.deps.length = effect2._depsLength;
    }
  }
  function cleanupDepEffect(dep, effect2) {
    const trackId = dep.get(effect2);
    if (trackId !== void 0 && effect2._trackId !== trackId) {
      dep.delete(effect2);
      if (dep.size === 0) {
        dep.cleanup();
      }
    }
  }
  let shouldTrack = true;
  let pauseScheduleStack = 0;
  const trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function pauseScheduling() {
    pauseScheduleStack++;
  }
  function resetScheduling() {
    pauseScheduleStack--;
    while (!pauseScheduleStack && queueEffectSchedulers.length) {
      queueEffectSchedulers.shift()();
    }
  }
  function trackEffect(effect2, dep, debuggerEventExtraInfo) {
    if (dep.get(effect2) !== effect2._trackId) {
      dep.set(effect2, effect2._trackId);
      const oldDep = effect2.deps[effect2._depsLength];
      if (oldDep !== dep) {
        if (oldDep) {
          cleanupDepEffect(oldDep, effect2);
        }
        effect2.deps[effect2._depsLength++] = dep;
      } else {
        effect2._depsLength++;
      }
    }
  }
  const queueEffectSchedulers = [];
  function triggerEffects(dep, dirtyLevel, debuggerEventExtraInfo) {
    pauseScheduling();
    for (const effect2 of dep.keys()) {
      if (!effect2.allowRecurse && effect2._runnings) {
        continue;
      }
      if (effect2._dirtyLevel < dirtyLevel && (!effect2._runnings || dirtyLevel !== 2)) {
        const lastDirtyLevel = effect2._dirtyLevel;
        effect2._dirtyLevel = dirtyLevel;
        if (lastDirtyLevel === 0 && (!effect2._queryings || dirtyLevel !== 2)) {
          effect2.trigger();
          if (effect2.scheduler) {
            queueEffectSchedulers.push(effect2.scheduler);
          }
        }
      }
    }
    resetScheduling();
  }

  const createDep = (cleanup, computed) => {
    const dep = /* @__PURE__ */ new Map();
    dep.cleanup = cleanup;
    dep.computed = computed;
    return dep;
  };

  const targetMap = /* @__PURE__ */ new WeakMap();
  const ITERATE_KEY = Symbol("");
  const MAP_KEY_ITERATE_KEY = Symbol("");
  function track(target, type, key) {
    if (shouldTrack && activeEffect) {
      let depsMap = targetMap.get(target);
      if (!depsMap) {
        targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
      }
      let dep = depsMap.get(key);
      if (!dep) {
        depsMap.set(key, dep = createDep(() => depsMap.delete(key)));
      }
      trackEffect(
        activeEffect,
        dep);
    }
  }
  function trigger$1(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    let deps = [];
    if (type === "clear") {
      deps = [...depsMap.values()];
    } else if (key === "length" && isArray$2(target)) {
      const newLength = Number(newValue);
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || !isSymbol$1(key2) && key2 >= newLength) {
          deps.push(dep);
        }
      });
    } else {
      if (key !== void 0) {
        deps.push(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            deps.push(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray$2(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            deps.push(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    pauseScheduling();
    for (const dep of deps) {
      if (dep) {
        triggerEffects(
          dep,
          3);
      }
    }
    resetScheduling();
  }
  function getDepFromReactive(object, key) {
    var _a;
    return (_a = targetMap.get(object)) == null ? void 0 : _a.get(key);
  }

  const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  const builtInSymbols = new Set(
    /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol$1)
  );
  const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        pauseScheduling();
        const res = toRaw(this)[key].apply(this, args);
        resetScheduling();
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function hasOwnProperty$c(key) {
    const obj = toRaw(this);
    track(obj, "has", key);
    return obj.hasOwnProperty(key);
  }
  class BaseReactiveHandler {
    constructor(_isReadonly = false, _shallow = false) {
      this._isReadonly = _isReadonly;
      this._shallow = _shallow;
    }
    get(target, key, receiver) {
      const isReadonly2 = this._isReadonly, shallow = this._shallow;
      if (key === "__v_isReactive") {
        return !isReadonly2;
      } else if (key === "__v_isReadonly") {
        return isReadonly2;
      } else if (key === "__v_isShallow") {
        return shallow;
      } else if (key === "__v_raw") {
        if (receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target) || // receiver is not the reactive proxy, but has the same prototype
        // this means the reciever is a user proxy of the reactive proxy
        Object.getPrototypeOf(target) === Object.getPrototypeOf(receiver)) {
          return target;
        }
        return;
      }
      const targetIsArray = isArray$2(target);
      if (!isReadonly2) {
        if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
          return Reflect.get(arrayInstrumentations, key, receiver);
        }
        if (key === "hasOwnProperty") {
          return hasOwnProperty$c;
        }
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol$1(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly2) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        return targetIsArray && isIntegerKey(key) ? res : res.value;
      }
      if (isObject$1(res)) {
        return isReadonly2 ? readonly(res) : reactive(res);
      }
      return res;
    }
  }
  class MutableReactiveHandler extends BaseReactiveHandler {
    constructor(shallow = false) {
      super(false, shallow);
    }
    set(target, key, value, receiver) {
      let oldValue = target[key];
      if (!this._shallow) {
        const isOldValueReadonly = isReadonly(oldValue);
        if (!isShallow(value) && !isReadonly(value)) {
          oldValue = toRaw(oldValue);
          value = toRaw(value);
        }
        if (!isArray$2(target) && isRef(oldValue) && !isRef(value)) {
          if (isOldValueReadonly) {
            return false;
          } else {
            oldValue.value = value;
            return true;
          }
        }
      }
      const hadKey = isArray$2(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger$1(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger$1(target, "set", key, value);
        }
      }
      return result;
    }
    deleteProperty(target, key) {
      const hadKey = hasOwn(target, key);
      target[key];
      const result = Reflect.deleteProperty(target, key);
      if (result && hadKey) {
        trigger$1(target, "delete", key, void 0);
      }
      return result;
    }
    has(target, key) {
      const result = Reflect.has(target, key);
      if (!isSymbol$1(key) || !builtInSymbols.has(key)) {
        track(target, "has", key);
      }
      return result;
    }
    ownKeys(target) {
      track(
        target,
        "iterate",
        isArray$2(target) ? "length" : ITERATE_KEY
      );
      return Reflect.ownKeys(target);
    }
  }
  class ReadonlyReactiveHandler extends BaseReactiveHandler {
    constructor(shallow = false) {
      super(true, shallow);
    }
    set(target, key) {
      return true;
    }
    deleteProperty(target, key) {
      return true;
    }
  }
  const mutableHandlers = /* @__PURE__ */ new MutableReactiveHandler();
  const readonlyHandlers = /* @__PURE__ */ new ReadonlyReactiveHandler();
  const shallowReactiveHandlers = /* @__PURE__ */ new MutableReactiveHandler(
    true
  );

  const toShallow = (value) => value;
  const getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "get", key);
      }
      track(rawTarget, "get", rawKey);
    }
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has(key, isReadonly = false) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (!isReadonly) {
      if (hasChanged(key, rawKey)) {
        track(rawTarget, "has", key);
      }
      track(rawTarget, "has", rawKey);
    }
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size$1(target, isReadonly = false) {
    target = target["__v_raw"];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger$1(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    const oldValue = get2.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger$1(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger$1(target, "set", key, value);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get2 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    }
    get2 ? get2.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger$1(target, "delete", key, void 0);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const result = target.clear();
    if (hadItems) {
      trigger$1(target, "clear", void 0, void 0);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed["__v_raw"];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this["__v_raw"];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(
        rawTarget,
        "iterate",
        isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY
      );
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      return type === "delete" ? false : type === "clear" ? void 0 : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size$1(this);
      },
      has,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size$1(this);
      },
      has,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size$1(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size$1(this, true);
      },
      has(key) {
        return has.call(this, key, true);
      },
      add: createReadonlyMethod("add"),
      set: createReadonlyMethod("set"),
      delete: createReadonlyMethod("delete"),
      clear: createReadonlyMethod("clear"),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(
        method,
        false,
        false
      );
      readonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        false
      );
      shallowInstrumentations2[method] = createIterableMethod(
        method,
        false,
        true
      );
      shallowReadonlyInstrumentations2[method] = createIterableMethod(
        method,
        true,
        true
      );
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  const [
    mutableInstrumentations,
    readonlyInstrumentations,
    shallowInstrumentations,
    shallowReadonlyInstrumentations
  ] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(
        hasOwn(instrumentations, key) && key in target ? instrumentations : target,
        key,
        receiver
      );
    };
  }
  const mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  const shallowCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, true)
  };
  const readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };

  const reactiveMap = /* @__PURE__ */ new WeakMap();
  const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  const readonlyMap = /* @__PURE__ */ new WeakMap();
  const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1 /* COMMON */;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2 /* COLLECTION */;
      default:
        return 0 /* INVALID */;
    }
  }
  function getTargetType(value) {
    return value["__v_skip"] || !Object.isExtensible(value) ? 0 /* INVALID */ : targetTypeMap(toRawType(value));
  }
  function reactive(target) {
    if (isReadonly(target)) {
      return target;
    }
    return createReactiveObject(
      target,
      false,
      mutableHandlers,
      mutableCollectionHandlers,
      reactiveMap
    );
  }
  function shallowReactive(target) {
    return createReactiveObject(
      target,
      false,
      shallowReactiveHandlers,
      shallowCollectionHandlers,
      shallowReactiveMap
    );
  }
  function readonly(target) {
    return createReactiveObject(
      target,
      true,
      readonlyHandlers,
      readonlyCollectionHandlers,
      readonlyMap
    );
  }
  function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject$1(target)) {
      return target;
    }
    if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0 /* INVALID */) {
      return target;
    }
    const proxy = new Proxy(
      target,
      targetType === 2 /* COLLECTION */ ? collectionHandlers : baseHandlers
    );
    proxyMap.set(target, proxy);
    return proxy;
  }
  function isReactive(value) {
    if (isReadonly(value)) {
      return isReactive(value["__v_raw"]);
    }
    return !!(value && value["__v_isReactive"]);
  }
  function isReadonly(value) {
    return !!(value && value["__v_isReadonly"]);
  }
  function isShallow(value) {
    return !!(value && value["__v_isShallow"]);
  }
  function isProxy(value) {
    return isReactive(value) || isReadonly(value);
  }
  function toRaw(observed) {
    const raw = observed && observed["__v_raw"];
    return raw ? toRaw(raw) : observed;
  }
  function markRaw(value) {
    def(value, "__v_skip", true);
    return value;
  }
  const toReactive = (value) => isObject$1(value) ? reactive(value) : value;
  const toReadonly = (value) => isObject$1(value) ? readonly(value) : value;

  class ComputedRefImpl {
    constructor(getter, _setter, isReadonly, isSSR) {
      this._setter = _setter;
      this.dep = void 0;
      this.__v_isRef = true;
      this["__v_isReadonly"] = false;
      this.effect = new ReactiveEffect(
        () => getter(this._value),
        () => triggerRefValue(this, 1)
      );
      this.effect.computed = this;
      this.effect.active = this._cacheable = !isSSR;
      this["__v_isReadonly"] = isReadonly;
    }
    get value() {
      const self = toRaw(this);
      trackRefValue(self);
      if (!self._cacheable || self.effect.dirty) {
        if (hasChanged(self._value, self._value = self.effect.run())) {
          triggerRefValue(self, 2);
        }
      }
      return self._value;
    }
    set value(newValue) {
      this._setter(newValue);
    }
    // #region polyfill _dirty for backward compatibility third party code for Vue <= 3.3.x
    get _dirty() {
      return this.effect.dirty;
    }
    set _dirty(v) {
      this.effect.dirty = v;
    }
    // #endregion
  }
  function computed$1(getterOrOptions, debugOptions, isSSR = false) {
    let getter;
    let setter;
    const onlyGetter = isFunction$1(getterOrOptions);
    if (onlyGetter) {
      getter = getterOrOptions;
      setter = NOOP;
    } else {
      getter = getterOrOptions.get;
      setter = getterOrOptions.set;
    }
    const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
    return cRef;
  }

  function trackRefValue(ref2) {
    if (shouldTrack && activeEffect) {
      ref2 = toRaw(ref2);
      trackEffect(
        activeEffect,
        ref2.dep || (ref2.dep = createDep(
          () => ref2.dep = void 0,
          ref2 instanceof ComputedRefImpl ? ref2 : void 0
        )));
    }
  }
  function triggerRefValue(ref2, dirtyLevel = 3, newVal) {
    ref2 = toRaw(ref2);
    const dep = ref2.dep;
    if (dep) {
      triggerEffects(
        dep,
        dirtyLevel);
    }
  }
  function isRef(r) {
    return !!(r && r.__v_isRef === true);
  }
  function ref(value) {
    return createRef(value, false);
  }
  function shallowRef(value) {
    return createRef(value, true);
  }
  function createRef(rawValue, shallow) {
    if (isRef(rawValue)) {
      return rawValue;
    }
    return new RefImpl(rawValue, shallow);
  }
  class RefImpl {
    constructor(value, __v_isShallow) {
      this.__v_isShallow = __v_isShallow;
      this.dep = void 0;
      this.__v_isRef = true;
      this._rawValue = __v_isShallow ? value : toRaw(value);
      this._value = __v_isShallow ? value : toReactive(value);
    }
    get value() {
      trackRefValue(this);
      return this._value;
    }
    set value(newVal) {
      const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
      newVal = useDirectValue ? newVal : toRaw(newVal);
      if (hasChanged(newVal, this._rawValue)) {
        this._rawValue = newVal;
        this._value = useDirectValue ? newVal : toReactive(newVal);
        triggerRefValue(this, 3);
      }
    }
  }
  function unref(ref2) {
    return isRef(ref2) ? ref2.value : ref2;
  }
  const shallowUnwrapHandlers = {
    get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
    set: (target, key, value, receiver) => {
      const oldValue = target[key];
      if (isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      } else {
        return Reflect.set(target, key, value, receiver);
      }
    }
  };
  function proxyRefs(objectWithRefs) {
    return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
  }
  class ObjectRefImpl {
    constructor(_object, _key, _defaultValue) {
      this._object = _object;
      this._key = _key;
      this._defaultValue = _defaultValue;
      this.__v_isRef = true;
    }
    get value() {
      const val = this._object[this._key];
      return val === void 0 ? this._defaultValue : val;
    }
    set value(newVal) {
      this._object[this._key] = newVal;
    }
    get dep() {
      return getDepFromReactive(toRaw(this._object), this._key);
    }
  }
  class GetterRefImpl {
    constructor(_getter) {
      this._getter = _getter;
      this.__v_isRef = true;
      this.__v_isReadonly = true;
    }
    get value() {
      return this._getter();
    }
  }
  function toRef(source, key, defaultValue) {
    if (isRef(source)) {
      return source;
    } else if (isFunction$1(source)) {
      return new GetterRefImpl(source);
    } else if (isObject$1(source) && arguments.length > 1) {
      return propertyToRef(source, key, defaultValue);
    } else {
      return ref(source);
    }
  }
  function propertyToRef(source, key, defaultValue) {
    const val = source[key];
    return isRef(val) ? val : new ObjectRefImpl(source, key, defaultValue);
  }

  const stack$1 = [];
  function warn$1$1(msg, ...args) {
    pauseTracking();
    const instance = stack$1.length ? stack$1[stack$1.length - 1].component : null;
    const appWarnHandler = instance && instance.appContext.config.warnHandler;
    const trace = getComponentTrace();
    if (appWarnHandler) {
      callWithErrorHandling(
        appWarnHandler,
        instance,
        11,
        [
          msg + args.join(""),
          instance && instance.proxy,
          trace.map(
            ({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`
          ).join("\n"),
          trace
        ]
      );
    } else {
      const warnArgs = [`[Vue warn]: ${msg}`, ...args];
      if (trace.length && // avoid spamming console during tests
      true) {
        warnArgs.push(`
`, ...formatTrace(trace));
      }
      console.warn(...warnArgs);
    }
    resetTracking();
  }
  function getComponentTrace() {
    let currentVNode = stack$1[stack$1.length - 1];
    if (!currentVNode) {
      return [];
    }
    const normalizedStack = [];
    while (currentVNode) {
      const last = normalizedStack[0];
      if (last && last.vnode === currentVNode) {
        last.recurseCount++;
      } else {
        normalizedStack.push({
          vnode: currentVNode,
          recurseCount: 0
        });
      }
      const parentInstance = currentVNode.component && currentVNode.component.parent;
      currentVNode = parentInstance && parentInstance.vnode;
    }
    return normalizedStack;
  }
  function formatTrace(trace) {
    const logs = [];
    trace.forEach((entry, i) => {
      logs.push(...i === 0 ? [] : [`
`], ...formatTraceEntry(entry));
    });
    return logs;
  }
  function formatTraceEntry({ vnode, recurseCount }) {
    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;
    const isRoot = vnode.component ? vnode.component.parent == null : false;
    const open = ` at <${formatComponentName(
    vnode.component,
    vnode.type,
    isRoot
  )}`;
    const close = `>` + postfix;
    return vnode.props ? [open, ...formatProps(vnode.props), close] : [open + close];
  }
  function formatProps(props) {
    const res = [];
    const keys = Object.keys(props);
    keys.slice(0, 3).forEach((key) => {
      res.push(...formatProp(key, props[key]));
    });
    if (keys.length > 3) {
      res.push(` ...`);
    }
    return res;
  }
  function formatProp(key, value, raw) {
    if (isString(value)) {
      value = JSON.stringify(value);
      return raw ? value : [`${key}=${value}`];
    } else if (typeof value === "number" || typeof value === "boolean" || value == null) {
      return raw ? value : [`${key}=${value}`];
    } else if (isRef(value)) {
      value = formatProp(key, toRaw(value.value), true);
      return raw ? value : [`${key}=Ref<`, value, `>`];
    } else if (isFunction$1(value)) {
      return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];
    } else {
      value = toRaw(value);
      return raw ? value : [`${key}=`, value];
    }
  }
  function callWithErrorHandling(fn, instance, type, args) {
    let res;
    try {
      res = args ? fn(...args) : fn();
    } catch (err) {
      handleError(err, instance, type);
    }
    return res;
  }
  function callWithAsyncErrorHandling(fn, instance, type, args) {
    if (isFunction$1(fn)) {
      const res = callWithErrorHandling(fn, instance, type, args);
      if (res && isPromise(res)) {
        res.catch((err) => {
          handleError(err, instance, type);
        });
      }
      return res;
    }
    const values = [];
    for (let i = 0; i < fn.length; i++) {
      values.push(callWithAsyncErrorHandling(fn[i], instance, type, args));
    }
    return values;
  }
  function handleError(err, instance, type, throwInDev = true) {
    const contextVNode = instance ? instance.vnode : null;
    if (instance) {
      let cur = instance.parent;
      const exposedInstance = instance.proxy;
      const errorInfo = `https://vuejs.org/errors/#runtime-${type}`;
      while (cur) {
        const errorCapturedHooks = cur.ec;
        if (errorCapturedHooks) {
          for (let i = 0; i < errorCapturedHooks.length; i++) {
            if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {
              return;
            }
          }
        }
        cur = cur.parent;
      }
      const appErrorHandler = instance.appContext.config.errorHandler;
      if (appErrorHandler) {
        callWithErrorHandling(
          appErrorHandler,
          null,
          10,
          [err, exposedInstance, errorInfo]
        );
        return;
      }
    }
    logError(err, type, contextVNode, throwInDev);
  }
  function logError(err, type, contextVNode, throwInDev = true) {
    {
      console.error(err);
    }
  }

  let isFlushing = false;
  let isFlushPending = false;
  const queue = [];
  let flushIndex = 0;
  const pendingPostFlushCbs = [];
  let activePostFlushCbs = null;
  let postFlushIndex = 0;
  const resolvedPromise = /* @__PURE__ */ Promise.resolve();
  let currentFlushPromise = null;
  function nextTick(fn) {
    const p = currentFlushPromise || resolvedPromise;
    return fn ? p.then(this ? fn.bind(this) : fn) : p;
  }
  function findInsertionIndex(id) {
    let start = flushIndex + 1;
    let end = queue.length;
    while (start < end) {
      const middle = start + end >>> 1;
      const middleJob = queue[middle];
      const middleJobId = getId(middleJob);
      if (middleJobId < id || middleJobId === id && middleJob.pre) {
        start = middle + 1;
      } else {
        end = middle;
      }
    }
    return start;
  }
  function queueJob(job) {
    if (!queue.length || !queue.includes(
      job,
      isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex
    )) {
      if (job.id == null) {
        queue.push(job);
      } else {
        queue.splice(findInsertionIndex(job.id), 0, job);
      }
      queueFlush();
    }
  }
  function queueFlush() {
    if (!isFlushing && !isFlushPending) {
      isFlushPending = true;
      currentFlushPromise = resolvedPromise.then(flushJobs);
    }
  }
  function invalidateJob(job) {
    const i = queue.indexOf(job);
    if (i > flushIndex) {
      queue.splice(i, 1);
    }
  }
  function queuePostFlushCb(cb) {
    if (!isArray$2(cb)) {
      if (!activePostFlushCbs || !activePostFlushCbs.includes(
        cb,
        cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex
      )) {
        pendingPostFlushCbs.push(cb);
      }
    } else {
      pendingPostFlushCbs.push(...cb);
    }
    queueFlush();
  }
  function flushPreFlushCbs(instance, seen, i = isFlushing ? flushIndex + 1 : 0) {
    for (; i < queue.length; i++) {
      const cb = queue[i];
      if (cb && cb.pre) {
        if (instance && cb.id !== instance.uid) {
          continue;
        }
        queue.splice(i, 1);
        i--;
        cb();
      }
    }
  }
  function flushPostFlushCbs(seen) {
    if (pendingPostFlushCbs.length) {
      const deduped = [...new Set(pendingPostFlushCbs)];
      pendingPostFlushCbs.length = 0;
      if (activePostFlushCbs) {
        activePostFlushCbs.push(...deduped);
        return;
      }
      activePostFlushCbs = deduped;
      activePostFlushCbs.sort((a, b) => getId(a) - getId(b));
      for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
        activePostFlushCbs[postFlushIndex]();
      }
      activePostFlushCbs = null;
      postFlushIndex = 0;
    }
  }
  const getId = (job) => job.id == null ? Infinity : job.id;
  const comparator = (a, b) => {
    const diff = getId(a) - getId(b);
    if (diff === 0) {
      if (a.pre && !b.pre)
        return -1;
      if (b.pre && !a.pre)
        return 1;
    }
    return diff;
  };
  function flushJobs(seen) {
    isFlushPending = false;
    isFlushing = true;
    queue.sort(comparator);
    const check = NOOP;
    try {
      for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
        const job = queue[flushIndex];
        if (job && job.active !== false) {
          if (!!("production" !== "production") && check(job)) ;
          callWithErrorHandling(job, null, 14);
        }
      }
    } finally {
      flushIndex = 0;
      queue.length = 0;
      flushPostFlushCbs();
      isFlushing = false;
      currentFlushPromise = null;
      if (queue.length || pendingPostFlushCbs.length) {
        flushJobs();
      }
    }
  }

  function emit(instance, event, ...rawArgs) {
    if (instance.isUnmounted)
      return;
    const props = instance.vnode.props || EMPTY_OBJ;
    let args = rawArgs;
    const isModelListener = event.startsWith("update:");
    const modelArg = isModelListener && event.slice(7);
    if (modelArg && modelArg in props) {
      const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
      const { number, trim } = props[modifiersKey] || EMPTY_OBJ;
      if (trim) {
        args = rawArgs.map((a) => isString(a) ? a.trim() : a);
      }
      if (number) {
        args = rawArgs.map(looseToNumber);
      }
    }
    let handlerName;
    let handler = props[handlerName = toHandlerKey(event)] || // also try camelCase event handler (#2249)
    props[handlerName = toHandlerKey(camelize(event))];
    if (!handler && isModelListener) {
      handler = props[handlerName = toHandlerKey(hyphenate(event))];
    }
    if (handler) {
      callWithAsyncErrorHandling(
        handler,
        instance,
        6,
        args
      );
    }
    const onceHandler = props[handlerName + `Once`];
    if (onceHandler) {
      if (!instance.emitted) {
        instance.emitted = {};
      } else if (instance.emitted[handlerName]) {
        return;
      }
      instance.emitted[handlerName] = true;
      callWithAsyncErrorHandling(
        onceHandler,
        instance,
        6,
        args
      );
    }
  }
  function normalizeEmitsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.emitsCache;
    const cached = cache.get(comp);
    if (cached !== void 0) {
      return cached;
    }
    const raw = comp.emits;
    let normalized = {};
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction$1(comp)) {
      const extendEmits = (raw2) => {
        const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
        if (normalizedFromExtend) {
          hasExtends = true;
          extend(normalized, normalizedFromExtend);
        }
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendEmits);
      }
      if (comp.extends) {
        extendEmits(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendEmits);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, null);
      }
      return null;
    }
    if (isArray$2(raw)) {
      raw.forEach((key) => normalized[key] = null);
    } else {
      extend(normalized, raw);
    }
    if (isObject$1(comp)) {
      cache.set(comp, normalized);
    }
    return normalized;
  }
  function isEmitListener(options, key) {
    if (!options || !isOn(key)) {
      return false;
    }
    key = key.slice(2).replace(/Once$/, "");
    return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
  }

  let currentRenderingInstance = null;
  let currentScopeId = null;
  function setCurrentRenderingInstance(instance) {
    const prev = currentRenderingInstance;
    currentRenderingInstance = instance;
    currentScopeId = instance && instance.type.__scopeId || null;
    return prev;
  }
  function withCtx(fn, ctx = currentRenderingInstance, isNonScopedSlot) {
    if (!ctx)
      return fn;
    if (fn._n) {
      return fn;
    }
    const renderFnWithContext = (...args) => {
      if (renderFnWithContext._d) {
        setBlockTracking(-1);
      }
      const prevInstance = setCurrentRenderingInstance(ctx);
      let res;
      try {
        res = fn(...args);
      } finally {
        setCurrentRenderingInstance(prevInstance);
        if (renderFnWithContext._d) {
          setBlockTracking(1);
        }
      }
      return res;
    };
    renderFnWithContext._n = true;
    renderFnWithContext._c = true;
    renderFnWithContext._d = true;
    return renderFnWithContext;
  }
  function markAttrsAccessed() {
  }
  function renderComponentRoot(instance) {
    const {
      type: Component,
      vnode,
      proxy,
      withProxy,
      props,
      propsOptions: [propsOptions],
      slots,
      attrs,
      emit,
      render,
      renderCache,
      data,
      setupState,
      ctx,
      inheritAttrs
    } = instance;
    let result;
    let fallthroughAttrs;
    const prev = setCurrentRenderingInstance(instance);
    try {
      if (vnode.shapeFlag & 4) {
        const proxyToUse = withProxy || proxy;
        const thisProxy = !!("production" !== "production") && setupState.__isScriptSetup ? new Proxy(proxyToUse, {
          get(target, key, receiver) {
            warn$1$1(
              `Property '${String(
              key
            )}' was accessed via 'this'. Avoid using 'this' in templates.`
            );
            return Reflect.get(target, key, receiver);
          }
        }) : proxyToUse;
        result = normalizeVNode(
          render.call(
            thisProxy,
            proxyToUse,
            renderCache,
            props,
            setupState,
            data,
            ctx
          )
        );
        fallthroughAttrs = attrs;
      } else {
        const render2 = Component;
        if (!!("production" !== "production") && attrs === props) ;
        result = normalizeVNode(
          render2.length > 1 ? render2(
            props,
            !!("production" !== "production") ? {
              get attrs() {
                markAttrsAccessed();
                return attrs;
              },
              slots,
              emit
            } : { attrs, slots, emit }
          ) : render2(
            props,
            null
            /* we know it doesn't need it */
          )
        );
        fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
      }
    } catch (err) {
      blockStack.length = 0;
      handleError(err, instance, 1);
      result = createVNode(Comment);
    }
    let root = result;
    if (fallthroughAttrs && inheritAttrs !== false) {
      const keys = Object.keys(fallthroughAttrs);
      const { shapeFlag } = root;
      if (keys.length) {
        if (shapeFlag & (1 | 6)) {
          if (propsOptions && keys.some(isModelListener)) {
            fallthroughAttrs = filterModelListeners(
              fallthroughAttrs,
              propsOptions
            );
          }
          root = cloneVNode(root, fallthroughAttrs);
        }
      }
    }
    if (vnode.dirs) {
      root = cloneVNode(root);
      root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
    }
    if (vnode.transition) {
      root.transition = vnode.transition;
    }
    {
      result = root;
    }
    setCurrentRenderingInstance(prev);
    return result;
  }
  const getFunctionalFallthrough = (attrs) => {
    let res;
    for (const key in attrs) {
      if (key === "class" || key === "style" || isOn(key)) {
        (res || (res = {}))[key] = attrs[key];
      }
    }
    return res;
  };
  const filterModelListeners = (attrs, props) => {
    const res = {};
    for (const key in attrs) {
      if (!isModelListener(key) || !(key.slice(9) in props)) {
        res[key] = attrs[key];
      }
    }
    return res;
  };
  function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
    const { props: prevProps, children: prevChildren, component } = prevVNode;
    const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
    const emits = component.emitsOptions;
    if (nextVNode.dirs || nextVNode.transition) {
      return true;
    }
    if (optimized && patchFlag >= 0) {
      if (patchFlag & 1024) {
        return true;
      }
      if (patchFlag & 16) {
        if (!prevProps) {
          return !!nextProps;
        }
        return hasPropsChanged(prevProps, nextProps, emits);
      } else if (patchFlag & 8) {
        const dynamicProps = nextVNode.dynamicProps;
        for (let i = 0; i < dynamicProps.length; i++) {
          const key = dynamicProps[i];
          if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
            return true;
          }
        }
      }
    } else {
      if (prevChildren || nextChildren) {
        if (!nextChildren || !nextChildren.$stable) {
          return true;
        }
      }
      if (prevProps === nextProps) {
        return false;
      }
      if (!prevProps) {
        return !!nextProps;
      }
      if (!nextProps) {
        return true;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    }
    return false;
  }
  function hasPropsChanged(prevProps, nextProps, emitsOptions) {
    const nextKeys = Object.keys(nextProps);
    if (nextKeys.length !== Object.keys(prevProps).length) {
      return true;
    }
    for (let i = 0; i < nextKeys.length; i++) {
      const key = nextKeys[i];
      if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
        return true;
      }
    }
    return false;
  }
  function updateHOCHostEl({ vnode, parent }, el) {
    if (!el)
      return;
    while (parent) {
      const root = parent.subTree;
      if (root.suspense && root.suspense.activeBranch === vnode) {
        root.el = vnode.el;
      }
      if (root === vnode) {
        (vnode = parent.vnode).el = el;
        parent = parent.parent;
      } else {
        break;
      }
    }
  }

  const COMPONENTS = "components";
  function resolveComponent(name, maybeSelfReference) {
    return resolveAsset(COMPONENTS, name, true, maybeSelfReference) || name;
  }
  const NULL_DYNAMIC_COMPONENT = Symbol.for("v-ndc");
  function resolveAsset(type, name, warnMissing = true, maybeSelfReference = false) {
    const instance = currentRenderingInstance || currentInstance;
    if (instance) {
      const Component = instance.type;
      if (type === COMPONENTS) {
        const selfName = getComponentName(
          Component,
          false
        );
        if (selfName && (selfName === name || selfName === camelize(name) || selfName === capitalize$1(camelize(name)))) {
          return Component;
        }
      }
      const res = (
        // local registration
        // check instance[type] first which is resolved for options API
        resolve(instance[type] || Component[type], name) || // global registration
        resolve(instance.appContext[type], name)
      );
      if (!res && maybeSelfReference) {
        return Component;
      }
      return res;
    }
  }
  function resolve(registry, name) {
    return registry && (registry[name] || registry[camelize(name)] || registry[capitalize$1(camelize(name))]);
  }

  const isSuspense = (type) => type.__isSuspense;
  function queueEffectWithSuspense(fn, suspense) {
    if (suspense && suspense.pendingBranch) {
      if (isArray$2(fn)) {
        suspense.effects.push(...fn);
      } else {
        suspense.effects.push(fn);
      }
    } else {
      queuePostFlushCb(fn);
    }
  }

  function watchEffect(effect, options) {
    return doWatch(effect, null, options);
  }
  const INITIAL_WATCHER_VALUE = {};
  function watch(source, cb, options) {
    return doWatch(source, cb, options);
  }
  function doWatch(source, cb, {
    immediate,
    deep,
    flush,
    once,
    onTrack,
    onTrigger
  } = EMPTY_OBJ) {
    var _a;
    if (cb && once) {
      const _cb = cb;
      cb = (...args) => {
        _cb(...args);
        unwatch();
      };
    }
    const instance = getCurrentScope() === ((_a = currentInstance) == null ? void 0 : _a.scope) ? currentInstance : null;
    let getter;
    let forceTrigger = false;
    let isMultiSource = false;
    if (isRef(source)) {
      getter = () => source.value;
      forceTrigger = isShallow(source);
    } else if (isReactive(source)) {
      getter = () => source;
      deep = true;
    } else if (isArray$2(source)) {
      isMultiSource = true;
      forceTrigger = source.some((s) => isReactive(s) || isShallow(s));
      getter = () => source.map((s) => {
        if (isRef(s)) {
          return s.value;
        } else if (isReactive(s)) {
          return traverse$1(s);
        } else if (isFunction$1(s)) {
          return callWithErrorHandling(s, instance, 2);
        } else ;
      });
    } else if (isFunction$1(source)) {
      if (cb) {
        getter = () => callWithErrorHandling(source, instance, 2);
      } else {
        getter = () => {
          if (instance && instance.isUnmounted) {
            return;
          }
          if (cleanup) {
            cleanup();
          }
          return callWithAsyncErrorHandling(
            source,
            instance,
            3,
            [onCleanup]
          );
        };
      }
    } else {
      getter = NOOP;
    }
    if (cb && deep) {
      const baseGetter = getter;
      getter = () => traverse$1(baseGetter());
    }
    let cleanup;
    let onCleanup = (fn) => {
      cleanup = effect.onStop = () => {
        callWithErrorHandling(fn, instance, 4);
        cleanup = effect.onStop = void 0;
      };
    };
    let ssrCleanup;
    if (isInSSRComponentSetup) {
      onCleanup = NOOP;
      if (!cb) {
        getter();
      } else if (immediate) {
        callWithAsyncErrorHandling(cb, instance, 3, [
          getter(),
          isMultiSource ? [] : void 0,
          onCleanup
        ]);
      }
      if (flush === "sync") {
        const ctx = useSSRContext();
        ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
      } else {
        return NOOP;
      }
    }
    let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
    const job = () => {
      if (!effect.active || !effect.dirty) {
        return;
      }
      if (cb) {
        const newValue = effect.run();
        if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i) => hasChanged(v, oldValue[i])) : hasChanged(newValue, oldValue)) || false) {
          if (cleanup) {
            cleanup();
          }
          callWithAsyncErrorHandling(cb, instance, 3, [
            newValue,
            // pass undefined as the old value when it's changed for the first time
            oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
            onCleanup
          ]);
          oldValue = newValue;
        }
      } else {
        effect.run();
      }
    };
    job.allowRecurse = !!cb;
    let scheduler;
    if (flush === "sync") {
      scheduler = job;
    } else if (flush === "post") {
      scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
    } else {
      job.pre = true;
      if (instance)
        job.id = instance.uid;
      scheduler = () => queueJob(job);
    }
    const effect = new ReactiveEffect(getter, NOOP, scheduler);
    const unwatch = () => {
      effect.stop();
      if (instance && instance.scope) {
        remove(instance.scope.effects, effect);
      }
    };
    if (cb) {
      if (immediate) {
        job();
      } else {
        oldValue = effect.run();
      }
    } else if (flush === "post") {
      queuePostRenderEffect(
        effect.run.bind(effect),
        instance && instance.suspense
      );
    } else {
      effect.run();
    }
    if (ssrCleanup)
      ssrCleanup.push(unwatch);
    return unwatch;
  }
  function instanceWatch(source, value, options) {
    const publicThis = this.proxy;
    const getter = isString(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
    let cb;
    if (isFunction$1(value)) {
      cb = value;
    } else {
      cb = value.handler;
      options = value;
    }
    const cur = currentInstance;
    setCurrentInstance(this);
    const res = doWatch(getter, cb.bind(publicThis), options);
    if (cur) {
      setCurrentInstance(cur);
    } else {
      unsetCurrentInstance();
    }
    return res;
  }
  function createPathGetter(ctx, path) {
    const segments = path.split(".");
    return () => {
      let cur = ctx;
      for (let i = 0; i < segments.length && cur; i++) {
        cur = cur[segments[i]];
      }
      return cur;
    };
  }
  function traverse$1(value, seen) {
    if (!isObject$1(value) || value["__v_skip"]) {
      return value;
    }
    seen = seen || /* @__PURE__ */ new Set();
    if (seen.has(value)) {
      return value;
    }
    seen.add(value);
    if (isRef(value)) {
      traverse$1(value.value, seen);
    } else if (isArray$2(value)) {
      for (let i = 0; i < value.length; i++) {
        traverse$1(value[i], seen);
      }
    } else if (isSet(value) || isMap(value)) {
      value.forEach((v) => {
        traverse$1(v, seen);
      });
    } else if (isPlainObject$1(value)) {
      for (const key in value) {
        traverse$1(value[key], seen);
      }
    }
    return value;
  }
  function withDirectives(vnode, directives) {
    const internalInstance = currentRenderingInstance;
    if (internalInstance === null) {
      return vnode;
    }
    const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
    const bindings = vnode.dirs || (vnode.dirs = []);
    for (let i = 0; i < directives.length; i++) {
      let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i];
      if (dir) {
        if (isFunction$1(dir)) {
          dir = {
            mounted: dir,
            updated: dir
          };
        }
        if (dir.deep) {
          traverse$1(value);
        }
        bindings.push({
          dir,
          instance,
          value,
          oldValue: void 0,
          arg,
          modifiers
        });
      }
    }
    return vnode;
  }
  function invokeDirectiveHook(vnode, prevVNode, instance, name) {
    const bindings = vnode.dirs;
    const oldBindings = prevVNode && prevVNode.dirs;
    for (let i = 0; i < bindings.length; i++) {
      const binding = bindings[i];
      if (oldBindings) {
        binding.oldValue = oldBindings[i].value;
      }
      let hook = binding.dir[name];
      if (hook) {
        pauseTracking();
        callWithAsyncErrorHandling(hook, instance, 8, [
          vnode.el,
          binding,
          vnode,
          prevVNode
        ]);
        resetTracking();
      }
    }
  }

  const leaveCbKey = Symbol("_leaveCb");
  const enterCbKey$1 = Symbol("_enterCb");
  function useTransitionState() {
    const state = {
      isMounted: false,
      isLeaving: false,
      isUnmounting: false,
      leavingVNodes: /* @__PURE__ */ new Map()
    };
    onMounted(() => {
      state.isMounted = true;
    });
    onBeforeUnmount(() => {
      state.isUnmounting = true;
    });
    return state;
  }
  const TransitionHookValidator = [Function, Array];
  const BaseTransitionPropsValidators = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    // enter
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    // leave
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    // appear
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  };
  const BaseTransitionImpl = {
    name: `BaseTransition`,
    props: BaseTransitionPropsValidators,
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevTransitionKey;
      return () => {
        const children = slots.default && getTransitionRawChildren(slots.default(), true);
        if (!children || !children.length) {
          return;
        }
        let child = children[0];
        if (children.length > 1) {
          for (const c of children) {
            if (c.type !== Comment) {
              child = c;
              break;
            }
          }
        }
        const rawProps = toRaw(props);
        const { mode } = rawProps;
        if (state.isLeaving) {
          return emptyPlaceholder(child);
        }
        const innerChild = getKeepAliveChild(child);
        if (!innerChild) {
          return emptyPlaceholder(child);
        }
        const enterHooks = resolveTransitionHooks(
          innerChild,
          rawProps,
          state,
          instance
        );
        setTransitionHooks(innerChild, enterHooks);
        const oldChild = instance.subTree;
        const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
        let transitionKeyChanged = false;
        const { getTransitionKey } = innerChild.type;
        if (getTransitionKey) {
          const key = getTransitionKey();
          if (prevTransitionKey === void 0) {
            prevTransitionKey = key;
          } else if (key !== prevTransitionKey) {
            prevTransitionKey = key;
            transitionKeyChanged = true;
          }
        }
        if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
          const leavingHooks = resolveTransitionHooks(
            oldInnerChild,
            rawProps,
            state,
            instance
          );
          setTransitionHooks(oldInnerChild, leavingHooks);
          if (mode === "out-in") {
            state.isLeaving = true;
            leavingHooks.afterLeave = () => {
              state.isLeaving = false;
              if (instance.update.active !== false) {
                instance.effect.dirty = true;
                instance.update();
              }
            };
            return emptyPlaceholder(child);
          } else if (mode === "in-out" && innerChild.type !== Comment) {
            leavingHooks.delayLeave = (el, earlyRemove, delayedLeave) => {
              const leavingVNodesCache = getLeavingNodesForType(
                state,
                oldInnerChild
              );
              leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
              el[leaveCbKey] = () => {
                earlyRemove();
                el[leaveCbKey] = void 0;
                delete enterHooks.delayedLeave;
              };
              enterHooks.delayedLeave = delayedLeave;
            };
          }
        }
        return child;
      };
    }
  };
  const BaseTransition = BaseTransitionImpl;
  function getLeavingNodesForType(state, vnode) {
    const { leavingVNodes } = state;
    let leavingVNodesCache = leavingVNodes.get(vnode.type);
    if (!leavingVNodesCache) {
      leavingVNodesCache = /* @__PURE__ */ Object.create(null);
      leavingVNodes.set(vnode.type, leavingVNodesCache);
    }
    return leavingVNodesCache;
  }
  function resolveTransitionHooks(vnode, props, state, instance) {
    const {
      appear,
      mode,
      persisted = false,
      onBeforeEnter,
      onEnter,
      onAfterEnter,
      onEnterCancelled,
      onBeforeLeave,
      onLeave,
      onAfterLeave,
      onLeaveCancelled,
      onBeforeAppear,
      onAppear,
      onAfterAppear,
      onAppearCancelled
    } = props;
    const key = String(vnode.key);
    const leavingVNodesCache = getLeavingNodesForType(state, vnode);
    const callHook = (hook, args) => {
      hook && callWithAsyncErrorHandling(
        hook,
        instance,
        9,
        args
      );
    };
    const callAsyncHook = (hook, args) => {
      const done = args[1];
      callHook(hook, args);
      if (isArray$2(hook)) {
        if (hook.every((hook2) => hook2.length <= 1))
          done();
      } else if (hook.length <= 1) {
        done();
      }
    };
    const hooks = {
      mode,
      persisted,
      beforeEnter(el) {
        let hook = onBeforeEnter;
        if (!state.isMounted) {
          if (appear) {
            hook = onBeforeAppear || onBeforeEnter;
          } else {
            return;
          }
        }
        if (el[leaveCbKey]) {
          el[leaveCbKey](
            true
            /* cancelled */
          );
        }
        const leavingVNode = leavingVNodesCache[key];
        if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el[leaveCbKey]) {
          leavingVNode.el[leaveCbKey]();
        }
        callHook(hook, [el]);
      },
      enter(el) {
        let hook = onEnter;
        let afterHook = onAfterEnter;
        let cancelHook = onEnterCancelled;
        if (!state.isMounted) {
          if (appear) {
            hook = onAppear || onEnter;
            afterHook = onAfterAppear || onAfterEnter;
            cancelHook = onAppearCancelled || onEnterCancelled;
          } else {
            return;
          }
        }
        let called = false;
        const done = el[enterCbKey$1] = (cancelled) => {
          if (called)
            return;
          called = true;
          if (cancelled) {
            callHook(cancelHook, [el]);
          } else {
            callHook(afterHook, [el]);
          }
          if (hooks.delayedLeave) {
            hooks.delayedLeave();
          }
          el[enterCbKey$1] = void 0;
        };
        if (hook) {
          callAsyncHook(hook, [el, done]);
        } else {
          done();
        }
      },
      leave(el, remove) {
        const key2 = String(vnode.key);
        if (el[enterCbKey$1]) {
          el[enterCbKey$1](
            true
            /* cancelled */
          );
        }
        if (state.isUnmounting) {
          return remove();
        }
        callHook(onBeforeLeave, [el]);
        let called = false;
        const done = el[leaveCbKey] = (cancelled) => {
          if (called)
            return;
          called = true;
          remove();
          if (cancelled) {
            callHook(onLeaveCancelled, [el]);
          } else {
            callHook(onAfterLeave, [el]);
          }
          el[leaveCbKey] = void 0;
          if (leavingVNodesCache[key2] === vnode) {
            delete leavingVNodesCache[key2];
          }
        };
        leavingVNodesCache[key2] = vnode;
        if (onLeave) {
          callAsyncHook(onLeave, [el, done]);
        } else {
          done();
        }
      },
      clone(vnode2) {
        return resolveTransitionHooks(vnode2, props, state, instance);
      }
    };
    return hooks;
  }
  function emptyPlaceholder(vnode) {
    if (isKeepAlive(vnode)) {
      vnode = cloneVNode(vnode);
      vnode.children = null;
      return vnode;
    }
  }
  function getKeepAliveChild(vnode) {
    return isKeepAlive(vnode) ? (
      // #7121 ensure get the child component subtree in case
      // it's been replaced during HMR
      vnode.children ? vnode.children[0] : void 0
    ) : vnode;
  }
  function setTransitionHooks(vnode, hooks) {
    if (vnode.shapeFlag & 6 && vnode.component) {
      setTransitionHooks(vnode.component.subTree, hooks);
    } else if (vnode.shapeFlag & 128) {
      vnode.ssContent.transition = hooks.clone(vnode.ssContent);
      vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
    } else {
      vnode.transition = hooks;
    }
  }
  function getTransitionRawChildren(children, keepComment = false, parentKey) {
    let ret = [];
    let keyedFragmentCount = 0;
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i);
      if (child.type === Fragment) {
        if (child.patchFlag & 128)
          keyedFragmentCount++;
        ret = ret.concat(
          getTransitionRawChildren(child.children, keepComment, key)
        );
      } else if (keepComment || child.type !== Comment) {
        ret.push(key != null ? cloneVNode(child, { key }) : child);
      }
    }
    if (keyedFragmentCount > 1) {
      for (let i = 0; i < ret.length; i++) {
        ret[i].patchFlag = -2;
      }
    }
    return ret;
  }

  /*! #__NO_SIDE_EFFECTS__ */
  // @__NO_SIDE_EFFECTS__
  function defineComponent(options, extraOptions) {
    return isFunction$1(options) ? (
      // #8326: extend call and options.name access are considered side-effects
      // by Rollup, so we have to wrap it in a pure-annotated IIFE.
      /* @__PURE__ */ (() => extend({ name: options.name }, extraOptions, { setup: options }))()
    ) : options;
  }

  const isAsyncWrapper = (i) => !!i.type.__asyncLoader;

  const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
  function onActivated(hook, target) {
    registerKeepAliveHook(hook, "a", target);
  }
  function onDeactivated(hook, target) {
    registerKeepAliveHook(hook, "da", target);
  }
  function registerKeepAliveHook(hook, type, target = currentInstance) {
    const wrappedHook = hook.__wdc || (hook.__wdc = () => {
      let current = target;
      while (current) {
        if (current.isDeactivated) {
          return;
        }
        current = current.parent;
      }
      return hook();
    });
    injectHook(type, wrappedHook, target);
    if (target) {
      let current = target.parent;
      while (current && current.parent) {
        if (isKeepAlive(current.parent.vnode)) {
          injectToKeepAliveRoot(wrappedHook, type, target, current);
        }
        current = current.parent;
      }
    }
  }
  function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
    const injected = injectHook(
      type,
      hook,
      keepAliveRoot,
      true
      /* prepend */
    );
    onUnmounted(() => {
      remove(keepAliveRoot[type], injected);
    }, target);
  }

  function injectHook(type, hook, target = currentInstance, prepend = false) {
    if (target) {
      const hooks = target[type] || (target[type] = []);
      const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
        if (target.isUnmounted) {
          return;
        }
        pauseTracking();
        setCurrentInstance(target);
        const res = callWithAsyncErrorHandling(hook, target, type, args);
        unsetCurrentInstance();
        resetTracking();
        return res;
      });
      if (prepend) {
        hooks.unshift(wrappedHook);
      } else {
        hooks.push(wrappedHook);
      }
      return wrappedHook;
    }
  }
  const createHook = (lifecycle) => (hook, target = currentInstance) => (
    // post-create lifecycle registrations are noops during SSR (except for serverPrefetch)
    (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target)
  );
  const onBeforeMount = createHook("bm");
  const onMounted = createHook("m");
  const onBeforeUpdate = createHook("bu");
  const onUpdated = createHook("u");
  const onBeforeUnmount = createHook("bum");
  const onUnmounted = createHook("um");
  const onServerPrefetch = createHook("sp");
  const onRenderTriggered = createHook(
    "rtg"
  );
  const onRenderTracked = createHook(
    "rtc"
  );
  function onErrorCaptured(hook, target = currentInstance) {
    injectHook("ec", hook, target);
  }

  function renderList(source, renderItem, cache, index) {
    let ret;
    const cached = cache && cache[index];
    if (isArray$2(source) || isString(source)) {
      ret = new Array(source.length);
      for (let i = 0, l = source.length; i < l; i++) {
        ret[i] = renderItem(source[i], i, void 0, cached && cached[i]);
      }
    } else if (typeof source === "number") {
      ret = new Array(source);
      for (let i = 0; i < source; i++) {
        ret[i] = renderItem(i + 1, i, void 0, cached && cached[i]);
      }
    } else if (isObject$1(source)) {
      if (source[Symbol.iterator]) {
        ret = Array.from(
          source,
          (item, i) => renderItem(item, i, void 0, cached && cached[i])
        );
      } else {
        const keys = Object.keys(source);
        ret = new Array(keys.length);
        for (let i = 0, l = keys.length; i < l; i++) {
          const key = keys[i];
          ret[i] = renderItem(source[key], key, i, cached && cached[i]);
        }
      }
    } else {
      ret = [];
    }
    if (cache) {
      cache[index] = ret;
    }
    return ret;
  }

  function renderSlot(slots, name, props = {}, fallback, noSlotted) {
    if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
      if (name !== "default")
        props.name = name;
      return createVNode("slot", props, fallback && fallback());
    }
    let slot = slots[name];
    if (slot && slot._c) {
      slot._d = false;
    }
    openBlock();
    const validSlotContent = slot && ensureValidVNode$1(slot(props));
    const rendered = createBlock(
      Fragment,
      {
        key: props.key || // slot content array of a dynamic conditional slot may have a branch
        // key attached in the `createSlots` helper, respect that
        validSlotContent && validSlotContent.key || `_${name}`
      },
      validSlotContent || (fallback ? fallback() : []),
      validSlotContent && slots._ === 1 ? 64 : -2
    );
    if (!noSlotted && rendered.scopeId) {
      rendered.slotScopeIds = [rendered.scopeId + "-s"];
    }
    if (slot && slot._c) {
      slot._d = true;
    }
    return rendered;
  }
  function ensureValidVNode$1(vnodes) {
    return vnodes.some((child) => {
      if (!isVNode(child))
        return true;
      if (child.type === Comment)
        return false;
      if (child.type === Fragment && !ensureValidVNode$1(child.children))
        return false;
      return true;
    }) ? vnodes : null;
  }

  const getPublicInstance = (i) => {
    if (!i)
      return null;
    if (isStatefulComponent(i))
      return getExposeProxy(i) || i.proxy;
    return getPublicInstance(i.parent);
  };
  const publicPropertiesMap = (
    // Move PURE marker to new line to workaround compiler discarding it
    // due to type annotation
    /* @__PURE__ */ extend(/* @__PURE__ */ Object.create(null), {
      $: (i) => i,
      $el: (i) => i.vnode.el,
      $data: (i) => i.data,
      $props: (i) => i.props,
      $attrs: (i) => i.attrs,
      $slots: (i) => i.slots,
      $refs: (i) => i.refs,
      $parent: (i) => getPublicInstance(i.parent),
      $root: (i) => getPublicInstance(i.root),
      $emit: (i) => i.emit,
      $options: (i) => __VUE_OPTIONS_API__ ? resolveMergedOptions(i) : i.type,
      $forceUpdate: (i) => i.f || (i.f = () => {
        i.effect.dirty = true;
        queueJob(i.update);
      }),
      $nextTick: (i) => i.n || (i.n = nextTick.bind(i.proxy)),
      $watch: (i) => __VUE_OPTIONS_API__ ? instanceWatch.bind(i) : NOOP
    })
  );
  const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
  const PublicInstanceProxyHandlers = {
    get({ _: instance }, key) {
      const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
      let normalizedProps;
      if (key[0] !== "$") {
        const n = accessCache[key];
        if (n !== void 0) {
          switch (n) {
            case 1 /* SETUP */:
              return setupState[key];
            case 2 /* DATA */:
              return data[key];
            case 4 /* CONTEXT */:
              return ctx[key];
            case 3 /* PROPS */:
              return props[key];
          }
        } else if (hasSetupBinding(setupState, key)) {
          accessCache[key] = 1 /* SETUP */;
          return setupState[key];
        } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
          accessCache[key] = 2 /* DATA */;
          return data[key];
        } else if (
          // only cache other properties when instance has declared (thus stable)
          // props
          (normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)
        ) {
          accessCache[key] = 3 /* PROPS */;
          return props[key];
        } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
          accessCache[key] = 4 /* CONTEXT */;
          return ctx[key];
        } else if (!__VUE_OPTIONS_API__ || shouldCacheAccess) {
          accessCache[key] = 0 /* OTHER */;
        }
      }
      const publicGetter = publicPropertiesMap[key];
      let cssModule, globalProperties;
      if (publicGetter) {
        if (key === "$attrs") {
          track(instance, "get", key);
        }
        return publicGetter(instance);
      } else if (
        // css module (injected by vue-loader)
        (cssModule = type.__cssModules) && (cssModule = cssModule[key])
      ) {
        return cssModule;
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4 /* CONTEXT */;
        return ctx[key];
      } else if (
        // global properties
        globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)
      ) {
        {
          return globalProperties[key];
        }
      } else ;
    },
    set({ _: instance }, key, value) {
      const { data, setupState, ctx } = instance;
      if (hasSetupBinding(setupState, key)) {
        setupState[key] = value;
        return true;
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        data[key] = value;
        return true;
      } else if (hasOwn(instance.props, key)) {
        return false;
      }
      if (key[0] === "$" && key.slice(1) in instance) {
        return false;
      } else {
        {
          ctx[key] = value;
        }
      }
      return true;
    },
    has({
      _: { data, setupState, accessCache, ctx, appContext, propsOptions }
    }, key) {
      let normalizedProps;
      return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
    },
    defineProperty(target, key, descriptor) {
      if (descriptor.get != null) {
        target._.accessCache[key] = 0;
      } else if (hasOwn(descriptor, "value")) {
        this.set(target, key, descriptor.value, null);
      }
      return Reflect.defineProperty(target, key, descriptor);
    }
  };
  function normalizePropsOrEmits(props) {
    return isArray$2(props) ? props.reduce(
      (normalized, p) => (normalized[p] = null, normalized),
      {}
    ) : props;
  }
  let shouldCacheAccess = true;
  function applyOptions(instance) {
    const options = resolveMergedOptions(instance);
    const publicThis = instance.proxy;
    const ctx = instance.ctx;
    shouldCacheAccess = false;
    if (options.beforeCreate) {
      callHook$1(options.beforeCreate, instance, "bc");
    }
    const {
      // state
      data: dataOptions,
      computed: computedOptions,
      methods,
      watch: watchOptions,
      provide: provideOptions,
      inject: injectOptions,
      // lifecycle
      created,
      beforeMount,
      mounted,
      beforeUpdate,
      updated,
      activated,
      deactivated,
      beforeDestroy,
      beforeUnmount,
      destroyed,
      unmounted,
      render,
      renderTracked,
      renderTriggered,
      errorCaptured,
      serverPrefetch,
      // public API
      expose,
      inheritAttrs,
      // assets
      components,
      directives,
      filters
    } = options;
    const checkDuplicateProperties = null;
    if (injectOptions) {
      resolveInjections(injectOptions, ctx, checkDuplicateProperties);
    }
    if (methods) {
      for (const key in methods) {
        const methodHandler = methods[key];
        if (isFunction$1(methodHandler)) {
          {
            ctx[key] = methodHandler.bind(publicThis);
          }
        }
      }
    }
    if (dataOptions) {
      const data = dataOptions.call(publicThis, publicThis);
      if (!isObject$1(data)) ; else {
        instance.data = reactive(data);
      }
    }
    shouldCacheAccess = true;
    if (computedOptions) {
      for (const key in computedOptions) {
        const opt = computedOptions[key];
        const get = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
        const set = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
        const c = computed({
          get,
          set
        });
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => c.value,
          set: (v) => c.value = v
        });
      }
    }
    if (watchOptions) {
      for (const key in watchOptions) {
        createWatcher(watchOptions[key], ctx, publicThis, key);
      }
    }
    if (provideOptions) {
      const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
      Reflect.ownKeys(provides).forEach((key) => {
        provide(key, provides[key]);
      });
    }
    if (created) {
      callHook$1(created, instance, "c");
    }
    function registerLifecycleHook(register, hook) {
      if (isArray$2(hook)) {
        hook.forEach((_hook) => register(_hook.bind(publicThis)));
      } else if (hook) {
        register(hook.bind(publicThis));
      }
    }
    registerLifecycleHook(onBeforeMount, beforeMount);
    registerLifecycleHook(onMounted, mounted);
    registerLifecycleHook(onBeforeUpdate, beforeUpdate);
    registerLifecycleHook(onUpdated, updated);
    registerLifecycleHook(onActivated, activated);
    registerLifecycleHook(onDeactivated, deactivated);
    registerLifecycleHook(onErrorCaptured, errorCaptured);
    registerLifecycleHook(onRenderTracked, renderTracked);
    registerLifecycleHook(onRenderTriggered, renderTriggered);
    registerLifecycleHook(onBeforeUnmount, beforeUnmount);
    registerLifecycleHook(onUnmounted, unmounted);
    registerLifecycleHook(onServerPrefetch, serverPrefetch);
    if (isArray$2(expose)) {
      if (expose.length) {
        const exposed = instance.exposed || (instance.exposed = {});
        expose.forEach((key) => {
          Object.defineProperty(exposed, key, {
            get: () => publicThis[key],
            set: (val) => publicThis[key] = val
          });
        });
      } else if (!instance.exposed) {
        instance.exposed = {};
      }
    }
    if (render && instance.render === NOOP) {
      instance.render = render;
    }
    if (inheritAttrs != null) {
      instance.inheritAttrs = inheritAttrs;
    }
    if (components)
      instance.components = components;
    if (directives)
      instance.directives = directives;
  }
  function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP) {
    if (isArray$2(injectOptions)) {
      injectOptions = normalizeInject(injectOptions);
    }
    for (const key in injectOptions) {
      const opt = injectOptions[key];
      let injected;
      if (isObject$1(opt)) {
        if ("default" in opt) {
          injected = inject(
            opt.from || key,
            opt.default,
            true
          );
        } else {
          injected = inject(opt.from || key);
        }
      } else {
        injected = inject(opt);
      }
      if (isRef(injected)) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    }
  }
  function callHook$1(hook, instance, type) {
    callWithAsyncErrorHandling(
      isArray$2(hook) ? hook.map((h) => h.bind(instance.proxy)) : hook.bind(instance.proxy),
      instance,
      type
    );
  }
  function createWatcher(raw, ctx, publicThis, key) {
    const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
    if (isString(raw)) {
      const handler = ctx[raw];
      if (isFunction$1(handler)) {
        watch(getter, handler);
      }
    } else if (isFunction$1(raw)) {
      watch(getter, raw.bind(publicThis));
    } else if (isObject$1(raw)) {
      if (isArray$2(raw)) {
        raw.forEach((r) => createWatcher(r, ctx, publicThis, key));
      } else {
        const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
        if (isFunction$1(handler)) {
          watch(getter, handler, raw);
        }
      }
    } else ;
  }
  function resolveMergedOptions(instance) {
    const base = instance.type;
    const { mixins, extends: extendsOptions } = base;
    const {
      mixins: globalMixins,
      optionsCache: cache,
      config: { optionMergeStrategies }
    } = instance.appContext;
    const cached = cache.get(base);
    let resolved;
    if (cached) {
      resolved = cached;
    } else if (!globalMixins.length && !mixins && !extendsOptions) {
      {
        resolved = base;
      }
    } else {
      resolved = {};
      if (globalMixins.length) {
        globalMixins.forEach(
          (m) => mergeOptions(resolved, m, optionMergeStrategies, true)
        );
      }
      mergeOptions(resolved, base, optionMergeStrategies);
    }
    if (isObject$1(base)) {
      cache.set(base, resolved);
    }
    return resolved;
  }
  function mergeOptions(to, from, strats, asMixin = false) {
    const { mixins, extends: extendsOptions } = from;
    if (extendsOptions) {
      mergeOptions(to, extendsOptions, strats, true);
    }
    if (mixins) {
      mixins.forEach(
        (m) => mergeOptions(to, m, strats, true)
      );
    }
    for (const key in from) {
      if (asMixin && key === "expose") ; else {
        const strat = internalOptionMergeStrats[key] || strats && strats[key];
        to[key] = strat ? strat(to[key], from[key]) : from[key];
      }
    }
    return to;
  }
  const internalOptionMergeStrats = {
    data: mergeDataFn,
    props: mergeEmitsOrPropsOptions,
    emits: mergeEmitsOrPropsOptions,
    // objects
    methods: mergeObjectOptions,
    computed: mergeObjectOptions,
    // lifecycle
    beforeCreate: mergeAsArray,
    created: mergeAsArray,
    beforeMount: mergeAsArray,
    mounted: mergeAsArray,
    beforeUpdate: mergeAsArray,
    updated: mergeAsArray,
    beforeDestroy: mergeAsArray,
    beforeUnmount: mergeAsArray,
    destroyed: mergeAsArray,
    unmounted: mergeAsArray,
    activated: mergeAsArray,
    deactivated: mergeAsArray,
    errorCaptured: mergeAsArray,
    serverPrefetch: mergeAsArray,
    // assets
    components: mergeObjectOptions,
    directives: mergeObjectOptions,
    // watch
    watch: mergeWatchOptions,
    // provide / inject
    provide: mergeDataFn,
    inject: mergeInject
  };
  function mergeDataFn(to, from) {
    if (!from) {
      return to;
    }
    if (!to) {
      return from;
    }
    return function mergedDataFn() {
      return (extend)(
        isFunction$1(to) ? to.call(this, this) : to,
        isFunction$1(from) ? from.call(this, this) : from
      );
    };
  }
  function mergeInject(to, from) {
    return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
  }
  function normalizeInject(raw) {
    if (isArray$2(raw)) {
      const res = {};
      for (let i = 0; i < raw.length; i++) {
        res[raw[i]] = raw[i];
      }
      return res;
    }
    return raw;
  }
  function mergeAsArray(to, from) {
    return to ? [...new Set([].concat(to, from))] : from;
  }
  function mergeObjectOptions(to, from) {
    return to ? extend(/* @__PURE__ */ Object.create(null), to, from) : from;
  }
  function mergeEmitsOrPropsOptions(to, from) {
    if (to) {
      if (isArray$2(to) && isArray$2(from)) {
        return [.../* @__PURE__ */ new Set([...to, ...from])];
      }
      return extend(
        /* @__PURE__ */ Object.create(null),
        normalizePropsOrEmits(to),
        normalizePropsOrEmits(from != null ? from : {})
      );
    } else {
      return from;
    }
  }
  function mergeWatchOptions(to, from) {
    if (!to)
      return from;
    if (!from)
      return to;
    const merged = extend(/* @__PURE__ */ Object.create(null), to);
    for (const key in from) {
      merged[key] = mergeAsArray(to[key], from[key]);
    }
    return merged;
  }

  function createAppContext() {
    return {
      app: null,
      config: {
        isNativeTag: NO,
        performance: false,
        globalProperties: {},
        optionMergeStrategies: {},
        errorHandler: void 0,
        warnHandler: void 0,
        compilerOptions: {}
      },
      mixins: [],
      components: {},
      directives: {},
      provides: /* @__PURE__ */ Object.create(null),
      optionsCache: /* @__PURE__ */ new WeakMap(),
      propsCache: /* @__PURE__ */ new WeakMap(),
      emitsCache: /* @__PURE__ */ new WeakMap()
    };
  }
  let uid$1 = 0;
  function createAppAPI(render, hydrate) {
    return function createApp(rootComponent, rootProps = null) {
      if (!isFunction$1(rootComponent)) {
        rootComponent = extend({}, rootComponent);
      }
      if (rootProps != null && !isObject$1(rootProps)) {
        rootProps = null;
      }
      const context = createAppContext();
      const installedPlugins = /* @__PURE__ */ new WeakSet();
      let isMounted = false;
      const app = context.app = {
        _uid: uid$1++,
        _component: rootComponent,
        _props: rootProps,
        _container: null,
        _context: context,
        _instance: null,
        version: version$1,
        get config() {
          return context.config;
        },
        set config(v) {
        },
        use(plugin, ...options) {
          if (installedPlugins.has(plugin)) ; else if (plugin && isFunction$1(plugin.install)) {
            installedPlugins.add(plugin);
            plugin.install(app, ...options);
          } else if (isFunction$1(plugin)) {
            installedPlugins.add(plugin);
            plugin(app, ...options);
          } else ;
          return app;
        },
        mixin(mixin) {
          if (__VUE_OPTIONS_API__) {
            if (!context.mixins.includes(mixin)) {
              context.mixins.push(mixin);
            }
          }
          return app;
        },
        component(name, component) {
          if (!component) {
            return context.components[name];
          }
          context.components[name] = component;
          return app;
        },
        directive(name, directive) {
          if (!directive) {
            return context.directives[name];
          }
          context.directives[name] = directive;
          return app;
        },
        mount(rootContainer, isHydrate, namespace) {
          if (!isMounted) {
            const vnode = createVNode(rootComponent, rootProps);
            vnode.appContext = context;
            if (namespace === true) {
              namespace = "svg";
            } else if (namespace === false) {
              namespace = void 0;
            }
            if (isHydrate && hydrate) {
              hydrate(vnode, rootContainer);
            } else {
              render(vnode, rootContainer, namespace);
            }
            isMounted = true;
            app._container = rootContainer;
            rootContainer.__vue_app__ = app;
            return getExposeProxy(vnode.component) || vnode.component.proxy;
          }
        },
        unmount() {
          if (isMounted) {
            render(null, app._container);
            delete app._container.__vue_app__;
          }
        },
        provide(key, value) {
          context.provides[key] = value;
          return app;
        },
        runWithContext(fn) {
          currentApp = app;
          try {
            return fn();
          } finally {
            currentApp = null;
          }
        }
      };
      return app;
    };
  }
  let currentApp = null;

  function provide(key, value) {
    if (!currentInstance) ; else {
      let provides = currentInstance.provides;
      const parentProvides = currentInstance.parent && currentInstance.parent.provides;
      if (parentProvides === provides) {
        provides = currentInstance.provides = Object.create(parentProvides);
      }
      provides[key] = value;
    }
  }
  function inject(key, defaultValue, treatDefaultAsFactory = false) {
    const instance = currentInstance || currentRenderingInstance;
    if (instance || currentApp) {
      const provides = instance ? instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides : currentApp._context.provides;
      if (provides && key in provides) {
        return provides[key];
      } else if (arguments.length > 1) {
        return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance && instance.proxy) : defaultValue;
      } else ;
    }
  }

  function initProps(instance, rawProps, isStateful, isSSR = false) {
    const props = {};
    const attrs = {};
    def(attrs, InternalObjectKey, 1);
    instance.propsDefaults = /* @__PURE__ */ Object.create(null);
    setFullProps(instance, rawProps, props, attrs);
    for (const key in instance.propsOptions[0]) {
      if (!(key in props)) {
        props[key] = void 0;
      }
    }
    if (isStateful) {
      instance.props = isSSR ? props : shallowReactive(props);
    } else {
      if (!instance.type.props) {
        instance.props = attrs;
      } else {
        instance.props = props;
      }
    }
    instance.attrs = attrs;
  }
  function updateProps(instance, rawProps, rawPrevProps, optimized) {
    const {
      props,
      attrs,
      vnode: { patchFlag }
    } = instance;
    const rawCurrentProps = toRaw(props);
    const [options] = instance.propsOptions;
    let hasAttrsChanged = false;
    if (
      // always force full diff in dev
      // - #1942 if hmr is enabled with sfc component
      // - vite#872 non-sfc component used by sfc component
      (optimized || patchFlag > 0) && !(patchFlag & 16)
    ) {
      if (patchFlag & 8) {
        const propsToUpdate = instance.vnode.dynamicProps;
        for (let i = 0; i < propsToUpdate.length; i++) {
          let key = propsToUpdate[i];
          if (isEmitListener(instance.emitsOptions, key)) {
            continue;
          }
          const value = rawProps[key];
          if (options) {
            if (hasOwn(attrs, key)) {
              if (value !== attrs[key]) {
                attrs[key] = value;
                hasAttrsChanged = true;
              }
            } else {
              const camelizedKey = camelize(key);
              props[camelizedKey] = resolvePropValue(
                options,
                rawCurrentProps,
                camelizedKey,
                value,
                instance,
                false
              );
            }
          } else {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          }
        }
      }
    } else {
      if (setFullProps(instance, rawProps, props, attrs)) {
        hasAttrsChanged = true;
      }
      let kebabKey;
      for (const key in rawCurrentProps) {
        if (!rawProps || // for camelCase
        !hasOwn(rawProps, key) && // it's possible the original props was passed in as kebab-case
        // and converted to camelCase (#955)
        ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
          if (options) {
            if (rawPrevProps && // for camelCase
            (rawPrevProps[key] !== void 0 || // for kebab-case
            rawPrevProps[kebabKey] !== void 0)) {
              props[key] = resolvePropValue(
                options,
                rawCurrentProps,
                key,
                void 0,
                instance,
                true
              );
            }
          } else {
            delete props[key];
          }
        }
      }
      if (attrs !== rawCurrentProps) {
        for (const key in attrs) {
          if (!rawProps || !hasOwn(rawProps, key) && true) {
            delete attrs[key];
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (hasAttrsChanged) {
      trigger$1(instance, "set", "$attrs");
    }
  }
  function setFullProps(instance, rawProps, props, attrs) {
    const [options, needCastKeys] = instance.propsOptions;
    let hasAttrsChanged = false;
    let rawCastValues;
    if (rawProps) {
      for (let key in rawProps) {
        if (isReservedProp(key)) {
          continue;
        }
        const value = rawProps[key];
        let camelKey;
        if (options && hasOwn(options, camelKey = camelize(key))) {
          if (!needCastKeys || !needCastKeys.includes(camelKey)) {
            props[camelKey] = value;
          } else {
            (rawCastValues || (rawCastValues = {}))[camelKey] = value;
          }
        } else if (!isEmitListener(instance.emitsOptions, key)) {
          if (!(key in attrs) || value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
    if (needCastKeys) {
      const rawCurrentProps = toRaw(props);
      const castValues = rawCastValues || EMPTY_OBJ;
      for (let i = 0; i < needCastKeys.length; i++) {
        const key = needCastKeys[i];
        props[key] = resolvePropValue(
          options,
          rawCurrentProps,
          key,
          castValues[key],
          instance,
          !hasOwn(castValues, key)
        );
      }
    }
    return hasAttrsChanged;
  }
  function resolvePropValue(options, props, key, value, instance, isAbsent) {
    const opt = options[key];
    if (opt != null) {
      const hasDefault = hasOwn(opt, "default");
      if (hasDefault && value === void 0) {
        const defaultValue = opt.default;
        if (opt.type !== Function && !opt.skipFactory && isFunction$1(defaultValue)) {
          const { propsDefaults } = instance;
          if (key in propsDefaults) {
            value = propsDefaults[key];
          } else {
            setCurrentInstance(instance);
            value = propsDefaults[key] = defaultValue.call(
              null,
              props
            );
            unsetCurrentInstance();
          }
        } else {
          value = defaultValue;
        }
      }
      if (opt[0 /* shouldCast */]) {
        if (isAbsent && !hasDefault) {
          value = false;
        } else if (opt[1 /* shouldCastTrue */] && (value === "" || value === hyphenate(key))) {
          value = true;
        }
      }
    }
    return value;
  }
  function normalizePropsOptions(comp, appContext, asMixin = false) {
    const cache = appContext.propsCache;
    const cached = cache.get(comp);
    if (cached) {
      return cached;
    }
    const raw = comp.props;
    const normalized = {};
    const needCastKeys = [];
    let hasExtends = false;
    if (__VUE_OPTIONS_API__ && !isFunction$1(comp)) {
      const extendProps = (raw2) => {
        hasExtends = true;
        const [props, keys] = normalizePropsOptions(raw2, appContext, true);
        extend(normalized, props);
        if (keys)
          needCastKeys.push(...keys);
      };
      if (!asMixin && appContext.mixins.length) {
        appContext.mixins.forEach(extendProps);
      }
      if (comp.extends) {
        extendProps(comp.extends);
      }
      if (comp.mixins) {
        comp.mixins.forEach(extendProps);
      }
    }
    if (!raw && !hasExtends) {
      if (isObject$1(comp)) {
        cache.set(comp, EMPTY_ARR);
      }
      return EMPTY_ARR;
    }
    if (isArray$2(raw)) {
      for (let i = 0; i < raw.length; i++) {
        const normalizedKey = camelize(raw[i]);
        if (validatePropName(normalizedKey)) {
          normalized[normalizedKey] = EMPTY_OBJ;
        }
      }
    } else if (raw) {
      for (const key in raw) {
        const normalizedKey = camelize(key);
        if (validatePropName(normalizedKey)) {
          const opt = raw[key];
          const prop = normalized[normalizedKey] = isArray$2(opt) || isFunction$1(opt) ? { type: opt } : extend({}, opt);
          if (prop) {
            const booleanIndex = getTypeIndex(Boolean, prop.type);
            const stringIndex = getTypeIndex(String, prop.type);
            prop[0 /* shouldCast */] = booleanIndex > -1;
            prop[1 /* shouldCastTrue */] = stringIndex < 0 || booleanIndex < stringIndex;
            if (booleanIndex > -1 || hasOwn(prop, "default")) {
              needCastKeys.push(normalizedKey);
            }
          }
        }
      }
    }
    const res = [normalized, needCastKeys];
    if (isObject$1(comp)) {
      cache.set(comp, res);
    }
    return res;
  }
  function validatePropName(key) {
    if (key[0] !== "$") {
      return true;
    }
    return false;
  }
  function getType(ctor) {
    const match = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
    return match ? match[2] : ctor === null ? "null" : "";
  }
  function isSameType(a, b) {
    return getType(a) === getType(b);
  }
  function getTypeIndex(type, expectedTypes) {
    if (isArray$2(expectedTypes)) {
      return expectedTypes.findIndex((t) => isSameType(t, type));
    } else if (isFunction$1(expectedTypes)) {
      return isSameType(expectedTypes, type) ? 0 : -1;
    }
    return -1;
  }

  const isInternalKey = (key) => key[0] === "_" || key === "$stable";
  const normalizeSlotValue = (value) => isArray$2(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
  const normalizeSlot = (key, rawSlot, ctx) => {
    if (rawSlot._n) {
      return rawSlot;
    }
    const normalized = withCtx((...args) => {
      if (!!("production" !== "production") && currentInstance) ;
      return normalizeSlotValue(rawSlot(...args));
    }, ctx);
    normalized._c = false;
    return normalized;
  };
  const normalizeObjectSlots = (rawSlots, slots, instance) => {
    const ctx = rawSlots._ctx;
    for (const key in rawSlots) {
      if (isInternalKey(key))
        continue;
      const value = rawSlots[key];
      if (isFunction$1(value)) {
        slots[key] = normalizeSlot(key, value, ctx);
      } else if (value != null) {
        const normalized = normalizeSlotValue(value);
        slots[key] = () => normalized;
      }
    }
  };
  const normalizeVNodeSlots = (instance, children) => {
    const normalized = normalizeSlotValue(children);
    instance.slots.default = () => normalized;
  };
  const initSlots = (instance, children) => {
    if (instance.vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        instance.slots = toRaw(children);
        def(children, "_", type);
      } else {
        normalizeObjectSlots(
          children,
          instance.slots = {});
      }
    } else {
      instance.slots = {};
      if (children) {
        normalizeVNodeSlots(instance, children);
      }
    }
    def(instance.slots, InternalObjectKey, 1);
  };
  const updateSlots = (instance, children, optimized) => {
    const { vnode, slots } = instance;
    let needDeletionCheck = true;
    let deletionComparisonTarget = EMPTY_OBJ;
    if (vnode.shapeFlag & 32) {
      const type = children._;
      if (type) {
        if (optimized && type === 1) {
          needDeletionCheck = false;
        } else {
          extend(slots, children);
          if (!optimized && type === 1) {
            delete slots._;
          }
        }
      } else {
        needDeletionCheck = !children.$stable;
        normalizeObjectSlots(children, slots);
      }
      deletionComparisonTarget = children;
    } else if (children) {
      normalizeVNodeSlots(instance, children);
      deletionComparisonTarget = { default: 1 };
    }
    if (needDeletionCheck) {
      for (const key in slots) {
        if (!isInternalKey(key) && deletionComparisonTarget[key] == null) {
          delete slots[key];
        }
      }
    }
  };

  function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
    if (isArray$2(rawRef)) {
      rawRef.forEach(
        (r, i) => setRef(
          r,
          oldRawRef && (isArray$2(oldRawRef) ? oldRawRef[i] : oldRawRef),
          parentSuspense,
          vnode,
          isUnmount
        )
      );
      return;
    }
    if (isAsyncWrapper(vnode) && !isUnmount) {
      return;
    }
    const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
    const value = isUnmount ? null : refValue;
    const { i: owner, r: ref } = rawRef;
    const oldRef = oldRawRef && oldRawRef.r;
    const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
    const setupState = owner.setupState;
    if (oldRef != null && oldRef !== ref) {
      if (isString(oldRef)) {
        refs[oldRef] = null;
        if (hasOwn(setupState, oldRef)) {
          setupState[oldRef] = null;
        }
      } else if (isRef(oldRef)) {
        oldRef.value = null;
      }
    }
    if (isFunction$1(ref)) {
      callWithErrorHandling(ref, owner, 12, [value, refs]);
    } else {
      const _isString = isString(ref);
      const _isRef = isRef(ref);
      if (_isString || _isRef) {
        const doSet = () => {
          if (rawRef.f) {
            const existing = _isString ? hasOwn(setupState, ref) ? setupState[ref] : refs[ref] : ref.value;
            if (isUnmount) {
              isArray$2(existing) && remove(existing, refValue);
            } else {
              if (!isArray$2(existing)) {
                if (_isString) {
                  refs[ref] = [refValue];
                  if (hasOwn(setupState, ref)) {
                    setupState[ref] = refs[ref];
                  }
                } else {
                  ref.value = [refValue];
                  if (rawRef.k)
                    refs[rawRef.k] = ref.value;
                }
              } else if (!existing.includes(refValue)) {
                existing.push(refValue);
              }
            }
          } else if (_isString) {
            refs[ref] = value;
            if (hasOwn(setupState, ref)) {
              setupState[ref] = value;
            }
          } else if (_isRef) {
            ref.value = value;
            if (rawRef.k)
              refs[rawRef.k] = value;
          } else ;
        };
        if (value) {
          doSet.id = -1;
          queuePostRenderEffect(doSet, parentSuspense);
        } else {
          doSet();
        }
      }
    }
  }

  function initFeatureFlags() {
    if (typeof __VUE_OPTIONS_API__ !== "boolean") {
      getGlobalThis().__VUE_OPTIONS_API__ = true;
    }
    if (typeof __VUE_PROD_HYDRATION_MISMATCH_DETAILS__ !== "boolean") {
      getGlobalThis().__VUE_PROD_HYDRATION_MISMATCH_DETAILS__ = false;
    }
  }

  const queuePostRenderEffect = queueEffectWithSuspense ;
  function createRenderer(options) {
    return baseCreateRenderer(options);
  }
  function baseCreateRenderer(options, createHydrationFns) {
    {
      initFeatureFlags();
    }
    const target = getGlobalThis();
    target.__VUE__ = true;
    const {
      insert: hostInsert,
      remove: hostRemove,
      patchProp: hostPatchProp,
      createElement: hostCreateElement,
      createText: hostCreateText,
      createComment: hostCreateComment,
      setText: hostSetText,
      setElementText: hostSetElementText,
      parentNode: hostParentNode,
      nextSibling: hostNextSibling,
      setScopeId: hostSetScopeId = NOOP,
      insertStaticContent: hostInsertStaticContent
    } = options;
    const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, namespace = void 0, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
      if (n1 === n2) {
        return;
      }
      if (n1 && !isSameVNodeType(n1, n2)) {
        anchor = getNextHostNode(n1);
        unmount(n1, parentComponent, parentSuspense, true);
        n1 = null;
      }
      if (n2.patchFlag === -2) {
        optimized = false;
        n2.dynamicChildren = null;
      }
      const { type, ref, shapeFlag } = n2;
      switch (type) {
        case Text:
          processText(n1, n2, container, anchor);
          break;
        case Comment:
          processCommentNode(n1, n2, container, anchor);
          break;
        case Static:
          if (n1 == null) {
            mountStaticNode(n2, container, anchor, namespace);
          }
          break;
        case Fragment:
          processFragment(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          break;
        default:
          if (shapeFlag & 1) {
            processElement(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 6) {
            processComponent(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (shapeFlag & 64) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else if (shapeFlag & 128) {
            type.process(
              n1,
              n2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized,
              internals
            );
          } else ;
      }
      if (ref != null && parentComponent) {
        setRef(ref, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
      }
    };
    const processText = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateText(n2.children),
          container,
          anchor
        );
      } else {
        const el = n2.el = n1.el;
        if (n2.children !== n1.children) {
          hostSetText(el, n2.children);
        }
      }
    };
    const processCommentNode = (n1, n2, container, anchor) => {
      if (n1 == null) {
        hostInsert(
          n2.el = hostCreateComment(n2.children || ""),
          container,
          anchor
        );
      } else {
        n2.el = n1.el;
      }
    };
    const mountStaticNode = (n2, container, anchor, namespace) => {
      [n2.el, n2.anchor] = hostInsertStaticContent(
        n2.children,
        container,
        anchor,
        namespace,
        n2.el,
        n2.anchor
      );
    };
    const moveStaticNode = ({ el, anchor }, container, nextSibling) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostInsert(el, container, nextSibling);
        el = next;
      }
      hostInsert(anchor, container, nextSibling);
    };
    const removeStaticNode = ({ el, anchor }) => {
      let next;
      while (el && el !== anchor) {
        next = hostNextSibling(el);
        hostRemove(el);
        el = next;
      }
      hostRemove(anchor);
    };
    const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      if (n2.type === "svg") {
        namespace = "svg";
      } else if (n2.type === "math") {
        namespace = "mathml";
      }
      if (n1 == null) {
        mountElement(
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        patchElement(
          n1,
          n2,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let el;
      let vnodeHook;
      const { props, shapeFlag, transition, dirs } = vnode;
      el = vnode.el = hostCreateElement(
        vnode.type,
        namespace,
        props && props.is,
        props
      );
      if (shapeFlag & 8) {
        hostSetElementText(el, vnode.children);
      } else if (shapeFlag & 16) {
        mountChildren(
          vnode.children,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(vnode, namespace),
          slotScopeIds,
          optimized
        );
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "created");
      }
      setScopeId(el, vnode, vnode.scopeId, slotScopeIds, parentComponent);
      if (props) {
        for (const key in props) {
          if (key !== "value" && !isReservedProp(key)) {
            hostPatchProp(
              el,
              key,
              null,
              props[key],
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in props) {
          hostPatchProp(el, "value", null, props.value, namespace);
        }
        if (vnodeHook = props.onVnodeBeforeMount) {
          invokeVNodeHook(vnodeHook, parentComponent, vnode);
        }
      }
      if (dirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
      }
      const needCallTransitionHooks = needTransition(parentSuspense, transition);
      if (needCallTransitionHooks) {
        transition.beforeEnter(el);
      }
      hostInsert(el, container, anchor);
      if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          needCallTransitionHooks && transition.enter(el);
          dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
        }, parentSuspense);
      }
    };
    const setScopeId = (el, vnode, scopeId, slotScopeIds, parentComponent) => {
      if (scopeId) {
        hostSetScopeId(el, scopeId);
      }
      if (slotScopeIds) {
        for (let i = 0; i < slotScopeIds.length; i++) {
          hostSetScopeId(el, slotScopeIds[i]);
        }
      }
      if (parentComponent) {
        let subTree = parentComponent.subTree;
        if (vnode === subTree) {
          const parentVNode = parentComponent.vnode;
          setScopeId(
            el,
            parentVNode,
            parentVNode.scopeId,
            parentVNode.slotScopeIds,
            parentComponent.parent
          );
        }
      }
    };
    const mountChildren = (children, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, start = 0) => {
      for (let i = start; i < children.length; i++) {
        const child = children[i] = optimized ? cloneIfMounted(children[i]) : normalizeVNode(children[i]);
        patch(
          null,
          child,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
    };
    const patchElement = (n1, n2, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const el = n2.el = n1.el;
      let { patchFlag, dynamicChildren, dirs } = n2;
      patchFlag |= n1.patchFlag & 16;
      const oldProps = n1.props || EMPTY_OBJ;
      const newProps = n2.props || EMPTY_OBJ;
      let vnodeHook;
      parentComponent && toggleRecurse(parentComponent, false);
      if (vnodeHook = newProps.onVnodeBeforeUpdate) {
        invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
      }
      if (dirs) {
        invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
      }
      parentComponent && toggleRecurse(parentComponent, true);
      if (dynamicChildren) {
        patchBlockChildren(
          n1.dynamicChildren,
          dynamicChildren,
          el,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds
        );
      } else if (!optimized) {
        patchChildren(
          n1,
          n2,
          el,
          null,
          parentComponent,
          parentSuspense,
          resolveChildrenNamespace(n2, namespace),
          slotScopeIds,
          false
        );
      }
      if (patchFlag > 0) {
        if (patchFlag & 16) {
          patchProps(
            el,
            n2,
            oldProps,
            newProps,
            parentComponent,
            parentSuspense,
            namespace
          );
        } else {
          if (patchFlag & 2) {
            if (oldProps.class !== newProps.class) {
              hostPatchProp(el, "class", null, newProps.class, namespace);
            }
          }
          if (patchFlag & 4) {
            hostPatchProp(el, "style", oldProps.style, newProps.style, namespace);
          }
          if (patchFlag & 8) {
            const propsToUpdate = n2.dynamicProps;
            for (let i = 0; i < propsToUpdate.length; i++) {
              const key = propsToUpdate[i];
              const prev = oldProps[key];
              const next = newProps[key];
              if (next !== prev || key === "value") {
                hostPatchProp(
                  el,
                  key,
                  prev,
                  next,
                  namespace,
                  n1.children,
                  parentComponent,
                  parentSuspense,
                  unmountChildren
                );
              }
            }
          }
        }
        if (patchFlag & 1) {
          if (n1.children !== n2.children) {
            hostSetElementText(el, n2.children);
          }
        }
      } else if (!optimized && dynamicChildren == null) {
        patchProps(
          el,
          n2,
          oldProps,
          newProps,
          parentComponent,
          parentSuspense,
          namespace
        );
      }
      if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
          dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
        }, parentSuspense);
      }
    };
    const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, namespace, slotScopeIds) => {
      for (let i = 0; i < newChildren.length; i++) {
        const oldVNode = oldChildren[i];
        const newVNode = newChildren[i];
        const container = (
          // oldVNode may be an errored async setup() component inside Suspense
          // which will not have a mounted element
          oldVNode.el && // - In the case of a Fragment, we need to provide the actual parent
          // of the Fragment itself so it can move its children.
          (oldVNode.type === Fragment || // - In the case of different nodes, there is going to be a replacement
          // which also requires the correct parent container
          !isSameVNodeType(oldVNode, newVNode) || // - In the case of a component, it could contain anything.
          oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : (
            // In other cases, the parent container is not actually used so we
            // just pass the block element here to avoid a DOM parentNode call.
            fallbackContainer
          )
        );
        patch(
          oldVNode,
          newVNode,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          true
        );
      }
    };
    const patchProps = (el, vnode, oldProps, newProps, parentComponent, parentSuspense, namespace) => {
      if (oldProps !== newProps) {
        if (oldProps !== EMPTY_OBJ) {
          for (const key in oldProps) {
            if (!isReservedProp(key) && !(key in newProps)) {
              hostPatchProp(
                el,
                key,
                oldProps[key],
                null,
                namespace,
                vnode.children,
                parentComponent,
                parentSuspense,
                unmountChildren
              );
            }
          }
        }
        for (const key in newProps) {
          if (isReservedProp(key))
            continue;
          const next = newProps[key];
          const prev = oldProps[key];
          if (next !== prev && key !== "value") {
            hostPatchProp(
              el,
              key,
              prev,
              next,
              namespace,
              vnode.children,
              parentComponent,
              parentSuspense,
              unmountChildren
            );
          }
        }
        if ("value" in newProps) {
          hostPatchProp(el, "value", oldProps.value, newProps.value, namespace);
        }
      }
    };
    const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
      const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
      let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
      if (fragmentSlotScopeIds) {
        slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
      }
      if (n1 == null) {
        hostInsert(fragmentStartAnchor, container, anchor);
        hostInsert(fragmentEndAnchor, container, anchor);
        mountChildren(
          n2.children,
          container,
          fragmentEndAnchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      } else {
        if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && // #2715 the previous fragment could've been a BAILed one as a result
        // of renderSlot() with no valid children
        n1.dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            container,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          if (
            // #2080 if the stable fragment has a key, it's a <template v-for> that may
            //  get moved around. Make sure all root level vnodes inherit el.
            // #2134 or if it's a component root, it may also get moved around
            // as the component is being moved.
            n2.key != null || parentComponent && n2 === parentComponent.subTree
          ) {
            traverseStaticChildren(
              n1,
              n2,
              true
              /* shallow */
            );
          }
        } else {
          patchChildren(
            n1,
            n2,
            container,
            fragmentEndAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        }
      }
    };
    const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      n2.slotScopeIds = slotScopeIds;
      if (n1 == null) {
        if (n2.shapeFlag & 512) {
          parentComponent.ctx.activate(
            n2,
            container,
            anchor,
            namespace,
            optimized
          );
        } else {
          mountComponent(
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            optimized
          );
        }
      } else {
        updateComponent(n1, n2, optimized);
      }
    };
    const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, namespace, optimized) => {
      const instance = (initialVNode.component = createComponentInstance(
        initialVNode,
        parentComponent,
        parentSuspense
      ));
      if (isKeepAlive(initialVNode)) {
        instance.ctx.renderer = internals;
      }
      {
        setupComponent(instance);
      }
      if (instance.asyncDep) {
        parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
        if (!initialVNode.el) {
          const placeholder = instance.subTree = createVNode(Comment);
          processCommentNode(null, placeholder, container, anchor);
        }
      } else {
        setupRenderEffect(
          instance,
          initialVNode,
          container,
          anchor,
          parentSuspense,
          namespace,
          optimized
        );
      }
    };
    const updateComponent = (n1, n2, optimized) => {
      const instance = n2.component = n1.component;
      if (shouldUpdateComponent(n1, n2, optimized)) {
        if (instance.asyncDep && !instance.asyncResolved) {
          updateComponentPreRender(instance, n2, optimized);
          return;
        } else {
          instance.next = n2;
          invalidateJob(instance.update);
          instance.effect.dirty = true;
          instance.update();
        }
      } else {
        n2.el = n1.el;
        instance.vnode = n2;
      }
    };
    const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, namespace, optimized) => {
      const componentUpdateFn = () => {
        if (!instance.isMounted) {
          let vnodeHook;
          const { el, props } = initialVNode;
          const { bm, m, parent } = instance;
          const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
          toggleRecurse(instance, false);
          if (bm) {
            invokeArrayFns(bm);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
            invokeVNodeHook(vnodeHook, parent, initialVNode);
          }
          toggleRecurse(instance, true);
          if (el && hydrateNode) {
            const hydrateSubTree = () => {
              instance.subTree = renderComponentRoot(instance);
              hydrateNode(
                el,
                instance.subTree,
                instance,
                parentSuspense,
                null
              );
            };
            if (isAsyncWrapperVNode) {
              initialVNode.type.__asyncLoader().then(
                // note: we are moving the render call into an async callback,
                // which means it won't track dependencies - but it's ok because
                // a server-rendered async wrapper is already in resolved state
                // and it will never need to change.
                () => !instance.isUnmounted && hydrateSubTree()
              );
            } else {
              hydrateSubTree();
            }
          } else {
            const subTree = instance.subTree = renderComponentRoot(instance);
            patch(
              null,
              subTree,
              container,
              anchor,
              instance,
              parentSuspense,
              namespace
            );
            initialVNode.el = subTree.el;
          }
          if (m) {
            queuePostRenderEffect(m, parentSuspense);
          }
          if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
            const scopedInitialVNode = initialVNode;
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode),
              parentSuspense
            );
          }
          if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
            instance.a && queuePostRenderEffect(instance.a, parentSuspense);
          }
          instance.isMounted = true;
          initialVNode = container = anchor = null;
        } else {
          let { next, bu, u, parent, vnode } = instance;
          {
            const nonHydratedAsyncRoot = locateNonHydratedAsyncRoot(instance);
            if (nonHydratedAsyncRoot) {
              if (next) {
                next.el = vnode.el;
                updateComponentPreRender(instance, next, optimized);
              }
              nonHydratedAsyncRoot.asyncDep.then(() => {
                if (!instance.isUnmounted) {
                  componentUpdateFn();
                }
              });
              return;
            }
          }
          let originNext = next;
          let vnodeHook;
          toggleRecurse(instance, false);
          if (next) {
            next.el = vnode.el;
            updateComponentPreRender(instance, next, optimized);
          } else {
            next = vnode;
          }
          if (bu) {
            invokeArrayFns(bu);
          }
          if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
            invokeVNodeHook(vnodeHook, parent, next, vnode);
          }
          toggleRecurse(instance, true);
          const nextTree = renderComponentRoot(instance);
          const prevTree = instance.subTree;
          instance.subTree = nextTree;
          patch(
            prevTree,
            nextTree,
            // parent may have changed if it's in a teleport
            hostParentNode(prevTree.el),
            // anchor may have changed if it's in a fragment
            getNextHostNode(prevTree),
            instance,
            parentSuspense,
            namespace
          );
          next.el = nextTree.el;
          if (originNext === null) {
            updateHOCHostEl(instance, nextTree.el);
          }
          if (u) {
            queuePostRenderEffect(u, parentSuspense);
          }
          if (vnodeHook = next.props && next.props.onVnodeUpdated) {
            queuePostRenderEffect(
              () => invokeVNodeHook(vnodeHook, parent, next, vnode),
              parentSuspense
            );
          }
        }
      };
      const effect = instance.effect = new ReactiveEffect(
        componentUpdateFn,
        NOOP,
        () => queueJob(update),
        instance.scope
        // track it in component's effect scope
      );
      const update = instance.update = () => {
        if (effect.dirty) {
          effect.run();
        }
      };
      update.id = instance.uid;
      toggleRecurse(instance, true);
      update();
    };
    const updateComponentPreRender = (instance, nextVNode, optimized) => {
      nextVNode.component = instance;
      const prevProps = instance.vnode.props;
      instance.vnode = nextVNode;
      instance.next = null;
      updateProps(instance, nextVNode.props, prevProps, optimized);
      updateSlots(instance, nextVNode.children, optimized);
      pauseTracking();
      flushPreFlushCbs(instance);
      resetTracking();
    };
    const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized = false) => {
      const c1 = n1 && n1.children;
      const prevShapeFlag = n1 ? n1.shapeFlag : 0;
      const c2 = n2.children;
      const { patchFlag, shapeFlag } = n2;
      if (patchFlag > 0) {
        if (patchFlag & 128) {
          patchKeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        } else if (patchFlag & 256) {
          patchUnkeyedChildren(
            c1,
            c2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
          return;
        }
      }
      if (shapeFlag & 8) {
        if (prevShapeFlag & 16) {
          unmountChildren(c1, parentComponent, parentSuspense);
        }
        if (c2 !== c1) {
          hostSetElementText(container, c2);
        }
      } else {
        if (prevShapeFlag & 16) {
          if (shapeFlag & 16) {
            patchKeyedChildren(
              c1,
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else {
            unmountChildren(c1, parentComponent, parentSuspense, true);
          }
        } else {
          if (prevShapeFlag & 8) {
            hostSetElementText(container, "");
          }
          if (shapeFlag & 16) {
            mountChildren(
              c2,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        }
      }
    };
    const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      c1 = c1 || EMPTY_ARR;
      c2 = c2 || EMPTY_ARR;
      const oldLength = c1.length;
      const newLength = c2.length;
      const commonLength = Math.min(oldLength, newLength);
      let i;
      for (i = 0; i < commonLength; i++) {
        const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        patch(
          c1[i],
          nextChild,
          container,
          null,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized
        );
      }
      if (oldLength > newLength) {
        unmountChildren(
          c1,
          parentComponent,
          parentSuspense,
          true,
          false,
          commonLength
        );
      } else {
        mountChildren(
          c2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          namespace,
          slotScopeIds,
          optimized,
          commonLength
        );
      }
    };
    const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized) => {
      let i = 0;
      const l2 = c2.length;
      let e1 = c1.length - 1;
      let e2 = l2 - 1;
      while (i <= e1 && i <= e2) {
        const n1 = c1[i];
        const n2 = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        i++;
      }
      while (i <= e1 && i <= e2) {
        const n1 = c1[e1];
        const n2 = c2[e2] = optimized ? cloneIfMounted(c2[e2]) : normalizeVNode(c2[e2]);
        if (isSameVNodeType(n1, n2)) {
          patch(
            n1,
            n2,
            container,
            null,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            optimized
          );
        } else {
          break;
        }
        e1--;
        e2--;
      }
      if (i > e1) {
        if (i <= e2) {
          const nextPos = e2 + 1;
          const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
          while (i <= e2) {
            patch(
              null,
              c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]),
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            i++;
          }
        }
      } else if (i > e2) {
        while (i <= e1) {
          unmount(c1[i], parentComponent, parentSuspense, true);
          i++;
        }
      } else {
        const s1 = i;
        const s2 = i;
        const keyToNewIndexMap = /* @__PURE__ */ new Map();
        for (i = s2; i <= e2; i++) {
          const nextChild = c2[i] = optimized ? cloneIfMounted(c2[i]) : normalizeVNode(c2[i]);
          if (nextChild.key != null) {
            keyToNewIndexMap.set(nextChild.key, i);
          }
        }
        let j;
        let patched = 0;
        const toBePatched = e2 - s2 + 1;
        let moved = false;
        let maxNewIndexSoFar = 0;
        const newIndexToOldIndexMap = new Array(toBePatched);
        for (i = 0; i < toBePatched; i++)
          newIndexToOldIndexMap[i] = 0;
        for (i = s1; i <= e1; i++) {
          const prevChild = c1[i];
          if (patched >= toBePatched) {
            unmount(prevChild, parentComponent, parentSuspense, true);
            continue;
          }
          let newIndex;
          if (prevChild.key != null) {
            newIndex = keyToNewIndexMap.get(prevChild.key);
          } else {
            for (j = s2; j <= e2; j++) {
              if (newIndexToOldIndexMap[j - s2] === 0 && isSameVNodeType(prevChild, c2[j])) {
                newIndex = j;
                break;
              }
            }
          }
          if (newIndex === void 0) {
            unmount(prevChild, parentComponent, parentSuspense, true);
          } else {
            newIndexToOldIndexMap[newIndex - s2] = i + 1;
            if (newIndex >= maxNewIndexSoFar) {
              maxNewIndexSoFar = newIndex;
            } else {
              moved = true;
            }
            patch(
              prevChild,
              c2[newIndex],
              container,
              null,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
            patched++;
          }
        }
        const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
        j = increasingNewIndexSequence.length - 1;
        for (i = toBePatched - 1; i >= 0; i--) {
          const nextIndex = s2 + i;
          const nextChild = c2[nextIndex];
          const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
          if (newIndexToOldIndexMap[i] === 0) {
            patch(
              null,
              nextChild,
              container,
              anchor,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          } else if (moved) {
            if (j < 0 || i !== increasingNewIndexSequence[j]) {
              move(nextChild, container, anchor, 2);
            } else {
              j--;
            }
          }
        }
      }
    };
    const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
      const { el, type, transition, children, shapeFlag } = vnode;
      if (shapeFlag & 6) {
        move(vnode.component.subTree, container, anchor, moveType);
        return;
      }
      if (shapeFlag & 128) {
        vnode.suspense.move(container, anchor, moveType);
        return;
      }
      if (shapeFlag & 64) {
        type.move(vnode, container, anchor, internals);
        return;
      }
      if (type === Fragment) {
        hostInsert(el, container, anchor);
        for (let i = 0; i < children.length; i++) {
          move(children[i], container, anchor, moveType);
        }
        hostInsert(vnode.anchor, container, anchor);
        return;
      }
      if (type === Static) {
        moveStaticNode(vnode, container, anchor);
        return;
      }
      const needTransition2 = moveType !== 2 && shapeFlag & 1 && transition;
      if (needTransition2) {
        if (moveType === 0) {
          transition.beforeEnter(el);
          hostInsert(el, container, anchor);
          queuePostRenderEffect(() => transition.enter(el), parentSuspense);
        } else {
          const { leave, delayLeave, afterLeave } = transition;
          const remove2 = () => hostInsert(el, container, anchor);
          const performLeave = () => {
            leave(el, () => {
              remove2();
              afterLeave && afterLeave();
            });
          };
          if (delayLeave) {
            delayLeave(el, remove2, performLeave);
          } else {
            performLeave();
          }
        }
      } else {
        hostInsert(el, container, anchor);
      }
    };
    const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
      const {
        type,
        props,
        ref,
        children,
        dynamicChildren,
        shapeFlag,
        patchFlag,
        dirs
      } = vnode;
      if (ref != null) {
        setRef(ref, null, parentSuspense, vnode, true);
      }
      if (shapeFlag & 256) {
        parentComponent.ctx.deactivate(vnode);
        return;
      }
      const shouldInvokeDirs = shapeFlag & 1 && dirs;
      const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
      let vnodeHook;
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
      if (shapeFlag & 6) {
        unmountComponent(vnode.component, parentSuspense, doRemove);
      } else {
        if (shapeFlag & 128) {
          vnode.suspense.unmount(parentSuspense, doRemove);
          return;
        }
        if (shouldInvokeDirs) {
          invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
        }
        if (shapeFlag & 64) {
          vnode.type.remove(
            vnode,
            parentComponent,
            parentSuspense,
            optimized,
            internals,
            doRemove
          );
        } else if (dynamicChildren && // #1153: fast path should not be taken for non-stable (v-for) fragments
        (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
          unmountChildren(
            dynamicChildren,
            parentComponent,
            parentSuspense,
            false,
            true
          );
        } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
          unmountChildren(children, parentComponent, parentSuspense);
        }
        if (doRemove) {
          remove(vnode);
        }
      }
      if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
        queuePostRenderEffect(() => {
          vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
          shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
        }, parentSuspense);
      }
    };
    const remove = (vnode) => {
      const { type, el, anchor, transition } = vnode;
      if (type === Fragment) {
        {
          removeFragment(el, anchor);
        }
        return;
      }
      if (type === Static) {
        removeStaticNode(vnode);
        return;
      }
      const performRemove = () => {
        hostRemove(el);
        if (transition && !transition.persisted && transition.afterLeave) {
          transition.afterLeave();
        }
      };
      if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
        const { leave, delayLeave } = transition;
        const performLeave = () => leave(el, performRemove);
        if (delayLeave) {
          delayLeave(vnode.el, performRemove, performLeave);
        } else {
          performLeave();
        }
      } else {
        performRemove();
      }
    };
    const removeFragment = (cur, end) => {
      let next;
      while (cur !== end) {
        next = hostNextSibling(cur);
        hostRemove(cur);
        cur = next;
      }
      hostRemove(end);
    };
    const unmountComponent = (instance, parentSuspense, doRemove) => {
      const { bum, scope, update, subTree, um } = instance;
      if (bum) {
        invokeArrayFns(bum);
      }
      scope.stop();
      if (update) {
        update.active = false;
        unmount(subTree, instance, parentSuspense, doRemove);
      }
      if (um) {
        queuePostRenderEffect(um, parentSuspense);
      }
      queuePostRenderEffect(() => {
        instance.isUnmounted = true;
      }, parentSuspense);
      if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
        parentSuspense.deps--;
        if (parentSuspense.deps === 0) {
          parentSuspense.resolve();
        }
      }
    };
    const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
      for (let i = start; i < children.length; i++) {
        unmount(children[i], parentComponent, parentSuspense, doRemove, optimized);
      }
    };
    const getNextHostNode = (vnode) => {
      if (vnode.shapeFlag & 6) {
        return getNextHostNode(vnode.component.subTree);
      }
      if (vnode.shapeFlag & 128) {
        return vnode.suspense.next();
      }
      return hostNextSibling(vnode.anchor || vnode.el);
    };
    const render = (vnode, container, namespace) => {
      if (vnode == null) {
        if (container._vnode) {
          unmount(container._vnode, null, null, true);
        }
      } else {
        patch(
          container._vnode || null,
          vnode,
          container,
          null,
          null,
          null,
          namespace
        );
      }
      flushPreFlushCbs();
      flushPostFlushCbs();
      container._vnode = vnode;
    };
    const internals = {
      p: patch,
      um: unmount,
      m: move,
      r: remove,
      mt: mountComponent,
      mc: mountChildren,
      pc: patchChildren,
      pbc: patchBlockChildren,
      n: getNextHostNode,
      o: options
    };
    let hydrate;
    let hydrateNode;
    if (createHydrationFns) {
      [hydrate, hydrateNode] = createHydrationFns(
        internals
      );
    }
    return {
      render,
      hydrate,
      createApp: createAppAPI(render, hydrate)
    };
  }
  function resolveChildrenNamespace({ type, props }, currentNamespace) {
    return currentNamespace === "svg" && type === "foreignObject" || currentNamespace === "mathml" && type === "annotation-xml" && props && props.encoding && props.encoding.includes("html") ? void 0 : currentNamespace;
  }
  function toggleRecurse({ effect, update }, allowed) {
    effect.allowRecurse = update.allowRecurse = allowed;
  }
  function needTransition(parentSuspense, transition) {
    return (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
  }
  function traverseStaticChildren(n1, n2, shallow = false) {
    const ch1 = n1.children;
    const ch2 = n2.children;
    if (isArray$2(ch1) && isArray$2(ch2)) {
      for (let i = 0; i < ch1.length; i++) {
        const c1 = ch1[i];
        let c2 = ch2[i];
        if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
          if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
            c2 = ch2[i] = cloneIfMounted(ch2[i]);
            c2.el = c1.el;
          }
          if (!shallow)
            traverseStaticChildren(c1, c2);
        }
        if (c2.type === Text) {
          c2.el = c1.el;
        }
      }
    }
  }
  function getSequence(arr) {
    const p = arr.slice();
    const result = [0];
    let i, j, u, v, c;
    const len = arr.length;
    for (i = 0; i < len; i++) {
      const arrI = arr[i];
      if (arrI !== 0) {
        j = result[result.length - 1];
        if (arr[j] < arrI) {
          p[i] = j;
          result.push(i);
          continue;
        }
        u = 0;
        v = result.length - 1;
        while (u < v) {
          c = u + v >> 1;
          if (arr[result[c]] < arrI) {
            u = c + 1;
          } else {
            v = c;
          }
        }
        if (arrI < arr[result[u]]) {
          if (u > 0) {
            p[i] = result[u - 1];
          }
          result[u] = i;
        }
      }
    }
    u = result.length;
    v = result[u - 1];
    while (u-- > 0) {
      result[u] = v;
      v = p[v];
    }
    return result;
  }
  function locateNonHydratedAsyncRoot(instance) {
    const subComponent = instance.subTree.component;
    if (subComponent) {
      if (subComponent.asyncDep && !subComponent.asyncResolved) {
        return subComponent;
      } else {
        return locateNonHydratedAsyncRoot(subComponent);
      }
    }
  }

  const isTeleport = (type) => type.__isTeleport;
  const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
  const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
  const isTargetMathML = (target) => typeof MathMLElement === "function" && target instanceof MathMLElement;
  const resolveTarget = (props, select) => {
    const targetSelector = props && props.to;
    if (isString(targetSelector)) {
      if (!select) {
        return null;
      } else {
        const target = select(targetSelector);
        return target;
      }
    } else {
      return targetSelector;
    }
  };
  const TeleportImpl = {
    name: "Teleport",
    __isTeleport: true,
    process(n1, n2, container, anchor, parentComponent, parentSuspense, namespace, slotScopeIds, optimized, internals) {
      const {
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        o: { insert, querySelector, createText, createComment }
      } = internals;
      const disabled = isTeleportDisabled(n2.props);
      let { shapeFlag, children, dynamicChildren } = n2;
      if (n1 == null) {
        const placeholder = n2.el = createText("");
        const mainAnchor = n2.anchor = createText("");
        insert(placeholder, container, anchor);
        insert(mainAnchor, container, anchor);
        const target = n2.target = resolveTarget(n2.props, querySelector);
        const targetAnchor = n2.targetAnchor = createText("");
        if (target) {
          insert(targetAnchor, target);
          if (namespace === "svg" || isTargetSVG(target)) {
            namespace = "svg";
          } else if (namespace === "mathml" || isTargetMathML(target)) {
            namespace = "mathml";
          }
        }
        const mount = (container2, anchor2) => {
          if (shapeFlag & 16) {
            mountChildren(
              children,
              container2,
              anchor2,
              parentComponent,
              parentSuspense,
              namespace,
              slotScopeIds,
              optimized
            );
          }
        };
        if (disabled) {
          mount(container, mainAnchor);
        } else if (target) {
          mount(target, targetAnchor);
        }
      } else {
        n2.el = n1.el;
        const mainAnchor = n2.anchor = n1.anchor;
        const target = n2.target = n1.target;
        const targetAnchor = n2.targetAnchor = n1.targetAnchor;
        const wasDisabled = isTeleportDisabled(n1.props);
        const currentContainer = wasDisabled ? container : target;
        const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
        if (namespace === "svg" || isTargetSVG(target)) {
          namespace = "svg";
        } else if (namespace === "mathml" || isTargetMathML(target)) {
          namespace = "mathml";
        }
        if (dynamicChildren) {
          patchBlockChildren(
            n1.dynamicChildren,
            dynamicChildren,
            currentContainer,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds
          );
          traverseStaticChildren(n1, n2, true);
        } else if (!optimized) {
          patchChildren(
            n1,
            n2,
            currentContainer,
            currentAnchor,
            parentComponent,
            parentSuspense,
            namespace,
            slotScopeIds,
            false
          );
        }
        if (disabled) {
          if (!wasDisabled) {
            moveTeleport(
              n2,
              container,
              mainAnchor,
              internals,
              1
            );
          } else {
            if (n2.props && n1.props && n2.props.to !== n1.props.to) {
              n2.props.to = n1.props.to;
            }
          }
        } else {
          if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
            const nextTarget = n2.target = resolveTarget(
              n2.props,
              querySelector
            );
            if (nextTarget) {
              moveTeleport(
                n2,
                nextTarget,
                null,
                internals,
                0
              );
            }
          } else if (wasDisabled) {
            moveTeleport(
              n2,
              target,
              targetAnchor,
              internals,
              1
            );
          }
        }
      }
      updateCssVars(n2);
    },
    remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
      const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
      if (target) {
        hostRemove(targetAnchor);
      }
      doRemove && hostRemove(anchor);
      if (shapeFlag & 16) {
        const shouldRemove = doRemove || !isTeleportDisabled(props);
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          unmount(
            child,
            parentComponent,
            parentSuspense,
            shouldRemove,
            !!child.dynamicChildren
          );
        }
      }
    },
    move: moveTeleport,
    hydrate: hydrateTeleport
  };
  function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
    if (moveType === 0) {
      insert(vnode.targetAnchor, container, parentAnchor);
    }
    const { el, anchor, shapeFlag, children, props } = vnode;
    const isReorder = moveType === 2;
    if (isReorder) {
      insert(el, container, parentAnchor);
    }
    if (!isReorder || isTeleportDisabled(props)) {
      if (shapeFlag & 16) {
        for (let i = 0; i < children.length; i++) {
          move(
            children[i],
            container,
            parentAnchor,
            2
          );
        }
      }
    }
    if (isReorder) {
      insert(anchor, container, parentAnchor);
    }
  }
  function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, {
    o: { nextSibling, parentNode, querySelector }
  }, hydrateChildren) {
    const target = vnode.target = resolveTarget(
      vnode.props,
      querySelector
    );
    if (target) {
      const targetNode = target._lpa || target.firstChild;
      if (vnode.shapeFlag & 16) {
        if (isTeleportDisabled(vnode.props)) {
          vnode.anchor = hydrateChildren(
            nextSibling(node),
            vnode,
            parentNode(node),
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
          vnode.targetAnchor = targetNode;
        } else {
          vnode.anchor = nextSibling(node);
          let targetAnchor = targetNode;
          while (targetAnchor) {
            targetAnchor = nextSibling(targetAnchor);
            if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
              vnode.targetAnchor = targetAnchor;
              target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
              break;
            }
          }
          hydrateChildren(
            targetNode,
            vnode,
            target,
            parentComponent,
            parentSuspense,
            slotScopeIds,
            optimized
          );
        }
      }
      updateCssVars(vnode);
    }
    return vnode.anchor && nextSibling(vnode.anchor);
  }
  const Teleport = TeleportImpl;
  function updateCssVars(vnode) {
    const ctx = vnode.ctx;
    if (ctx && ctx.ut) {
      let node = vnode.children[0].el;
      while (node && node !== vnode.targetAnchor) {
        if (node.nodeType === 1)
          node.setAttribute("data-v-owner", ctx.uid);
        node = node.nextSibling;
      }
      ctx.ut();
    }
  }

  const Fragment = Symbol.for("v-fgt");
  const Text = Symbol.for("v-txt");
  const Comment = Symbol.for("v-cmt");
  const Static = Symbol.for("v-stc");
  const blockStack = [];
  let currentBlock = null;
  function openBlock(disableTracking = false) {
    blockStack.push(currentBlock = disableTracking ? null : []);
  }
  function closeBlock() {
    blockStack.pop();
    currentBlock = blockStack[blockStack.length - 1] || null;
  }
  let isBlockTreeEnabled = 1;
  function setBlockTracking(value) {
    isBlockTreeEnabled += value;
  }
  function setupBlock(vnode) {
    vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
    closeBlock();
    if (isBlockTreeEnabled > 0 && currentBlock) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  function createBlock(type, props, children, patchFlag, dynamicProps) {
    return setupBlock(
      createVNode(
        type,
        props,
        children,
        patchFlag,
        dynamicProps,
        true
      )
    );
  }
  function isVNode(value) {
    return value ? value.__v_isVNode === true : false;
  }
  function isSameVNodeType(n1, n2) {
    return n1.type === n2.type && n1.key === n2.key;
  }
  const InternalObjectKey = `__vInternal`;
  const normalizeKey = ({ key }) => key != null ? key : null;
  const normalizeRef = ({
    ref,
    ref_key,
    ref_for
  }) => {
    if (typeof ref === "number") {
      ref = "" + ref;
    }
    return ref != null ? isString(ref) || isRef(ref) || isFunction$1(ref) ? { i: currentRenderingInstance, r: ref, k: ref_key, f: !!ref_for } : ref : null;
  };
  function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
    const vnode = {
      __v_isVNode: true,
      __v_skip: true,
      type,
      props,
      key: props && normalizeKey(props),
      ref: props && normalizeRef(props),
      scopeId: currentScopeId,
      slotScopeIds: null,
      children,
      component: null,
      suspense: null,
      ssContent: null,
      ssFallback: null,
      dirs: null,
      transition: null,
      el: null,
      anchor: null,
      target: null,
      targetAnchor: null,
      staticCount: 0,
      shapeFlag,
      patchFlag,
      dynamicProps,
      dynamicChildren: null,
      appContext: null,
      ctx: currentRenderingInstance
    };
    if (needFullChildrenNormalization) {
      normalizeChildren(vnode, children);
      if (shapeFlag & 128) {
        type.normalize(vnode);
      }
    } else if (children) {
      vnode.shapeFlag |= isString(children) ? 8 : 16;
    }
    if (isBlockTreeEnabled > 0 && // avoid a block node from tracking itself
    !isBlockNode && // has current parent block
    currentBlock && // presence of a patch flag indicates this node needs patching on updates.
    // component nodes also should always be patched, because even if the
    // component doesn't need to update, it needs to persist the instance on to
    // the next vnode so that it can be properly unmounted later.
    (vnode.patchFlag > 0 || shapeFlag & 6) && // the EVENTS flag is only for hydration and if it is the only flag, the
    // vnode should not be considered dynamic due to handler caching.
    vnode.patchFlag !== 32) {
      currentBlock.push(vnode);
    }
    return vnode;
  }
  const createVNode = _createVNode;
  function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
    if (!type || type === NULL_DYNAMIC_COMPONENT) {
      type = Comment;
    }
    if (isVNode(type)) {
      const cloned = cloneVNode(
        type,
        props,
        true
        /* mergeRef: true */
      );
      if (children) {
        normalizeChildren(cloned, children);
      }
      if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
        if (cloned.shapeFlag & 6) {
          currentBlock[currentBlock.indexOf(type)] = cloned;
        } else {
          currentBlock.push(cloned);
        }
      }
      cloned.patchFlag |= -2;
      return cloned;
    }
    if (isClassComponent(type)) {
      type = type.__vccOpts;
    }
    if (props) {
      props = guardReactiveProps(props);
      let { class: klass, style } = props;
      if (klass && !isString(klass)) {
        props.class = normalizeClass(klass);
      }
      if (isObject$1(style)) {
        if (isProxy(style) && !isArray$2(style)) {
          style = extend({}, style);
        }
        props.style = normalizeStyle(style);
      }
    }
    const shapeFlag = isString(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$1(type) ? 4 : isFunction$1(type) ? 2 : 0;
    return createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      isBlockNode,
      true
    );
  }
  function guardReactiveProps(props) {
    if (!props)
      return null;
    return isProxy(props) || InternalObjectKey in props ? extend({}, props) : props;
  }
  function cloneVNode(vnode, extraProps, mergeRef = false) {
    const { props, ref, patchFlag, children } = vnode;
    const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
    const cloned = {
      __v_isVNode: true,
      __v_skip: true,
      type: vnode.type,
      props: mergedProps,
      key: mergedProps && normalizeKey(mergedProps),
      ref: extraProps && extraProps.ref ? (
        // #2078 in the case of <component :is="vnode" ref="extra"/>
        // if the vnode itself already has a ref, cloneVNode will need to merge
        // the refs so the single vnode can be set on multiple refs
        mergeRef && ref ? isArray$2(ref) ? ref.concat(normalizeRef(extraProps)) : [ref, normalizeRef(extraProps)] : normalizeRef(extraProps)
      ) : ref,
      scopeId: vnode.scopeId,
      slotScopeIds: vnode.slotScopeIds,
      children: children,
      target: vnode.target,
      targetAnchor: vnode.targetAnchor,
      staticCount: vnode.staticCount,
      shapeFlag: vnode.shapeFlag,
      // if the vnode is cloned with extra props, we can no longer assume its
      // existing patch flag to be reliable and need to add the FULL_PROPS flag.
      // note: preserve flag for fragments since they use the flag for children
      // fast paths only.
      patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
      dynamicProps: vnode.dynamicProps,
      dynamicChildren: vnode.dynamicChildren,
      appContext: vnode.appContext,
      dirs: vnode.dirs,
      transition: vnode.transition,
      // These should technically only be non-null on mounted VNodes. However,
      // they *should* be copied for kept-alive vnodes. So we just always copy
      // them since them being non-null during a mount doesn't affect the logic as
      // they will simply be overwritten.
      component: vnode.component,
      suspense: vnode.suspense,
      ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
      ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
      el: vnode.el,
      anchor: vnode.anchor,
      ctx: vnode.ctx,
      ce: vnode.ce
    };
    return cloned;
  }
  function createTextVNode(text = " ", flag = 0) {
    return createVNode(Text, null, text, flag);
  }
  function createCommentVNode(text = "", asBlock = false) {
    return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
  }
  function normalizeVNode(child) {
    if (child == null || typeof child === "boolean") {
      return createVNode(Comment);
    } else if (isArray$2(child)) {
      return createVNode(
        Fragment,
        null,
        // #3666, avoid reference pollution when reusing vnode
        child.slice()
      );
    } else if (typeof child === "object") {
      return cloneIfMounted(child);
    } else {
      return createVNode(Text, null, String(child));
    }
  }
  function cloneIfMounted(child) {
    return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
  }
  function normalizeChildren(vnode, children) {
    let type = 0;
    const { shapeFlag } = vnode;
    if (children == null) {
      children = null;
    } else if (isArray$2(children)) {
      type = 16;
    } else if (typeof children === "object") {
      if (shapeFlag & (1 | 64)) {
        const slot = children.default;
        if (slot) {
          slot._c && (slot._d = false);
          normalizeChildren(vnode, slot());
          slot._c && (slot._d = true);
        }
        return;
      } else {
        type = 32;
        const slotFlag = children._;
        if (!slotFlag && !(InternalObjectKey in children)) {
          children._ctx = currentRenderingInstance;
        } else if (slotFlag === 3 && currentRenderingInstance) {
          if (currentRenderingInstance.slots._ === 1) {
            children._ = 1;
          } else {
            children._ = 2;
            vnode.patchFlag |= 1024;
          }
        }
      }
    } else if (isFunction$1(children)) {
      children = { default: children, _ctx: currentRenderingInstance };
      type = 32;
    } else {
      children = String(children);
      if (shapeFlag & 64) {
        type = 16;
        children = [createTextVNode(children)];
      } else {
        type = 8;
      }
    }
    vnode.children = children;
    vnode.shapeFlag |= type;
  }
  function mergeProps(...args) {
    const ret = {};
    for (let i = 0; i < args.length; i++) {
      const toMerge = args[i];
      for (const key in toMerge) {
        if (key === "class") {
          if (ret.class !== toMerge.class) {
            ret.class = normalizeClass([ret.class, toMerge.class]);
          }
        } else if (key === "style") {
          ret.style = normalizeStyle([ret.style, toMerge.style]);
        } else if (isOn(key)) {
          const existing = ret[key];
          const incoming = toMerge[key];
          if (incoming && existing !== incoming && !(isArray$2(existing) && existing.includes(incoming))) {
            ret[key] = existing ? [].concat(existing, incoming) : incoming;
          }
        } else if (key !== "") {
          ret[key] = toMerge[key];
        }
      }
    }
    return ret;
  }
  function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
    callWithAsyncErrorHandling(hook, instance, 7, [
      vnode,
      prevVNode
    ]);
  }

  const emptyAppContext = createAppContext();
  let uid = 0;
  function createComponentInstance(vnode, parent, suspense) {
    const type = vnode.type;
    const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
    const instance = {
      uid: uid++,
      vnode,
      type,
      parent,
      appContext,
      root: null,
      // to be immediately set
      next: null,
      subTree: null,
      // will be set synchronously right after creation
      effect: null,
      update: null,
      // will be set synchronously right after creation
      scope: new EffectScope(
        true
        /* detached */
      ),
      render: null,
      proxy: null,
      exposed: null,
      exposeProxy: null,
      withProxy: null,
      provides: parent ? parent.provides : Object.create(appContext.provides),
      accessCache: null,
      renderCache: [],
      // local resolved assets
      components: null,
      directives: null,
      // resolved props and emits options
      propsOptions: normalizePropsOptions(type, appContext),
      emitsOptions: normalizeEmitsOptions(type, appContext),
      // emit
      emit: null,
      // to be set immediately
      emitted: null,
      // props default value
      propsDefaults: EMPTY_OBJ,
      // inheritAttrs
      inheritAttrs: type.inheritAttrs,
      // state
      ctx: EMPTY_OBJ,
      data: EMPTY_OBJ,
      props: EMPTY_OBJ,
      attrs: EMPTY_OBJ,
      slots: EMPTY_OBJ,
      refs: EMPTY_OBJ,
      setupState: EMPTY_OBJ,
      setupContext: null,
      attrsProxy: null,
      slotsProxy: null,
      // suspense related
      suspense,
      suspenseId: suspense ? suspense.pendingId : 0,
      asyncDep: null,
      asyncResolved: false,
      // lifecycle hooks
      // not using enums here because it results in computed properties
      isMounted: false,
      isUnmounted: false,
      isDeactivated: false,
      bc: null,
      c: null,
      bm: null,
      m: null,
      bu: null,
      u: null,
      um: null,
      bum: null,
      da: null,
      a: null,
      rtg: null,
      rtc: null,
      ec: null,
      sp: null
    };
    {
      instance.ctx = { _: instance };
    }
    instance.root = parent ? parent.root : instance;
    instance.emit = emit.bind(null, instance);
    if (vnode.ce) {
      vnode.ce(instance);
    }
    return instance;
  }
  let currentInstance = null;
  const getCurrentInstance = () => currentInstance || currentRenderingInstance;
  let internalSetCurrentInstance;
  let setInSSRSetupState;
  {
    const g = getGlobalThis();
    const registerGlobalSetter = (key, setter) => {
      let setters;
      if (!(setters = g[key]))
        setters = g[key] = [];
      setters.push(setter);
      return (v) => {
        if (setters.length > 1)
          setters.forEach((set) => set(v));
        else
          setters[0](v);
      };
    };
    internalSetCurrentInstance = registerGlobalSetter(
      `__VUE_INSTANCE_SETTERS__`,
      (v) => currentInstance = v
    );
    setInSSRSetupState = registerGlobalSetter(
      `__VUE_SSR_SETTERS__`,
      (v) => isInSSRComponentSetup = v
    );
  }
  const setCurrentInstance = (instance) => {
    internalSetCurrentInstance(instance);
    instance.scope.on();
  };
  const unsetCurrentInstance = () => {
    currentInstance && currentInstance.scope.off();
    internalSetCurrentInstance(null);
  };
  function isStatefulComponent(instance) {
    return instance.vnode.shapeFlag & 4;
  }
  let isInSSRComponentSetup = false;
  function setupComponent(instance, isSSR = false) {
    isSSR && setInSSRSetupState(isSSR);
    const { props, children } = instance.vnode;
    const isStateful = isStatefulComponent(instance);
    initProps(instance, props, isStateful, isSSR);
    initSlots(instance, children);
    const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
    isSSR && setInSSRSetupState(false);
    return setupResult;
  }
  function setupStatefulComponent(instance, isSSR) {
    const Component = instance.type;
    instance.accessCache = /* @__PURE__ */ Object.create(null);
    instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
    const { setup } = Component;
    if (setup) {
      const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
      setCurrentInstance(instance);
      pauseTracking();
      const setupResult = callWithErrorHandling(
        setup,
        instance,
        0,
        [
          instance.props,
          setupContext
        ]
      );
      resetTracking();
      unsetCurrentInstance();
      if (isPromise(setupResult)) {
        setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
        if (isSSR) {
          return setupResult.then((resolvedResult) => {
            handleSetupResult(instance, resolvedResult, isSSR);
          }).catch((e) => {
            handleError(e, instance, 0);
          });
        } else {
          instance.asyncDep = setupResult;
        }
      } else {
        handleSetupResult(instance, setupResult, isSSR);
      }
    } else {
      finishComponentSetup(instance, isSSR);
    }
  }
  function handleSetupResult(instance, setupResult, isSSR) {
    if (isFunction$1(setupResult)) {
      if (instance.type.__ssrInlineRender) {
        instance.ssrRender = setupResult;
      } else {
        instance.render = setupResult;
      }
    } else if (isObject$1(setupResult)) {
      instance.setupState = proxyRefs(setupResult);
    } else ;
    finishComponentSetup(instance, isSSR);
  }
  let compile;
  function finishComponentSetup(instance, isSSR, skipOptions) {
    const Component = instance.type;
    if (!instance.render) {
      if (!isSSR && compile && !Component.render) {
        const template = Component.template || resolveMergedOptions(instance).template;
        if (template) {
          const { isCustomElement, compilerOptions } = instance.appContext.config;
          const { delimiters, compilerOptions: componentCompilerOptions } = Component;
          const finalCompilerOptions = extend(
            extend(
              {
                isCustomElement,
                delimiters
              },
              compilerOptions
            ),
            componentCompilerOptions
          );
          Component.render = compile(template, finalCompilerOptions);
        }
      }
      instance.render = Component.render || NOOP;
    }
    if (__VUE_OPTIONS_API__ && true) {
      setCurrentInstance(instance);
      pauseTracking();
      try {
        applyOptions(instance);
      } finally {
        resetTracking();
        unsetCurrentInstance();
      }
    }
  }
  function getAttrsProxy(instance) {
    return instance.attrsProxy || (instance.attrsProxy = new Proxy(
      instance.attrs,
      {
        get(target, key) {
          track(instance, "get", "$attrs");
          return target[key];
        }
      }
    ));
  }
  function createSetupContext(instance) {
    const expose = (exposed) => {
      instance.exposed = exposed || {};
    };
    {
      return {
        get attrs() {
          return getAttrsProxy(instance);
        },
        slots: instance.slots,
        emit: instance.emit,
        expose
      };
    }
  }
  function getExposeProxy(instance) {
    if (instance.exposed) {
      return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
        get(target, key) {
          if (key in target) {
            return target[key];
          } else if (key in publicPropertiesMap) {
            return publicPropertiesMap[key](instance);
          }
        },
        has(target, key) {
          return key in target || key in publicPropertiesMap;
        }
      }));
    }
  }
  const classifyRE = /(?:^|[-_])(\w)/g;
  const classify = (str) => str.replace(classifyRE, (c) => c.toUpperCase()).replace(/[-_]/g, "");
  function getComponentName(Component, includeInferred = true) {
    return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
  }
  function formatComponentName(instance, Component, isRoot = false) {
    let name = getComponentName(Component);
    if (!name && Component.__file) {
      const match = Component.__file.match(/([^/\\]+)\.\w+$/);
      if (match) {
        name = match[1];
      }
    }
    if (!name && instance && instance.parent) {
      const inferFromRegistry = (registry) => {
        for (const key in registry) {
          if (registry[key] === Component) {
            return key;
          }
        }
      };
      name = inferFromRegistry(
        instance.components || instance.parent.type.components
      ) || inferFromRegistry(instance.appContext.components);
    }
    return name ? classify(name) : isRoot ? `App` : `Anonymous`;
  }
  function isClassComponent(value) {
    return isFunction$1(value) && "__vccOpts" in value;
  }

  const computed = (getterOrOptions, debugOptions) => {
    return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
  };

  function h(type, propsOrChildren, children) {
    const l = arguments.length;
    if (l === 2) {
      if (isObject$1(propsOrChildren) && !isArray$2(propsOrChildren)) {
        if (isVNode(propsOrChildren)) {
          return createVNode(type, null, [propsOrChildren]);
        }
        return createVNode(type, propsOrChildren);
      } else {
        return createVNode(type, null, propsOrChildren);
      }
    } else {
      if (l > 3) {
        children = Array.prototype.slice.call(arguments, 2);
      } else if (l === 3 && isVNode(children)) {
        children = [children];
      }
      return createVNode(type, propsOrChildren, children);
    }
  }

  const ssrContextKey$1 = Symbol.for("v-scx");
  const useSSRContext = () => {
    {
      const ctx = inject(ssrContextKey$1);
      return ctx;
    }
  };

  const version$1 = "3.4.0";

  const svgNS = "http://www.w3.org/2000/svg";
  const mathmlNS = "http://www.w3.org/1998/Math/MathML";
  const doc = typeof document !== "undefined" ? document : null;
  const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
  const nodeOps = {
    insert: (child, parent, anchor) => {
      parent.insertBefore(child, anchor || null);
    },
    remove: (child) => {
      const parent = child.parentNode;
      if (parent) {
        parent.removeChild(child);
      }
    },
    createElement: (tag, namespace, is, props) => {
      const el = namespace === "svg" ? doc.createElementNS(svgNS, tag) : namespace === "mathml" ? doc.createElementNS(mathmlNS, tag) : doc.createElement(tag, is ? { is } : void 0);
      if (tag === "select" && props && props.multiple != null) {
        el.setAttribute("multiple", props.multiple);
      }
      return el;
    },
    createText: (text) => doc.createTextNode(text),
    createComment: (text) => doc.createComment(text),
    setText: (node, text) => {
      node.nodeValue = text;
    },
    setElementText: (el, text) => {
      el.textContent = text;
    },
    parentNode: (node) => node.parentNode,
    nextSibling: (node) => node.nextSibling,
    querySelector: (selector) => doc.querySelector(selector),
    setScopeId(el, id) {
      el.setAttribute(id, "");
    },
    // __UNSAFE__
    // Reason: innerHTML.
    // Static content here can only come from compiled templates.
    // As long as the user only uses trusted templates, this is safe.
    insertStaticContent(content, parent, anchor, namespace, start, end) {
      const before = anchor ? anchor.previousSibling : parent.lastChild;
      if (start && (start === end || start.nextSibling)) {
        while (true) {
          parent.insertBefore(start.cloneNode(true), anchor);
          if (start === end || !(start = start.nextSibling))
            break;
        }
      } else {
        templateContainer.innerHTML = namespace === "svg" ? `<svg>${content}</svg>` : namespace === "mathml" ? `<math>${content}</math>` : content;
        const template = templateContainer.content;
        if (namespace === "svg" || namespace === "mathml") {
          const wrapper = template.firstChild;
          while (wrapper.firstChild) {
            template.appendChild(wrapper.firstChild);
          }
          template.removeChild(wrapper);
        }
        parent.insertBefore(template, anchor);
      }
      return [
        // first
        before ? before.nextSibling : parent.firstChild,
        // last
        anchor ? anchor.previousSibling : parent.lastChild
      ];
    }
  };

  const TRANSITION = "transition";
  const ANIMATION = "animation";
  const vtcKey = Symbol("_vtc");
  const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
  Transition.displayName = "Transition";
  const DOMTransitionPropsValidators = {
    name: String,
    type: String,
    css: {
      type: Boolean,
      default: true
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
  };
  const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend(
    {},
    BaseTransitionPropsValidators,
    DOMTransitionPropsValidators
  );
  const callHook = (hook, args = []) => {
    if (isArray$2(hook)) {
      hook.forEach((h2) => h2(...args));
    } else if (hook) {
      hook(...args);
    }
  };
  const hasExplicitCallback = (hook) => {
    return hook ? isArray$2(hook) ? hook.some((h2) => h2.length > 1) : hook.length > 1 : false;
  };
  function resolveTransitionProps(rawProps) {
    const baseProps = {};
    for (const key in rawProps) {
      if (!(key in DOMTransitionPropsValidators)) {
        baseProps[key] = rawProps[key];
      }
    }
    if (rawProps.css === false) {
      return baseProps;
    }
    const {
      name = "v",
      type,
      duration,
      enterFromClass = `${name}-enter-from`,
      enterActiveClass = `${name}-enter-active`,
      enterToClass = `${name}-enter-to`,
      appearFromClass = enterFromClass,
      appearActiveClass = enterActiveClass,
      appearToClass = enterToClass,
      leaveFromClass = `${name}-leave-from`,
      leaveActiveClass = `${name}-leave-active`,
      leaveToClass = `${name}-leave-to`
    } = rawProps;
    const durations = normalizeDuration(duration);
    const enterDuration = durations && durations[0];
    const leaveDuration = durations && durations[1];
    const {
      onBeforeEnter,
      onEnter,
      onEnterCancelled,
      onLeave,
      onLeaveCancelled,
      onBeforeAppear = onBeforeEnter,
      onAppear = onEnter,
      onAppearCancelled = onEnterCancelled
    } = baseProps;
    const finishEnter = (el, isAppear, done) => {
      removeTransitionClass(el, isAppear ? appearToClass : enterToClass);
      removeTransitionClass(el, isAppear ? appearActiveClass : enterActiveClass);
      done && done();
    };
    const finishLeave = (el, done) => {
      el._isLeaving = false;
      removeTransitionClass(el, leaveFromClass);
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
      done && done();
    };
    const makeEnterHook = (isAppear) => {
      return (el, done) => {
        const hook = isAppear ? onAppear : onEnter;
        const resolve = () => finishEnter(el, isAppear, done);
        callHook(hook, [el, resolve]);
        nextFrame(() => {
          removeTransitionClass(el, isAppear ? appearFromClass : enterFromClass);
          addTransitionClass(el, isAppear ? appearToClass : enterToClass);
          if (!hasExplicitCallback(hook)) {
            whenTransitionEnds(el, type, enterDuration, resolve);
          }
        });
      };
    };
    return extend(baseProps, {
      onBeforeEnter(el) {
        callHook(onBeforeEnter, [el]);
        addTransitionClass(el, enterFromClass);
        addTransitionClass(el, enterActiveClass);
      },
      onBeforeAppear(el) {
        callHook(onBeforeAppear, [el]);
        addTransitionClass(el, appearFromClass);
        addTransitionClass(el, appearActiveClass);
      },
      onEnter: makeEnterHook(false),
      onAppear: makeEnterHook(true),
      onLeave(el, done) {
        el._isLeaving = true;
        const resolve = () => finishLeave(el, done);
        addTransitionClass(el, leaveFromClass);
        forceReflow();
        addTransitionClass(el, leaveActiveClass);
        nextFrame(() => {
          if (!el._isLeaving) {
            return;
          }
          removeTransitionClass(el, leaveFromClass);
          addTransitionClass(el, leaveToClass);
          if (!hasExplicitCallback(onLeave)) {
            whenTransitionEnds(el, type, leaveDuration, resolve);
          }
        });
        callHook(onLeave, [el, resolve]);
      },
      onEnterCancelled(el) {
        finishEnter(el, false);
        callHook(onEnterCancelled, [el]);
      },
      onAppearCancelled(el) {
        finishEnter(el, true);
        callHook(onAppearCancelled, [el]);
      },
      onLeaveCancelled(el) {
        finishLeave(el);
        callHook(onLeaveCancelled, [el]);
      }
    });
  }
  function normalizeDuration(duration) {
    if (duration == null) {
      return null;
    } else if (isObject$1(duration)) {
      return [NumberOf(duration.enter), NumberOf(duration.leave)];
    } else {
      const n = NumberOf(duration);
      return [n, n];
    }
  }
  function NumberOf(val) {
    const res = toNumber$1(val);
    return res;
  }
  function addTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.add(c));
    (el[vtcKey] || (el[vtcKey] = /* @__PURE__ */ new Set())).add(cls);
  }
  function removeTransitionClass(el, cls) {
    cls.split(/\s+/).forEach((c) => c && el.classList.remove(c));
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.delete(cls);
      if (!_vtc.size) {
        el[vtcKey] = void 0;
      }
    }
  }
  function nextFrame(cb) {
    requestAnimationFrame(() => {
      requestAnimationFrame(cb);
    });
  }
  let endId = 0;
  function whenTransitionEnds(el, expectedType, explicitTimeout, resolve) {
    const id = el._endId = ++endId;
    const resolveIfNotStale = () => {
      if (id === el._endId) {
        resolve();
      }
    };
    if (explicitTimeout) {
      return setTimeout(resolveIfNotStale, explicitTimeout);
    }
    const { type, timeout, propCount } = getTransitionInfo(el, expectedType);
    if (!type) {
      return resolve();
    }
    const endEvent = type + "end";
    let ended = 0;
    const end = () => {
      el.removeEventListener(endEvent, onEnd);
      resolveIfNotStale();
    };
    const onEnd = (e) => {
      if (e.target === el && ++ended >= propCount) {
        end();
      }
    };
    setTimeout(() => {
      if (ended < propCount) {
        end();
      }
    }, timeout + 1);
    el.addEventListener(endEvent, onEnd);
  }
  function getTransitionInfo(el, expectedType) {
    const styles = window.getComputedStyle(el);
    const getStyleProperties = (key) => (styles[key] || "").split(", ");
    const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
    const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
    const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
    const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
    const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
    const animationTimeout = getTimeout(animationDelays, animationDurations);
    let type = null;
    let timeout = 0;
    let propCount = 0;
    if (expectedType === TRANSITION) {
      if (transitionTimeout > 0) {
        type = TRANSITION;
        timeout = transitionTimeout;
        propCount = transitionDurations.length;
      }
    } else if (expectedType === ANIMATION) {
      if (animationTimeout > 0) {
        type = ANIMATION;
        timeout = animationTimeout;
        propCount = animationDurations.length;
      }
    } else {
      timeout = Math.max(transitionTimeout, animationTimeout);
      type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
      propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
    }
    const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(
      getStyleProperties(`${TRANSITION}Property`).toString()
    );
    return {
      type,
      timeout,
      propCount,
      hasTransform
    };
  }
  function getTimeout(delays, durations) {
    while (delays.length < durations.length) {
      delays = delays.concat(delays);
    }
    return Math.max(...durations.map((d, i) => toMs(d) + toMs(delays[i])));
  }
  function toMs(s) {
    if (s === "auto")
      return 0;
    return Number(s.slice(0, -1).replace(",", ".")) * 1e3;
  }
  function forceReflow() {
    return document.body.offsetHeight;
  }

  function patchClass(el, value, isSVG) {
    const transitionClasses = el[vtcKey];
    if (transitionClasses) {
      value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
    }
    if (value == null) {
      el.removeAttribute("class");
    } else if (isSVG) {
      el.setAttribute("class", value);
    } else {
      el.className = value;
    }
  }

  const vShowOldKey = Symbol("_vod");
  const vShow = {
    beforeMount(el, { value }, { transition }) {
      el[vShowOldKey] = el.style.display === "none" ? "" : el.style.display;
      if (transition && value) {
        transition.beforeEnter(el);
      } else {
        setDisplay(el, value);
      }
    },
    mounted(el, { value }, { transition }) {
      if (transition && value) {
        transition.enter(el);
      }
    },
    updated(el, { value, oldValue }, { transition }) {
      if (!value === !oldValue)
        return;
      if (transition) {
        if (value) {
          transition.beforeEnter(el);
          setDisplay(el, true);
          transition.enter(el);
        } else {
          transition.leave(el, () => {
            setDisplay(el, false);
          });
        }
      } else {
        setDisplay(el, value);
      }
    },
    beforeUnmount(el, { value }) {
      setDisplay(el, value);
    }
  };
  function setDisplay(el, value) {
    el.style.display = value ? el[vShowOldKey] : "none";
  }

  const CSS_VAR_TEXT = Symbol("");

  function patchStyle(el, prev, next) {
    const style = el.style;
    const isCssString = isString(next);
    if (next && !isCssString) {
      if (prev && !isString(prev)) {
        for (const key in prev) {
          if (next[key] == null) {
            setStyle(style, key, "");
          }
        }
      }
      for (const key in next) {
        setStyle(style, key, next[key]);
      }
    } else {
      const currentDisplay = style.display;
      if (isCssString) {
        if (prev !== next) {
          const cssVarText = style[CSS_VAR_TEXT];
          if (cssVarText) {
            next += ";" + cssVarText;
          }
          style.cssText = next;
        }
      } else if (prev) {
        el.removeAttribute("style");
      }
      if (vShowOldKey in el) {
        style.display = currentDisplay;
      }
    }
  }
  const importantRE = /\s*!important$/;
  function setStyle(style, name, val) {
    if (isArray$2(val)) {
      val.forEach((v) => setStyle(style, name, v));
    } else {
      if (val == null)
        val = "";
      if (name.startsWith("--")) {
        style.setProperty(name, val);
      } else {
        const prefixed = autoPrefix(style, name);
        if (importantRE.test(val)) {
          style.setProperty(
            hyphenate(prefixed),
            val.replace(importantRE, ""),
            "important"
          );
        } else {
          style[prefixed] = val;
        }
      }
    }
  }
  const prefixes = ["Webkit", "Moz", "ms"];
  const prefixCache = {};
  function autoPrefix(style, rawName) {
    const cached = prefixCache[rawName];
    if (cached) {
      return cached;
    }
    let name = camelize(rawName);
    if (name !== "filter" && name in style) {
      return prefixCache[rawName] = name;
    }
    name = capitalize$1(name);
    for (let i = 0; i < prefixes.length; i++) {
      const prefixed = prefixes[i] + name;
      if (prefixed in style) {
        return prefixCache[rawName] = prefixed;
      }
    }
    return rawName;
  }

  const xlinkNS = "http://www.w3.org/1999/xlink";
  function patchAttr(el, key, value, isSVG, instance) {
    if (isSVG && key.startsWith("xlink:")) {
      if (value == null) {
        el.removeAttributeNS(xlinkNS, key.slice(6, key.length));
      } else {
        el.setAttributeNS(xlinkNS, key, value);
      }
    } else {
      const isBoolean = isSpecialBooleanAttr(key);
      if (value == null || isBoolean && !includeBooleanAttr(value)) {
        el.removeAttribute(key);
      } else {
        el.setAttribute(key, isBoolean ? "" : value);
      }
    }
  }

  function patchDOMProp(el, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
    if (key === "innerHTML" || key === "textContent") {
      if (prevChildren) {
        unmountChildren(prevChildren, parentComponent, parentSuspense);
      }
      el[key] = value == null ? "" : value;
      return;
    }
    const tag = el.tagName;
    if (key === "value" && tag !== "PROGRESS" && // custom elements may use _value internally
    !tag.includes("-")) {
      el._value = value;
      const oldValue = tag === "OPTION" ? el.getAttribute("value") : el.value;
      const newValue = value == null ? "" : value;
      if (oldValue !== newValue) {
        el.value = newValue;
      }
      if (value == null) {
        el.removeAttribute(key);
      }
      return;
    }
    let needRemove = false;
    if (value === "" || value == null) {
      const type = typeof el[key];
      if (type === "boolean") {
        value = includeBooleanAttr(value);
      } else if (value == null && type === "string") {
        value = "";
        needRemove = true;
      } else if (type === "number") {
        value = 0;
        needRemove = true;
      }
    }
    try {
      el[key] = value;
    } catch (e) {
    }
    needRemove && el.removeAttribute(key);
  }

  function addEventListener(el, event, handler, options) {
    el.addEventListener(event, handler, options);
  }
  function removeEventListener(el, event, handler, options) {
    el.removeEventListener(event, handler, options);
  }
  const veiKey = Symbol("_vei");
  function patchEvent(el, rawName, prevValue, nextValue, instance = null) {
    const invokers = el[veiKey] || (el[veiKey] = {});
    const existingInvoker = invokers[rawName];
    if (nextValue && existingInvoker) {
      existingInvoker.value = nextValue;
    } else {
      const [name, options] = parseName(rawName);
      if (nextValue) {
        const invoker = invokers[rawName] = createInvoker(nextValue, instance);
        addEventListener(el, name, invoker, options);
      } else if (existingInvoker) {
        removeEventListener(el, name, existingInvoker, options);
        invokers[rawName] = void 0;
      }
    }
  }
  const optionsModifierRE = /(?:Once|Passive|Capture)$/;
  function parseName(name) {
    let options;
    if (optionsModifierRE.test(name)) {
      options = {};
      let m;
      while (m = name.match(optionsModifierRE)) {
        name = name.slice(0, name.length - m[0].length);
        options[m[0].toLowerCase()] = true;
      }
    }
    const event = name[2] === ":" ? name.slice(3) : hyphenate(name.slice(2));
    return [event, options];
  }
  let cachedNow = 0;
  const p$1 = /* @__PURE__ */ Promise.resolve();
  const getNow = () => cachedNow || (p$1.then(() => cachedNow = 0), cachedNow = Date.now());
  function createInvoker(initialValue, instance) {
    const invoker = (e) => {
      if (!e._vts) {
        e._vts = Date.now();
      } else if (e._vts <= invoker.attached) {
        return;
      }
      callWithAsyncErrorHandling(
        patchStopImmediatePropagation(e, invoker.value),
        instance,
        5,
        [e]
      );
    };
    invoker.value = initialValue;
    invoker.attached = getNow();
    return invoker;
  }
  function patchStopImmediatePropagation(e, value) {
    if (isArray$2(value)) {
      const originalStop = e.stopImmediatePropagation;
      e.stopImmediatePropagation = () => {
        originalStop.call(e);
        e._stopped = true;
      };
      return value.map((fn) => (e2) => !e2._stopped && fn && fn(e2));
    } else {
      return value;
    }
  }

  const isNativeOn = (key) => key.charCodeAt(0) === 111 && key.charCodeAt(1) === 110 && // lowercase letter
  key.charCodeAt(2) > 96 && key.charCodeAt(2) < 123;
  const patchProp = (el, key, prevValue, nextValue, namespace, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
    const isSVG = namespace === "svg";
    if (key === "class") {
      patchClass(el, nextValue, isSVG);
    } else if (key === "style") {
      patchStyle(el, prevValue, nextValue);
    } else if (isOn(key)) {
      if (!isModelListener(key)) {
        patchEvent(el, key, prevValue, nextValue, parentComponent);
      }
    } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el, key, nextValue, isSVG)) {
      patchDOMProp(
        el,
        key,
        nextValue,
        prevChildren,
        parentComponent,
        parentSuspense,
        unmountChildren
      );
    } else {
      if (key === "true-value") {
        el._trueValue = nextValue;
      } else if (key === "false-value") {
        el._falseValue = nextValue;
      }
      patchAttr(el, key, nextValue, isSVG);
    }
  };
  function shouldSetAsProp(el, key, value, isSVG) {
    if (isSVG) {
      if (key === "innerHTML" || key === "textContent") {
        return true;
      }
      if (key in el && isNativeOn(key) && isFunction$1(value)) {
        return true;
      }
      return false;
    }
    if (key === "spellcheck" || key === "draggable" || key === "translate") {
      return false;
    }
    if (key === "form") {
      return false;
    }
    if (key === "list" && el.tagName === "INPUT") {
      return false;
    }
    if (key === "type" && el.tagName === "TEXTAREA") {
      return false;
    }
    if (key === "width" || key === "height") {
      const tag = el.tagName;
      if (tag === "IMG" || tag === "VIDEO" || tag === "CANVAS" || tag === "SOURCE") {
        return false;
      }
    }
    if (isNativeOn(key) && isString(value)) {
      return false;
    }
    return key in el;
  }

  const positionMap = /* @__PURE__ */ new WeakMap();
  const newPositionMap = /* @__PURE__ */ new WeakMap();
  const moveCbKey = Symbol("_moveCb");
  const enterCbKey = Symbol("_enterCb");
  const TransitionGroupImpl = {
    name: "TransitionGroup",
    props: /* @__PURE__ */ extend({}, TransitionPropsValidators, {
      tag: String,
      moveClass: String
    }),
    setup(props, { slots }) {
      const instance = getCurrentInstance();
      const state = useTransitionState();
      let prevChildren;
      let children;
      onUpdated(() => {
        if (!prevChildren.length) {
          return;
        }
        const moveClass = props.moveClass || `${props.name || "v"}-move`;
        if (!hasCSSTransform(
          prevChildren[0].el,
          instance.vnode.el,
          moveClass
        )) {
          return;
        }
        prevChildren.forEach(callPendingCbs);
        prevChildren.forEach(recordPosition);
        const movedChildren = prevChildren.filter(applyTranslation);
        forceReflow();
        movedChildren.forEach((c) => {
          const el = c.el;
          const style = el.style;
          addTransitionClass(el, moveClass);
          style.transform = style.webkitTransform = style.transitionDuration = "";
          const cb = el[moveCbKey] = (e) => {
            if (e && e.target !== el) {
              return;
            }
            if (!e || /transform$/.test(e.propertyName)) {
              el.removeEventListener("transitionend", cb);
              el[moveCbKey] = null;
              removeTransitionClass(el, moveClass);
            }
          };
          el.addEventListener("transitionend", cb);
        });
      });
      return () => {
        const rawProps = toRaw(props);
        const cssTransitionProps = resolveTransitionProps(rawProps);
        let tag = rawProps.tag || Fragment;
        prevChildren = children;
        children = slots.default ? getTransitionRawChildren(slots.default()) : [];
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if (child.key != null) {
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
          }
        }
        if (prevChildren) {
          for (let i = 0; i < prevChildren.length; i++) {
            const child = prevChildren[i];
            setTransitionHooks(
              child,
              resolveTransitionHooks(child, cssTransitionProps, state, instance)
            );
            positionMap.set(child, child.el.getBoundingClientRect());
          }
        }
        return createVNode(tag, null, children);
      };
    }
  };
  const removeMode = (props) => delete props.mode;
  /* @__PURE__ */ removeMode(TransitionGroupImpl.props);
  const TransitionGroup = TransitionGroupImpl;
  function callPendingCbs(c) {
    const el = c.el;
    if (el[moveCbKey]) {
      el[moveCbKey]();
    }
    if (el[enterCbKey]) {
      el[enterCbKey]();
    }
  }
  function recordPosition(c) {
    newPositionMap.set(c, c.el.getBoundingClientRect());
  }
  function applyTranslation(c) {
    const oldPos = positionMap.get(c);
    const newPos = newPositionMap.get(c);
    const dx = oldPos.left - newPos.left;
    const dy = oldPos.top - newPos.top;
    if (dx || dy) {
      const s = c.el.style;
      s.transform = s.webkitTransform = `translate(${dx}px,${dy}px)`;
      s.transitionDuration = "0s";
      return c;
    }
  }
  function hasCSSTransform(el, root, moveClass) {
    const clone = el.cloneNode();
    const _vtc = el[vtcKey];
    if (_vtc) {
      _vtc.forEach((cls) => {
        cls.split(/\s+/).forEach((c) => c && clone.classList.remove(c));
      });
    }
    moveClass.split(/\s+/).forEach((c) => c && clone.classList.add(c));
    clone.style.display = "none";
    const container = root.nodeType === 1 ? root : root.parentNode;
    container.appendChild(clone);
    const { hasTransform } = getTransitionInfo(clone);
    container.removeChild(clone);
    return hasTransform;
  }

  const rendererOptions = /* @__PURE__ */ extend({ patchProp }, nodeOps);
  let renderer;
  function ensureRenderer() {
    return renderer || (renderer = createRenderer(rendererOptions));
  }
  const createApp = (...args) => {
    const app = ensureRenderer().createApp(...args);
    const { mount } = app;
    app.mount = (containerOrSelector) => {
      const container = normalizeContainer(containerOrSelector);
      if (!container)
        return;
      const component = app._component;
      if (!isFunction$1(component) && !component.render && !component.template) {
        component.template = container.innerHTML;
      }
      container.innerHTML = "";
      const proxy = mount(container, false, resolveRootNamespace(container));
      if (container instanceof Element) {
        container.removeAttribute("v-cloak");
        container.setAttribute("data-v-app", "");
      }
      return proxy;
    };
    return app;
  };
  function resolveRootNamespace(container) {
    if (container instanceof SVGElement) {
      return "svg";
    }
    if (typeof MathMLElement === "function" && container instanceof MathMLElement) {
      return "mathml";
    }
  }
  function normalizeContainer(container) {
    if (isString(container)) {
      const res = document.querySelector(container);
      return res;
    }
    return container;
  }

  /** @license @lljj/vue3-form-naive (c) 2020-2023 Liu.Jun License: Apache-2.0 */
  function y(e){return (y="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function b(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function P(){return (P=Object.assign||function(e){for(var r=1;r<arguments.length;r++){var t=arguments[r];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);}return e}).apply(this,arguments)}function w(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a);}return t}function E(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?w(Object(t),!0).forEach((function(r){b(e,r,t[r]);})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):w(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));}));}return e}function S(e,r){if(null==e)return {};var t,a,o=function(e,r){if(null==e)return {};var t,a,o={},n=Object.keys(e);for(a=0;a<n.length;a++)t=n[a],r.indexOf(t)>=0||(o[t]=e[t]);return o}(e,r);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)t=n[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t]);}return o}function F(e,r){return function(e){if(Array.isArray(e))return e}(e)||function(e,r){if("undefined"==typeof Symbol||!(Symbol.iterator in Object(e)))return;var t=[],a=!0,o=!1,n=void 0;try{for(var i,s=e[Symbol.iterator]();!(a=(i=s.next()).done)&&(t.push(i.value),!r||t.length!==r);a=!0);}catch(e){o=!0,n=e;}finally{try{a||null==s.return||s.return();}finally{if(o)throw n}}return t}(e,r)||O(e,r)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function x(e){return function(e){if(Array.isArray(e))return _(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||O(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function O(e,r){if(e){if("string"==typeof e)return _(e,r);var t=Object.prototype.toString.call(e).slice(8,-1);return "Object"===t&&e.constructor&&(t=e.constructor.name),"Map"===t||"Set"===t?Array.from(e):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?_(e,r):void 0}}function _(e,r){(null==r||r>e.length)&&(r=e.length);for(var t=0,a=new Array(r);t<r;t++)a[t]=e[t];return a}function D(e){var r=function(e,r){if("object"!=typeof e||null===e)return e;var t=e[Symbol.toPrimitive];if(void 0!==t){var a=t.call(e,r||"default");if("object"!=typeof a)return a;throw new TypeError("@@toPrimitive must return a primitive value.")}return ("string"===r?String:Number)(e)}(e,"string");return "symbol"==typeof r?r:String(r)}function k(e){return e?"".concat("__pathRoot",".").concat(e).replace(/\./g,"_"):"__pathRoot"}function j(e){return ""===e}function A(e,r){return ""===e?r:[e,r].join(".")}function I(e,r){for(var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=r.split("."),o=0;o<a.length-t;o+=1){if(void 0===e)return;e=""===a[o]?e:e[a[o]];}return e}function R(e,r){delete e[r];}function $(e,r,t){for(var a=r.split("."),o=0;o<a.length;o+=1){if(a.length-o<2){e[a[a.length-1]]=t;break}e=e[a[o]];}}function N(r){return "string"==typeof r?resolveComponent(r):r}var L=function(e){var a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},o=a.model,n=void 0===o?"value":o;return defineComponent({inheritAttrs:!1,setup:function(r,a){var o=a.attrs,i=a.slots;return function(){var r,a=o.modelValue,s=o["onUpdate:modelValue"],l=S(o,["modelValue","onUpdate:modelValue"]);return h(N(e),E((b(r={},n,a),b(r,"onUpdate:".concat(n),s),r),l),i)}}})};function V(e){return "[object Object]"===Object.prototype.toString.call(e)}function z(e){return "[object Arguments]"===Object.prototype.toString.call(e)}function q(e,r){var t=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=Object.assign({},e);return V(r)?Object.keys(r).reduce((function(a,o){var n=e?e[o]:{},i=r[o];return e&&e.hasOwnProperty(o)&&V(i)?a[o]=q(n,i,t):t&&Array.isArray(n)&&Array.isArray(i)?a[o]=n.concat(i):a[o]=i,a}),a):a}function M(e){var r,t=e.type;return !t&&e.const?(r=e.const,Array.isArray(r)?"array":"string"==typeof r?"string":null==r?"null":"boolean"==typeof r?"boolean":isNaN(r)?"object"===y(r)?"object":"string":"number"):!t&&e.enum?"string":!t&&e.items?"array":t||!e.properties&&!e.additionalProperties?t instanceof Array&&2===t.length&&t.includes("null")?t.find((function(e){return "null"!==e})):t:"object"}function W(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(e===r)return !0;if("function"==typeof e||"function"==typeof r)return !0;if("object"!==y(e)||"object"!==y(r))return !1;if(null===e||null===r)return !1;if(e instanceof Date&&r instanceof Date)return e.getTime()===r.getTime();if(e instanceof RegExp&&r instanceof RegExp)return e.source===r.source&&e.global===r.global&&e.multiline===r.multiline&&e.lastIndex===r.lastIndex&&e.ignoreCase===r.ignoreCase;if(z(e)||z(r)){if(!z(e)||!z(r))return !1;var o=Array.prototype.slice;return W(o.call(e),o.call(r),t,a)}if(e.constructor!==r.constructor)return !1;var n=Object.keys(e),i=Object.keys(r);if(0===n.length&&0===i.length)return !0;if(n.length!==i.length)return !1;for(var s,l=t.length;l--;)if(t[l]===e)return a[l]===r;t.push(e),a.push(r),n.sort(),i.sort();for(var u=n.length-1;u>=0;u--)if(n[u]!==i[u])return !1;for(var c=n.length-1;c>=0;c--)if(!W(e[s=n[c]],r[s],t,a))return !1;return t.pop(),a.pop(),!0}var U,B,Q=(U="".concat(+new Date),B=0,function(){var e="".concat(+new Date);return e===U?B+=1:B=0,"".concat(U=e,"x").concat(B)});function H(e){if(!e)return !0;for(var r in e)if(Object.prototype.hasOwnProperty.call(e,r))return !1;return !0}function K(e,r){return Object.entries(e).reduce((function(e,t){var a=F(t,2),o=a[0],n=a[1],i=r(o,n);return void 0!==i&&(e[i]=n),e}),{})}function G(e){return void 0===e?e:String(e).replace(/^./,(function(e){return e.toLocaleLowerCase()}))}function J(e,r){return e*r/function e(r,t){return 0===t?r:e(t,r%t)}(e,r)}function Z(e,r){for(var t=r.split("/"),a=0;a<t.length;a+=1){if(void 0===e)return;e=""===t[a]?e:e[t[a]];}return e}function Y(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=e;if(!e.startsWith("#"))throw new Error("Could not find a definition for ".concat(t,"."));var a=Z(r,e=decodeURIComponent(e.substring(1)));if(void 0===a)throw new Error("Could not find a definition for ".concat(t,"."));return a.hasOwnProperty("$ref")?Y(a.$ref,r):a}function X(e,r){return e(r={exports:{}},r.exports),r.exports}function ee(e){return e&&e.default||e}var re,te=X((function(e,r){
  /** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
  !function(e){function r(){for(var e=arguments.length,r=Array(e),t=0;t<e;t++)r[t]=arguments[t];if(r.length>1){r[0]=r[0].slice(0,-1);for(var a=r.length-1,o=1;o<a;++o)r[o]=r[o].slice(1,-1);return r[a]=r[a].slice(1),r.join("")}return r[0]}function t(e){return "(?:"+e+")"}function a(e){return void 0===e?"undefined":null===e?"null":Object.prototype.toString.call(e).split(" ").pop().split("]").shift().toLowerCase()}function o(e){return e.toUpperCase()}function n(e){var a=r("[0-9]","[A-Fa-f]"),o=t(t("%[EFef]"+a+"%"+a+a+"%"+a+a)+"|"+t("%[89A-Fa-f]"+a+"%"+a+a)+"|"+t("%"+a+a)),n="[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",i=r("[\\:\\/\\?\\#\\[\\]\\@]",n),s=e?"[\\uE000-\\uF8FF]":"[]",l=r("[A-Za-z]","[0-9]","[\\-\\.\\_\\~]",e?"[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]":"[]");t("[A-Za-z]"+r("[A-Za-z]","[0-9]","[\\+\\-\\.]")+"*"),t(t(o+"|"+r(l,n,"[\\:]"))+"*");var u=t(t("25[0-5]")+"|"+t("2[0-4][0-9]")+"|"+t("1[0-9][0-9]")+"|"+t("0?[1-9][0-9]")+"|0?0?[0-9]"),c=t(u+"\\."+u+"\\."+u+"\\."+u),d=t(a+"{1,4}"),m=t(t(d+"\\:"+d)+"|"+c),p=t(t(d+"\\:")+"{6}"+m),f=t("\\:\\:"+t(d+"\\:")+"{5}"+m),h=t(t(d)+"?\\:\\:"+t(d+"\\:")+"{4}"+m),v=t(t(t(d+"\\:")+"{0,1}"+d)+"?\\:\\:"+t(d+"\\:")+"{3}"+m),g=t(t(t(d+"\\:")+"{0,2}"+d)+"?\\:\\:"+t(d+"\\:")+"{2}"+m),y=t(t(t(d+"\\:")+"{0,3}"+d)+"?\\:\\:"+d+"\\:"+m),b=t(t(t(d+"\\:")+"{0,4}"+d)+"?\\:\\:"+m),P=t(t(t(d+"\\:")+"{0,5}"+d)+"?\\:\\:"+d),w=t(t(t(d+"\\:")+"{0,6}"+d)+"?\\:\\:"),E=t([p,f,h,v,g,y,b,P,w].join("|")),S=t(t(l+"|"+o)+"+");t("[vV]"+a+"+\\."+r(l,n,"[\\:]")+"+"),t(t(o+"|"+r(l,n))+"*");var F=t(o+"|"+r(l,n,"[\\:\\@]"));return t(t(o+"|"+r(l,n,"[\\@]"))+"+"),t(t(F+"|"+r("[\\/\\?]",s))+"*"),{NOT_SCHEME:new RegExp(r("[^]","[A-Za-z]","[0-9]","[\\+\\-\\.]"),"g"),NOT_USERINFO:new RegExp(r("[^\\%\\:]",l,n),"g"),NOT_HOST:new RegExp(r("[^\\%\\[\\]\\:]",l,n),"g"),NOT_PATH:new RegExp(r("[^\\%\\/\\:\\@]",l,n),"g"),NOT_PATH_NOSCHEME:new RegExp(r("[^\\%\\/\\@]",l,n),"g"),NOT_QUERY:new RegExp(r("[^\\%]",l,n,"[\\:\\@\\/\\?]",s),"g"),NOT_FRAGMENT:new RegExp(r("[^\\%]",l,n,"[\\:\\@\\/\\?]"),"g"),ESCAPE:new RegExp(r("[^]",l,n),"g"),UNRESERVED:new RegExp(l,"g"),OTHER_CHARS:new RegExp(r("[^\\%]",l,i),"g"),PCT_ENCODED:new RegExp(o,"g"),IPV4ADDRESS:new RegExp("^("+c+")$"),IPV6ADDRESS:new RegExp("^\\[?("+E+")"+t(t("\\%25|\\%(?!"+a+"{2})")+"("+S+")")+"?\\]?$")}}var i=n(!1),s=n(!0),l=function(e,r){if(Array.isArray(e))return e;if(Symbol.iterator in Object(e))return function(e,r){var t=[],a=!0,o=!1,n=void 0;try{for(var i,s=e[Symbol.iterator]();!(a=(i=s.next()).done)&&(t.push(i.value),!r||t.length!==r);a=!0);}catch(e){o=!0,n=e;}finally{try{!a&&s.return&&s.return();}finally{if(o)throw n}}return t}(e,r);throw new TypeError("Invalid attempt to destructure non-iterable instance")},u=2147483647,c=/^xn--/,d=/[^\0-\x7E]/,m=/[\x2E\u3002\uFF0E\uFF61]/g,p={overflow:"Overflow: input needs wider integers to process","not-basic":"Illegal input >= 0x80 (not a basic code point)","invalid-input":"Invalid input"},f=Math.floor,h=String.fromCharCode;function v(e){throw new RangeError(p[e])}function g(e,r){var t=e.split("@"),a="";t.length>1&&(a=t[0]+"@",e=t[1]);var o=function(e,r){for(var t=[],a=e.length;a--;)t[a]=r(e[a]);return t}((e=e.replace(m,".")).split("."),r).join(".");return a+o}function y(e){for(var r=[],t=0,a=e.length;t<a;){var o=e.charCodeAt(t++);if(o>=55296&&o<=56319&&t<a){var n=e.charCodeAt(t++);56320==(64512&n)?r.push(((1023&o)<<10)+(1023&n)+65536):(r.push(o),t--);}else r.push(o);}return r}var b=function(e,r){return e+22+75*(e<26)-((0!=r)<<5)},P=function(e,r,t){var a=0;for(e=t?f(e/700):e>>1,e+=f(e/r);e>455;a+=36)e=f(e/35);return f(a+36*e/(e+38))},w=function(e){var r,t=[],a=e.length,o=0,n=128,i=72,s=e.lastIndexOf("-");s<0&&(s=0);for(var l=0;l<s;++l)e.charCodeAt(l)>=128&&v("not-basic"),t.push(e.charCodeAt(l));for(var c=s>0?s+1:0;c<a;){for(var d=o,m=1,p=36;;p+=36){c>=a&&v("invalid-input");var h=(r=e.charCodeAt(c++))-48<10?r-22:r-65<26?r-65:r-97<26?r-97:36;(h>=36||h>f((u-o)/m))&&v("overflow"),o+=h*m;var g=p<=i?1:p>=i+26?26:p-i;if(h<g)break;var y=36-g;m>f(u/y)&&v("overflow"),m*=y;}var b=t.length+1;i=P(o-d,b,0==d),f(o/b)>u-n&&v("overflow"),n+=f(o/b),o%=b,t.splice(o++,0,n);}return String.fromCodePoint.apply(String,t)},E=function(e){var r=[],t=(e=y(e)).length,a=128,o=0,n=72,i=!0,s=!1,l=void 0;try{for(var c,d=e[Symbol.iterator]();!(i=(c=d.next()).done);i=!0){var m=c.value;m<128&&r.push(h(m));}}catch(e){s=!0,l=e;}finally{try{!i&&d.return&&d.return();}finally{if(s)throw l}}var p=r.length,g=p;for(p&&r.push("-");g<t;){var w=u,E=!0,S=!1,F=void 0;try{for(var x,O=e[Symbol.iterator]();!(E=(x=O.next()).done);E=!0){var _=x.value;_>=a&&_<w&&(w=_);}}catch(e){S=!0,F=e;}finally{try{!E&&O.return&&O.return();}finally{if(S)throw F}}var D=g+1;w-a>f((u-o)/D)&&v("overflow"),o+=(w-a)*D,a=w;var k=!0,j=!1,A=void 0;try{for(var I,C=e[Symbol.iterator]();!(k=(I=C.next()).done);k=!0){var R=I.value;if(R<a&&++o>u&&v("overflow"),R==a){for(var $=o,N=36;;N+=36){var L=N<=n?1:N>=n+26?26:N-n;if($<L)break;var T=$-L,V=36-L;r.push(h(b(L+T%V,0))),$=f(T/V);}r.push(h(b($,0))),n=P(o,D,g==p),o=0,++g;}}}catch(e){j=!0,A=e;}finally{try{!k&&C.return&&C.return();}finally{if(j)throw A}}++o,++a;}return r.join("")},S=function(e){return g(e,(function(e){return d.test(e)?"xn--"+E(e):e}))},F=function(e){return g(e,(function(e){return c.test(e)?w(e.slice(4).toLowerCase()):e}))},x={};function O(e){var r=e.charCodeAt(0);return r<16?"%0"+r.toString(16).toUpperCase():r<128?"%"+r.toString(16).toUpperCase():r<2048?"%"+(r>>6|192).toString(16).toUpperCase()+"%"+(63&r|128).toString(16).toUpperCase():"%"+(r>>12|224).toString(16).toUpperCase()+"%"+(r>>6&63|128).toString(16).toUpperCase()+"%"+(63&r|128).toString(16).toUpperCase()}function _(e){for(var r="",t=0,a=e.length;t<a;){var o=parseInt(e.substr(t+1,2),16);if(o<128)r+=String.fromCharCode(o),t+=3;else if(o>=194&&o<224){if(a-t>=6){var n=parseInt(e.substr(t+4,2),16);r+=String.fromCharCode((31&o)<<6|63&n);}else r+=e.substr(t,6);t+=6;}else if(o>=224){if(a-t>=9){var i=parseInt(e.substr(t+4,2),16),s=parseInt(e.substr(t+7,2),16);r+=String.fromCharCode((15&o)<<12|(63&i)<<6|63&s);}else r+=e.substr(t,9);t+=9;}else r+=e.substr(t,3),t+=3;}return r}function D(e,r){function t(e){var t=_(e);return t.match(r.UNRESERVED)?t:e}return e.scheme&&(e.scheme=String(e.scheme).replace(r.PCT_ENCODED,t).toLowerCase().replace(r.NOT_SCHEME,"")),void 0!==e.userinfo&&(e.userinfo=String(e.userinfo).replace(r.PCT_ENCODED,t).replace(r.NOT_USERINFO,O).replace(r.PCT_ENCODED,o)),void 0!==e.host&&(e.host=String(e.host).replace(r.PCT_ENCODED,t).toLowerCase().replace(r.NOT_HOST,O).replace(r.PCT_ENCODED,o)),void 0!==e.path&&(e.path=String(e.path).replace(r.PCT_ENCODED,t).replace(e.scheme?r.NOT_PATH:r.NOT_PATH_NOSCHEME,O).replace(r.PCT_ENCODED,o)),void 0!==e.query&&(e.query=String(e.query).replace(r.PCT_ENCODED,t).replace(r.NOT_QUERY,O).replace(r.PCT_ENCODED,o)),void 0!==e.fragment&&(e.fragment=String(e.fragment).replace(r.PCT_ENCODED,t).replace(r.NOT_FRAGMENT,O).replace(r.PCT_ENCODED,o)),e}function k(e){return e.replace(/^0*(.*)/,"$1")||"0"}function j(e,r){var t=e.match(r.IPV4ADDRESS)||[],a=l(t,2)[1];return a?a.split(".").map(k).join("."):e}function A(e,r){var t=e.match(r.IPV6ADDRESS)||[],a=l(t,3),o=a[1],n=a[2];if(o){for(var i=o.toLowerCase().split("::").reverse(),s=l(i,2),u=s[0],c=s[1],d=c?c.split(":").map(k):[],m=u.split(":").map(k),p=r.IPV4ADDRESS.test(m[m.length-1]),f=p?7:8,h=m.length-f,v=Array(f),g=0;g<f;++g)v[g]=d[g]||m[h+g]||"";p&&(v[f-1]=j(v[f-1],r));var y=v.reduce((function(e,r,t){if(!r||"0"===r){var a=e[e.length-1];a&&a.index+a.length===t?a.length++:e.push({index:t,length:1});}return e}),[]).sort((function(e,r){return r.length-e.length}))[0],b=void 0;if(y&&y.length>1){var P=v.slice(0,y.index),w=v.slice(y.index+y.length);b=P.join(":")+"::"+w.join(":");}else b=v.join(":");return n&&(b+="%"+n),b}return e}var I=/^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i,C=void 0==="".match(/(){0}/)[1];function R(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t={},a=!1!==r.iri?s:i;"suffix"===r.reference&&(e=(r.scheme?r.scheme+":":"")+"//"+e);var o=e.match(I);if(o){C?(t.scheme=o[1],t.userinfo=o[3],t.host=o[4],t.port=parseInt(o[5],10),t.path=o[6]||"",t.query=o[7],t.fragment=o[8],isNaN(t.port)&&(t.port=o[5])):(t.scheme=o[1]||void 0,t.userinfo=-1!==e.indexOf("@")?o[3]:void 0,t.host=-1!==e.indexOf("//")?o[4]:void 0,t.port=parseInt(o[5],10),t.path=o[6]||"",t.query=-1!==e.indexOf("?")?o[7]:void 0,t.fragment=-1!==e.indexOf("#")?o[8]:void 0,isNaN(t.port)&&(t.port=e.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/)?o[4]:void 0)),t.host&&(t.host=A(j(t.host,a),a)),void 0!==t.scheme||void 0!==t.userinfo||void 0!==t.host||void 0!==t.port||t.path||void 0!==t.query?void 0===t.scheme?t.reference="relative":void 0===t.fragment?t.reference="absolute":t.reference="uri":t.reference="same-document",r.reference&&"suffix"!==r.reference&&r.reference!==t.reference&&(t.error=t.error||"URI is not a "+r.reference+" reference.");var n=x[(r.scheme||t.scheme||"").toLowerCase()];if(r.unicodeSupport||n&&n.unicodeSupport)D(t,a);else {if(t.host&&(r.domainHost||n&&n.domainHost))try{t.host=S(t.host.replace(a.PCT_ENCODED,_).toLowerCase());}catch(e){t.error=t.error||"Host's domain name can not be converted to ASCII via punycode: "+e;}D(t,i);}n&&n.parse&&n.parse(t,r);}else t.error=t.error||"URI can not be parsed.";return t}function $(e,r){var t=!1!==r.iri?s:i,a=[];return void 0!==e.userinfo&&(a.push(e.userinfo),a.push("@")),void 0!==e.host&&a.push(A(j(String(e.host),t),t).replace(t.IPV6ADDRESS,(function(e,r,t){return "["+r+(t?"%25"+t:"")+"]"}))),"number"!=typeof e.port&&"string"!=typeof e.port||(a.push(":"),a.push(String(e.port))),a.length?a.join(""):void 0}var N=/^\.\.?\//,L=/^\/\.(\/|$)/,T=/^\/\.\.(\/|$)/,V=/^\/?(?:.|\n)*?(?=\/|$)/;function z(e){for(var r=[];e.length;)if(e.match(N))e=e.replace(N,"");else if(e.match(L))e=e.replace(L,"/");else if(e.match(T))e=e.replace(T,"/"),r.pop();else if("."===e||".."===e)e="";else {var t=e.match(V);if(!t)throw new Error("Unexpected dot segment condition");var a=t[0];e=e.slice(a.length),r.push(a);}return r.join("")}function q(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=r.iri?s:i,a=[],o=x[(r.scheme||e.scheme||"").toLowerCase()];if(o&&o.serialize&&o.serialize(e,r),e.host)if(t.IPV6ADDRESS.test(e.host));else if(r.domainHost||o&&o.domainHost)try{e.host=r.iri?F(e.host):S(e.host.replace(t.PCT_ENCODED,_).toLowerCase());}catch(t){e.error=e.error||"Host's domain name can not be converted to "+(r.iri?"Unicode":"ASCII")+" via punycode: "+t;}D(e,t),"suffix"!==r.reference&&e.scheme&&(a.push(e.scheme),a.push(":"));var n=$(e,r);if(void 0!==n&&("suffix"!==r.reference&&a.push("//"),a.push(n),e.path&&"/"!==e.path.charAt(0)&&a.push("/")),void 0!==e.path){var l=e.path;r.absolutePath||o&&o.absolutePath||(l=z(l)),void 0===n&&(l=l.replace(/^\/\//,"/%2F")),a.push(l);}return void 0!==e.query&&(a.push("?"),a.push(e.query)),void 0!==e.fragment&&(a.push("#"),a.push(e.fragment)),a.join("")}function M(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments[3],o={};return a||(e=R(q(e,t),t),r=R(q(r,t),t)),!(t=t||{}).tolerant&&r.scheme?(o.scheme=r.scheme,o.userinfo=r.userinfo,o.host=r.host,o.port=r.port,o.path=z(r.path||""),o.query=r.query):(void 0!==r.userinfo||void 0!==r.host||void 0!==r.port?(o.userinfo=r.userinfo,o.host=r.host,o.port=r.port,o.path=z(r.path||""),o.query=r.query):(r.path?("/"===r.path.charAt(0)?o.path=z(r.path):(void 0===e.userinfo&&void 0===e.host&&void 0===e.port||e.path?e.path?o.path=e.path.slice(0,e.path.lastIndexOf("/")+1)+r.path:o.path=r.path:o.path="/"+r.path,o.path=z(o.path)),o.query=r.query):(o.path=e.path,void 0!==r.query?o.query=r.query:o.query=e.query),o.userinfo=e.userinfo,o.host=e.host,o.port=e.port),o.scheme=e.scheme),o.fragment=r.fragment,o}function W(e,r){return e&&e.toString().replace(r&&r.iri?s.PCT_ENCODED:i.PCT_ENCODED,_)}var U={scheme:"http",domainHost:!0,parse:function(e,r){return e.host||(e.error=e.error||"HTTP URIs must have a host."),e},serialize:function(e,r){var t="https"===String(e.scheme).toLowerCase();return e.port!==(t?443:80)&&""!==e.port||(e.port=void 0),e.path||(e.path="/"),e}},B={scheme:"https",domainHost:U.domainHost,parse:U.parse,serialize:U.serialize};function Q(e){return "boolean"==typeof e.secure?e.secure:"wss"===String(e.scheme).toLowerCase()}var H={scheme:"ws",domainHost:!0,parse:function(e,r){var t=e;return t.secure=Q(t),t.resourceName=(t.path||"/")+(t.query?"?"+t.query:""),t.path=void 0,t.query=void 0,t},serialize:function(e,r){if(e.port!==(Q(e)?443:80)&&""!==e.port||(e.port=void 0),"boolean"==typeof e.secure&&(e.scheme=e.secure?"wss":"ws",e.secure=void 0),e.resourceName){var t=e.resourceName.split("?"),a=l(t,2),o=a[0],n=a[1];e.path=o&&"/"!==o?o:void 0,e.query=n,e.resourceName=void 0;}return e.fragment=void 0,e}},K={scheme:"wss",domainHost:H.domainHost,parse:H.parse,serialize:H.serialize},G={},J="[A-Za-z0-9\\-\\.\\_\\~\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]",Z="[0-9A-Fa-f]",Y=t(t("%[EFef]"+Z+"%"+Z+Z+"%"+Z+Z)+"|"+t("%[89A-Fa-f]"+Z+"%"+Z+Z)+"|"+t("%"+Z+Z)),X=r("[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]",'[\\"\\\\]'),ee=new RegExp(J,"g"),re=new RegExp(Y,"g"),te=new RegExp(r("[^]","[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]","[\\.]",'[\\"]',X),"g"),ae=new RegExp(r("[^]",J,"[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]"),"g"),oe=ae;function ne(e){var r=_(e);return r.match(ee)?r:e}var ie={scheme:"mailto",parse:function(e,r){var t=e,a=t.to=t.path?t.path.split(","):[];if(t.path=void 0,t.query){for(var o=!1,n={},i=t.query.split("&"),s=0,l=i.length;s<l;++s){var u=i[s].split("=");switch(u[0]){case"to":for(var c=u[1].split(","),d=0,m=c.length;d<m;++d)a.push(c[d]);break;case"subject":t.subject=W(u[1],r);break;case"body":t.body=W(u[1],r);break;default:o=!0,n[W(u[0],r)]=W(u[1],r);}}o&&(t.headers=n);}t.query=void 0;for(var p=0,f=a.length;p<f;++p){var h=a[p].split("@");if(h[0]=W(h[0]),r.unicodeSupport)h[1]=W(h[1],r).toLowerCase();else try{h[1]=S(W(h[1],r).toLowerCase());}catch(e){t.error=t.error||"Email address's domain name can not be converted to ASCII via punycode: "+e;}a[p]=h.join("@");}return t},serialize:function(e,r){var t,a=e,n=null!=(t=e.to)?t instanceof Array?t:"number"!=typeof t.length||t.split||t.setInterval||t.call?[t]:Array.prototype.slice.call(t):[];if(n){for(var i=0,s=n.length;i<s;++i){var l=String(n[i]),u=l.lastIndexOf("@"),c=l.slice(0,u).replace(re,ne).replace(re,o).replace(te,O),d=l.slice(u+1);try{d=r.iri?F(d):S(W(d,r).toLowerCase());}catch(e){a.error=a.error||"Email address's domain name can not be converted to "+(r.iri?"Unicode":"ASCII")+" via punycode: "+e;}n[i]=c+"@"+d;}a.path=n.join(",");}var m=e.headers=e.headers||{};e.subject&&(m.subject=e.subject),e.body&&(m.body=e.body);var p=[];for(var f in m)m[f]!==G[f]&&p.push(f.replace(re,ne).replace(re,o).replace(ae,O)+"="+m[f].replace(re,ne).replace(re,o).replace(oe,O));return p.length&&(a.query=p.join("&")),a}},se=/^([^\:]+)\:(.*)/,le={scheme:"urn",parse:function(e,r){var t=e.path&&e.path.match(se),a=e;if(t){var o=r.scheme||a.scheme||"urn",n=t[1].toLowerCase(),i=t[2],s=o+":"+(r.nid||n),l=x[s];a.nid=n,a.nss=i,a.path=void 0,l&&(a=l.parse(a,r));}else a.error=a.error||"URN can not be parsed.";return a},serialize:function(e,r){var t=r.scheme||e.scheme||"urn",a=e.nid,o=t+":"+(r.nid||a),n=x[o];n&&(e=n.serialize(e,r));var i=e,s=e.nss;return i.path=(a||r.nid)+":"+s,i}},ue=/^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/,ce={scheme:"urn:uuid",parse:function(e,r){var t=e;return t.uuid=t.nss,t.nss=void 0,r.tolerant||t.uuid&&t.uuid.match(ue)||(t.error=t.error||"UUID is not valid."),t},serialize:function(e,r){var t=e;return t.nss=(e.uuid||"").toLowerCase(),t}};x[U.scheme]=U,x[B.scheme]=B,x[H.scheme]=H,x[K.scheme]=K,x[ie.scheme]=ie,x[le.scheme]=le,x[ce.scheme]=ce,e.SCHEMES=x,e.pctEncChar=O,e.pctDecChars=_,e.parse=R,e.removeDotSegments=z,e.serialize=q,e.resolveComponents=M,e.resolve=function(e,r,t){var a=function(e,r){var t=e;if(r)for(var a in r)t[a]=r[a];return t}({scheme:"null"},t);return q(M(R(e,a),R(r,a),a,!0),a)},e.normalize=function(e,r){return "string"==typeof e?e=q(R(e,r),r):"object"===a(e)&&(e=R(q(e,r),r)),e},e.equal=function(e,r,t){return "string"==typeof e?e=q(R(e,t),t):"object"===a(e)&&(e=q(e,t)),"string"==typeof r?r=q(R(r,t),t):"object"===a(r)&&(r=q(r,t)),e===r},e.escapeComponent=function(e,r){return e&&e.toString().replace(r&&r.iri?s.ESCAPE:i.ESCAPE,O)},e.unescapeComponent=W,Object.defineProperty(e,"__esModule",{value:!0});}(r);}));(re=te)&&re.__esModule&&Object.prototype.hasOwnProperty.call(re,"default")&&re.default;var ae=function e(r,t){if(r===t)return !0;if(r&&t&&"object"==typeof r&&"object"==typeof t){if(r.constructor!==t.constructor)return !1;var a,o,n;if(Array.isArray(r)){if((a=r.length)!=t.length)return !1;for(o=a;0!=o--;)if(!e(r[o],t[o]))return !1;return !0}if(r.constructor===RegExp)return r.source===t.source&&r.flags===t.flags;if(r.valueOf!==Object.prototype.valueOf)return r.valueOf()===t.valueOf();if(r.toString!==Object.prototype.toString)return r.toString()===t.toString();if((a=(n=Object.keys(r)).length)!==Object.keys(t).length)return !1;for(o=a;0!=o--;)if(!Object.prototype.hasOwnProperty.call(t,n[o]))return !1;for(o=a;0!=o--;){var i=n[o];if(!e(r[i],t[i]))return !1}return !0}return r!=r&&t!=t},oe={copy:function(e,r){for(var t in r=r||{},e)r[t]=e[t];return r},checkDataType:ne,checkDataTypes:function(e,r,t){switch(e.length){case 1:return ne(e[0],r,t,!0);default:var a="",o=se(e);for(var n in o.array&&o.object&&(a=o.null?"(":"(!"+r+" || ",a+="typeof "+r+' !== "object")',delete o.null,delete o.array,delete o.object),o.number&&delete o.integer,o)a+=(a?" && ":"")+ne(n,r,t,!0);return a}},coerceToTypes:function(e,r){if(Array.isArray(r)){for(var t=[],a=0;a<r.length;a++){var o=r[a];(ie[o]||"array"===e&&"array"===o)&&(t[t.length]=o);}if(t.length)return t}else {if(ie[r])return [r];if("array"===e&&"array"===r)return ["array"]}},toHash:se,getProperty:ce,escapeQuotes:de,equal:ae,ucs2length:function(e){for(var r,t=0,a=e.length,o=0;o<a;)t++,(r=e.charCodeAt(o++))>=55296&&r<=56319&&o<a&&56320==(64512&(r=e.charCodeAt(o)))&&o++;return t},varOccurences:function(e,r){r+="[^0-9]";var t=e.match(new RegExp(r,"g"));return t?t.length:0},varReplace:function(e,r,t){return r+="([^0-9])",t=t.replace(/\$/g,"$$$$"),e.replace(new RegExp(r,"g"),t+"$1")},schemaHasRules:function(e,r){if("boolean"==typeof e)return !e;for(var t in e)if(r[t])return !0},schemaHasRulesExcept:function(e,r,t){if("boolean"==typeof e)return !e&&"not"!=t;for(var a in e)if(a!=t&&r[a])return !0},schemaUnknownRules:function(e,r){if("boolean"==typeof e)return;for(var t in e)if(!r[t])return t},toQuotedString:me,getPathExpr:function(e,r,t,a){return he(e,t?"'/' + "+r+(a?"":".replace(/~/g, '~0').replace(/\\//g, '~1')"):a?"'[' + "+r+" + ']'":"'[\\'' + "+r+" + '\\']'")},getPath:function(e,r,t){var a=me(t?"/"+ve(r):ce(r));return he(e,a)},getData:function(e,r,t){var a,o,n,i;if(""===e)return "rootData";if("/"==e[0]){if(!pe.test(e))throw new Error("Invalid JSON-pointer: "+e);o=e,n="rootData";}else {if(!(i=e.match(fe)))throw new Error("Invalid JSON-pointer: "+e);if(a=+i[1],"#"==(o=i[2])){if(a>=r)throw new Error("Cannot access property/index "+a+" levels up, current level is "+r);return t[r-a]}if(a>r)throw new Error("Cannot access data "+a+" levels up, current level is "+r);if(n="data"+(r-a||""),!o)return n}for(var s=n,l=o.split("/"),u=0;u<l.length;u++){var c=l[u];c&&(n+=ce(ge(c)),s+=" && "+n);}return s},unescapeFragment:function(e){return ge(decodeURIComponent(e))},unescapeJsonPointer:ge,escapeFragment:function(e){return encodeURIComponent(ve(e))},escapeJsonPointer:ve};function ne(e,r,t,a){var o=a?" !== ":" === ",n=a?" || ":" && ",i=a?"!":"",s=a?"":"!";switch(e){case"null":return r+o+"null";case"array":return i+"Array.isArray("+r+")";case"object":return "("+i+r+n+"typeof "+r+o+'"object"'+n+s+"Array.isArray("+r+"))";case"integer":return "(typeof "+r+o+'"number"'+n+s+"("+r+" % 1)"+n+r+o+r+(t?n+i+"isFinite("+r+")":"")+")";case"number":return "(typeof "+r+o+'"'+e+'"'+(t?n+i+"isFinite("+r+")":"")+")";default:return "typeof "+r+o+'"'+e+'"'}}var ie=se(["string","number","integer","boolean","null"]);function se(e){for(var r={},t=0;t<e.length;t++)r[e[t]]=!0;return r}var le=/^[a-z$_][a-z$_0-9]*$/i,ue=/'|\\/g;function ce(e){return "number"==typeof e?"["+e+"]":le.test(e)?"."+e:"['"+de(e)+"']"}function de(e){return e.replace(ue,"\\$&").replace(/\n/g,"\\n").replace(/\r/g,"\\r").replace(/\f/g,"\\f").replace(/\t/g,"\\t")}function me(e){return "'"+de(e)+"'"}var pe=/^\/(?:[^~]|~0|~1)*$/,fe=/^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;function he(e,r){return '""'==e?r:(e+" + "+r).replace(/([^\\])' \+ '/g,"$1")}function ve(e){return e.replace(/~/g,"~0").replace(/\//g,"~1")}function ge(e){return e.replace(/~1/g,"/").replace(/~0/g,"~")}var ye=function(e){oe.copy(e,this);};var be=X((function(e){var r=e.exports=function(e,t,a){"function"==typeof t&&(a=t,t={}),function e(t,a,o,n,i,s,l,u,c,d){if(n&&"object"==typeof n&&!Array.isArray(n)){for(var m in a(n,i,s,l,u,c,d),n){var p=n[m];if(Array.isArray(p)){if(m in r.arrayKeywords)for(var f=0;f<p.length;f++)e(t,a,o,p[f],i+"/"+m+"/"+f,s,i,m,n,f);}else if(m in r.propsKeywords){if(p&&"object"==typeof p)for(var h in p)e(t,a,o,p[h],i+"/"+m+"/"+h.replace(/~/g,"~0").replace(/\//g,"~1"),s,i,m,n,h);}else (m in r.keywords||t.allKeys&&!(m in r.skipKeywords))&&e(t,a,o,p,i+"/"+m,s,i,m,n);}o(n,i,s,l,u,c,d);}}(t,"function"==typeof(a=t.cb||a)?a:a.pre||function(){},a.post||function(){},e,"",e);};r.keywords={additionalItems:!0,items:!0,contains:!0,additionalProperties:!0,propertyNames:!0,not:!0},r.arrayKeywords={items:!0,allOf:!0,anyOf:!0,oneOf:!0},r.propsKeywords={definitions:!0,properties:!0,patternProperties:!0,dependencies:!0},r.skipKeywords={default:!0,enum:!0,const:!0,required:!0,maximum:!0,minimum:!0,exclusiveMaximum:!0,exclusiveMinimum:!0,multipleOf:!0,maxLength:!0,minLength:!0,pattern:!0,format:!0,maxItems:!0,minItems:!0,uniqueItems:!0,maxProperties:!0,minProperties:!0};})),Pe=we;function we(e,r,t){var a=this._refs[t];if("string"==typeof a){if(!this._refs[a])return we.call(this,e,r,a);a=this._refs[a];}if((a=a||this._schemas[t])instanceof ye)return _e(a.schema,this._opts.inlineRefs)?a.schema:a.validate||this._compile(a);var o,n,i,s=Ee.call(this,r,t);return s&&(o=s.schema,r=s.root,i=s.baseId),o instanceof ye?n=o.validate||e.call(this,o.schema,r,void 0,i):void 0!==o&&(n=_e(o,this._opts.inlineRefs)?o:e.call(this,o,r,void 0,i)),n}function Ee(e,r){var t=te.parse(r),a=ke(t),o=De(this._getId(e.schema));if(0===Object.keys(e.schema).length||a!==o){var n=Ae(a),i=this._refs[n];if("string"==typeof i)return Se.call(this,e,i,t);if(i instanceof ye)i.validate||this._compile(i),e=i;else {if(!((i=this._schemas[n])instanceof ye))return;if(i.validate||this._compile(i),n==Ae(r))return {schema:i,root:e,baseId:o};e=i;}if(!e.schema)return;o=De(this._getId(e.schema));}return xe.call(this,t,o,e.schema,e)}function Se(e,r,t){var a=Ee.call(this,e,r);if(a){var o=a.schema,n=a.baseId;e=a.root;var i=this._getId(o);return i&&(n=Ie(n,i)),xe.call(this,t,n,o,e)}}we.normalizeId=Ae,we.fullPath=De,we.url=Ie,we.ids=function(e){var r=Ae(this._getId(e)),t={"":r},a={"":De(r,!1)},o={},n=this;return be(e,{allKeys:!0},(function(e,r,i,s,l,u,c){if(""!==r){var d=n._getId(e),m=t[s],p=a[s]+"/"+l;if(void 0!==c&&(p+="/"+("number"==typeof c?c:oe.escapeFragment(c))),"string"==typeof d){d=m=Ae(m?te.resolve(m,d):d);var f=n._refs[d];if("string"==typeof f&&(f=n._refs[f]),f&&f.schema){if(!ae(e,f.schema))throw new Error('id "'+d+'" resolves to more than one schema')}else if(d!=Ae(p))if("#"==d[0]){if(o[d]&&!ae(e,o[d]))throw new Error('id "'+d+'" resolves to more than one schema');o[d]=e;}else n._refs[d]=p;}t[r]=m,a[r]=p;}})),o},we.inlineRef=_e,we.schema=Ee;var Fe=oe.toHash(["properties","patternProperties","enum","dependencies","definitions"]);function xe(e,r,t,a){if(e.fragment=e.fragment||"","/"==e.fragment.slice(0,1)){for(var o=e.fragment.split("/"),n=1;n<o.length;n++){var i=o[n];if(i){if(void 0===(t=t[i=oe.unescapeFragment(i)]))break;var s;if(!Fe[i]&&((s=this._getId(t))&&(r=Ie(r,s)),t.$ref)){var l=Ie(r,t.$ref),u=Ee.call(this,a,l);u&&(t=u.schema,a=u.root,r=u.baseId);}}}return void 0!==t&&t!==a.schema?{schema:t,root:a,baseId:r}:void 0}}var Oe=oe.toHash(["type","format","pattern","maxLength","minLength","maxProperties","minProperties","maxItems","minItems","maximum","minimum","uniqueItems","multipleOf","required","enum"]);function _e(e,r){return !1!==r&&(void 0===r||!0===r?function e(r){var t;if(Array.isArray(r)){for(var a=0;a<r.length;a++)if("object"==typeof(t=r[a])&&!e(t))return !1}else for(var o in r){if("$ref"==o)return !1;if("object"==typeof(t=r[o])&&!e(t))return !1}return !0}(e):r?function e(r){var t,a=0;if(Array.isArray(r)){for(var o=0;o<r.length;o++)if("object"==typeof(t=r[o])&&(a+=e(t)),a==1/0)return 1/0}else for(var n in r){if("$ref"==n)return 1/0;if(Oe[n])a++;else if("object"==typeof(t=r[n])&&(a+=e(t)+1),a==1/0)return 1/0}return a}(e)<=r:void 0)}function De(e,r){return !1!==r&&(e=Ae(e)),ke(te.parse(e))}function ke(e){return te.serialize(e).split("#")[0]+"#"}var je=/#\/?$/;function Ae(e){return e?e.replace(je,""):""}function Ie(e,r){return r=Ae(r),te.resolve(e,r)}var Ce={Validation:$e((function(e){this.message="validation failed",this.errors=e,this.ajv=this.validation=!0;})),MissingRef:$e(Re)};function Re(e,r,t){this.message=t||Re.message(e,r),this.missingRef=Pe.url(e,r),this.missingSchema=Pe.normalizeId(Pe.fullPath(this.missingRef));}function $e(e){return e.prototype=Object.create(Error.prototype),e.prototype.constructor=e,e}Re.message=function(e,r){return "can't resolve reference "+r+" from id "+e};var Ne=function(e,r){r||(r={}),"function"==typeof r&&(r={cmp:r});var t,a="boolean"==typeof r.cycles&&r.cycles,o=r.cmp&&(t=r.cmp,function(e){return function(r,a){var o={key:r,value:e[r]},n={key:a,value:e[a]};return t(o,n)}}),n=[];return function e(r){if(r&&r.toJSON&&"function"==typeof r.toJSON&&(r=r.toJSON()),void 0!==r){if("number"==typeof r)return isFinite(r)?""+r:"null";if("object"!=typeof r)return JSON.stringify(r);var t,i;if(Array.isArray(r)){for(i="[",t=0;t<r.length;t++)t&&(i+=","),i+=e(r[t])||"null";return i+"]"}if(null===r)return "null";if(-1!==n.indexOf(r)){if(a)return JSON.stringify("__cycle__");throw new TypeError("Converting circular structure to JSON")}var s=n.push(r)-1,l=Object.keys(r).sort(o&&o(r));for(i="",t=0;t<l.length;t++){var u=l[t],c=e(r[u]);c&&(i&&(i+=","),i+=JSON.stringify(u)+":"+c);}return n.splice(s,1),"{"+i+"}"}}(e)},Le=function(e,r,t){var a="",o=!0===e.schema.$async,n=e.util.schemaHasRulesExcept(e.schema,e.RULES.all,"$ref"),i=e.self._getId(e.schema);if(e.opts.strictKeywords){var s=e.util.schemaUnknownRules(e.schema,e.RULES.keywords);if(s){var l="unknown keyword: "+s;if("log"!==e.opts.strictKeywords)throw new Error(l);e.logger.warn(l);}}if(e.isTop&&(a+=" var validate = ",o&&(e.async=!0,a+="async "),a+="function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ",i&&(e.opts.sourceCode||e.opts.processCode)&&(a+=" /*# sourceURL="+i+" */ ")),"boolean"==typeof e.schema||!n&&!e.schema.$ref){var u=e.level,c=e.dataLevel,d=e.schema["false schema"],m=e.schemaPath+e.util.getProperty("false schema"),p=e.errSchemaPath+"/false schema",f=!e.opts.allErrors,h="data"+(c||""),v="valid"+u;if(!1===e.schema){e.isTop?f=!0:a+=" var "+v+" = false; ",(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'false schema' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(p)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'boolean schema is false' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";var g=a;a=J.pop(),!e.compositeRule&&f?e.async?a+=" throw new ValidationError(["+g+"]); ":a+=" validate.errors = ["+g+"]; return false; ":a+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";}else e.isTop?a+=o?" return data; ":" validate.errors = null; return true; ":a+=" var "+v+" = true; ";return e.isTop&&(a+=" }; return validate; "),a}if(e.isTop){var y=e.isTop;u=e.level=0,c=e.dataLevel=0,h="data";if(e.rootId=e.resolve.fullPath(e.self._getId(e.root.schema)),e.baseId=e.baseId||e.rootId,delete e.isTop,e.dataPathArr=[""],void 0!==e.schema.default&&e.opts.useDefaults&&e.opts.strictDefaults){var b="default is ignored in the schema root";if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b);}a+=" var vErrors = null; ",a+=" var errors = 0;     ",a+=" if (rootData === undefined) rootData = data; ";}else {u=e.level,h="data"+((c=e.dataLevel)||"");if(i&&(e.baseId=e.resolve.url(e.baseId,i)),o&&!e.async)throw new Error("async schema in sync schema");a+=" var errs_"+u+" = errors;";}v="valid"+u,f=!e.opts.allErrors;var P="",w="",E=e.schema.type,S=Array.isArray(E);if(E&&e.opts.nullable&&!0===e.schema.nullable&&(S?-1==E.indexOf("null")&&(E=E.concat("null")):"null"!=E&&(E=[E,"null"],S=!0)),S&&1==E.length&&(E=E[0],S=!1),e.schema.$ref&&n){if("fail"==e.opts.extendRefs)throw new Error('$ref: validation keywords used in schema at path "'+e.errSchemaPath+'" (see option extendRefs)');!0!==e.opts.extendRefs&&(n=!1,e.logger.warn('$ref: keywords ignored in schema at path "'+e.errSchemaPath+'"'));}if(e.schema.$comment&&e.opts.$comment&&(a+=" "+e.RULES.all.$comment.code(e,"$comment")),E){if(e.opts.coerceTypes)var F=e.util.coerceToTypes(e.opts.coerceTypes,E);var x=e.RULES.types[E];if(F||S||!0===x||x&&!Z(x)){m=e.schemaPath+".type",p=e.errSchemaPath+"/type",m=e.schemaPath+".type",p=e.errSchemaPath+"/type";var O=S?"checkDataTypes":"checkDataType";if(a+=" if ("+e.util[O](E,h,e.opts.strictNumbers,!0)+") { ",F){var _="dataType"+u,D="coerced"+u;a+=" var "+_+" = typeof "+h+"; var "+D+" = undefined; ","array"==e.opts.coerceTypes&&(a+=" if ("+_+" == 'object' && Array.isArray("+h+") && "+h+".length == 1) { "+h+" = "+h+"[0]; "+_+" = typeof "+h+"; if ("+e.util.checkDataType(e.schema.type,h,e.opts.strictNumbers)+") "+D+" = "+h+"; } "),a+=" if ("+D+" !== undefined) ; ";var k=F;if(k)for(var j,A=-1,I=k.length-1;A<I;)"string"==(j=k[A+=1])?a+=" else if ("+_+" == 'number' || "+_+" == 'boolean') "+D+" = '' + "+h+"; else if ("+h+" === null) "+D+" = ''; ":"number"==j||"integer"==j?(a+=" else if ("+_+" == 'boolean' || "+h+" === null || ("+_+" == 'string' && "+h+" && "+h+" == +"+h+" ","integer"==j&&(a+=" && !("+h+" % 1)"),a+=")) "+D+" = +"+h+"; "):"boolean"==j?a+=" else if ("+h+" === 'false' || "+h+" === 0 || "+h+" === null) "+D+" = false; else if ("+h+" === 'true' || "+h+" === 1) "+D+" = true; ":"null"==j?a+=" else if ("+h+" === '' || "+h+" === 0 || "+h+" === false) "+D+" = null; ":"array"==e.opts.coerceTypes&&"array"==j&&(a+=" else if ("+_+" == 'string' || "+_+" == 'number' || "+_+" == 'boolean' || "+h+" == null) "+D+" = ["+h+"]; ");a+=" else {   ",(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(p)+" , params: { type: '",a+=S?""+E.join(","):""+E,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=S?""+E.join(","):""+E,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+m+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";g=a;a=J.pop(),!e.compositeRule&&f?e.async?a+=" throw new ValidationError(["+g+"]); ":a+=" validate.errors = ["+g+"]; return false; ":a+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } if ("+D+" !== undefined) {  ";var C=c?"data"+(c-1||""):"parentData";a+=" "+h+" = "+D+"; ",c||(a+="if ("+C+" !== undefined)"),a+=" "+C+"["+(c?e.dataPathArr[c]:"parentDataProperty")+"] = "+D+"; } ";}else {(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(p)+" , params: { type: '",a+=S?""+E.join(","):""+E,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=S?""+E.join(","):""+E,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+m+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";g=a;a=J.pop(),!e.compositeRule&&f?e.async?a+=" throw new ValidationError(["+g+"]); ":a+=" validate.errors = ["+g+"]; return false; ":a+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";}a+=" } ";}}if(e.schema.$ref&&!n)a+=" "+e.RULES.all.$ref.code(e,"$ref")+" ",f&&(a+=" } if (errors === ",a+=y?"0":"errs_"+u,a+=") { ",w+="}");else {var R=e.RULES;if(R)for(var $=-1,N=R.length-1;$<N;)if(Z(x=R[$+=1])){if(x.type&&(a+=" if ("+e.util.checkDataType(x.type,h,e.opts.strictNumbers)+") { "),e.opts.useDefaults)if("object"==x.type&&e.schema.properties){d=e.schema.properties;var L=Object.keys(d);if(L)for(var T,V=-1,z=L.length-1;V<z;){if(void 0!==(W=d[T=L[V+=1]]).default){var q=h+e.util.getProperty(T);if(e.compositeRule){if(e.opts.strictDefaults){b="default is ignored for: "+q;if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b);}}else a+=" if ("+q+" === undefined ","empty"==e.opts.useDefaults&&(a+=" || "+q+" === null || "+q+" === '' "),a+=" ) "+q+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(W.default)+" ":a+=" "+JSON.stringify(W.default)+" ",a+="; ";}}}else if("array"==x.type&&Array.isArray(e.schema.items)){var M=e.schema.items;if(M){A=-1;for(var W,U=M.length-1;A<U;)if(void 0!==(W=M[A+=1]).default){q=h+"["+A+"]";if(e.compositeRule){if(e.opts.strictDefaults){b="default is ignored for: "+q;if("log"!==e.opts.strictDefaults)throw new Error(b);e.logger.warn(b);}}else a+=" if ("+q+" === undefined ","empty"==e.opts.useDefaults&&(a+=" || "+q+" === null || "+q+" === '' "),a+=" ) "+q+" = ","shared"==e.opts.useDefaults?a+=" "+e.useDefault(W.default)+" ":a+=" "+JSON.stringify(W.default)+" ",a+="; ";}}}var B=x.rules;if(B)for(var Q,H=-1,K=B.length-1;H<K;)if(Y(Q=B[H+=1])){var G=Q.code(e,Q.keyword,x.type);G&&(a+=" "+G+" ",f&&(P+="}"));}if(f&&(a+=" "+P+" ",P=""),x.type&&(a+=" } ",E&&E===x.type&&!F)){a+=" else { ";var J;m=e.schemaPath+".type",p=e.errSchemaPath+"/type";(J=J||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'type' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(p)+" , params: { type: '",a+=S?""+E.join(","):""+E,a+="' } ",!1!==e.opts.messages&&(a+=" , message: 'should be ",a+=S?""+E.join(","):""+E,a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+m+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+h+" "),a+=" } "):a+=" {} ";g=a;a=J.pop(),!e.compositeRule&&f?e.async?a+=" throw new ValidationError(["+g+"]); ":a+=" validate.errors = ["+g+"]; return false; ":a+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ";}f&&(a+=" if (errors === ",a+=y?"0":"errs_"+u,a+=") { ",w+="}");}}function Z(e){for(var r=e.rules,t=0;t<r.length;t++)if(Y(r[t]))return !0}function Y(r){return void 0!==e.schema[r.keyword]||r.implements&&function(r){for(var t=r.implements,a=0;a<t.length;a++)if(void 0!==e.schema[t[a]])return !0}(r)}return f&&(a+=" "+w+" "),y?(o?(a+=" if (errors === 0) return data;           ",a+=" else throw new ValidationError(vErrors); "):(a+=" validate.errors = vErrors; ",a+=" return errors === 0;       "),a+=" }; return validate;"):a+=" var "+v+" = errors === errs_"+u+";",a},Te=oe.ucs2length,Ve=Ce.Validation,ze=function e(r,t,a,o){var n=this,i=this._opts,s=[void 0],l={},u=[],c={},d=[],m={},p=[];t=t||{schema:r,refVal:s,refs:l};var f=qe.call(this,r,t,o),h=this._compilations[f.index];if(f.compiling)return h.callValidate=function e(){var r=h.validate,t=r.apply(this,arguments);return e.errors=r.errors,t};var v=this._formats,g=this.RULES;try{var y=P(r,t,a,o);h.validate=y;var b=h.callValidate;return b&&(b.schema=y.schema,b.errors=null,b.refs=y.refs,b.refVal=y.refVal,b.root=y.root,b.$async=y.$async,i.sourceCode&&(b.source=y.source)),y}finally{Me.call(this,r,t,o);}function P(r,a,o,c){var m=!a||a&&a.schema==r;if(a.schema!=t.schema)return e.call(n,r,a,o,c);var f,h=!0===r.$async,y=Le({isTop:!0,schema:r,isRoot:m,baseId:c,root:a,schemaPath:"",errSchemaPath:"#",errorPath:'""',MissingRefError:Ce.MissingRef,RULES:g,validate:Le,util:oe,resolve:Pe,resolveRef:w,usePattern:F,useDefault:x,useCustomRule:O,opts:i,formats:v,logger:n.logger,self:n});y=Ke(s,Qe)+Ke(u,Ue)+Ke(d,Be)+Ke(p,He)+y,i.processCode&&(y=i.processCode(y,r));try{f=new Function("self","RULES","formats","root","refVal","defaults","customRules","equal","ucs2length","ValidationError",y)(n,g,v,t,s,d,p,ae,Te,Ve),s[0]=f;}catch(e){throw n.logger.error("Error compiling schema, function code:",y),e}return f.schema=r,f.errors=null,f.refs=l,f.refVal=s,f.root=m?f:a,h&&(f.$async=!0),!0===i.sourceCode&&(f.source={code:y,patterns:u,defaults:d}),f}function w(r,o,u){o=Pe.url(r,o);var c,d,m=l[o];if(void 0!==m)return S(c=s[m],d="refVal["+m+"]");if(!u&&t.refs){var p=t.refs[o];if(void 0!==p)return S(c=t.refVal[p],d=E(o,c))}d=E(o);var f=Pe.call(n,P,t,o);if(void 0===f){var h=a&&a[o];h&&(f=Pe.inlineRef(h,i.inlineRefs)?h:e.call(n,h,t,a,r));}if(void 0!==f)return function(e,r){var t=l[e];s[t]=r;}(o,f),S(f,d);!function(e){delete l[e];}(o);}function E(e,r){var t=s.length;return s[t]=r,l[e]=t,"refVal"+t}function S(e,r){return "object"==typeof e||"boolean"==typeof e?{code:r,schema:e,inline:!0}:{code:r,$async:e&&!!e.$async}}function F(e){var r=c[e];return void 0===r&&(r=c[e]=u.length,u[r]=e),"pattern"+r}function x(e){switch(typeof e){case"boolean":case"number":return ""+e;case"string":return oe.toQuotedString(e);case"object":if(null===e)return "null";var r=Ne(e),t=m[r];return void 0===t&&(t=m[r]=d.length,d[t]=e),"default"+t}}function O(e,r,t,a){if(!1!==n._opts.validateSchema){var o=e.definition.dependencies;if(o&&!o.every((function(e){return Object.prototype.hasOwnProperty.call(t,e)})))throw new Error("parent schema must have all required keywords: "+o.join(","));var s=e.definition.validateSchema;if(s)if(!s(r)){var l="keyword schema is invalid: "+n.errorsText(s.errors);if("log"!=n._opts.validateSchema)throw new Error(l);n.logger.error(l);}}var u,c=e.definition.compile,d=e.definition.inline,m=e.definition.macro;if(c)u=c.call(n,r,t,a);else if(m)u=m.call(n,r,t,a),!1!==i.validateSchema&&n.validateSchema(u,!0);else if(d)u=d.call(n,a,e.keyword,r,t);else if(!(u=e.definition.validate))return;if(void 0===u)throw new Error('custom keyword "'+e.keyword+'"failed to compile');var f=p.length;return p[f]=u,{code:"customRule"+f,validate:u}}};function qe(e,r,t){var a=We.call(this,e,r,t);return a>=0?{index:a,compiling:!0}:(a=this._compilations.length,this._compilations[a]={schema:e,root:r,baseId:t},{index:a,compiling:!1})}function Me(e,r,t){var a=We.call(this,e,r,t);a>=0&&this._compilations.splice(a,1);}function We(e,r,t){for(var a=0;a<this._compilations.length;a++){var o=this._compilations[a];if(o.schema==e&&o.root==r&&o.baseId==t)return a}return -1}function Ue(e,r){return "var pattern"+e+" = new RegExp("+oe.toQuotedString(r[e])+");"}function Be(e){return "var default"+e+" = defaults["+e+"];"}function Qe(e,r){return void 0===r[e]?"":"var refVal"+e+" = refVal["+e+"];"}function He(e){return "var customRule"+e+" = customRules["+e+"];"}function Ke(e,r){if(!e.length)return "";for(var t="",a=0;a<e.length;a++)t+=r(a,e);return t}var Ge=X((function(e){var r=e.exports=function(){this._cache={};};r.prototype.put=function(e,r){this._cache[e]=r;},r.prototype.get=function(e){return this._cache[e]},r.prototype.del=function(e){delete this._cache[e];},r.prototype.clear=function(){this._cache={};};})),Je=/^(\d\d\d\d)-(\d\d)-(\d\d)$/,Ze=[0,31,28,31,30,31,30,31,31,30,31,30,31],Ye=/^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i,Xe=/^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,er=/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,rr=/^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,tr=/^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i,ar=/^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,or=/^(?:\/(?:[^~/]|~0|~1)*)*$/,nr=/^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,ir=/^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,sr=lr;function lr(e){return e="full"==e?"full":"fast",oe.copy(lr[e])}function ur(e){var r=e.match(Je);if(!r)return !1;var t=+r[1],a=+r[2],o=+r[3];return a>=1&&a<=12&&o>=1&&o<=(2==a&&function(e){return e%4==0&&(e%100!=0||e%400==0)}(t)?29:Ze[a])}function cr(e,r){var t=e.match(Ye);if(!t)return !1;var a=t[1],o=t[2],n=t[3],i=t[5];return (a<=23&&o<=59&&n<=59||23==a&&59==o&&60==n)&&(!r||i)}lr.fast={date:/^\d\d\d\d-[0-1]\d-[0-3]\d$/,time:/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,"date-time":/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,uri:/^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,"uri-reference":/^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,"uri-template":rr,url:tr,email:/^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,hostname:Xe,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:fr,uuid:ar,"json-pointer":or,"json-pointer-uri-fragment":nr,"relative-json-pointer":ir},lr.full={date:ur,time:cr,"date-time":function(e){var r=e.split(dr);return 2==r.length&&ur(r[0])&&cr(r[1],!0)},uri:function(e){return mr.test(e)&&er.test(e)},"uri-reference":/^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,"uri-template":rr,url:tr,email:/^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,hostname:Xe,ipv4:/^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,ipv6:/^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,regex:fr,uuid:ar,"json-pointer":or,"json-pointer-uri-fragment":nr,"relative-json-pointer":ir};var dr=/t|\s/i;var mr=/\/|:/;var pr=/[^\\]\\Z/;function fr(e){if(pr.test(e))return !1;try{return new RegExp(e),!0}catch(e){return !1}}var hr$1=function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s;var p="maximum"==r,f=p?"exclusiveMaximum":"exclusiveMinimum",h=e.schema[f],v=e.opts.$data&&h&&h.$data,g=p?"<":">",y=p?">":"<",b=void 0;if(!m&&"number"!=typeof s&&void 0!==s)throw new Error(r+" must be number");if(!v&&void 0!==h&&"number"!=typeof h&&"boolean"!=typeof h)throw new Error(f+" must be number or boolean");if(v){var P=e.util.getData(h.$data,i,e.dataPathArr),w="exclusive"+n,E="exclType"+n,S="exclIsNumber"+n,F="' + "+(_="op"+n)+" + '";o+=" var schemaExcl"+n+" = "+P+"; ",o+=" var "+w+"; var "+E+" = typeof "+(P="schemaExcl"+n)+"; if ("+E+" != 'boolean' && "+E+" != 'undefined' && "+E+" != 'number') { ";var x;b=f;(x=x||[]).push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(b||"_exclusiveLimit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: {} ",!1!==e.opts.messages&&(o+=" , message: '"+f+" should be boolean' "),e.opts.verbose&&(o+=" , schema: validate.schema"+l+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var O=o;o=x.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+O+"]); ":o+=" validate.errors = ["+O+"]; return false; ":o+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } else if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),o+=" "+E+" == 'number' ? ( ("+w+" = "+a+" === undefined || "+P+" "+g+"= "+a+") ? "+d+" "+y+"= "+P+" : "+d+" "+y+" "+a+" ) : ( ("+w+" = "+P+" === true) ? "+d+" "+y+"= "+a+" : "+d+" "+y+" "+a+" ) || "+d+" !== "+d+") { var op"+n+" = "+w+" ? '"+g+"' : '"+g+"='; ",void 0===s&&(b=f,u=e.errSchemaPath+"/"+f,a=P,m=v);}else {F=g;if((S="number"==typeof h)&&m){var _="'"+F+"'";o+=" if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),o+=" ( "+a+" === undefined || "+h+" "+g+"= "+a+" ? "+d+" "+y+"= "+h+" : "+d+" "+y+" "+a+" ) || "+d+" !== "+d+") { ";}else {S&&void 0===s?(w=!0,b=f,u=e.errSchemaPath+"/"+f,a=h,y+="="):(S&&(a=Math[p?"min":"max"](h,s)),h===(!S||a)?(w=!0,b=f,u=e.errSchemaPath+"/"+f,y+="="):(w=!1,F+="="));_="'"+F+"'";o+=" if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),o+=" "+d+" "+y+" "+a+" || "+d+" !== "+d+") { ";}}b=b||r,(x=x||[]).push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(b||"_limit")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { comparison: "+_+", limit: "+a+", exclusive: "+w+" } ",!1!==e.opts.messages&&(o+=" , message: 'should be "+F+" ",o+=m?"' + "+a:a+"'"),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";O=o;return o=x.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+O+"]); ":o+=" validate.errors = ["+O+"]; return false; ":o+=" var err = "+O+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } ",c&&(o+=" else { "),o},vr=function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;if(m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,!m&&"number"!=typeof s)throw new Error(r+" must be number");o+="if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),o+=" "+d+".length "+("maxItems"==r?">":"<")+" "+a+") { ";var p=r,f=f||[];f.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(p||"_limitItems")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(o+=" , message: 'should NOT have ",o+="maxItems"==r?"more":"fewer",o+=" than ",o+=m?"' + "+a+" + '":""+s,o+=" items' "),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var h=o;return o=f.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+h+"]); ":o+=" validate.errors = ["+h+"]; return false; ":o+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&&(o+=" else { "),o},gr=function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;if(m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,!m&&"number"!=typeof s)throw new Error(r+" must be number");var p="maxLength"==r?">":"<";o+="if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),!1===e.opts.unicode?o+=" "+d+".length ":o+=" ucs2length("+d+") ",o+=" "+p+" "+a+") { ";var f=r,h=h||[];h.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(f||"_limitLength")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(o+=" , message: 'should NOT be ",o+="maxLength"==r?"longer":"shorter",o+=" than ",o+=m?"' + "+a+" + '":""+s,o+=" characters' "),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var v=o;return o=h.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+v+"]); ":o+=" validate.errors = ["+v+"]; return false; ":o+=" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&&(o+=" else { "),o},yr=function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;if(m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,!m&&"number"!=typeof s)throw new Error(r+" must be number");o+="if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'number') || "),o+=" Object.keys("+d+").length "+("maxProperties"==r?">":"<")+" "+a+") { ";var p=r,f=f||[];f.push(o),o="",!1!==e.createErrors?(o+=" { keyword: '"+(p||"_limitProperties")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { limit: "+a+" } ",!1!==e.opts.messages&&(o+=" , message: 'should NOT have ",o+="maxProperties"==r?"more":"fewer",o+=" than ",o+=m?"' + "+a+" + '":""+s,o+=" properties' "),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var h=o;return o=f.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+h+"]); ":o+=" validate.errors = ["+h+"]; return false; ":o+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&&(o+=" else { "),o},br={$ref:function(e,r,t){var a,o,n=" ",i=e.level,s=e.dataLevel,l=e.schema[r],u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(s||""),m="valid"+i;if("#"==l||"#/"==l)e.isRoot?(a=e.async,o="validate"):(a=!0===e.root.schema.$async,o="root.refVal[0]");else {var p=e.resolveRef(e.baseId,l,e.isRoot);if(void 0===p){var f=e.MissingRefError.message(e.baseId,l);if("fail"==e.opts.missingRefs){e.logger.error(f),(y=y||[]).push(n),n="",!1!==e.createErrors?(n+=" { keyword: '$ref' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { ref: '"+e.util.escapeQuotes(l)+"' } ",!1!==e.opts.messages&&(n+=" , message: 'can\\'t resolve reference "+e.util.escapeQuotes(l)+"' "),e.opts.verbose&&(n+=" , schema: "+e.util.toQuotedString(l)+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),n+=" } "):n+=" {} ";var h=n;n=y.pop(),!e.compositeRule&&c?e.async?n+=" throw new ValidationError(["+h+"]); ":n+=" validate.errors = ["+h+"]; return false; ":n+=" var err = "+h+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",c&&(n+=" if (false) { ");}else {if("ignore"!=e.opts.missingRefs)throw new e.MissingRefError(e.baseId,l,f);e.logger.warn(f),c&&(n+=" if (true) { ");}}else if(p.inline){var v=e.util.copy(e);v.level++;var g="valid"+v.level;v.schema=p.schema,v.schemaPath="",v.errSchemaPath=l,n+=" "+e.validate(v).replace(/validate\.schema/g,p.code)+" ",c&&(n+=" if ("+g+") { ");}else a=!0===p.$async||e.async&&!1!==p.$async,o=p.code;}if(o){var y;(y=y||[]).push(n),n="",e.opts.passContext?n+=" "+o+".call(this, ":n+=" "+o+"( ",n+=" "+d+", (dataPath || '')",'""'!=e.errorPath&&(n+=" + "+e.errorPath);var b=n+=" , "+(s?"data"+(s-1||""):"parentData")+" , "+(s?e.dataPathArr[s]:"parentDataProperty")+", rootData)  ";if(n=y.pop(),a){if(!e.async)throw new Error("async schema referenced by sync schema");c&&(n+=" var "+m+"; "),n+=" try { await "+b+"; ",c&&(n+=" "+m+" = true; "),n+=" } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ",c&&(n+=" "+m+" = false; "),n+=" } ",c&&(n+=" if ("+m+") { ");}else n+=" if (!"+b+") { if (vErrors === null) vErrors = "+o+".errors; else vErrors = vErrors.concat("+o+".errors); errors = vErrors.length; } ",c&&(n+=" else { ");}return n},allOf:function(e,r,t){var a=" ",o=e.schema[r],n=e.schemaPath+e.util.getProperty(r),i=e.errSchemaPath+"/"+r,s=!e.opts.allErrors,l=e.util.copy(e),u="";l.level++;var c="valid"+l.level,d=l.baseId,m=!0,p=o;if(p)for(var f,h=-1,v=p.length-1;h<v;)f=p[h+=1],(e.opts.strictKeywords?"object"==typeof f&&Object.keys(f).length>0||!1===f:e.util.schemaHasRules(f,e.RULES.all))&&(m=!1,l.schema=f,l.schemaPath=n+"["+h+"]",l.errSchemaPath=i+"/"+h,a+="  "+e.validate(l)+" ",l.baseId=d,s&&(a+=" if ("+c+") { ",u+="}"));return s&&(a+=m?" if (true) { ":" "+u.slice(0,-1)+" "),a},anyOf:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m="errs__"+o,p=e.util.copy(e),f="";p.level++;var h="valid"+p.level;if(i.every((function(r){return e.opts.strictKeywords?"object"==typeof r&&Object.keys(r).length>0||!1===r:e.util.schemaHasRules(r,e.RULES.all)}))){var v=p.baseId;a+=" var "+m+" = errors; var "+d+" = false;  ";var g=e.compositeRule;e.compositeRule=p.compositeRule=!0;var y=i;if(y)for(var b,P=-1,w=y.length-1;P<w;)b=y[P+=1],p.schema=b,p.schemaPath=s+"["+P+"]",p.errSchemaPath=l+"/"+P,a+="  "+e.validate(p)+" ",p.baseId=v,a+=" "+d+" = "+d+" || "+h+"; if (!"+d+") { ",f+="}";e.compositeRule=p.compositeRule=g,a+=" "+f+" if (!"+d+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'anyOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should match some schema in anyOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&u&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+=" } else {  errors = "+m+"; if (vErrors !== null) { if ("+m+") vErrors.length = "+m+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } ");}else u&&(a+=" if (true) { ");return a},$comment:function(e,r,t){var a=" ",o=e.schema[r],n=e.errSchemaPath+"/"+r;e.opts.allErrors;var i=e.util.toQuotedString(o);return !0===e.opts.$comment?a+=" console.log("+i+");":"function"==typeof e.opts.$comment&&(a+=" self._opts.$comment("+i+", "+e.util.toQuotedString(n)+", validate.root.schema);"),a},const:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m=e.opts.$data&&i&&i.$data;m&&(a+=" var schema"+o+" = "+e.util.getData(i.$data,n,e.dataPathArr)+"; "),m||(a+=" var schema"+o+" = validate.schema"+s+";"),a+="var "+d+" = equal("+c+", schema"+o+"); if (!"+d+") {   ";var p=p||[];p.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'const' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { allowedValue: schema"+o+" } ",!1!==e.opts.messages&&(a+=" , message: 'should be equal to constant' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var f=a;return a=p.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+f+"]); ":a+=" validate.errors = ["+f+"]; return false; ":a+=" var err = "+f+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",u&&(a+=" else { "),a},contains:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m="errs__"+o,p=e.util.copy(e);p.level++;var f="valid"+p.level,h="i"+o,v=p.dataLevel=e.dataLevel+1,g="data"+v,y=e.baseId,b=e.opts.strictKeywords?"object"==typeof i&&Object.keys(i).length>0||!1===i:e.util.schemaHasRules(i,e.RULES.all);if(a+="var "+m+" = errors;var "+d+";",b){var P=e.compositeRule;e.compositeRule=p.compositeRule=!0,p.schema=i,p.schemaPath=s,p.errSchemaPath=l,a+=" var "+f+" = false; for (var "+h+" = 0; "+h+" < "+c+".length; "+h+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,h,e.opts.jsonPointers,!0);var w=c+"["+h+"]";p.dataPathArr[v]=h;var E=e.validate(p);p.baseId=y,e.util.varOccurences(E,g)<2?a+=" "+e.util.varReplace(E,g,w)+" ":a+=" var "+g+" = "+w+"; "+E+" ",a+=" if ("+f+") break; }  ",e.compositeRule=p.compositeRule=P,a+="  if (!"+f+") {";}else a+=" if ("+c+".length == 0) {";var S=S||[];S.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'contains' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should contain a valid item' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var F=a;return a=S.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+F+"]); ":a+=" validate.errors = ["+F+"]; return false; ":a+=" var err = "+F+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { ",b&&(a+="  errors = "+m+"; if (vErrors !== null) { if ("+m+") vErrors.length = "+m+"; else vErrors = null; } "),e.opts.allErrors&&(a+=" } "),a},dependencies:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="errs__"+o,m=e.util.copy(e),p="";m.level++;var f="valid"+m.level,h={},v={},g=e.opts.ownProperties;for(w in i)if("__proto__"!=w){var y=i[w],b=Array.isArray(y)?v:h;b[w]=y;}a+="var "+d+" = errors;";var P=e.errorPath;for(var w in a+="var missing"+o+";",v)if((b=v[w]).length){if(a+=" if ( "+c+e.util.getProperty(w)+" !== undefined ",g&&(a+=" && Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(w)+"') "),u){a+=" && ( ";var E=b;if(E)for(var S=-1,F=E.length-1;S<F;){j=E[S+=1],S&&(a+=" || "),a+=" ( ( "+(R=c+(C=e.util.getProperty(j)))+" === undefined ",g&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(j)+"') "),a+=") && (missing"+o+" = "+e.util.toQuotedString(e.opts.jsonPointers?j:C)+") ) ";}a+=")) {  ";var x="missing"+o,O="' + "+x+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(P,x,!0):P+" + "+x);var _=_||[];_.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { property: '"+e.util.escapeQuotes(w)+"', missingProperty: '"+O+"', depsCount: "+b.length+", deps: '"+e.util.escapeQuotes(1==b.length?b[0]:b.join(", "))+"' } ",!1!==e.opts.messages&&(a+=" , message: 'should have ",1==b.length?a+="property "+e.util.escapeQuotes(b[0]):a+="properties "+e.util.escapeQuotes(b.join(", ")),a+=" when property "+e.util.escapeQuotes(w)+" is present' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var D=a;a=_.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+D+"]); ":a+=" validate.errors = ["+D+"]; return false; ":a+=" var err = "+D+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";}else {a+=" ) { ";var k=b;if(k)for(var j,A=-1,I=k.length-1;A<I;){j=k[A+=1];var C=e.util.getProperty(j),R=(O=e.util.escapeQuotes(j),c+C);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(P,j,e.opts.jsonPointers)),a+=" if ( "+R+" === undefined ",g&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(j)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'dependencies' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { property: '"+e.util.escapeQuotes(w)+"', missingProperty: '"+O+"', depsCount: "+b.length+", deps: '"+e.util.escapeQuotes(1==b.length?b[0]:b.join(", "))+"' } ",!1!==e.opts.messages&&(a+=" , message: 'should have ",1==b.length?a+="property "+e.util.escapeQuotes(b[0]):a+="properties "+e.util.escapeQuotes(b.join(", ")),a+=" when property "+e.util.escapeQuotes(w)+" is present' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";}}a+=" }   ",u&&(p+="}",a+=" else { ");}e.errorPath=P;var $=m.baseId;for(var w in h){y=h[w];(e.opts.strictKeywords?"object"==typeof y&&Object.keys(y).length>0||!1===y:e.util.schemaHasRules(y,e.RULES.all))&&(a+=" "+f+" = true; if ( "+c+e.util.getProperty(w)+" !== undefined ",g&&(a+=" && Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(w)+"') "),a+=") { ",m.schema=y,m.schemaPath=s+e.util.getProperty(w),m.errSchemaPath=l+"/"+e.util.escapeFragment(w),a+="  "+e.validate(m)+" ",m.baseId=$,a+=" }  ",u&&(a+=" if ("+f+") { ",p+="}"));}return u&&(a+="   "+p+" if ("+d+" == errors) {"),a},enum:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m=e.opts.$data&&i&&i.$data;m&&(a+=" var schema"+o+" = "+e.util.getData(i.$data,n,e.dataPathArr)+"; ");var p="i"+o,f="schema"+o;m||(a+=" var "+f+" = validate.schema"+s+";"),a+="var "+d+";",m&&(a+=" if (schema"+o+" === undefined) "+d+" = true; else if (!Array.isArray(schema"+o+")) "+d+" = false; else {"),a+=d+" = false;for (var "+p+"=0; "+p+"<"+f+".length; "+p+"++) if (equal("+c+", "+f+"["+p+"])) { "+d+" = true; break; }",m&&(a+="  }  "),a+=" if (!"+d+") {   ";var h=h||[];h.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'enum' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { allowedValues: schema"+o+" } ",!1!==e.opts.messages&&(a+=" , message: 'should be equal to one of the allowed values' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var v=a;return a=h.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+v+"]); ":a+=" validate.errors = ["+v+"]; return false; ":a+=" var err = "+v+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" }",u&&(a+=" else { "),a},format:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||"");if(!1===e.opts.format)return u&&(a+=" if (true) { "),a;var d,m=e.opts.$data&&i&&i.$data;m?(a+=" var schema"+o+" = "+e.util.getData(i.$data,n,e.dataPathArr)+"; ",d="schema"+o):d=i;var p=e.opts.unknownFormats,f=Array.isArray(p);if(m){a+=" var "+(h="format"+o)+" = formats["+d+"]; var "+(v="isObject"+o)+" = typeof "+h+" == 'object' && !("+h+" instanceof RegExp) && "+h+".validate; var "+(g="formatType"+o)+" = "+v+" && "+h+".type || 'string'; if ("+v+") { ",e.async&&(a+=" var async"+o+" = "+h+".async; "),a+=" "+h+" = "+h+".validate; } if (  ",m&&(a+=" ("+d+" !== undefined && typeof "+d+" != 'string') || "),a+=" (","ignore"!=p&&(a+=" ("+d+" && !"+h+" ",f&&(a+=" && self._opts.unknownFormats.indexOf("+d+") == -1 "),a+=") || "),a+=" ("+h+" && "+g+" == '"+t+"' && !(typeof "+h+" == 'function' ? ",e.async?a+=" (async"+o+" ? await "+h+"("+c+") : "+h+"("+c+")) ":a+=" "+h+"("+c+") ",a+=" : "+h+".test("+c+"))))) {";}else {var h;if(!(h=e.formats[i])){if("ignore"==p)return e.logger.warn('unknown format "'+i+'" ignored in schema at path "'+e.errSchemaPath+'"'),u&&(a+=" if (true) { "),a;if(f&&p.indexOf(i)>=0)return u&&(a+=" if (true) { "),a;throw new Error('unknown format "'+i+'" is used in schema at path "'+e.errSchemaPath+'"')}var v,g=(v="object"==typeof h&&!(h instanceof RegExp)&&h.validate)&&h.type||"string";if(v){var y=!0===h.async;h=h.validate;}if(g!=t)return u&&(a+=" if (true) { "),a;if(y){if(!e.async)throw new Error("async format in sync schema");a+=" if (!(await "+(b="formats"+e.util.getProperty(i)+".validate")+"("+c+"))) { ";}else {a+=" if (! ";var b="formats"+e.util.getProperty(i);v&&(b+=".validate"),a+="function"==typeof h?" "+b+"("+c+") ":" "+b+".test("+c+") ",a+=") { ";}}var P=P||[];P.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'format' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { format:  ",a+=m?""+d:""+e.util.toQuotedString(i),a+="  } ",!1!==e.opts.messages&&(a+=" , message: 'should match format \"",a+=m?"' + "+d+" + '":""+e.util.escapeQuotes(i),a+="\"' "),e.opts.verbose&&(a+=" , schema:  ",a+=m?"validate.schema"+s:""+e.util.toQuotedString(i),a+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var w=a;return a=P.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+w+"]); ":a+=" validate.errors = ["+w+"]; return false; ":a+=" var err = "+w+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",u&&(a+=" else { "),a},if:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m="errs__"+o,p=e.util.copy(e);p.level++;var f="valid"+p.level,h=e.schema.then,v=e.schema.else,g=void 0!==h&&(e.opts.strictKeywords?"object"==typeof h&&Object.keys(h).length>0||!1===h:e.util.schemaHasRules(h,e.RULES.all)),y=void 0!==v&&(e.opts.strictKeywords?"object"==typeof v&&Object.keys(v).length>0||!1===v:e.util.schemaHasRules(v,e.RULES.all)),b=p.baseId;if(g||y){var P;p.createErrors=!1,p.schema=i,p.schemaPath=s,p.errSchemaPath=l,a+=" var "+m+" = errors; var "+d+" = true;  ";var w=e.compositeRule;e.compositeRule=p.compositeRule=!0,a+="  "+e.validate(p)+" ",p.baseId=b,p.createErrors=!0,a+="  errors = "+m+"; if (vErrors !== null) { if ("+m+") vErrors.length = "+m+"; else vErrors = null; }  ",e.compositeRule=p.compositeRule=w,g?(a+=" if ("+f+") {  ",p.schema=e.schema.then,p.schemaPath=e.schemaPath+".then",p.errSchemaPath=e.errSchemaPath+"/then",a+="  "+e.validate(p)+" ",p.baseId=b,a+=" "+d+" = "+f+"; ",g&&y?a+=" var "+(P="ifClause"+o)+" = 'then'; ":P="'then'",a+=" } ",y&&(a+=" else { ")):a+=" if (!"+f+") { ",y&&(p.schema=e.schema.else,p.schemaPath=e.schemaPath+".else",p.errSchemaPath=e.errSchemaPath+"/else",a+="  "+e.validate(p)+" ",p.baseId=b,a+=" "+d+" = "+f+"; ",g&&y?a+=" var "+(P="ifClause"+o)+" = 'else'; ":P="'else'",a+=" } "),a+=" if (!"+d+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'if' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { failingKeyword: "+P+" } ",!1!==e.opts.messages&&(a+=" , message: 'should match \"' + "+P+" + '\" schema' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&u&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+=" }   ",u&&(a+=" else { ");}else u&&(a+=" if (true) { ");return a},items:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m="errs__"+o,p=e.util.copy(e),f="";p.level++;var h="valid"+p.level,v="i"+o,g=p.dataLevel=e.dataLevel+1,y="data"+g,b=e.baseId;if(a+="var "+m+" = errors;var "+d+";",Array.isArray(i)){var P=e.schema.additionalItems;if(!1===P){a+=" "+d+" = "+c+".length <= "+i.length+"; ";var w=l;l=e.errSchemaPath+"/additionalItems",a+="  if (!"+d+") {   ";var E=E||[];E.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { limit: "+i.length+" } ",!1!==e.opts.messages&&(a+=" , message: 'should NOT have more than "+i.length+" items' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var S=a;a=E.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+S+"]); ":a+=" validate.errors = ["+S+"]; return false; ":a+=" var err = "+S+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } ",l=w,u&&(f+="}",a+=" else { ");}var F=i;if(F)for(var x,O=-1,_=F.length-1;O<_;)if(x=F[O+=1],e.opts.strictKeywords?"object"==typeof x&&Object.keys(x).length>0||!1===x:e.util.schemaHasRules(x,e.RULES.all)){a+=" "+h+" = true; if ("+c+".length > "+O+") { ";var D=c+"["+O+"]";p.schema=x,p.schemaPath=s+"["+O+"]",p.errSchemaPath=l+"/"+O,p.errorPath=e.util.getPathExpr(e.errorPath,O,e.opts.jsonPointers,!0),p.dataPathArr[g]=O;var k=e.validate(p);p.baseId=b,e.util.varOccurences(k,y)<2?a+=" "+e.util.varReplace(k,y,D)+" ":a+=" var "+y+" = "+D+"; "+k+" ",a+=" }  ",u&&(a+=" if ("+h+") { ",f+="}");}if("object"==typeof P&&(e.opts.strictKeywords?"object"==typeof P&&Object.keys(P).length>0||!1===P:e.util.schemaHasRules(P,e.RULES.all))){p.schema=P,p.schemaPath=e.schemaPath+".additionalItems",p.errSchemaPath=e.errSchemaPath+"/additionalItems",a+=" "+h+" = true; if ("+c+".length > "+i.length+") {  for (var "+v+" = "+i.length+"; "+v+" < "+c+".length; "+v+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,v,e.opts.jsonPointers,!0);D=c+"["+v+"]";p.dataPathArr[g]=v;k=e.validate(p);p.baseId=b,e.util.varOccurences(k,y)<2?a+=" "+e.util.varReplace(k,y,D)+" ":a+=" var "+y+" = "+D+"; "+k+" ",u&&(a+=" if (!"+h+") break; "),a+=" } }  ",u&&(a+=" if ("+h+") { ",f+="}");}}else if(e.opts.strictKeywords?"object"==typeof i&&Object.keys(i).length>0||!1===i:e.util.schemaHasRules(i,e.RULES.all)){p.schema=i,p.schemaPath=s,p.errSchemaPath=l,a+="  for (var "+v+" = 0; "+v+" < "+c+".length; "+v+"++) { ",p.errorPath=e.util.getPathExpr(e.errorPath,v,e.opts.jsonPointers,!0);D=c+"["+v+"]";p.dataPathArr[g]=v;k=e.validate(p);p.baseId=b,e.util.varOccurences(k,y)<2?a+=" "+e.util.varReplace(k,y,D)+" ":a+=" var "+y+" = "+D+"; "+k+" ",u&&(a+=" if (!"+h+") break; "),a+=" }";}return u&&(a+=" "+f+" if ("+m+" == errors) {"),a},maximum:hr$1,minimum:hr$1,maxItems:vr,minItems:vr,maxLength:gr,minLength:gr,maxProperties:yr,minProperties:yr,multipleOf:function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;if(m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,!m&&"number"!=typeof s)throw new Error(r+" must be number");o+="var division"+n+";if (",m&&(o+=" "+a+" !== undefined && ( typeof "+a+" != 'number' || "),o+=" (division"+n+" = "+d+" / "+a+", ",e.opts.multipleOfPrecision?o+=" Math.abs(Math.round(division"+n+") - division"+n+") > 1e-"+e.opts.multipleOfPrecision+" ":o+=" division"+n+" !== parseInt(division"+n+") ",o+=" ) ",m&&(o+="  )  "),o+=" ) {   ";var p=p||[];p.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'multipleOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { multipleOf: "+a+" } ",!1!==e.opts.messages&&(o+=" , message: 'should be multiple of ",o+=m?"' + "+a:a+"'"),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var f=o;return o=p.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+f+"]); ":o+=" validate.errors = ["+f+"]; return false; ":o+=" var err = "+f+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&&(o+=" else { "),o},not:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="errs__"+o,m=e.util.copy(e);m.level++;var p="valid"+m.level;if(e.opts.strictKeywords?"object"==typeof i&&Object.keys(i).length>0||!1===i:e.util.schemaHasRules(i,e.RULES.all)){m.schema=i,m.schemaPath=s,m.errSchemaPath=l,a+=" var "+d+" = errors;  ";var f,h=e.compositeRule;e.compositeRule=m.compositeRule=!0,m.createErrors=!1,m.opts.allErrors&&(f=m.opts.allErrors,m.opts.allErrors=!1),a+=" "+e.validate(m)+" ",m.createErrors=!0,f&&(m.opts.allErrors=f),e.compositeRule=m.compositeRule=h,a+=" if ("+p+") {   ";var v=v||[];v.push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var g=a;a=v.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+g+"]); ":a+=" validate.errors = ["+g+"]; return false; ":a+=" var err = "+g+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else {  errors = "+d+"; if (vErrors !== null) { if ("+d+") vErrors.length = "+d+"; else vErrors = null; } ",e.opts.allErrors&&(a+=" } ");}else a+="  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'not' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: {} ",!1!==e.opts.messages&&(a+=" , message: 'should NOT be valid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",u&&(a+=" if (false) { ");return a},oneOf:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m="errs__"+o,p=e.util.copy(e),f="";p.level++;var h="valid"+p.level,v=p.baseId,g="prevValid"+o,y="passingSchemas"+o;a+="var "+m+" = errors , "+g+" = false , "+d+" = false , "+y+" = null; ";var b=e.compositeRule;e.compositeRule=p.compositeRule=!0;var P=i;if(P)for(var w,E=-1,S=P.length-1;E<S;)w=P[E+=1],(e.opts.strictKeywords?"object"==typeof w&&Object.keys(w).length>0||!1===w:e.util.schemaHasRules(w,e.RULES.all))?(p.schema=w,p.schemaPath=s+"["+E+"]",p.errSchemaPath=l+"/"+E,a+="  "+e.validate(p)+" ",p.baseId=v):a+=" var "+h+" = true; ",E&&(a+=" if ("+h+" && "+g+") { "+d+" = false; "+y+" = ["+y+", "+E+"]; } else { ",f+="}"),a+=" if ("+h+") { "+d+" = "+g+" = true; "+y+" = "+E+"; }";return e.compositeRule=p.compositeRule=b,a+=f+"if (!"+d+") {   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'oneOf' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { passingSchemas: "+y+" } ",!1!==e.opts.messages&&(a+=" , message: 'should match exactly one schema in oneOf' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&u&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),a+="} else {  errors = "+m+"; if (vErrors !== null) { if ("+m+") vErrors.length = "+m+"; else vErrors = null; }",e.opts.allErrors&&(a+=" } "),a},pattern:function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m=e.opts.$data&&s&&s.$data;m?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,o+="if ( ",m&&(o+=" ("+a+" !== undefined && typeof "+a+" != 'string') || "),o+=" !"+(m?"(new RegExp("+a+"))":e.usePattern(s))+".test("+d+") ) {   ";var p=p||[];p.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'pattern' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { pattern:  ",o+=m?""+a:""+e.util.toQuotedString(s),o+="  } ",!1!==e.opts.messages&&(o+=" , message: 'should match pattern \"",o+=m?"' + "+a+" + '":""+e.util.escapeQuotes(s),o+="\"' "),e.opts.verbose&&(o+=" , schema:  ",o+=m?"validate.schema"+l:""+e.util.toQuotedString(s),o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var f=o;return o=p.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+f+"]); ":o+=" validate.errors = ["+f+"]; return false; ":o+=" var err = "+f+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+="} ",c&&(o+=" else { "),o},properties:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="errs__"+o,m=e.util.copy(e),p="";m.level++;var f="valid"+m.level,h="key"+o,v="idx"+o,g=m.dataLevel=e.dataLevel+1,y="data"+g,b="dataProperties"+o,P=Object.keys(i||{}).filter(C),w=e.schema.patternProperties||{},E=Object.keys(w).filter(C),S=e.schema.additionalProperties,F=P.length||E.length,x=!1===S,O="object"==typeof S&&Object.keys(S).length,_=e.opts.removeAdditional,D=x||O||_,k=e.opts.ownProperties,j=e.baseId,A=e.schema.required;if(A&&(!e.opts.$data||!A.$data)&&A.length<e.opts.loopRequired)var I=e.util.toHash(A);function C(e){return "__proto__"!==e}if(a+="var "+d+" = errors;var "+f+" = true;",k&&(a+=" var "+b+" = undefined;"),D){if(a+=k?" "+b+" = "+b+" || Object.keys("+c+"); for (var "+v+"=0; "+v+"<"+b+".length; "+v+"++) { var "+h+" = "+b+"["+v+"]; ":" for (var "+h+" in "+c+") { ",F){if(a+=" var isAdditional"+o+" = !(false ",P.length)if(P.length>8)a+=" || validate.schema"+s+".hasOwnProperty("+h+") ";else {var R=P;if(R)for(var $=-1,N=R.length-1;$<N;)G=R[$+=1],a+=" || "+h+" == "+e.util.toQuotedString(G)+" ";}if(E.length){var L=E;if(L)for(var T=-1,V=L.length-1;T<V;)ne=L[T+=1],a+=" || "+e.usePattern(ne)+".test("+h+") ";}a+=" ); if (isAdditional"+o+") { ";}if("all"==_)a+=" delete "+c+"["+h+"]; ";else {var z=e.errorPath,q="' + "+h+" + '";if(e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(e.errorPath,h,e.opts.jsonPointers)),x)if(_)a+=" delete "+c+"["+h+"]; ";else {a+=" "+f+" = false; ";var M=l;l=e.errSchemaPath+"/additionalProperties",(te=te||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'additionalProperties' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { additionalProperty: '"+q+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is an invalid additional property":a+="should NOT have additional properties",a+="' "),e.opts.verbose&&(a+=" , schema: false , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var W=a;a=te.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+W+"]); ":a+=" validate.errors = ["+W+"]; return false; ":a+=" var err = "+W+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l=M,u&&(a+=" break; ");}else if(O)if("failing"==_){a+=" var "+d+" = errors;  ";var U=e.compositeRule;e.compositeRule=m.compositeRule=!0,m.schema=S,m.schemaPath=e.schemaPath+".additionalProperties",m.errSchemaPath=e.errSchemaPath+"/additionalProperties",m.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,h,e.opts.jsonPointers);var B=c+"["+h+"]";m.dataPathArr[g]=h;var Q=e.validate(m);m.baseId=j,e.util.varOccurences(Q,y)<2?a+=" "+e.util.varReplace(Q,y,B)+" ":a+=" var "+y+" = "+B+"; "+Q+" ",a+=" if (!"+f+") { errors = "+d+"; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete "+c+"["+h+"]; }  ",e.compositeRule=m.compositeRule=U;}else {m.schema=S,m.schemaPath=e.schemaPath+".additionalProperties",m.errSchemaPath=e.errSchemaPath+"/additionalProperties",m.errorPath=e.opts._errorDataPathProperty?e.errorPath:e.util.getPathExpr(e.errorPath,h,e.opts.jsonPointers);B=c+"["+h+"]";m.dataPathArr[g]=h;Q=e.validate(m);m.baseId=j,e.util.varOccurences(Q,y)<2?a+=" "+e.util.varReplace(Q,y,B)+" ":a+=" var "+y+" = "+B+"; "+Q+" ",u&&(a+=" if (!"+f+") break; ");}e.errorPath=z;}F&&(a+=" } "),a+=" }  ",u&&(a+=" if ("+f+") { ",p+="}");}var H=e.opts.useDefaults&&!e.compositeRule;if(P.length){var K=P;if(K)for(var G,J=-1,Z=K.length-1;J<Z;){var Y=i[G=K[J+=1]];if(e.opts.strictKeywords?"object"==typeof Y&&Object.keys(Y).length>0||!1===Y:e.util.schemaHasRules(Y,e.RULES.all)){var X=e.util.getProperty(G),ee=(B=c+X,H&&void 0!==Y.default);m.schema=Y,m.schemaPath=s+X,m.errSchemaPath=l+"/"+e.util.escapeFragment(G),m.errorPath=e.util.getPath(e.errorPath,G,e.opts.jsonPointers),m.dataPathArr[g]=e.util.toQuotedString(G);Q=e.validate(m);if(m.baseId=j,e.util.varOccurences(Q,y)<2){Q=e.util.varReplace(Q,y,B);var re=B;}else {re=y;a+=" var "+y+" = "+B+"; ";}if(ee)a+=" "+Q+" ";else {if(I&&I[G]){a+=" if ( "+re+" === undefined ",k&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(G)+"') "),a+=") { "+f+" = false; ";z=e.errorPath,M=l;var te,ae=e.util.escapeQuotes(G);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(z,G,e.opts.jsonPointers)),l=e.errSchemaPath+"/required",(te=te||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+ae+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+ae+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";W=a;a=te.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+W+"]); ":a+=" validate.errors = ["+W+"]; return false; ":a+=" var err = "+W+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",l=M,e.errorPath=z,a+=" } else { ";}else u?(a+=" if ( "+re+" === undefined ",k&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(G)+"') "),a+=") { "+f+" = true; } else { "):(a+=" if ("+re+" !== undefined ",k&&(a+=" &&   Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(G)+"') "),a+=" ) { ");a+=" "+Q+" } ";}}u&&(a+=" if ("+f+") { ",p+="}");}}if(E.length){var oe=E;if(oe)for(var ne,ie=-1,se=oe.length-1;ie<se;){Y=w[ne=oe[ie+=1]];if(e.opts.strictKeywords?"object"==typeof Y&&Object.keys(Y).length>0||!1===Y:e.util.schemaHasRules(Y,e.RULES.all)){m.schema=Y,m.schemaPath=e.schemaPath+".patternProperties"+e.util.getProperty(ne),m.errSchemaPath=e.errSchemaPath+"/patternProperties/"+e.util.escapeFragment(ne),a+=k?" "+b+" = "+b+" || Object.keys("+c+"); for (var "+v+"=0; "+v+"<"+b+".length; "+v+"++) { var "+h+" = "+b+"["+v+"]; ":" for (var "+h+" in "+c+") { ",a+=" if ("+e.usePattern(ne)+".test("+h+")) { ",m.errorPath=e.util.getPathExpr(e.errorPath,h,e.opts.jsonPointers);B=c+"["+h+"]";m.dataPathArr[g]=h;Q=e.validate(m);m.baseId=j,e.util.varOccurences(Q,y)<2?a+=" "+e.util.varReplace(Q,y,B)+" ":a+=" var "+y+" = "+B+"; "+Q+" ",u&&(a+=" if (!"+f+") break; "),a+=" } ",u&&(a+=" else "+f+" = true; "),a+=" }  ",u&&(a+=" if ("+f+") { ",p+="}");}}}return u&&(a+=" "+p+" if ("+d+" == errors) {"),a},propertyNames:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="errs__"+o,m=e.util.copy(e);m.level++;var p="valid"+m.level;if(a+="var "+d+" = errors;",e.opts.strictKeywords?"object"==typeof i&&Object.keys(i).length>0||!1===i:e.util.schemaHasRules(i,e.RULES.all)){m.schema=i,m.schemaPath=s,m.errSchemaPath=l;var f="key"+o,h="idx"+o,v="i"+o,g="' + "+f+" + '",y="data"+(m.dataLevel=e.dataLevel+1),b="dataProperties"+o,P=e.opts.ownProperties,w=e.baseId;P&&(a+=" var "+b+" = undefined; "),a+=P?" "+b+" = "+b+" || Object.keys("+c+"); for (var "+h+"=0; "+h+"<"+b+".length; "+h+"++) { var "+f+" = "+b+"["+h+"]; ":" for (var "+f+" in "+c+") { ",a+=" var startErrs"+o+" = errors; ";var E=f,S=e.compositeRule;e.compositeRule=m.compositeRule=!0;var F=e.validate(m);m.baseId=w,e.util.varOccurences(F,y)<2?a+=" "+e.util.varReplace(F,y,E)+" ":a+=" var "+y+" = "+E+"; "+F+" ",e.compositeRule=m.compositeRule=S,a+=" if (!"+p+") { for (var "+v+"=startErrs"+o+"; "+v+"<errors; "+v+"++) { vErrors["+v+"].propertyName = "+f+"; }   var err =   ",!1!==e.createErrors?(a+=" { keyword: 'propertyNames' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { propertyName: '"+g+"' } ",!1!==e.opts.messages&&(a+=" , message: 'property name \\'"+g+"\\' is invalid' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&u&&(e.async?a+=" throw new ValidationError(vErrors); ":a+=" validate.errors = vErrors; return false; "),u&&(a+=" break; "),a+=" } }";}return u&&(a+="  if ("+d+" == errors) {"),a},required:function(e,r,t){var a=" ",o=e.level,n=e.dataLevel,i=e.schema[r],s=e.schemaPath+e.util.getProperty(r),l=e.errSchemaPath+"/"+r,u=!e.opts.allErrors,c="data"+(n||""),d="valid"+o,m=e.opts.$data&&i&&i.$data;m&&(a+=" var schema"+o+" = "+e.util.getData(i.$data,n,e.dataPathArr)+"; ");var p="schema"+o;if(!m)if(i.length<e.opts.loopRequired&&e.schema.properties&&Object.keys(e.schema.properties).length){var f=[],h=i;if(h)for(var v,g=-1,y=h.length-1;g<y;){v=h[g+=1];var b=e.schema.properties[v];b&&(e.opts.strictKeywords?"object"==typeof b&&Object.keys(b).length>0||!1===b:e.util.schemaHasRules(b,e.RULES.all))||(f[f.length]=v);}}else f=i;if(m||f.length){var P=e.errorPath,w=m||f.length>=e.opts.loopRequired,E=e.opts.ownProperties;if(u)if(a+=" var missing"+o+"; ",w){m||(a+=" var "+p+" = validate.schema"+s+"; ");var S="' + "+(k="schema"+o+"["+(O="i"+o)+"]")+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(P,k,e.opts.jsonPointers)),a+=" var "+d+" = true; ",m&&(a+=" if (schema"+o+" === undefined) "+d+" = true; else if (!Array.isArray(schema"+o+")) "+d+" = false; else {"),a+=" for (var "+O+" = 0; "+O+" < "+p+".length; "+O+"++) { "+d+" = "+c+"["+p+"["+O+"]] !== undefined ",E&&(a+=" &&   Object.prototype.hasOwnProperty.call("+c+", "+p+"["+O+"]) "),a+="; if (!"+d+") break; } ",m&&(a+="  }  "),a+="  if (!"+d+") {   ",(D=D||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+S+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+S+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";var F=a;a=D.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+F+"]); ":a+=" validate.errors = ["+F+"]; return false; ":a+=" var err = "+F+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { ";}else {a+=" if ( ";var x=f;if(x)for(var O=-1,_=x.length-1;O<_;){A=x[O+=1],O&&(a+=" || "),a+=" ( ( "+($=c+(R=e.util.getProperty(A)))+" === undefined ",E&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(A)+"') "),a+=") && (missing"+o+" = "+e.util.toQuotedString(e.opts.jsonPointers?A:R)+") ) ";}a+=") {  ";var D;S="' + "+(k="missing"+o)+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.opts.jsonPointers?e.util.getPathExpr(P,k,!0):P+" + "+k),(D=D||[]).push(a),a="",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+S+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+S+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ";F=a;a=D.pop(),!e.compositeRule&&u?e.async?a+=" throw new ValidationError(["+F+"]); ":a+=" validate.errors = ["+F+"]; return false; ":a+=" var err = "+F+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",a+=" } else { ";}else if(w){m||(a+=" var "+p+" = validate.schema"+s+"; ");var k;S="' + "+(k="schema"+o+"["+(O="i"+o)+"]")+" + '";e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPathExpr(P,k,e.opts.jsonPointers)),m&&(a+=" if ("+p+" && !Array.isArray("+p+")) {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+S+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+S+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if ("+p+" !== undefined) { "),a+=" for (var "+O+" = 0; "+O+" < "+p+".length; "+O+"++) { if ("+c+"["+p+"["+O+"]] === undefined ",E&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", "+p+"["+O+"]) "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+S+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+S+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ",m&&(a+="  }  ");}else {var j=f;if(j)for(var A,I=-1,C=j.length-1;I<C;){A=j[I+=1];var R=e.util.getProperty(A),$=(S=e.util.escapeQuotes(A),c+R);e.opts._errorDataPathProperty&&(e.errorPath=e.util.getPath(P,A,e.opts.jsonPointers)),a+=" if ( "+$+" === undefined ",E&&(a+=" || ! Object.prototype.hasOwnProperty.call("+c+", '"+e.util.escapeQuotes(A)+"') "),a+=") {  var err =   ",!1!==e.createErrors?(a+=" { keyword: 'required' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(l)+" , params: { missingProperty: '"+S+"' } ",!1!==e.opts.messages&&(a+=" , message: '",e.opts._errorDataPathProperty?a+="is a required property":a+="should have required property \\'"+S+"\\'",a+="' "),e.opts.verbose&&(a+=" , schema: validate.schema"+s+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+c+" "),a+=" } "):a+=" {} ",a+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";}}e.errorPath=P;}else u&&(a+=" if (true) {");return a},uniqueItems:function(e,r,t){var a,o=" ",n=e.level,i=e.dataLevel,s=e.schema[r],l=e.schemaPath+e.util.getProperty(r),u=e.errSchemaPath+"/"+r,c=!e.opts.allErrors,d="data"+(i||""),m="valid"+n,p=e.opts.$data&&s&&s.$data;if(p?(o+=" var schema"+n+" = "+e.util.getData(s.$data,i,e.dataPathArr)+"; ",a="schema"+n):a=s,(s||p)&&!1!==e.opts.uniqueItems){p&&(o+=" var "+m+"; if ("+a+" === false || "+a+" === undefined) "+m+" = true; else if (typeof "+a+" != 'boolean') "+m+" = false; else { "),o+=" var i = "+d+".length , "+m+" = true , j; if (i > 1) { ";var f=e.schema.items&&e.schema.items.type,h=Array.isArray(f);if(!f||"object"==f||"array"==f||h&&(f.indexOf("object")>=0||f.indexOf("array")>=0))o+=" outer: for (;i--;) { for (j = i; j--;) { if (equal("+d+"[i], "+d+"[j])) { "+m+" = false; break outer; } } } ";else {o+=" var itemIndices = {}, item; for (;i--;) { var item = "+d+"[i]; ";var v="checkDataType"+(h?"s":"");o+=" if ("+e.util[v](f,"item",e.opts.strictNumbers,!0)+") continue; ",h&&(o+=" if (typeof item == 'string') item = '\"' + item; "),o+=" if (typeof itemIndices[item] == 'number') { "+m+" = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";}o+=" } ",p&&(o+="  }  "),o+=" if (!"+m+") {   ";var g=g||[];g.push(o),o="",!1!==e.createErrors?(o+=" { keyword: 'uniqueItems' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(u)+" , params: { i: i, j: j } ",!1!==e.opts.messages&&(o+=" , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' "),e.opts.verbose&&(o+=" , schema:  ",o+=p?"validate.schema"+l:""+s,o+="         , parentSchema: validate.schema"+e.schemaPath+" , data: "+d+" "),o+=" } "):o+=" {} ";var y=o;o=g.pop(),!e.compositeRule&&c?e.async?o+=" throw new ValidationError(["+y+"]); ":o+=" validate.errors = ["+y+"]; return false; ":o+=" var err = "+y+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",o+=" } ",c&&(o+=" else { ");}else c&&(o+=" if (true) { ");return o},validate:Le},Pr=oe.toHash,wr=["multipleOf","maximum","exclusiveMaximum","minimum","exclusiveMinimum","maxLength","minLength","pattern","additionalItems","maxItems","minItems","uniqueItems","maxProperties","minProperties","required","additionalProperties","enum","format","const"],Er=function(e,r){for(var t=0;t<r.length;t++){e=JSON.parse(JSON.stringify(e));var a,o=r[t].split("/"),n=e;for(a=1;a<o.length;a++)n=n[o[a]];for(a=0;a<wr.length;a++){var i=wr[a],s=n[i];s&&(n[i]={anyOf:[s,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]});}}return e},Sr=Ce.MissingRef,Fr=function e(r,t,a){var o=this;if("function"!=typeof this._opts.loadSchema)throw new Error("options.loadSchema should be a function");"function"==typeof t&&(a=t,t=void 0);var n=i(r).then((function(){var e=o._addSchema(r,void 0,t);return e.validate||function e(r){try{return o._compile(r)}catch(e){if(e instanceof Sr)return a(e);throw e}function a(a){var n=a.missingSchema;if(u(n))throw new Error("Schema "+n+" is loaded but "+a.missingRef+" cannot be resolved");var s=o._loadingSchemas[n];return s||(s=o._loadingSchemas[n]=o._opts.loadSchema(n)).then(l,l),s.then((function(e){if(!u(n))return i(e).then((function(){u(n)||o.addSchema(e,n,void 0,t);}))})).then((function(){return e(r)}));function l(){delete o._loadingSchemas[n];}function u(e){return o._refs[e]||o._schemas[e]}}}(e)}));a&&n.then((function(e){a(null,e);}),a);return n;function i(r){var t=r.$schema;return t&&!o.getSchema(t)?e.call(o,{$ref:t},!0):Promise.resolve()}};var xr=function(e,r,t){var a,o,n=" ",i=e.level,s=e.dataLevel,l=e.schema[r],u=e.schemaPath+e.util.getProperty(r),c=e.errSchemaPath+"/"+r,d=!e.opts.allErrors,m="data"+(s||""),p="valid"+i,f="errs__"+i,h=e.opts.$data&&l&&l.$data;h?(n+=" var schema"+i+" = "+e.util.getData(l.$data,s,e.dataPathArr)+"; ",o="schema"+i):o=l;var v,g,y,b,P,w="definition"+i,E=this.definition,S="";if(h&&E.$data){P="keywordValidate"+i;var F=E.validateSchema;n+=" var "+w+" = RULES.custom['"+r+"'].definition; var "+P+" = "+w+".validate;";}else {if(!(b=e.useCustomRule(this,l,e.schema,e)))return;o="validate.schema"+u,P=b.code,v=E.compile,g=E.inline,y=E.macro;}var x=P+".errors",O="i"+i,_="ruleErr"+i,D=E.async;if(D&&!e.async)throw new Error("async keyword in sync schema");if(g||y||(n+=x+" = null;"),n+="var "+f+" = errors;var "+p+";",h&&E.$data&&(S+="}",n+=" if ("+o+" === undefined) { "+p+" = true; } else { ",F&&(S+="}",n+=" "+p+" = "+w+".validateSchema("+o+"); if ("+p+") { ")),g)E.statements?n+=" "+b.validate+" ":n+=" "+p+" = "+b.validate+"; ";else if(y){var k=e.util.copy(e);S="";k.level++;var j="valid"+k.level;k.schema=b.validate,k.schemaPath="";var A=e.compositeRule;e.compositeRule=k.compositeRule=!0;var I=e.validate(k).replace(/validate\.schema/g,P);e.compositeRule=k.compositeRule=A,n+=" "+I;}else {(N=N||[]).push(n),n="",n+="  "+P+".call( ",e.opts.passContext?n+="this":n+="self",v||!1===E.schema?n+=" , "+m+" ":n+=" , "+o+" , "+m+" , validate.schema"+e.schemaPath+" ",n+=" , (dataPath || '')",'""'!=e.errorPath&&(n+=" + "+e.errorPath);var C=s?"data"+(s-1||""):"parentData",R=s?e.dataPathArr[s]:"parentDataProperty",$=n+=" , "+C+" , "+R+" , rootData )  ";n=N.pop(),!1===E.errors?(n+=" "+p+" = ",D&&(n+="await "),n+=$+"; "):n+=D?" var "+(x="customErrors"+i)+" = null; try { "+p+" = await "+$+"; } catch (e) { "+p+" = false; if (e instanceof ValidationError) "+x+" = e.errors; else throw e; } ":" "+x+" = null; "+p+" = "+$+"; ";}if(E.modifying&&(n+=" if ("+C+") "+m+" = "+C+"["+R+"];"),n+=""+S,E.valid)d&&(n+=" if (true) { ");else {var N;n+=" if ( ",void 0===E.valid?(n+=" !",n+=y?""+j:""+p):n+=" "+!E.valid+" ",n+=") { ",a=this.keyword,(N=N||[]).push(n),n="",(N=N||[]).push(n),n="",!1!==e.createErrors?(n+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { keyword: '"+this.keyword+"' } ",!1!==e.opts.messages&&(n+=" , message: 'should pass \""+this.keyword+"\" keyword validation' "),e.opts.verbose&&(n+=" , schema: validate.schema"+u+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+m+" "),n+=" } "):n+=" {} ";var L=n;n=N.pop(),!e.compositeRule&&d?e.async?n+=" throw new ValidationError(["+L+"]); ":n+=" validate.errors = ["+L+"]; return false; ":n+=" var err = "+L+";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";var T=n;n=N.pop(),g?E.errors?"full"!=E.errors&&(n+="  for (var "+O+"="+f+"; "+O+"<errors; "+O+"++) { var "+_+" = vErrors["+O+"]; if ("+_+".dataPath === undefined) "+_+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+_+".schemaPath === undefined) { "+_+'.schemaPath = "'+c+'"; } ',e.opts.verbose&&(n+=" "+_+".schema = "+o+"; "+_+".data = "+m+"; "),n+=" } "):!1===E.errors?n+=" "+T+" ":(n+=" if ("+f+" == errors) { "+T+" } else {  for (var "+O+"="+f+"; "+O+"<errors; "+O+"++) { var "+_+" = vErrors["+O+"]; if ("+_+".dataPath === undefined) "+_+".dataPath = (dataPath || '') + "+e.errorPath+"; if ("+_+".schemaPath === undefined) { "+_+'.schemaPath = "'+c+'"; } ',e.opts.verbose&&(n+=" "+_+".schema = "+o+"; "+_+".data = "+m+"; "),n+=" } } "):y?(n+="   var err =   ",!1!==e.createErrors?(n+=" { keyword: '"+(a||"custom")+"' , dataPath: (dataPath || '') + "+e.errorPath+" , schemaPath: "+e.util.toQuotedString(c)+" , params: { keyword: '"+this.keyword+"' } ",!1!==e.opts.messages&&(n+=" , message: 'should pass \""+this.keyword+"\" keyword validation' "),e.opts.verbose&&(n+=" , schema: validate.schema"+u+" , parentSchema: validate.schema"+e.schemaPath+" , data: "+m+" "),n+=" } "):n+=" {} ",n+=";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ",!e.compositeRule&&d&&(e.async?n+=" throw new ValidationError(vErrors); ":n+=" validate.errors = vErrors; return false; ")):!1===E.errors?n+=" "+T+" ":(n+=" if (Array.isArray("+x+")) { if (vErrors === null) vErrors = "+x+"; else vErrors = vErrors.concat("+x+"); errors = vErrors.length;  for (var "+O+"="+f+"; "+O+"<errors; "+O+"++) { var "+_+" = vErrors["+O+"]; if ("+_+".dataPath === undefined) "+_+".dataPath = (dataPath || '') + "+e.errorPath+";  "+_+'.schemaPath = "'+c+'";  ',e.opts.verbose&&(n+=" "+_+".schema = "+o+"; "+_+".data = "+m+"; "),n+=" } } else { "+T+" } "),n+=" } ",d&&(n+=" else { ");}return n},Or="http://json-schema.org/draft-07/schema#",_r="http://json-schema.org/draft-07/schema#",Dr="Core schema meta-schema",kr={schemaArray:{type:"array",minItems:1,items:{$ref:"#"}},nonNegativeInteger:{type:"integer",minimum:0},nonNegativeIntegerDefault0:{allOf:[{$ref:"#/definitions/nonNegativeInteger"},{default:0}]},simpleTypes:{enum:["array","boolean","integer","null","number","object","string"]},stringArray:{type:"array",items:{type:"string"},uniqueItems:!0,default:[]}},jr=["object","boolean"],Ar={$id:{type:"string",format:"uri-reference"},$schema:{type:"string",format:"uri"},$ref:{type:"string",format:"uri-reference"},$comment:{type:"string"},title:{type:"string"},description:{type:"string"},default:!0,readOnly:{type:"boolean",default:!1},examples:{type:"array",items:!0},multipleOf:{type:"number",exclusiveMinimum:0},maximum:{type:"number"},exclusiveMaximum:{type:"number"},minimum:{type:"number"},exclusiveMinimum:{type:"number"},maxLength:{$ref:"#/definitions/nonNegativeInteger"},minLength:{$ref:"#/definitions/nonNegativeIntegerDefault0"},pattern:{type:"string",format:"regex"},additionalItems:{$ref:"#"},items:{anyOf:[{$ref:"#"},{$ref:"#/definitions/schemaArray"}],default:!0},maxItems:{$ref:"#/definitions/nonNegativeInteger"},minItems:{$ref:"#/definitions/nonNegativeIntegerDefault0"},uniqueItems:{type:"boolean",default:!1},contains:{$ref:"#"},maxProperties:{$ref:"#/definitions/nonNegativeInteger"},minProperties:{$ref:"#/definitions/nonNegativeIntegerDefault0"},required:{$ref:"#/definitions/stringArray"},additionalProperties:{$ref:"#"},definitions:{type:"object",additionalProperties:{$ref:"#"},default:{}},properties:{type:"object",additionalProperties:{$ref:"#"},default:{}},patternProperties:{type:"object",additionalProperties:{$ref:"#"},propertyNames:{format:"regex"},default:{}},dependencies:{type:"object",additionalProperties:{anyOf:[{$ref:"#"},{$ref:"#/definitions/stringArray"}]}},propertyNames:{$ref:"#"},const:!0,enum:{type:"array",items:!0,minItems:1,uniqueItems:!0},type:{anyOf:[{$ref:"#/definitions/simpleTypes"},{type:"array",items:{$ref:"#/definitions/simpleTypes"},minItems:1,uniqueItems:!0}]},format:{type:"string"},contentMediaType:{type:"string"},contentEncoding:{type:"string"},if:{$ref:"#"},then:{$ref:"#"},else:{$ref:"#"},allOf:{$ref:"#/definitions/schemaArray"},anyOf:{$ref:"#/definitions/schemaArray"},oneOf:{$ref:"#/definitions/schemaArray"},not:{$ref:"#"}},Ir={$schema:Or,$id:_r,title:Dr,definitions:kr,type:jr,properties:Ar,default:!0},Cr=ee(Object.freeze({__proto__:null,$schema:Or,$id:_r,title:Dr,definitions:kr,type:jr,properties:Ar,default:Ir})),Rr={$id:"https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",definitions:{simpleTypes:Cr.definitions.simpleTypes},type:"object",dependencies:{schema:["validate"],$data:["validate"],statements:["inline"],valid:{not:{required:["macro"]}}},properties:{type:Cr.properties.type,schema:{type:"boolean"},statements:{type:"boolean"},dependencies:{type:"array",items:{type:"string"}},metaSchema:{type:"object"},modifying:{type:"boolean"},valid:{type:"boolean"},$data:{type:"boolean"},async:{type:"boolean"},errors:{anyOf:[{type:"boolean"},{const:"full"}]}}},$r=/^[a-z_$][a-z0-9_$-]*$/i,Nr=function(e,r){var t=this.RULES;if(t.keywords[e])throw new Error("Keyword "+e+" is already defined");if(!$r.test(e))throw new Error("Keyword "+e+" is not a valid identifier");if(r){this.validateKeyword(r,!0);var a=r.type;if(Array.isArray(a))for(var o=0;o<a.length;o++)i(e,a[o],r);else i(e,a,r);var n=r.metaSchema;n&&(r.$data&&this._opts.$data&&(n={anyOf:[n,{$ref:"https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}]}),r.validateSchema=this.compile(n,!0));}function i(e,r,a){for(var o,n=0;n<t.length;n++){var i=t[n];if(i.type==r){o=i;break}}o||(o={type:r,rules:[]},t.push(o));var s={keyword:e,definition:a,custom:!0,code:xr,implements:a.implements};o.rules.push(s),t.custom[e]=s;}return t.keywords[e]=t.all[e]=!0,this},Lr=function(e){var r=this.RULES.custom[e];return r?r.definition:this.RULES.keywords[e]||!1},Tr$1=function(e){var r=this.RULES;delete r.keywords[e],delete r.all[e],delete r.custom[e];for(var t=0;t<r.length;t++)for(var a=r[t].rules,o=0;o<a.length;o++)if(a[o].keyword==e){a.splice(o,1);break}return this},Vr=function e(r,t){e.errors=null;var a=this._validateKeyword=this._validateKeyword||this.compile(Rr,!0);if(a(r))return !0;if(e.errors=a.errors,t)throw new Error("custom keyword definition is invalid: "+this.errorsText(a.errors));return !1};var zr="http://json-schema.org/draft-07/schema#",qr="https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",Mr="Meta-schema for $data reference (JSON Schema extension proposal)",Wr=["$data"],Ur={$data:{type:"string",anyOf:[{format:"relative-json-pointer"},{format:"json-pointer"}]}},Br={$schema:zr,$id:qr,description:Mr,type:"object",required:Wr,properties:Ur,additionalProperties:!1},Qr=ee(Object.freeze({__proto__:null,$schema:zr,$id:qr,description:Mr,type:"object",required:Wr,properties:Ur,additionalProperties:!1,default:Br})),Hr=Zr;Zr.prototype.validate=function(e,r){var t;if("string"==typeof e){if(!(t=this.getSchema(e)))throw new Error('no schema with key or ref "'+e+'"')}else {var a=this._addSchema(e);t=a.validate||this._compile(a);}var o=t(r);!0!==t.$async&&(this.errors=t.errors);return o},Zr.prototype.compile=function(e,r){var t=this._addSchema(e,void 0,r);return t.validate||this._compile(t)},Zr.prototype.addSchema=function(e,r,t,a){if(Array.isArray(e)){for(var o=0;o<e.length;o++)this.addSchema(e[o],void 0,t,a);return this}var n=this._getId(e);if(void 0!==n&&"string"!=typeof n)throw new Error("schema id must be string");return at(this,r=Pe.normalizeId(r||n)),this._schemas[r]=this._addSchema(e,t,a,!0),this},Zr.prototype.addMetaSchema=function(e,r,t){return this.addSchema(e,r,t,!0),this},Zr.prototype.validateSchema=function(e,r){var t=e.$schema;if(void 0!==t&&"string"!=typeof t)throw new Error("$schema must be a string");if(!(t=t||this._opts.defaultMeta||function(e){var r=e._opts.meta;return e._opts.defaultMeta="object"==typeof r?e._getId(r)||r:e.getSchema(Kr)?Kr:void 0,e._opts.defaultMeta}(this)))return this.logger.warn("meta-schema not available"),this.errors=null,!0;var a=this.validate(t,e);if(!a&&r){var o="schema is invalid: "+this.errorsText();if("log"!=this._opts.validateSchema)throw new Error(o);this.logger.error(o);}return a},Zr.prototype.getSchema=function(e){var r=Yr(this,e);switch(typeof r){case"object":return r.validate||this._compile(r);case"string":return this.getSchema(r);case"undefined":return function(e,r){var t=Pe.schema.call(e,{schema:{}},r);if(t){var a=t.schema,o=t.root,n=t.baseId,i=ze.call(e,a,o,void 0,n);return e._fragments[r]=new ye({ref:r,fragment:!0,schema:a,root:o,baseId:n,validate:i}),i}}(this,e)}},Zr.prototype.removeSchema=function(e){if(e instanceof RegExp)return Xr(this,this._schemas,e),Xr(this,this._refs,e),this;switch(typeof e){case"undefined":return Xr(this,this._schemas),Xr(this,this._refs),this._cache.clear(),this;case"string":var r=Yr(this,e);return r&&this._cache.del(r.cacheKey),delete this._schemas[e],delete this._refs[e],this;case"object":var t=this._opts.serialize,a=t?t(e):e;this._cache.del(a);var o=this._getId(e);o&&(o=Pe.normalizeId(o),delete this._schemas[o],delete this._refs[o]);}return this},Zr.prototype.addFormat=function(e,r){"string"==typeof r&&(r=new RegExp(r));return this._formats[e]=r,this},Zr.prototype.errorsText=function(e,r){if(!(e=e||this.errors))return "No errors";for(var t=void 0===(r=r||{}).separator?", ":r.separator,a=void 0===r.dataVar?"data":r.dataVar,o="",n=0;n<e.length;n++){var i=e[n];i&&(o+=a+i.dataPath+" "+i.message+t);}return o.slice(0,-t.length)},Zr.prototype._addSchema=function(e,r,t,a){if("object"!=typeof e&&"boolean"!=typeof e)throw new Error("schema should be object or boolean");var o=this._opts.serialize,n=o?o(e):e,i=this._cache.get(n);if(i)return i;a=a||!1!==this._opts.addUsedSchema;var s=Pe.normalizeId(this._getId(e));s&&a&&at(this,s);var l,u=!1!==this._opts.validateSchema&&!r;u&&!(l=s&&s==Pe.normalizeId(e.$schema))&&this.validateSchema(e,!0);var c=Pe.ids.call(this,e),d=new ye({id:s,schema:e,localRefs:c,cacheKey:n,meta:t});"#"!=s[0]&&a&&(this._refs[s]=d);this._cache.put(n,d),u&&l&&this.validateSchema(e,!0);return d},Zr.prototype._compile=function(e,r){if(e.compiling)return e.validate=o,o.schema=e.schema,o.errors=null,o.root=r||o,!0===e.schema.$async&&(o.$async=!0),o;var t,a;e.compiling=!0,e.meta&&(t=this._opts,this._opts=this._metaOpts);try{a=ze.call(this,e.schema,r,e.localRefs);}catch(r){throw delete e.validate,r}finally{e.compiling=!1,e.meta&&(this._opts=t);}return e.validate=a,e.refs=a.refs,e.refVal=a.refVal,e.root=a.root,a;function o(){var r=e.validate,t=r.apply(this,arguments);return o.errors=r.errors,t}},Zr.prototype.compileAsync=Fr,Zr.prototype.addKeyword=Nr,Zr.prototype.getKeyword=Lr,Zr.prototype.removeKeyword=Tr$1,Zr.prototype.validateKeyword=Vr,Zr.ValidationError=Ce.Validation,Zr.MissingRefError=Ce.MissingRef,Zr.$dataMetaSchema=Er;var Kr="http://json-schema.org/draft-07/schema",Gr=["removeAdditional","useDefaults","coerceTypes","strictDefaults"],Jr=["/properties"];function Zr(e){if(!(this instanceof Zr))return new Zr(e);var r,t;e=this._opts=oe.copy(e)||{},function(e){var r=e._opts.logger;if(!1===r)e.logger={log:ot,warn:ot,error:ot};else {if(void 0===r&&(r=console),!("object"==typeof r&&r.log&&r.warn&&r.error))throw new Error("logger must implement log, warn and error methods");e.logger=r;}}(this),this._schemas={},this._refs={},this._fragments={},this._formats=sr(e.format),this._cache=e.cache||new Ge,this._loadingSchemas={},this._compilations=[],this.RULES=((r=[{type:"number",rules:[{maximum:["exclusiveMaximum"]},{minimum:["exclusiveMinimum"]},"multipleOf","format"]},{type:"string",rules:["maxLength","minLength","pattern","format"]},{type:"array",rules:["maxItems","minItems","items","contains","uniqueItems"]},{type:"object",rules:["maxProperties","minProperties","required","dependencies","propertyNames",{properties:["additionalProperties","patternProperties"]}]},{rules:["$ref","const","enum","not","anyOf","oneOf","allOf","if"]}]).all=Pr(t=["type","$comment"]),r.types=Pr(["number","integer","string","array","object","boolean","null"]),r.forEach((function(e){e.rules=e.rules.map((function(e){var a;if("object"==typeof e){var o=Object.keys(e)[0];a=e[o],e=o,a.forEach((function(e){t.push(e),r.all[e]=!0;}));}return t.push(e),r.all[e]={keyword:e,code:br[e],implements:a}})),r.all.$comment={keyword:"$comment",code:br.$comment},e.type&&(r.types[e.type]=e);})),r.keywords=Pr(t.concat(["$schema","$id","id","$data","$async","title","description","default","definitions","examples","readOnly","writeOnly","contentMediaType","contentEncoding","additionalItems","then","else"])),r.custom={},r),this._getId=function(e){switch(e.schemaId){case"auto":return tt;case"id":return et;default:return rt}}(e),e.loopRequired=e.loopRequired||1/0,"property"==e.errorDataPath&&(e._errorDataPathProperty=!0),void 0===e.serialize&&(e.serialize=Ne),this._metaOpts=function(e){for(var r=oe.copy(e._opts),t=0;t<Gr.length;t++)delete r[Gr[t]];return r}(this),e.formats&&function(e){for(var r in e._opts.formats){var t=e._opts.formats[r];e.addFormat(r,t);}}(this),e.keywords&&function(e){for(var r in e._opts.keywords){var t=e._opts.keywords[r];e.addKeyword(r,t);}}(this),function(e){var r;e._opts.$data&&(r=Qr,e.addMetaSchema(r,r.$id,!0));if(!1===e._opts.meta)return;var t=Cr;e._opts.$data&&(t=Er(t,Jr));e.addMetaSchema(t,Kr,!0),e._refs["http://json-schema.org/schema"]=Kr;}(this),"object"==typeof e.meta&&this.addMetaSchema(e.meta),e.nullable&&this.addKeyword("nullable",{metaSchema:{type:"boolean"}}),function(e){var r=e._opts.schemas;if(!r)return;if(Array.isArray(r))e.addSchema(r);else for(var t in r)e.addSchema(r[t],t);}(this);}function Yr(e,r){return r=Pe.normalizeId(r),e._schemas[r]||e._refs[r]||e._fragments[r]}function Xr(e,r,t){for(var a in r){var o=r[a];o.meta||t&&!t.test(a)||(e._cache.del(o.cacheKey),delete r[a]);}}function et(e){return e.$id&&this.logger.warn("schema $id ignored",e.$id),e.id}function rt(e){return e.id&&this.logger.warn("schema id ignored",e.id),e.$id}function tt(e){if(e.$id&&e.id&&e.$id!=e.id)throw new Error("schema $id is different from id");return e.$id||e.id}function at(e,r){if(e._schemas[r]||e._refs[r])throw new Error('schema with key or id "'+r+'" already exists')}function ot(){}var nt={$$currentLocalizeFn:function(e){if(e&&e.length)for(var r=0;r<e.length;r+=1){var t=e[r],a=void 0,o=void 0,n=void 0;switch(t.keyword){case"$ref":a="".concat(t.params.ref);break;case"additionalItems":a="",o=t.params.limit,a+="".concat(o,"");break;case"additionalProperties":a="";break;case"anyOf":a=" anyOf ";break;case"const":a="";break;case"contains":a="";break;case"custom":a=' "'.concat(t.keyword,' "');break;case"dependencies":a="",o=t.params.depsCount,a+="".concat(t.params.property,"").concat(t.params.deps);break;case"enum":a="";break;case"exclusiveMaximum":case"exclusiveMinimum":a="",n="".concat(t.params.comparison," ").concat(t.params.limit),a+=" ".concat(n);break;case"false schema":a="";break;case"format":a=' "'.concat(t.params.format,'"');break;case"formatExclusiveMaximum":a="formatExclusiveMaximum ";break;case"formatExclusiveMinimum":a="formatExclusiveMinimum ";break;case"formatMaximum":case"formatMinimum":a="",n="".concat(t.params.comparison," ").concat(t.params.limit),a+=" ".concat(n);break;case"if":a=' "'.concat(t.params.failingKeyword,'" ');break;case"maximum":a="",n="".concat(t.params.comparison," ").concat(t.params.limit),a+=" ".concat(n);break;case"maxItems":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"maxLength":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"maxProperties":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"minimum":a="",n="".concat(t.params.comparison," ").concat(t.params.limit),a+=" ".concat(n);break;case"minItems":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"minLength":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"minProperties":a="",o=t.params.limit,a+=" ".concat(o," ");break;case"multipleOf":a=" ".concat(t.params.multipleOf," ");break;case"not":a=' "not" schema';break;case"oneOf":a=' "oneOf"  schema';break;case"pattern":a=' "'.concat(t.params.pattern,'"');break;case"patternRequired":a=" ".concat(t.params.missingPattern);break;case"propertyNames":a=" '".concat(t.params.propertyName,"' ");break;case"required":a=" ".concat(t.params.missingProperty);break;case"switch":a=" ".concat(t.params.caseIndex,'  "switch" , ');break;case"type":a=" ".concat(t.params.type," ");break;case"uniqueItems":a=" ( ".concat(t.params.j,"  ").concat(t.params.i," )");break;default:continue}t.message=a;}},getCurrentLocalize:function(){return this.$$currentLocalizeFn},useLocal:function(e){this.$$currentLocalizeFn=e;}};function it(e,r){try{if("object"===y(r))return e.fill(null).map((function(){return JSON.parse(JSON.stringify(r))}))}catch(e){}}function st(e,r){return e.filter((function(e){return r.includes(e)}))}function lt(e,r,t){var a=Y(e.$ref,r);e.$ref;var o=S(e,["$ref"]);return mt(E(E({},a),o),r,t)}function ut(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];if(r.length<2)return r[0];for(var a={},o=[].concat(r),n=function(){var e=V(o[0])?o[0]:{},r=V(o[1])?o[1]:{};a=Object.assign({},e),Object.keys(r).reduce((function(t,a){var o=e[a],n=r[a];if(V(o)||V(n))if(V(o)&&V(n))t[a]=ut(o,n);else {var i=F(V(o)?[o,n]:[n,o],2),s=i[0],l=i[1];t[a]="additionalProperties"===a?!0===l&&s:s;}else if(Array.isArray(o)||Array.isArray(n))if(Array.isArray(o)&&Array.isArray(n)){if(V(o[0])||V(n[0]))throw new Error("");var u=st([].concat(o),[].concat(n));if(u.length<=0)throw new Error("");0===u.length&&"type"===a?t[a]=u[0]:t[a]=u;}else {var c=F(Array.isArray(o)?[o,n]:[n,o],2),d=c[0],m=c[1];if(void 0===m)t[a]=d;else {if(!d.includes(m))throw new Error("");t[a]=m;}}else t[a]=void 0!==o&&void 0!==n?"maxLength"===a||"maximum"===a||"maxItems"===a||"exclusiveMaximum"===a||"maxProperties"===a?Math.min(o,n):"minLength"===a||"minimum"===a||"minItems"===a||"exclusiveMinimum"===a||"minProperties"===a?Math.max(o,n):"multipleOf"===a?J(o,n):o:void 0===o?n:o;return t}),a),o.splice(0,2,a);};o.length>=2;)n();return a}function ct(e,r,t){var a=E(E({},e),{},{allOf:e.allOf.map((function(e){return mt(e,r,t)}))});try{var o=a.allOf,n=S(a,["allOf"]);return ut.apply(void 0,[n].concat(x(o)))}catch(e){return a.allOf,S(a,["allOf"])}}function dt(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return e.hasOwnProperty("allOf")&&(e=ct(e,r,t)),e.hasOwnProperty("$ref")&&(e=lt(e,r,t)),e}function mt(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return V(e)?dt(e,r,t):{}}var pt=/{{(.*)}}/;function ft(e,r,t,a){if(void 0!==t){var o=pt.exec(t);if(pt.lastIndex=0,o){var n=o[1].trim();return new Function("parentFormData","rootFormData","return ".concat(n))(I(e,r,1),e)}return a()}}function ht(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.schema,t=e.uiSchema,a=arguments.length>1?arguments[1]:void 0,o=bt({schema:r,uiSchema:t,containsSpec:!1});return ["title","description"].reduce((function(e,r){return o[r]&&(e["ui:".concat(r)]=String(o[r]).replace(/\$index/g,a+1)),e}),{})}function vt(e){var r=e.schema,t=void 0===r?{}:r,a=e.uiSchema,o=void 0===a?{}:a,n=e.curNodePath,i=void 0===n?"":n,s=e.rootFormData,l=void 0===s?{}:s,u=o["ui:widget"]||t["ui:widget"],c=o["ui:hidden"]||t["ui:hidden"];return "HiddenWidget"===u||"hidden"===u||!!ft(l,i,c,(function(){return "function"==typeof c?c(I(l,i,1),l):c}))}function gt(e,r){var t=r.schema,a=void 0===t?{}:t,o=r.uiSchema,n=void 0===o?{}:o,i=a["ui:field"]||n["ui:field"];if("function"==typeof i||"object"===y(i)||"string"==typeof i)return {field:i,fieldProps:n["ui:fieldProps"]||a["ui:fieldProps"]};var s=e[M(a)];if(s)return {field:s};if(!s&&(a.anyOf||a.oneOf))return {field:null};throw new Error("field, type: ".concat(a.type))}function yt(e){var r=e.schema,t=void 0===r?{}:r,a=e.uiSchema,o=void 0===a?{}:a,n=e.curNodePath,i=e.rootFormData,s=void 0===i?{}:i;return Object.assign.apply(Object,[{}].concat(x([t,o].map((function(e){return Object.keys(e).reduce((function(r,t){var a=e[t];if("ui:options"===t&&V(a))return E(E({},r),a);if("ui:hidden"!==t){if(0===t.indexOf("ui:"))return E(E({},r),{},b({},t.substring(3),void 0===n?a:ft(s,n,a,(function(){return a}))));if(0===t.indexOf("fui:"))return E(E({},r),{},b({},t.substring(4),a.call(null,I(s,n,1),s,n)))}return r}),{})})))))}function bt(e){var r=e.schema,t=void 0===r?{}:r,a=e.uiSchema,o=void 0===a?{}:a,n=e.containsSpec,i=void 0===n||n,s=e.curNodePath,l=e.rootFormData,u={};return i&&(u.readonly=!!t.readOnly,void 0!==t.multipleOf&&(u.step=t.multipleOf),(t.minimum||0===t.minimum)&&(u.min=t.minimum),(t.maximum||0===t.maximum)&&(u.max=t.maximum),(t.minLength||0===t.minLength)&&(u.minlength=t.minLength),(t.maxLength||0===t.maxLength)&&(u.maxlength=t.maxLength),"date-time"!==t.format&&"date"!==t.format||("array"===t.type?(u.isRange=!0,u.isNumberValue=!(t.items&&"string"===t.items.type)):u.isNumberValue=!("string"===t.type))),t.title&&(u.title=t.title),t.description&&(u.description=t.description),E(E({},u),yt({schema:t,uiSchema:o,curNodePath:s,rootFormData:l}))}function Pt(e){var r=e.schema,t=void 0===r?{}:r,a=e.uiSchema,o=void 0===a?{}:a,n=e.curNodePath,i=e.rootFormData,s=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,l=bt({schema:t,uiSchema:o,curNodePath:n,rootFormData:i});!l.widget&&s&&Object.assign(l,s({schema:t,uiSchema:o}));var u=l.widget,c=l.title,d=l.labelWidth,m=l.description,p=l.attrs,f=l.class,h=l.style,v=l.widgetListeners,g=l.fieldAttrs,y=l.fieldStyle,b=l.fieldClass,P=l.emptyValue,w=l.width,E=l.getWidget,F=l.renderScopedSlots,x=l.renderChildren,O=l.onChange,_=l.required,D=S(l,["widget","title","labelWidth","description","attrs","class","style","widgetListeners","fieldAttrs","fieldStyle","fieldClass","emptyValue","width","getWidget","renderScopedSlots","renderChildren","onChange","required"]);return {widget:u,label:c,labelWidth:d,description:m,widgetAttrs:p,widgetClass:f,widgetStyle:h,fieldAttrs:g,width:w,fieldStyle:y,fieldClass:b,emptyValue:P,getWidget:E,renderScopedSlots:F,renderChildren:x,onChange:O,widgetListeners:v,uiProps:D,uiRequired:_}}function wt(e){var r=e.schema,t=void 0===r?{}:r,a=e.uiSchema,o=void 0===a?{}:a,n=e.errorSchema,i=void 0===n?{}:n;return Object.assign.apply(Object,[{}].concat(x([t,o,i].map((function(e){return Object.keys(e).reduce((function(r,t){var a=e[t];return "err:options"===t&&V(a)?E(E({},r),a):0===t.indexOf("err:")?E(E({},r),{},b({},t.substring(4),a)):r}),{})})))))}function Et(e,r){if(!Array.isArray(r))return e;var t,a=function(e){return e.reduce((function(e,r){return e[r]=!0,e}),{})},o=a(e),n=r.filter((function(e){return "*"===e||o[e]})),i=a(n),s=e.filter((function(e){return !i[e]})),l=n.indexOf("*");if(-1===l){if(s.length)throw new Error("uiSchema order list does not contain ".concat((t=s).length>1?"properties '".concat(t.join("', '"),"'"):"property '".concat(t[0],"'")));return n}if(l!==n.lastIndexOf("*"))throw new Error("uiSchema order list contains more than one wildcard item");var u=x(n);return u.splice.apply(u,[l,1].concat(x(s))),u}function St(e){return Array.isArray(e.enum)&&1===e.enum.length||e.hasOwnProperty("const")}function Ft(e){if(Array.isArray(e.enum)&&1===e.enum.length)return e.enum[0];if(e.hasOwnProperty("const"))return e.const;throw new Error("schema cannot be inferred as a constant")}function xt(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},t=mt(e,r),a=t.oneOf||t.anyOf;return !!Array.isArray(t.enum)||!!Array.isArray(a)&&a.every((function(e){return St(e)}))}function Ot(e){return Array.isArray(e.items)&&e.items.length>0&&e.items.every((function(e){return V(e)}))}function _t(e){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return !(!e.uniqueItems||!e.items)&&xt(e.items,r)}function Dt(e){return e.additionalItems,V(e.additionalItems)}function kt(e,r,t,a){if(e.enum){var o=yt({schema:e,uiSchema:r,curNodePath:t,rootFormData:a}).enumNames||e.enumNames;return e.enum.map((function(e,r){return {label:o&&o[r]||String(e),value:e}}))}var n=e.oneOf||e.anyOf,i=r.oneOf||r.anyOf;return n.map((function(e,r){var o=i&&i[r]?yt({schema:e,uiSchema:i[r],curNodePath:t,rootFormData:a}):{},n=Ft(e);return {label:o.title||e.title||String(n),value:n}}))}function jt(e,r,t){if(e)return e;if(r){var a=t.split(".").pop();if(a&&a!=="".concat(Number(a)))return a}return ""}var It=$t(),Ct=null,Rt=null;function $t(){var e=new Hr({errorDataPath:"property",allErrors:!0,multipleOfPrecision:8,schemaId:"auto",unknownFormats:"ignore"});return e.addFormat("data-url",/^data:([a-z]+\/[a-z0-9-+.]+)?;(?:name=(.*);)?base64,(.*)$/),e.addFormat("color",/^(#?([0-9A-Fa-f]{3,4}){1,2}\b|aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow|(rgba?|hsla?)\(.*\))$/),e}function Nt(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return null===e?[]:e.map((function(e){var r=e.dataPath,t=e.keyword,a=e.message,o=e.params,n=e.schemaPath,i="".concat(r);return {name:t,property:i,message:a,params:o,stack:"".concat(i," ").concat(a).trim(),schemaPath:n}}))}function Lt(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.formData,t=e.schema,a=e.transformErrors,o=e.additionalMetaSchemas,n=void 0===o?[]:o,i=e.customFormats,s=void 0===i?{}:i,l=!W(Rt,n),u=!W(Ct,s);(l||u)&&(It=$t()),n&&l&&Array.isArray(n)&&(It.addMetaSchema(n),Rt=n),s&&u&&V(s)&&(Object.keys(s).forEach((function(e){It.addFormat(e,s[e]);})),Ct=s);var c=null;try{It.validate(t,r);}catch(e){c=e;}nt.getCurrentLocalize()(It.errors);var d=Nt(It.errors);It.errors=null;var m=c&&c.message&&"string"==typeof c.message&&c.message.includes("no schema with key or ref ");return m&&(d=[].concat(x(d),[{stack:c.message}])),"function"==typeof a&&(d=a(d)),{errors:d}}function Tt(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=e.formData,t=e.schema,a=e.uiSchema,o=e.transformErrors,n=e.additionalMetaSchemas,i=void 0===n?[]:n,s=e.customFormats,l=void 0===s?{}:s,u=e.errorSchema,c=void 0===u?{}:u,d=e.required,m=void 0!==d&&d,p=e.propPath,f=void 0===p?"":p,h=e.isOnlyFirstError,v=void 0===h||h,g="array"===t.type&&Array.isArray(r)&&0===r.length,y=void 0===r||g;if(m){if(y){var b={keyword:"required",params:{missingProperty:f}},P=wt({schema:t,uiSchema:a,errorSchema:c}).required;return P?b.message=P:nt.getCurrentLocalize()([b]),[b]}}else if(y&&!g)return [];var w=Lt({formData:r,schema:t,transformErrors:o,additionalMetaSchemas:i,customFormats:l}).errors;w=w.filter((function(e){return ""===e.property&&!e.schemaPath.includes("#/anyOf/")&&!e.schemaPath.includes("#/oneOf/")||"additionalProperties"===e.name}));var E=wt({schema:t,uiSchema:a,errorSchema:c});return (v&&w.length>0?[w[0]]:w).reduce((function(e,r){return r.message=void 0!==E[r.name]?E[r.name]:r.message,e.push(r),e}),[])}function Vt(e,r){try{return It.validate(e,r)}catch(e){return !1}}function zt(e,r,t){for(var a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=0;o<r.length;o++){var n=mt(r[o],t,e);if(n.properties){var i=E(E({},t.definitions?{definitions:t.definitions}:{}),{},{anyOf:Object.keys(n.properties).map((function(e){return {required:[e]}}))}),s=void 0;if(n.anyOf){var l=P({},n);l.allOf?l.allOf=l.allOf.slice():l.allOf=[],l.allOf.push(i),s=l;}else s=Object.assign({},n,i);if(a||delete s.required,Vt(s,e))return o}else if(Vt(n,e))return o}if(r[0]&&r[0].properties){var u=Object.keys(r[0].properties).find((function(e){return r[0].properties[e].const}));if(u)for(var c=0;c<r.length;c++)if(r[c].properties&&r[c].properties[u]&&r[c].properties[u].const===e[u])return c}return -1}function qt(e,r,t){var a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=zt(e,r,t,a);return -1===o?0:o}function Wt(e,r){if(Array.isArray(r))return Array.isArray(e)?r.map((function(r,t){return e[t]?Wt(e[t],r):r})):e;if(V(r)){var t=Object.assign({},e);return Object.keys(r).reduce((function(t,a){return t[a]=Wt(e?e[a]:{},r[a]),t}),t)}return r}function Ut(e,r,t){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},o=arguments.length>4&&void 0!==arguments[4]&&arguments[4],n=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=V(e)?e:{},s=V(a)?a:{};"allOf"in i&&(i=ct(i,t,s));var l=r;if(V(l)&&V(i.default))l=q(l,i.default);else if("default"in i)l=i.default;else {if("$ref"in i){var u=Y(i.$ref,t);return Ut(u,l,t,s,o,n)}if(Ot(i))l=i.items.map((function(e,a){return Ut(e,Array.isArray(r)?r[a]:void 0,t,s,o,n)}));else if("oneOf"in i){var c=mt(i.oneOf[qt(s,i.oneOf,t,n)],t,s);delete(i=q(i,c)).oneOf;}else if("anyOf"in i){var d=mt(i.anyOf[qt(s,i.anyOf,t,n)],t,s);delete(i=q(i,d)).anyOf;}}switch(void 0===l&&(l=i.default),M(i)){case"null":return null;case"object":return Object.keys(i.properties||{}).reduce((function(e,r){var a=Ut(i.properties[r],(l||{})[r],t,(s||{})[r],o,n);return (o||void 0!==a)&&(e[r]=a),e}),{});case"array":if(Array.isArray(l)&&(l=l.map((function(e,r){return Ut(i.items[r]||i.additionalItems||{},e,t,{},o,n)}))),Array.isArray(a)&&(l=a.map((function(e,r){return Ut(i.items,(l||{})[r],t,e,{},o,n)}))),i.minItems){if(_t(i,t))return l||[];var m=l?l.length:0;if(i.minItems>m){var p=l||[],f=Array.isArray(i.items)?i.additionalItems:i.items,h=it(new Array(i.minItems-m),Ut(f,f.defaults,t,{},o,n));return p.concat(h)}}l=void 0===l?[]:l;}return l}function Bt(e,r){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!V(e))throw new Error("Invalid schema: ".concat(e));var n=mt(e,t,r),i=Ut(n,e.default,t,r,a,o);return void 0===r?i:V(r)||Array.isArray(r)?Wt(i,r):0===r||!1===r||""===r?r:r||i}function Qt(e,r){void 0===r&&(r={});var t=r.insertAt;if(e&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],o=document.createElement("style");o.type="text/css","top"===t&&a.firstChild?a.insertBefore(o,a.firstChild):a.appendChild(o),o.styleSheet?o.styleSheet.cssText=e:o.appendChild(document.createTextNode(e));}}Qt('.genFromComponent{font-size:14px;line-height:1;word-wrap:break-word;word-break:break-word;padding:0;margin:0}.genFromComponent a,.genFromComponent h1,.genFromComponent h2,.genFromComponent h3,.genFromComponent li,.genFromComponent p,.genFromComponent ul{font-size:14px}.genFromComponent .genFormIcon{width:12px;height:12px;vertical-align:top}.genFromComponent .genFormBtn{display:inline-block;line-height:1;white-space:nowrap;cursor:pointer;background:#fff;border:1px solid #dcdfe6;color:#606266;-webkit-appearance:none;text-align:center;-webkit-box-sizing:border-box;box-sizing:border-box;outline:none;margin:0;-webkit-transition:.1s;transition:.1s;font-weight:500;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;padding:12px 20px;font-size:14px;border-radius:4px}.genFromComponent .genFormBtn.is-plain:focus,.genFromComponent .genFormBtn.is-plain:hover{background:#fff;border-color:#409eff;color:#409eff}.genFromComponent .hiddenWidget{display:none}.genFromComponent .fieldGroupWrap+.fieldGroupWrap .fieldGroupWrap_title{margin-top:20px}.genFromComponent .fieldGroupWrap_title{position:relative;display:block;width:100%;line-height:26px;margin-bottom:8px;font-size:15px;font-weight:700;border:0}.genFromComponent .fieldGroupWrap_des{font-size:12px;line-height:20px;margin-bottom:10px;color:#999}.genFromComponent .genFromWidget_des{padding:0;margin-top:0;margin-bottom:2px;font-size:12px;line-height:20px;color:#999;text-align:left;width:100%;-ms-flex-negative:0;flex-shrink:0}.genFromComponent .formItemErrorBox{margin:0 auto;color:#ff5757;padding-top:2px;position:absolute;top:100%;left:0;display:-webkit-box!important;line-height:16px;text-overflow:ellipsis;overflow:hidden;-webkit-box-orient:vertical;-webkit-line-clamp:1;white-space:normal;font-size:12px;text-align:left}.genFromComponent .genFormIcon-qs{fill:#606266;vertical-align:middle;display:inline-block;width:16px;height:16px;margin-left:2px;margin-top:-2px;cursor:pointer}.genFromComponent .genFormItemRequired:before{content:"*";color:#f56c6c;margin-right:4px}.genFromComponent .appendCombining_box{margin-bottom:22px}.genFromComponent .appendCombining_box .appendCombining_box{margin-bottom:10px}.genFromComponent .appendCombining_box{padding:10px;background:hsla(0,0%,94.9%,.8);-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 0 3px 1px rgba(0,0,0,.1);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 0 3px 1px rgba(0,0,0,.1)}.genFromComponent .validateWidget{margin-bottom:0!important;width:100%!important;-ms-flex-preferred-size:100%!important;flex-basis:100%!important;padding:0!important}.genFromComponent .validateWidget .formItemErrorBox{padding:5px 0;position:relative}.genFromComponent .arrayField:not(.genFormItem){margin-bottom:22px}.genFromComponent .arrayField:not(.genFormItem) .arrayField{margin-bottom:10px}.genFromComponent .arrayOrderList{background:hsla(0,0%,94.9%,.8);-webkit-box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 0 3px 1px rgba(0,0,0,.1);box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 0 3px 1px rgba(0,0,0,.1)}.genFromComponent .arrayOrderList_item{position:relative;padding:25px 10px 12px;border-radius:2px;margin-bottom:6px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.genFromComponent .arrayOrderList_bottomAddBtn{text-align:right;padding:15px 10px;margin-bottom:10px}.genFromComponent .bottomAddBtn{width:40%;min-width:10px;max-width:180px}.genFromComponent .arrayListItem_content{padding-top:15px;-webkit-box-flex:1;-ms-flex:1;flex:1;margin:0 auto;-webkit-box-shadow:0 -1px 0 0 rgba(0,0,0,.05);box-shadow:0 -1px 0 0 rgba(0,0,0,.05)}.genFromComponent .arrayListItem_index,.genFromComponent .arrayListItem_operateTool{position:absolute;height:25px}.genFromComponent .arrayListItem_index{top:6px;line-height:18px;height:18px;padding:0 6px;background-color:rgba(0,0,0,.28);color:#fff;font-size:12px;border-radius:2px}.genFromComponent .arrayListItem_operateTool{width:75px;right:9px;top:-1px;text-align:right;font-size:0}.genFromComponent .arrayListItem_btn{vertical-align:top;display:inline-block;padding:6px;margin:0;font-size:0;-webkit-appearance:none;-moz-appearance:none;appearance:none;outline:none;border:none;cursor:pointer;text-align:center;background:transparent;color:#666}.genFromComponent .arrayListItem_btn:hover{opacity:.6}.genFromComponent .arrayListItem_btn[disabled]{color:#999;opacity:.3!important;cursor:not-allowed}.genFromComponent .arrayListItem_orderBtn-bottom,.genFromComponent .arrayListItem_orderBtn-top{background-color:#f0f9eb}.genFromComponent .arrayListItem_btn-delete{background-color:#fef0f0}.genFromComponent .formFooter_item{text-align:right;border-top:1px solid rgba(0,0,0,.08);padding-top:10px}.genFromComponent.formInlineFooter>.fieldGroupWrap{display:inline-block;margin-right:10px}.genFromComponent.formInline .validateWidget{margin-right:0}.genFromComponent.formInline .formFooter_item{border-top:none;padding-top:0}.genFromWidget_des_mini{font-size:14px;line-height:1.5715}.layoutColumn .layoutColumn_w100{width:100%!important;-ms-flex-preferred-size:100%!important;flex-basis:100%!important}.layoutColumn .fieldGroupWrap_box{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:horizontal;-webkit-box-direction:normal;-ms-flex-direction:row;flex-direction:row;-ms-flex-wrap:wrap;flex-wrap:wrap;-webkit-box-align:start;-ms-flex-align:start;align-items:flex-start;-webkit-box-pack:start;-ms-flex-pack:start;justify-content:flex-start;-ms-flex-line-pack:start;align-content:flex-start}.layoutColumn .fieldGroupWrap_box>div{width:100%;-ms-flex-preferred-size:100%;flex-basis:100%}.layoutColumn .fieldGroupWrap_box>.genFormItem{-webkit-box-flex:0;-ms-flex-positive:0;flex-grow:0;-ms-flex-negative:0;flex-shrink:0;-webkit-box-sizing:border-box;box-sizing:border-box;padding-right:10px}.layoutColumn.layoutColumn-1 .fieldGroupWrap_box>.genFormItem{padding-right:0}.layoutColumn.layoutColumn-2 .fieldGroupWrap_box>.genFormItem{width:50%;-ms-flex-preferred-size:50%;flex-basis:50%}.layoutColumn.layoutColumn-3 .fieldGroupWrap_box>.genFormItem{width:33.333%;-ms-flex-preferred-size:33.333%;flex-basis:33.333%}');var Ht={formFooter:{type:Object,default:function(){return {show:!0,okBtn:"",cancelBtn:""}}},modelValue:{type:null,default:function(){return {}},required:!0},fallbackLabel:{type:Boolean,default:!1},strictMode:{type:Boolean,default:!1},formProps:{type:Object,default:function(){return {}}},schema:{type:Object,default:function(){return {}},required:!0},uiSchema:{type:Object,default:function(){return {}}},customFormats:{type:Object,default:function(){return {}}},customRule:{type:Function,default:null},errorSchema:{type:Object,default:function(){return {}}}},Kt={name:"FormFooter",props:{okBtn:{type:String,default:""},okBtnProps:{type:Object,default:function(){return {}}},cancelBtn:{type:String,default:""},formItemAttrs:{type:Object,default:function(){return {}}},globalOptions:{type:Object,default:function(){return {}}}},emits:["cancel","submit"],setup:function(e,r){var a=r.emit,o=e.globalOptions.COMPONENT_MAP;return function(){return h(N(o.formItem),E({class:{formFooter_item:!0}},e.formItemAttrs),{default:function(){return [h(N(o.button),{onClick:function(){a("cancel");}},{default:function(){return e.cancelBtn}}),h(N(o.button),E({style:{marginLeft:"10px"},type:"primary",onClick:function(){a("submit");}},e.okBtnProps),{default:function(){return e.okBtn}})]}})}}},Gt={name:"FieldGroupWrap",inject:["genFormProvide"],props:{curNodePath:{type:String,default:""},showTitle:{type:Boolean,default:!0},showDescription:{type:Boolean,default:!0},title:{type:String,default:""},description:{type:String,default:""}},computed:{trueTitle:function(){var e,r,t,a=this.title;if(a)return a;"boolean"==typeof(null===(e=this.genFormProvide.fallbackLabel)||void 0===e?void 0:e.value)?r=null===(t=this.genFormProvide.fallbackLabel)||void 0===t?void 0:t.value:r=this.genFormProvide.fallbackLabel;var o=r&&this.curNodePath.split(".").pop();return o!=="".concat(Number(o))?o:""}}},Jt={class:"fieldGroupWrap"},Zt={key:0,class:"fieldGroupWrap_title"},Yt={class:"fieldGroupWrap_box"};Gt.render=function(e,r,t,u,c,d){return openBlock(),createBlock("div",Jt,[t.showTitle&&d.trueTitle?(openBlock(),createBlock("h3",Zt,toDisplayString(d.trueTitle),1)):createCommentVNode("v-if",!0),t.showDescription&&t.description?(openBlock(),createBlock("p",{key:1,class:"fieldGroupWrap_des",innerHTML:t.description},null,8,["innerHTML"])):createCommentVNode("v-if",!0),createVNode("div",Yt,[renderSlot(e.$slots,"default")])])},Gt.__file="utils/components/FieldGroupWrap.vue";var Xt={formProps:{type:null},globalOptions:{type:null},schema:{type:Object,default:function(){return {}}},uiSchema:{type:Object,default:function(){return {}}},errorSchema:{type:Object,default:function(){return {}}},customRule:{type:Function,default:null},customFormats:{type:Object,default:function(){return {}}},rootSchema:{type:Object,default:function(){return {}}},rootFormData:{type:null,default:function(){return {}}},curNodePath:{type:String,default:""},required:{type:Boolean,default:!1},needValidFieldGroup:{type:Boolean,default:!0}},ea={class:"genFormIcon genFormIcon-down",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024"},ra=createVNode("path",{d:"M840.4 300H183.6c-19.7 0-30.7 20.8-18.5 35l328.4 380.8c9.4 10.9 27.5 10.9 37 0L858.9 335c12.2-14.2 1.2-35-18.5-35z"},null,-1);var ta={render:function(e,r){return openBlock(),createBlock("svg",ea,[ra])},__file:"utils/icons/IconCaretDown.vue"},aa={class:"genFormIcon genFormIcon-up",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024"},oa=createVNode("path",{d:"M858.9 689L530.5 308.2c-9.4-10.9-27.5-10.9-37 0L165.1 689c-12.2 14.2-1.2 35 18.5 35h656.8c19.7 0 30.7-20.8 18.5-35z"},null,-1);var na={render:function(e,r){return openBlock(),createBlock("svg",aa,[oa])},__file:"utils/icons/IconCaretUp.vue"},ia={class:"genFormIcon genFormIcon-close",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024"},sa=createVNode("path",{d:"M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1\n            191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0\n            0 0 203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z"},null,-1);var la={render:function(e,r){return openBlock(),createBlock("svg",ia,[sa])},__file:"utils/icons/IconClose.vue"},ua={class:"genFormIcon genFormIcon-plus",t:"1551322312294",viewBox:"0 0 1024 1024",version:"1.1",xmlns:"http://www.w3.org/2000/svg","p-id":"10297","xmlns:xlink":"http://www.w3.org/1999/xlink",width:"200",height:"200"},ca=createVNode("path",{d:"M474 152m8 0l60 0q8 0 8 8l0 704q0 8-8 8l-60 0q-8 0-8-8l0-704q0-8 8-8Z","p-id":"10298"},null,-1),da=createVNode("path",{d:"M168 474m8 0l672 0q8 0 8 8l0 60q0 8-8 8l-672 0q-8 0-8-8l0-60q0-8 8-8Z","p-id":"10299"},null,-1);var ma={render:function(e,r){return openBlock(),createBlock("svg",ua,[ca,da])},__file:"utils/icons/IconPlus.vue"},pa={class:"genFormIcon genFormIcon-qs",xmlns:"http://www.w3.org/2000/svg",viewBox:"0 0 1024 1024"},fa=createVNode("path",{d:"M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm0 708c-22.1\n            0-40-17.9-40-40s17.9-40 40-40 40 17.9 40 40-17.9 40-40 40zm62.9-219.5a48.3 48.3 0 0\n            0-30.9 44.8V620c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8v-21.5c0-23.1 6.7-45.9 19.9-64.9 12.9-18.6 30.9-32.8\n            52.1-40.9 34-13.1 56-41.6 56-72.7 0-44.1-43.1-80-96-80s-96 35.9-96 80v7.6c0 4.4-3.6\n            8-8 8h-48c-4.4 0-8-3.6-8-8V420c0-39.3 17.2-76 48.4-103.3C430.4 290.4 470 276 512 276s81.6 14.5 111.6\n            40.7C654.8 344 672 380.7 672 420c0 57.8-38.1 109.8-97.1 132.5z"},null,-1);var ha={render:function(e,r){return openBlock(),createBlock("svg",pa,[fa])},__file:"utils/icons/IconQuestion.vue"},va={name:"Widget",props:{isFormData:{type:Boolean,default:!0},curValue:{type:null,default:0},schema:{type:Object,default:function(){return {}}},uiSchema:{type:Object,default:function(){return {}}},errorSchema:{type:Object,default:function(){return {}}},customFormats:{type:Object,default:function(){return {}}},customRule:{type:Function,default:null},widget:{type:[String,Function,Object],default:null},required:{type:Boolean,default:!1},uiRequired:{type:Boolean},emptyValue:{type:null,default:void 0},rootFormData:{type:null},curNodePath:{type:String,default:""},label:{type:String,default:""},width:{type:String,default:""},labelWidth:{type:String,default:""},description:{type:String,default:""},widgetAttrs:{type:Object,default:function(){return {}}},widgetClass:{type:Object,default:function(){return {}}},widgetStyle:{type:Object,default:function(){return {}}},fieldAttrs:{type:Object,default:function(){return {}}},fieldClass:{type:Object,default:function(){return {}}},fieldStyle:{type:Object,default:function(){return {}}},uiProps:{type:Object,default:function(){return {}}},formProps:null,getWidget:null,renderScopedSlots:null,globalOptions:null,onChange:null},emits:["otherDataChange"],inheritAttrs:!0,setup:function(e,r){var a=r.emit,o=inject("genFormProvide"),n=computed({get:function(){return e.isFormData?I(e.rootFormData,e.curNodePath):e.curValue},set:function(r){var t=""===r||null===r?e.emptyValue:r;e.isFormData?$(e.rootFormData,e.curNodePath,t):a("otherDataChange",t);}}),i=computed((function(){var r;return null!==(r=e.uiRequired)&&void 0!==r?r:e.required}));e.uiProps.enumOptions&&e.uiProps.enumOptions.length>0&&void 0===n.value&&n.value!==e.uiProps.enumOptions[0]&&(e.schema.items?n.value=[]:i.value&&e.formProps.defaultSelectFirstOption&&(n.value=e.uiProps.enumOptions[0].value));var s=ref(null);return "function"==typeof e.getWidget&&watch(s,(function(){e.getWidget.call(null,s.value);})),function(){var r,a=j(e.curNodePath),l=e.formProps&&e.formProps.isMiniDes,u=null!=l?l:e.globalOptions.HELPERS.isMiniDes(e.formProps),c=e.description?h("div",{innerHTML:e.description,class:{genFromWidget_des:!0,genFromWidget_des_mini:u}}):null,d=e.globalOptions.COMPONENT_MAP,m=u&&c?h(N(d.popover),E({style:{margin:"0 2px",fontSize:"16px",cursor:"pointer"},placement:"top",trigger:"hover"},null===(r=e.formProps)||void 0===r?void 0:r.popover),{default:function(){return c},reference:function(){return h(ha)}}):null,p=E(E({},e.fieldStyle),e.width?{width:e.width,flexBasis:e.width,paddingRight:"10px"}:{}),f=jt(e.label,e.widget&&o.fallbackLabel.value,e.curNodePath);return h(N(d.formItem),E(E(E({class:E(E({},e.fieldClass),{},{genFormItem:!0}),style:p},e.fieldAttrs),e.labelWidth?{labelWidth:e.labelWidth}:{}),e.isFormData?{prop:a?"__$$root":e.curNodePath,rules:[{validator:function(r,t,o){a&&(t=e.rootFormData);var n=Tt({formData:t,schema:e.schema,uiSchema:e.uiSchema,customFormats:e.customFormats,errorSchema:e.errorSchema,required:i.value,propPath:e.curNodePath});if(n.length>0)return o?o(n[0].message):Promise.reject(n[0].message);var s=e.customRule;return s&&"function"==typeof s?s({field:e.curNodePath,value:t,rootFormData:e.rootFormData,callback:o}):o?o():Promise.resolve()},trigger:"change"}]}:{}),E(E({error:function(e){return e.error?h("div",{class:{formItemErrorBox:!0},title:e.error},[e.error]):null}},f?{label:function(){return h("span",{class:{genFormLabel:!0,genFormItemRequired:i.value}},["".concat(f)].concat(x(m?[m]:[]),["".concat(e.formProps&&e.formProps.labelSuffix||"")]))}}:{}),{},{default:function(r){return [].concat(x(!u&&c?[c]:[]),x(e.widget?[h(N(e.widget),E(E(E({style:e.widgetStyle,class:e.widgetClass},e.widgetAttrs),e.uiProps),{},{modelValue:n.value,ref:s,"onUpdate:modelValue":function(r){var t=n.value;t!==r&&(n.value=r,e.onChange&&e.onChange({curVal:r,preVal:t,parentFormData:I(e.rootFormData,e.curNodePath,1),rootFormData:e.rootFormData}));}},r?Object.keys(r).reduce((function(t,a){return t[a]=r[a],[e.widgetAttrs[a],e.uiProps[a]].forEach((function(e){e&&"function"==typeof e&&(t[a]=function(){e.apply(void 0,arguments),t[a].apply(t,arguments);});})),t}),{}):{}),E({},e.renderScopedSlots?"function"==typeof e.renderScopedSlots?e.renderScopedSlots():e.renderScopedSlots:{}))]:[]))}}))}}},ga={name:"ObjectField",props:Xt,setup:function(e){return function(){var r=e.curNodePath,a=bt({schema:e.schema,uiSchema:e.uiSchema,curNodePath:r,rootFormData:e.rootFormData}),o=a.title,n=a.description,i=a.showTitle,s=a.showDescription,l=a.order,u=a.fieldClass,c=a.fieldAttrs,d=a.fieldStyle,m=a.onlyShowIfDependent,p=Et(Object.keys(e.schema.properties||{}),l).map((function(a){var o=function(r){return Array.isArray(e.schema.required)&&!!~e.schema.required.indexOf(r)}(a),n=function(r){var t=!1,a=!1;return V(e.schema.dependencies)&&(a=Object.entries(e.schema.dependencies).some((function(a){var o=F(a,2),n=o[0],i=o[1],s=!(!Array.isArray(i)||!~i.indexOf(r));return t=t||s,s&&void 0!==I(e.rootFormData,e.curNodePath)[n]}))),{isDependency:t,curDependent:a}}(a),i=n.isDependency,s=n.curDependent;return i&&m&&!s?null:h(ja,E(E({key:a},e),{},{schema:e.schema.properties[a],uiSchema:e.uiSchema[a],errorSchema:e.errorSchema[a],required:o||s,curNodePath:A(r,a)}))}));return h(Gt,E({title:o,description:n,showTitle:i,showDescription:s,curNodePath:r,class:E({},u),style:d},c),{default:function(){return [].concat(x(p),x(e.needValidFieldGroup?[h(va,{key:"validateWidget-object",class:{validateWidget:!0,"validateWidget-object":!0},schema:Object.entries(e.schema).reduce((function(r,t){var a=F(t,2),o=a[0],n=a[1];return !1!==e.schema.additionalProperties&&["properties","id","$id"].includes(o)||(r[o]=n),r}),{}),uiSchema:e.uiSchema,errorSchema:e.errorSchema,curNodePath:r,rootFormData:e.rootFormData,globalOptions:e.globalOptions})]:[]))}})}}},ya={name:"StringField",props:Xt,setup:function(e,r){var a=r.attrs,o=computed((function(){var r=xt(e.schema)&&kt(e.schema,e.uiSchema,e.curNodePath,e.rootFormData),t=Pt({schema:e.schema,uiSchema:e.uiSchema,curNodePath:e.curNodePath,rootFormData:e.rootFormData},(function(){var t="number"===e.schema.type||"integer"===e.schema.type;return {widget:r?e.globalOptions.WIDGET_MAP.common.select:e.globalOptions.WIDGET_MAP.formats[e.schema.format]||(t?e.globalOptions.WIDGET_MAP.types.number:e.globalOptions.WIDGET_MAP.types.string)}}));return r&&!t.uiProps.enumOptions&&(t.uiProps.enumOptions=r),t}));return function(){return h(va,E(E(E({},e),a),o.value))}}},ba={name:"NumberField",props:Xt,setup:function(e,r){var a=r.attrs;return function(){return h(ya,E(E({},e),a))}}},Pa={name:"IntegerField",props:Xt,setup:function(e,r){var a=r.attrs;return function(){return h(ya,E(E({},e),a))}}},wa={name:"BooleanField",props:Xt,setup:function(e,r){var a=r.attrs;return function(){var r=e.schema,o=e.uiSchema,n=e.curNodePath,i=e.rootFormData,s=e.globalOptions,l=kt({enumNames:r.enumNames||["true","false"],enum:r.enum||[!0,!1]},o,n,i),u=Pt({schema:r,uiSchema:o,curNodePath:n,rootFormData:i},(function(){return {widget:s.WIDGET_MAP.types.boolean}}));return u.uiProps.enumOptions=u.uiProps.enumOptions||l,h(va,E(E(E({},a),e),u))}}},Ea={name:"ArrayOrderList",emits:["arrayOperate"],props:{vNodeList:{type:Array,default:[]},tupleItemsLength:{type:Number,default:0},addable:{type:Boolean,default:!0},showIndexNumber:{type:Boolean,default:!1},sortable:{type:Boolean,default:!0},removable:{type:Boolean,default:!0},maxItems:{},minItems:{},globalOptions:null},setup:function(e,r){var a=r.emit,o=computed((function(){var r=e.addable,t=e.maxItems,a=e.vNodeList;return !!r&&(void 0===t||a.length<t)})),n=computed((function(){var r=e.removable,t=e.minItems,a=e.vNodeList;return !!r&&(void 0===t||a.length>t)}));return function(){return e.vNodeList.length<=0&&!e.addable?null:h("div",{class:{arrayOrderList:!0}},e.vNodeList.map((function(r,o){var i=r.key,s=r.vNode,l=e.tupleItemsLength+o,u=o+1;return h("div",{key:i,class:{arrayOrderList_item:!0}},[e.showIndexNumber?h("div",{class:{arrayListItem_index:!0}},u):null,h("div",{class:{arrayListItem_operateTool:!0}},[h("button",{style:E({},e.sortable?{}:{display:"none"}),class:{arrayListItem_btn:!0,"arrayListItem_orderBtn-top":!0},type:"button",disabled:!e.sortable||0===o,onClick:function(){a("arrayOperate",{command:"moveUp",data:{index:l}});}},[h(na)]),h("button",{style:E({},e.sortable?{}:{display:"none"}),class:{arrayListItem_btn:!0,"arrayListItem_orderBtn-bottom":!0},type:"button",disabled:!e.sortable||o===e.vNodeList.length-1,onClick:function(){a("arrayOperate",{command:"moveDown",data:{index:l}});}},[h(ta)]),h("button",{style:E({},e.removable?{}:{display:"none"}),class:{arrayListItem_btn:!0,"arrayListItem_btn-delete":!0},type:"button",disabled:!n.value,onClick:function(){a("arrayOperate",{command:"remove",data:{index:l}});}},[h(la)])]),h("div",{class:{arrayListItem_content:!0}},[s])])})).concat([h("p",{style:E({},o.value?{}:{display:"none"}),class:{arrayOrderList_bottomAddBtn:!0}},[h("button",{class:{bottomAddBtn:!0,"is-plain":!0,genFormBtn:!0},type:"button",onClick:function(){a("arrayOperate",{command:"add"});}},[h(ma,{style:{marginRight:"5px"}}),e.maxItems?"( ".concat(e.vNodeList.length," / ").concat(e.maxItems," )"):""])])]))}}},Sa={name:"ArrayFieldNormal",props:E(E({},Xt),{},{itemsFormData:{type:Array}}),setup:function(e,r){var a=r.attrs;return function(){var r=e.schema,o=e.uiSchema,n=e.curNodePath,i=e.rootFormData,s=e.itemsFormData,l=e.errorSchema,u=e.globalOptions,c=bt({schema:r,uiSchema:o,curNodePath:n,rootFormData:i}),d=c.title,m=c.description,p=c.addable,f=c.showIndexNumber,h$1=c.sortable,v=c.removable,g=c.showTitle,y=c.showDescription,b=c.fieldClass,P=c.fieldAttrs,w=c.fieldStyle,S=s.map((function(a,i){var s=ht({schema:r.items,uiSchema:o.items},i);return {key:a.key,vNode:h(ja,E(E({key:a.key},e),{},{schema:r.items,required:![].concat(r.items.type).includes("null"),uiSchema:E(E({},o.items),s),errorSchema:l.items,curNodePath:A(n,i)}))}}));return h(Gt,{title:d,description:m,showTitle:g,showDescription:y,curNodePath:n,class:b,attrs:P,style:w},{default:function(){return h(Ea,E(E({},a),{},{vNodeList:S,showIndexNumber:f,addable:p,sortable:h$1,removable:v,maxItems:r.maxItems,minItems:r.minItems,globalOptions:u}))}})}}},Fa={name:"ArrayFieldMultiSelect",props:E({},Xt),setup:function(e,r){var a=r.attrs;return function(){var r=e.schema,o=e.rootSchema,n=e.uiSchema,i=e.curNodePath,s=e.rootFormData,l=e.globalOptions,u=kt(mt(r.items,o),n,i,s),c=Pt({schema:r,uiSchema:n,curNodePath:i,rootFormData:s},(function(){return {widget:l.WIDGET_MAP.common.checkboxGroup}}));return c.uiProps.multiple=!0,u&&!c.uiProps.enumOptions&&(c.uiProps.enumOptions=u),h(va,E(E(E({},a),e),c))}}},xa={name:"ArrayFieldTuple",props:E(E({},Xt),{},{itemsFormData:{type:Array,default:function(){return []}}}),emits:["arrayOperate"],setup:function(e,r){var a=r.emit;r.attrs;return function(){var r=!Array.isArray(e.itemsFormData);if(r||e.itemsFormData.length<e.schema.items.length){var t=Bt(e.schema,void 0,e.rootSchema);a("arrayOperate",r?{command:"setNewTarget",data:{newTarget:t}}:{command:"batchPush",data:{pushArray:t.slice(e.itemsFormData.length)}});}}(),function(){if(!Array.isArray(e.itemsFormData))return null;var r,o,n=e.schema,i=e.uiSchema,s=e.errorSchema,l=e.curNodePath,u=e.globalOptions,c=bt({schema:n,uiSchema:i,curNodePath:l,rootFormData:e.rootFormData}),d=c.title,m=c.description,p=c.addable,f=c.showIndexNumber,h$1=c.sortable,v=c.removable,g=c.showTitle,y=c.showDescription,b=c.fieldClass,P=c.fieldAttrs,w=c.fieldStyle,S=(r=e.itemsFormData,o=e.schema.items.length-1,r.reduce((function(e,r,t){return e[t>o?1:0].push(r),e}),[[],[]])),F=S[0].map((function(r,a){return h(ja,E(E({key:r.key},e),{},{required:![].concat(n.items[a].type).includes("null"),schema:n.items[a],uiSchema:i.items?i.items[a]:{},errorSchema:s.items?s.items[a]:{},curNodePath:A(l,a)}))})),O=S[1].map((function(r,a){var o=ht({schema:n.additionalItems,uiSchema:i.additionalItems},a);return {key:r.key,vNode:h(ja,E(E({key:r.key},e),{},{schema:n.additionalItems,required:![].concat(n.additionalItems.type).includes("null"),uiSchema:E(E({},i.additionalItems),o),errorSchema:s.additionalItems,curNodePath:A(e.curNodePath,a+n.items.length)}))}})),_=(void 0===p||p)&&Dt(e.schema);return h(Gt,E(E({title:d,description:m,showTitle:g,showDescription:y,curNodePath:l},P),{},{class:b,style:w}),{default:function(){return [].concat(x(F),[h(Ea,{onArrayOperate:function(){for(var e=arguments.length,r=new Array(e),t=0;t<e;t++)r[t]=arguments[t];return a.apply(void 0,["arrayOperate"].concat(r))},vNodeList:O,tupleItemsLength:n.items.length,addable:_,showIndexNumber:f,sortable:h$1,removable:v,maxItems:n.maxItems,minItems:n.minItems,globalOptions:u})])}})}}},Oa={name:"ArrayFieldSpecialFormat",props:Xt,setup:function(e,r){var a=r.attrs,o=computed((function(){return Pt({schema:E({"ui:widget":e.globalOptions.WIDGET_MAP.formats[e.schema.format]},e.schema),uiSchema:e.uiSchema,curNodePath:e.curNodePath,rootFormData:e.rootFormData})}));return function(){return h(va,E(E(E({},a),e),o.value))}}},_a={name:"ArrayField",props:Xt,setup:function(e){var r=this,a=function(){var r=I(e.rootFormData,e.curNodePath);return Array.isArray(r)?r:[]},o=ref(a().map((function(){return Q()}))),n=computed((function(){return a()}));watch(n,(function(e,r){e!==r&&toRaw(e)!==toRaw(r)&&Array.isArray(e)&&(o.value=e.map((function(){return Q()})));}),{deep:!0});var i=computed((function(){return n.value.map((function(e,r){return {key:o.value[r],value:e}}))})),s=computed((function(){return yt({schema:e.schema,uiSchema:e.uiSchema,curNodePath:e.curNodePath,rootFormData:e.rootFormData})})),l=function(t){var a=t.command,i=t.data,l={moveUp:function(e,r){!function(e,r){if(0===r)return !1;var t=[e[r],e[r-1]];e.splice.apply(e,[r-1,2].concat(t));}(e,r.index);},moveDown:function(e,r){!function(e,r){if(r===e.length-1)return !1;var t=e[r],a=[e[r+1],t];e.splice.apply(e,[r,2].concat(a));}(e,r.index);},remove:function(e,r){!function(e,r){e.splice(r,1).length;}(e,r.index);},add:function(e,r){var t=r.newRowData;e.push(t);},batchPush:function(e,r){r.pushArray.forEach((function(r){e.push(r);}));},setNewTarget:function(e,r){$(r.formData,r.nodePath,r.newTarget);}}[a];if(!l)throw new Error(" - [".concat(a,"]"));var u,c,d,m=i,p=i;"add"===a?(m={newRowData:(u=e.schema,c=e.rootSchema,d=u.items,Ot(u)&&Dt(u)&&(d=u.additionalItems),Bt(d,void 0,c))},p={newRowData:Q()}):"batchPush"===a?p={pushArray:m.pushArray.map((function(e){return Q()}))}:"setNewTarget"===a&&(m={formData:e.rootFormData,nodePath:e.curNodePath,newTarget:m.newTarget},p={formData:o,nodePath:"value",newTarget:m.newTarget.map((function(e){return Q()}))}),l.apply(null,[o.value,p]),l.apply(null,[n.value,m]),s.value.afterArrayOperate&&r.uiOptions.afterArrayOperate.call(null,n.value,a,i);};return function(){var r=e.schema,a=e.uiSchema,o=e.rootSchema,n=e.rootFormData,s=e.curNodePath,u=e.globalOptions;if(!r.hasOwnProperty("items"))throw new Error("[".concat(r,"]  items"));if(_t(r,o))return h(Fa,E(E({},e),{},{class:b({},G(Fa.name),!0)}));if(r.format||r["ui:widget"]||a["ui:widget"])return h(Oa,E(E({},e),{},{class:b({},G(Oa.name),!0)}));var c=Ot(r)?xa:Sa;return h("div",[h(c,E(E({itemsFormData:i.value},e),{},{onArrayOperate:l,class:b({},G(c.name),!0)})),e.needValidFieldGroup?h(va,{key:"validateWidget-array",class:{validateWidget:!0,"validateWidget-array":!0},schema:Object.entries(r).reduce((function(e,r){var t=F(r,2),a=t[0],o=t[1];return "items"!==a&&(e[a]=o),e}),{}),uiSchema:a,errorSchema:e.errorSchema,curNodePath:s,rootFormData:n,globalOptions:u}):null])}}},Da={name:"SelectLinkageField",props:E(E({},Xt),{},{combiningType:{type:String,default:"anyOf"},selectList:{type:Array,require:!0}}),setup:function(e){var r=ref(qt(I(e.rootFormData,e.curNodePath),e.selectList,e.rootSchema,!0)||0),a=function(){var a=Pt({schema:e.schema["".concat(e.combiningType,"Select")]||{},uiSchema:e.uiSchema["".concat(e.combiningType,"Select")]||{},curNodePath:e.curNodePath,rootFormData:e.rootFormData},(function(){return {widget:"SelectWidget"}}));if(a.label=a.label||e.schema.title,a.description=a.description||e.schema.description,!a.uiProps.enumOptions){var o=e.uiSchema[e.combiningType]||[];a.uiProps.enumOptions=e.selectList.map((function(e,r){return {label:bt({schema:e,uiSchema:o[r],containsSpec:!1}).title||" ".concat(r+1),value:r}}));}return h(va,E(E({key:"fieldSelect_".concat(e.combiningType),class:b({},"fieldSelect_".concat(e.combiningType),!0),isFormData:!1,curValue:r.value,curNodePath:e.curNodePath,rootFormData:e.rootFormData,globalOptions:e.globalOptions},a),{},{onOtherDataChange:function(e){r.value=e;}}))};return watch(r,(function(r,t){var a=I(e.rootFormData,e.curNodePath),o=Bt(e.selectList[r],void 0,e.rootSchema),n=Object.prototype.hasOwnProperty;if(V(a)){var i=mt(e.selectList[t],e.rootSchema);if("object"===M(i))for(var s in i.properties)n.call(i.properties,s)&&!n.call(o,s)&&R(a,s);}V(o)?Object.entries(o).forEach((function(t){var o,n=F(t,2),i=n[0],s=n[1];void 0===s||void 0!==a[i]&&!V(s)&&void 0===(null===(o=mt(e.selectList[r],e.rootSchema).properties[i])||void 0===o?void 0:o.const)||$(a,i,s);})):$(e.rootFormData,e.curNodePath,void 0===o&&Vt(mt(e.selectList[r],e.rootSchema),a)?a:o);})),function(){var o,n=e.curNodePath,i=k(n),s="object"===e.schema.type||e.schema.properties,l=[a()],u=e.selectList[r.value];if(u){var c=e.schema,d=e.combiningType,m="".concat(e.combiningType,"Select");c.properties,c[d],c[m];var p=S(c,["properties",d,m].map(D));u=Object.assign({},p,u);}var f=s&&H(u&&u.properties);if(u&&!f){var h$1=K(bt({schema:e.schema,uiSchema:e.uiSchema,containsSpec:!1,curNodePath:n,rootFormData:e.rootFormData}),(function(r){return r===e.combiningType?void 0:"ui:".concat(r)})),v=K(wt({schema:e.schema,uiSchema:e.uiSchema,errorSchema:e.errorSchema}),(function(r){return r===e.combiningType?void 0:"err:".concat(r)}));l.push(h(ja,E(E({key:"appendSchema_".concat(e.combiningType)},e),{},{schema:E({"ui:showTitle":!1,"ui:showDescription":!1},u),required:e.required,uiSchema:E(E({},h$1),(e.uiSchema[e.combiningType]||[])[r.value]),errorSchema:E(E({},v),(e.errorSchema[e.combiningType]||[])[r.value])})));}var g=null;if(s&&!H(e.schema.properties)){var y,P=u;P.title,P.description,P.properties;var w=S(P,["title","description","properties"]),F=Object.assign({},e.schema,w);delete F[e.combiningType],g=h(ja,E(E({key:"origin_".concat(e.combiningType),class:(y={},b(y,"".concat(e.combiningType,"_originBox"),!0),b(y,"".concat(i,"-originBox"),!0),y)},e),{},{schema:F}));}return l.push(h(va,{key:"validateWidget-".concat(e.combiningType),class:b({validateWidget:!0},"validateWidget-".concat(e.combiningType),!0),schema:e.schema,uiSchema:e.uiSchema,errorSchema:e.errorSchema,curNodePath:e.curNodePath,rootFormData:e.rootFormData,globalOptions:e.globalOptions})),h("div",[g,h("div",{key:"appendBox_".concat(e.combiningType),class:(o={appendCombining_box:!0},b(o,"".concat(e.combiningType,"_appendBox"),!0),b(o,"".concat(i,"-appendBox"),!0),o)},l)])}}},ka={array:_a,boolean:wa,integer:Pa,number:ba,object:ga,string:ya,null:{render:function(){return null}},anyOf:{name:"AnyOfField",setup:function(e,r){var a=r.attrs,o=r.slots;return function(){return h(Da,E(E({},a),{},{combiningType:"anyOf",selectList:a.schema.anyOf}),o)}}},oneOf:{name:"oneOfField",setup:function(e,r){var a=r.attrs,o=r.slots;return function(){return h(Da,E(E({},a),{},{combiningType:"oneOf",selectList:a.schema.oneOf}),o)}}}},ja={name:"SchemaField",props:Xt,setup:function(e){return function(){var r,a=mt(e.schema,e.rootSchema),o=E(E({},e),{},{schema:a});if(0===Object.keys(a).length)return null;var n,i,s=gt(ka,o),l=s.field,u=s.fieldProps,c=vt({schema:a,uiSchema:e.uiSchema,curNodePath:e.curNodePath,rootFormData:e.rootFormData}),d=k(e.curNodePath);return a.anyOf&&a.anyOf.length>0&&!xt(a)?h(N(ka.anyOf),E({class:(n={},b(n,"".concat(d,"-anyOf"),!0),b(n,"fieldItem",!0),b(n,"anyOfField",!0),n)},o)):a.oneOf&&a.oneOf.length>0&&!xt(a)?h(N(ka.oneOf),E({class:(i={},b(i,"".concat(d,"-oneOf"),!0),b(i,"fieldItem",!0),b(i,"oneOfField",!0),i)},o)):l&&!c?h(N(l),E(E({},o),{},{fieldProps:u,class:(r={},b(r,G(l.name)||l,!0),b(r,"hiddenWidget",c),b(r,"fieldItem",!0),b(r,d,!0),r)})):null}}};var Aa={CheckboxesWidget:L({name:"CheckboxesWidget",props:{enumOptions:{default:function(){return []},type:[Array]}},setup:function(e,r){var a=r.attrs;return function(){return h(N("n-checkbox-group"),a,{default:function(){return h(N("n-space"),{itemStyle:"display: flex"},{default:function(){return e.enumOptions.map((function(e,r){return h(N("n-checkbox"),{key:r,value:e.value},{default:function(){return e.label}})}))}})}})}}},{model:"value"}),RadioWidget:L({name:"RadioWidget",props:{enumOptions:{default:function(){return []},type:[Array]}},setup:function(e,r){var a=r.attrs;return function(){return h(N("n-radio-group"),a,{default:function(){return e.enumOptions.map((function(e,r){return h(N("n-radio"),{key:r,value:e.value},{default:function(){return e.label}})}))}})}}},{model:"value"}),SelectWidget:L({name:"SelectWidget",props:{enumOptions:{default:function(){return []},type:[Array]}},setup:function(e,r){var a=r.attrs;return function(){return h(N("n-select"),E({options:e.enumOptions},a))}}},{model:"value"}),TimePickerWidget:{name:"TimePickerWidget",inheritAttrs:!1,setup:function(e,r){var a=r.attrs;return function(){var e=a.modelValue,r=a["onUpdate:modelValue"],o=S(a,["modelValue","onUpdate:modelValue"]);return h(N("n-time-picker"),E(E({},o),{},{valueFormat:"HH:mm:ss",formattedValue:e,onUpdateFormattedValue:r}))}}},DatePickerWidget:{name:"DatePickerWidget",inheritAttrs:!1,setup:function(e,r){var a=r.attrs;return function(){var e=a.isNumberValue,r=a.isRange,o=a.modelValue,n=a["onUpdate:modelValue"],i=S(a,["isNumberValue","isRange","modelValue","onUpdate:modelValue"]),s=r&&o&&0===o.length?null:o;return h(N("n-date-picker"),E(E({type:r?"daterange":"date"},i),e?{value:s,onUpdateValue:n}:{valueFormat:e?"T":"yyyy-MM-dd",formattedValue:s,onUpdateFormattedValue:n}))}}},DateTimePickerWidget:{name:"DatePickerWidget",inheritAttrs:!1,setup:function(e,r){var a=r.attrs;return function(){var e=a.isNumberValue,r=a.isRange,o=a.modelValue,n=a["onUpdate:modelValue"],i=S(a,["isNumberValue","isRange","modelValue","onUpdate:modelValue"]),s=r&&o&&0===o.length?null:o;return h(N("n-date-picker"),E(E({type:r?"datetimerange":"datetime"},i),e?{value:s,onUpdateValue:n}:{valueFormat:e?"T":"yyyy-MM-dd'T'HH:mm:ss.SSS'Z'",formattedValue:s,onUpdateFormattedValue:n}))}}},UploadWidget:{name:"UploadWidget",props:{modelValue:{default:null,type:[String,Array]},responseFileUrl:{default:function(){return function(e){return e?e.url||e.data&&e.data.url:""}},type:[Function]},btnText:{type:String,default:""},slots:{type:null,default:null}},setup:function(e,r){var a=r.attrs,o=r.emit,n=e.modelValue,i=Array.isArray(n),s=a.fileList||(i?n.map((function(e,r){return {id:String(r),status:"finished",name:"".concat(r+1,""),url:e}})):n?[{id:"1",status:"finished",name:"",url:n}]:[]),l=ref(s),u=getCurrentInstance().appContext.config.globalProperties;return function(){a["onUpdate:modelValue"];var r=S(a,["onUpdate:modelValue"]),n=E(E({fileList:l.value,"on-error":function(){u.$message&&u.$message.error("");}},r),{},{"onUpdate:fileList":function(e){!function(e){var r;if(i)r=e.length?e.reduce((function(e,r){var t=r.url;return t&&e.push(t),e}),[]):[];else {var t=e[e.length-1],a=t&&t.url;a&&(r=a);}o("update:modelValue",r);}(e);},"on-change":function(e){var r=e.fileList;l.value=r;},"on-finish":function(r){var t=r.file,a=r.event;return t.url=function(r){var t={};try{t=JSON.parse(r.response);}catch(e){}return e.responseFileUrl(t)||t.url||""}(a.target),t}});i||(n.max=1);var s=E({default:function(){return h(N("n-button"),{type:"primary"},{default:function(){return e.btnText}})}},e.slots||{});return h(N("n-upload"),n,s)}}},InputWidget:L("n-input"),ColorWidget:L("n-color-picker"),TextAreaWidget:L("n-textarea"),InputNumberWidget:L("n-input-number"),AutoCompleteWidget:L("n-auto-complete"),SliderWidget:L("n-slider"),RateWidget:L("n-rate"),SwitchWidget:L("n-switch")},Ia=Aa.InputNumberWidget,Ca={types:{boolean:Aa.SwitchWidget,string:Aa.InputWidget,number:Ia,integer:Ia},formats:{color:Aa.ColorWidget,time:Aa.TimePickerWidget,date:Aa.DatePickerWidget,"date-time":Aa.DateTimePickerWidget},common:{select:Aa.SelectWidget,radioGroup:Aa.RadioWidget,checkboxGroup:Aa.CheckboxesWidget},widgetComponents:Aa};Qt(".genFromComponent .n-form-item-blank{-ms-flex-wrap:wrap;flex-wrap:wrap}.genFromComponent .n-form-item.n-form-item--top-labelled{grid-template-rows:none}.genFromComponent .formFooter_item .n-form-item-blank{-webkit-box-pack:end;-ms-flex-pack:end;justify-content:flex-end}.genFromComponent .n-form-item-feedback--error .n-form-item-feedback__line{display:-webkit-box!important;text-overflow:ellipsis;overflow:hidden;-webkit-box-orient:vertical;-webkit-line-clamp:2;white-space:normal;text-align:left;line-height:1.2;font-size:12px}.genFromComponent .validateWidget .n-form-item-blank,.genFromComponent .validateWidget .n-form-item-feedback-wrapper{min-height:auto}");var Ra={WIDGET_MAP:Ca,COMPONENT_MAP:{form:defineComponent({inheritAttrs:!1,setup:function(e,r){var a=r.attrs,o=r.slots,n={top:{labelAlign:"left",labelPlacement:"top"},left:{labelAlign:"left",labelPlacement:"left"},right:{labelAlign:"right",labelPlacement:"left"}},i=ref(null);return a.setFormRef&&onMounted((function(){i.value.$$validate=function(e){i.value.validate((function(r){return r?e(!1,r):e(!0)}));},a.setFormRef(i.value);})),function(){a.setFormRef;var e=a.labelPosition,r=a.model,s=S(a,["setFormRef","labelPosition","model"]);return h(N("n-form"),E(E({ref:i,model:r.value},n[e||"top"]),s),o)}}}),formItem:defineComponent({inheritAttrs:!1,setup:function(e,r){var a=r.attrs,o=r.slots;return function(){var e=a.prop,r=a.rules,n=E(E({},S(a,["prop","rules"])),{},{path:e,rule:(r||[]).map((function(e){return {trigger:e.trigger,asyncValidator:function(r,t,a){return e.validator(r,t,a)}}}))});return h(N("n-form-item"),n,o)}}}),button:"n-button",popover:defineComponent({setup:function(e,r){var a=r.attrs,o=r.slots;return function(){return h(N("n-popover"),a,{trigger:o.reference,default:o.default})}}})},HELPERS:{isMiniDes:function(e){return e&&["left","right"].includes(e.labelPosition)}}},$a=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r={name:"VueForm",props:Ht,emits:["update:modelValue","change","cancel","submit","validation-failed","form-mounted"],setup:function(a,o){var n=o.slots,i=o.emit,s=getCurrentInstance();!r.installed&&e.WIDGET_MAP.widgetComponents&&(Object.entries(e.WIDGET_MAP.widgetComponents).forEach((function(e){var r=F(e,2),t=r[0],a=r[1];return s.appContext.app.component(t,a)})),r.installed=!0);var l=toRef(a,"fallbackLabel");provide("genFormProvide",{fallbackLabel:l});var u=ref(Bt(a.schema,a.modelValue,a.schema,a.strictMode)),p=computed((function(){return E({show:!0,okBtn:"",okBtnProps:{},cancelBtn:""},a.formFooter)})),g=null,y=function(e,r){i("update:modelValue",e),i("change",{newValue:e,oldValue:r});},P=function(e,r){if(!W(e,r)){var t=Bt(a.schema,a.modelValue,a.schema,a.strictMode);W(u.value,t)||(u.value=t);}};watch(u,(function(e,r){y(e,r);}),{deep:!0}),watch((function(){return a.schema}),(function(e,r){P(e,r);})),watch((function(){return a.modelValue}),(function(e,r){P(e,r);})),y(u.value,a.modelValue);return function(){var r,o=a.formProps,l=o.layoutColumn,c=void 0===l?1:l,d=o.inlineFooter;o.labelSuffix,o.isMiniDes,o.defaultSelectFirstOption,o.popover;var m=S(o,["layoutColumn","inlineFooter","labelSuffix","isMiniDes","defaultSelectFirstOption","popover"]),f=m.inline,h$1=void 0!==f&&f,v=m.labelPosition,y=void 0===v?"top":v,P={schema:a.schema,uiSchema:a.uiSchema,errorSchema:a.errorSchema,customFormats:a.customFormats,customRule:a.customRule,rootSchema:a.schema,rootFormData:u.value,curNodePath:"",globalOptions:e,formProps:E({labelPosition:y,labelSuffix:"",defaultSelectFirstOption:!0,inline:h$1},a.formProps)};return h(N(e.COMPONENT_MAP.form),E({class:(r={genFromComponent:!0,formInlineFooter:d,formInline:h$1},b(r,"genFromComponent_".concat(a.schema.id,"Form"),!!a.schema.id),b(r,"layoutColumn",!h$1),b(r,"layoutColumn-".concat(c),!h$1),r),setFormRef:function(e){g=e,s.ctx.$$uiFormRef=g,i("form-mounted",e,{formData:u.value});},onSubmit:function(e){e.preventDefault();},model:u,labelPosition:y,inline:h$1},m),{default:function(){return [h(ja,P),n.default?n.default({formData:u,formRefFn:function(){return g}}):p.value.show?h(Kt,{globalOptions:e,okBtn:p.value.okBtn,okBtnProps:p.value.okBtnProps,cancelBtn:p.value.cancelBtn,formItemAttrs:p.value.formItemAttrs,onCancel:function(){i("cancel");},onSubmit:function(){(g.$$validate||g.validate)((function(e,r){return e?i("submit",u):i("validation-failed",r)}));}}):[]]}})}},install:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e.component(t.name||r.name,r);}};return r}(Ra);

  let onceCbs = [];
  const paramsMap = new WeakMap();
  function flushOnceCallbacks() {
      onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
      onceCbs = [];
  }
  function beforeNextFrameOnce(cb, ...params) {
      paramsMap.set(cb, params);
      if (onceCbs.includes(cb))
          return;
      onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
  }

  function getParentNode$1(node) {
      // document type
      if (node.nodeType === 9) {
          return null;
      }
      return node.parentNode;
  }
  function getScrollParent$1(node) {
      if (node === null)
          return null;
      const parentNode = getParentNode$1(node);
      if (parentNode === null) {
          return null;
      }
      // Document
      if (parentNode.nodeType === 9) {
          return document.documentElement;
      }
      // Element
      if (parentNode.nodeType === 1) {
          // Firefox want us to check `-x` and `-y` variations as well
          const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
          if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
              return parentNode;
          }
      }
      return getScrollParent$1(parentNode);
  }

  function unwrapElement(target) {
      if (typeof target === 'string')
          return document.querySelector(target);
      if (typeof target === 'function')
          return target();
      return target;
  }

  function happensIn(e, dataSetPropName) {
      let { target } = e;
      while (target) {
          if (target.dataset) {
              if (target.dataset[dataSetPropName] !== undefined)
                  return true;
          }
          target = target.parentElement;
      }
      return false;
  }

  function getPreciseEventTarget(event) {
      return event.composedPath()[0] || null;
  }

  function parseResponsiveProp(reponsiveProp) {
      if (typeof reponsiveProp === "number") {
          return {
              '': reponsiveProp.toString()
          };
      }
      const params = {};
      reponsiveProp.split(/ +/).forEach((pairLiteral) => {
          if (pairLiteral === '')
              return;
          const [prefix, value] = pairLiteral.split(':');
          if (value === undefined) {
              params[''] = prefix;
          }
          else {
              params[prefix] = value;
          }
      });
      return params;
  }
  function parseResponsivePropValue(reponsiveProp, activeKeyOrSize) {
      var _a;
      if (reponsiveProp === undefined || reponsiveProp === null)
          return undefined;
      const classObj = parseResponsiveProp(reponsiveProp);
      if (activeKeyOrSize === undefined)
          return classObj[''];
      if (typeof activeKeyOrSize === 'string') {
          return (_a = classObj[activeKeyOrSize]) !== null && _a !== void 0 ? _a : classObj[''];
      }
      else if (Array.isArray(activeKeyOrSize)) {
          for (let i = activeKeyOrSize.length - 1; i >= 0; --i) {
              const key = activeKeyOrSize[i];
              if (key in classObj)
                  return classObj[key];
          }
          return classObj[''];
      }
      else {
          // Here we suppose all the keys are number formatted
          let activeValue = undefined;
          let activeKey = -1;
          Object.keys(classObj).forEach((key) => {
              const keyAsNum = Number(key);
              if (!Number.isNaN(keyAsNum) &&
                  activeKeyOrSize >= keyAsNum &&
                  keyAsNum >= activeKey) {
                  activeKey = keyAsNum;
                  activeValue = classObj[key];
              }
          });
          return activeValue;
      }
  }

  function depx(value) {
      if (typeof value === 'string') {
          if (value.endsWith('px')) {
              return Number(value.slice(0, value.length - 2));
          }
          return Number(value);
      }
      return value;
  }
  function pxfy(value) {
      if (value === undefined || value === null)
          return undefined;
      if (typeof value === 'number')
          return `${value}px`;
      if (value.endsWith('px'))
          return value;
      return `${value}px`;
  }
  function getMargin(value, position) {
      const parts = value.trim().split(/\s+/g);
      const margin = {
          top: parts[0]
      };
      switch (parts.length) {
          case 1:
              margin.right = parts[0];
              margin.bottom = parts[0];
              margin.left = parts[0];
              break;
          case 2:
              margin.right = parts[1];
              margin.left = parts[1];
              margin.bottom = parts[0];
              break;
          case 3:
              margin.right = parts[1];
              margin.bottom = parts[2];
              margin.left = parts[1];
              break;
          case 4:
              margin.right = parts[1];
              margin.bottom = parts[2];
              margin.left = parts[3];
              break;
          default:
              throw new Error('[seemly/getMargin]:' + value + ' is not a valid value.');
      }
      if (position === undefined)
          return margin;
      return margin[position];
  }
  function getGap(value, orient) {
      const [rowGap, colGap] = value.split(' ');
      if (!orient)
          return {
              row: rowGap,
              col: colGap || rowGap
          };
      return orient === 'row' ? rowGap : colGap;
  }

  var colors = {
      black: '#000',
      silver: '#C0C0C0',
      gray: '#808080',
      white: '#FFF',
      maroon: '#800000',
      red: '#F00',
      purple: '#800080',
      fuchsia: '#F0F',
      green: '#008000',
      lime: '#0F0',
      olive: '#808000',
      yellow: '#FF0',
      navy: '#000080',
      blue: '#00F',
      teal: '#008080',
      aqua: '#0FF',
      transparent: '#0000'
  };

  // All the algorithms credit to https://stackoverflow.com/questions/36721830/convert-hsl-to-rgb-and-hex/54014428#54014428
  // original author: Kamil Kieczewski
  /**
   * @param h 360
   * @param s 100
   * @param l 100
   * @returns [h, s, v] 360, 100, 100
   */
  function hsl2hsv(h, s, l) {
      s /= 100;
      l /= 100;
      const v = s * Math.min(l, 1 - l) + l;
      return [h, v ? (2 - (2 * l) / v) * 100 : 0, v * 100];
  }
  /**
   * @param h 360
   * @param s 100
   * @param v 100
   * @returns [h, s, l] 360, 100, 100
   */
  function hsv2hsl(h, s, v) {
      s /= 100;
      v /= 100;
      const l = v - (v * s) / 2;
      const m = Math.min(l, 1 - l);
      return [h, m ? ((v - l) / m) * 100 : 0, l * 100];
  }
  /**
   * @param h 360
   * @param s 100
   * @param v 100
   * @returns [r, g, b] 255, 255, 255
   */
  function hsv2rgb(h, s, v) {
      s /= 100;
      v /= 100;
      let f = (n, k = (n + h / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
      return [f(5) * 255, f(3) * 255, f(1) * 255];
  }
  /**
   * @param r 255
   * @param g 255
   * @param b 255
   * @returns [360, 100, 100]
   */
  function rgb2hsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      let v = Math.max(r, g, b), c = v - Math.min(r, g, b);
      let h = c && (v == r ? (g - b) / c : v == g ? 2 + (b - r) / c : 4 + (r - g) / c);
      return [60 * (h < 0 ? h + 6 : h), v && (c / v) * 100, v * 100];
  }
  /**
   * @param r 255
   * @param g 255
   * @param b 255
   * @returns [360, 100, 100]
   */
  function rgb2hsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      let v = Math.max(r, g, b), c = v - Math.min(r, g, b), f = 1 - Math.abs(v + v - c - 1);
      let h = c && (v == r ? (g - b) / c : v == g ? 2 + (b - r) / c : 4 + (r - g) / c);
      return [60 * (h < 0 ? h + 6 : h), f ? (c / f) * 100 : 0, (v + v - c) * 50];
  }
  /**
   * @param h 360
   * @param s 100
   * @param l 100
   * @returns [255, 255, 255]
   */
  function hsl2rgb(h, s, l) {
      s /= 100;
      l /= 100;
      let a = s * Math.min(l, 1 - l);
      let f = (n, k = (n + h / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
      return [f(0) * 255, f(8) * 255, f(4) * 255];
  }

  const prefix$1 = '^\\s*';
  const suffix = '\\s*$';
  const percent = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*'; // 4 offset
  const float = '\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*'; // 4 offset
  const hex = '([0-9A-Fa-f])';
  const dhex = '([0-9A-Fa-f]{2})';
  const hslRegex = new RegExp(`${prefix$1}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hsvRegex = new RegExp(`${prefix$1}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
  const hslaRegex = new RegExp(`${prefix$1}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const hsvaRegex = new RegExp(`${prefix$1}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
  const rgbRegex = new RegExp(`${prefix$1}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
  const rgbaRegex = new RegExp(`${prefix$1}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
  const sHexRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${suffix}`);
  const hexRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${suffix}`);
  const sHexaRegex = new RegExp(`${prefix$1}#${hex}${hex}${hex}${hex}${suffix}`);
  const hexaRegex = new RegExp(`${prefix$1}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
  function parseHex(value) {
      return parseInt(value, 16);
  }
  /**
   * Convert color string to hsla array
   * @param color format like hsl(180, 100%, 100%), hsla(180, 100%, 100%, 1)
   * @returns
   */
  function hsla(color) {
      try {
          let i;
          if ((i = hslaRegex.exec(color))) {
              return [
                  roundDeg(i[1]),
                  roundPercent(i[5]),
                  roundPercent(i[9]),
                  roundAlpha(i[13])
              ];
          }
          else if ((i = hslRegex.exec(color))) {
              return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
      }
      catch (e) {
          throw e;
      }
  }
  /**
   * Convert color string to hsva array
   * @param color format like hsv(180, 100%, 100%), hsva(180, 100%, 100%, 1)
   * @returns
   */
  function hsva(color) {
      try {
          let i;
          if ((i = hsvaRegex.exec(color))) {
              return [
                  roundDeg(i[1]),
                  roundPercent(i[5]),
                  roundPercent(i[9]),
                  roundAlpha(i[13])
              ];
          }
          else if ((i = hsvRegex.exec(color))) {
              return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
      }
      catch (e) {
          throw e;
      }
  }
  /**
   * Convert color string to rgba array.
   * @param color format like #000[0], #000000[00], rgb(0, 0, 0), rgba(0, 0, 0, 0) and basic color keywords https://www.w3.org/TR/css-color-3/#html4 and transparent
   * @returns
   */
  function rgba(color) {
      try {
          let i;
          if ((i = hexRegex.exec(color))) {
              return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
          }
          else if ((i = rgbRegex.exec(color))) {
              return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
          }
          else if ((i = rgbaRegex.exec(color))) {
              return [
                  roundChannel(i[1]),
                  roundChannel(i[5]),
                  roundChannel(i[9]),
                  roundAlpha(i[13])
              ];
          }
          else if ((i = sHexRegex.exec(color))) {
              return [
                  parseHex(i[1] + i[1]),
                  parseHex(i[2] + i[2]),
                  parseHex(i[3] + i[3]),
                  1
              ];
          }
          else if ((i = hexaRegex.exec(color))) {
              return [
                  parseHex(i[1]),
                  parseHex(i[2]),
                  parseHex(i[3]),
                  roundAlpha(parseHex(i[4]) / 255)
              ];
          }
          else if ((i = sHexaRegex.exec(color))) {
              return [
                  parseHex(i[1] + i[1]),
                  parseHex(i[2] + i[2]),
                  parseHex(i[3] + i[3]),
                  roundAlpha(parseHex(i[4] + i[4]) / 255)
              ];
          }
          else if (color in colors) {
              return rgba(colors[color]);
          }
          throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
      }
      catch (e) {
          throw e;
      }
  }
  function normalizeAlpha$1(alphaValue) {
      return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
  }
  function stringifyRgb(r, g, b) {
      return `rgb(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)})`;
  }
  function stringifyRgba(r, g, b, a) {
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha$1(a)})`;
  }
  function compositeChannel(v1, a1, v2, a2, a) {
      return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
  }
  function composite(background, overlay) {
      if (!Array.isArray(background))
          background = rgba(background);
      if (!Array.isArray(overlay))
          overlay = rgba(overlay);
      const a1 = background[3];
      const a2 = overlay[3];
      const alpha = roundAlpha(a1 + a2 - a1 * a2);
      return stringifyRgba(compositeChannel(background[0], a1, overlay[0], a2, alpha), compositeChannel(background[1], a1, overlay[1], a2, alpha), compositeChannel(background[2], a1, overlay[2], a2, alpha), alpha);
  }
  function changeColor(base, options) {
      const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
      if (options.alpha) {
          return stringifyRgba(r, g, b, options.alpha);
      }
      return stringifyRgba(r, g, b, a);
  }
  function scaleColor(base, options) {
      const [r, g, b, a = 1] = Array.isArray(base) ? base : rgba(base);
      const { lightness = 1, alpha = 1 } = options;
      return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
  }
  function roundAlpha(value) {
      const v = Math.round(Number(value) * 100) / 100;
      if (v > 1)
          return 1;
      if (v < 0)
          return 0;
      return v;
  }
  function roundDeg(value) {
      const v = Math.round(Number(value));
      if (v >= 360)
          return 0;
      if (v < 0)
          return 0;
      return v;
  }
  function roundChannel(value) {
      const v = Math.round(Number(value));
      if (v > 255)
          return 255;
      if (v < 0)
          return 0;
      return v;
  }
  function roundPercent(value) {
      const v = Math.round(Number(value));
      if (v > 100)
          return 100;
      if (v < 0)
          return 0;
      return v;
  }
  function toRgbString(base) {
      const [r, g, b] = Array.isArray(base) ? base : rgba(base);
      return stringifyRgb(r, g, b);
  }
  function toRgbaString(base) {
      const [r, g, b] = base;
      if (3 in base) {
          return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base[3])})`;
      }
      return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
  }
  function toHsvString(base) {
      return `hsv(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
  }
  function toHsvaString(base) {
      const [h, s, v] = base;
      if (3 in base) {
          return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, ${roundAlpha(base[3])})`;
      }
      return `hsva(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(v)}%, 1)`;
  }
  function toHslString(base) {
      return `hsl(${roundDeg(base[0])}, ${roundPercent(base[1])}%, ${roundPercent(base[2])}%)`;
  }
  function toHslaString(base) {
      const [h, s, l] = base;
      if (3 in base) {
          return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, ${roundAlpha(base[3])})`;
      }
      return `hsla(${roundDeg(h)}, ${roundPercent(s)}%, ${roundPercent(l)}%, 1)`;
  }
  /**
   *
   * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
   * @returns
   */
  function toHexaString(base) {
      if (typeof base === 'string') {
          let i;
          if (i = hexRegex.exec(base)) {
              return `${i[0]}FF`;
          }
          else if (i = hexaRegex.exec(base)) {
              return i[0];
          }
          else if (i = sHexRegex.exec(base)) {
              return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}FF`;
          }
          else if (i = sHexaRegex.exec(base)) {
              return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}${i[4]}${i[4]}`;
          }
          throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
      }
      const hex = `#${base
        .slice(0, 3)
        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))
        .join('')}`;
      const a = base.length === 3
          ? 'FF'
          : roundChannel(base[3] * 255)
              .toString(16)
              .padStart(2, '0')
              .toUpperCase();
      return hex + a;
  }
  /**
   *
   * @param base [255, 255, 255, 255], [255, 255, 255], any hex string
   * @returns
   */
  function toHexString(base) {
      if (typeof base === 'string') {
          let i;
          if (i = hexRegex.exec(base)) {
              return i[0];
          }
          else if (i = hexaRegex.exec(base)) {
              return i[0].slice(0, 7);
          }
          else if (i = (sHexRegex.exec(base) || sHexaRegex.exec(base))) {
              return `#${i[1]}${i[1]}${i[2]}${i[2]}${i[3]}${i[3]}`;
          }
          throw new Error(`[seemly/toHexString]: Invalid hex value ${base}.`);
      }
      return `#${base
        .slice(0, 3)
        .map((unit) => roundChannel(unit).toString(16).toUpperCase().padStart(2, '0'))
        .join('')}`;
  }

  function createId(length = 8) {
      return Math.random()
          .toString(16)
          .slice(2, 2 + length);
  }
  function repeat(count, v) {
      const ret = [];
      for (let i = 0; i < count; ++i) {
          ret.push(v);
      }
      return ret;
  }
  function indexMap(count, createValue) {
      const ret = [];
      if (!createValue) {
          for (let i = 0; i < count; ++i) {
              ret.push(i);
          }
          return ret;
      }
      for (let i = 0; i < count; ++i) {
          ret.push(createValue(i));
      }
      return ret;
  }

  function getSlot$1(instance, slotName = 'default', fallback = []) {
      const slots = instance.$slots;
      const slot = slots[slotName];
      if (slot === undefined)
          return fallback;
      return slot();
  }

  function getVNodeChildren(vNode, slotName = 'default', fallback = []) {
      const { children } = vNode;
      if (children !== null &&
          typeof children === 'object' &&
          !Array.isArray(children)) {
          const slot = children[slotName];
          if (typeof slot === 'function') {
              return slot();
          }
      }
      return fallback;
  }

  function keep(object, keys = [], rest) {
      const keepedObject = {};
      keys.forEach((key) => {
          keepedObject[key] = object[key];
      });
      return Object.assign(keepedObject, rest);
  }

  function omit(object, keys = [], rest) {
      const omitedObject = {};
      const originalKeys = Object.getOwnPropertyNames(object);
      originalKeys.forEach((originalKey) => {
          if (!keys.includes(originalKey)) {
              omitedObject[originalKey] = object[originalKey];
          }
      });
      return Object.assign(omitedObject, rest);
  }

  // o(n) flatten
  function flatten$3(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
          if (vNode === null)
              return;
          if (typeof vNode !== 'object') {
              if (typeof vNode === 'string' || typeof vNode === 'number') {
                  result.push(createTextVNode(String(vNode)));
              }
              return;
          }
          if (Array.isArray(vNode)) {
              flatten$3(vNode, filterCommentNode, result);
              return;
          }
          if (vNode.type === Fragment) {
              if (vNode.children === null)
                  return;
              if (Array.isArray(vNode.children)) {
                  flatten$3(vNode.children, filterCommentNode, result);
              }
              // rawSlot
          }
          else if (vNode.type !== Comment) {
              result.push(vNode);
          }
      });
      return result;
  }

  function call(funcs, ...args) {
      if (Array.isArray(funcs)) {
          funcs.forEach((func) => call(func, ...args));
      }
      else
          return funcs(...args);
  }

  function keysOf(obj) {
      return Object.keys(obj);
  }

  const render$1 = (r, ...args) => {
      if (typeof r === 'function') {
          return r(...args);
      }
      else if (typeof r === 'string') {
          return createTextVNode(r);
      }
      else if (typeof r === 'number') {
          return createTextVNode(String(r));
      }
      else {
          return null;
      }
  };

  const warnedMessages = new Set();
  function warnOnce(location, message) {
      const mergedMessage = `[naive/${location}]: ${message}`;
      if (warnedMessages.has(mergedMessage))
          return;
      warnedMessages.add(mergedMessage);
      console.error(mergedMessage);
  }
  function warn$2(location, message) {
      console.error(`[naive/${location}]: ${message}`);
  }
  function throwError(location, message) {
      throw new Error(`[naive/${location}]: ${message}`);
  }

  function smallerSize(size) {
      switch (size) {
          case 'tiny':
              return 'mini';
          case 'small':
              return 'tiny';
          case 'medium':
              return 'small';
          case 'large':
              return 'medium';
          case 'huge':
              return 'large';
      }
      throw Error(`${size} has no smaller size.`);
  }

  function getTitleAttribute(value) {
      switch (typeof value) {
          case 'string':
              // The empty string should also be reset to undefined.
              return value || undefined;
          case 'number':
              return String(value);
          default:
              return undefined;
      }
  }

  function getFirstSlotVNode(slots, slotName = 'default', props = undefined) {
      const slot = slots[slotName];
      if (!slot) {
          warn$2('getFirstSlotVNode', `slot[${slotName}] is empty`);
          return null;
      }
      const slotContent = flatten$3(slot(props));
      // vue will normalize the slot, so slot must be an array
      if (slotContent.length === 1) {
          return slotContent[0];
      }
      else {
          warn$2('getFirstSlotVNode', `slot[${slotName}] should have exactly one child`);
          return null;
      }
  }

  function createDataKey(key) {
      return typeof key === 'string' ? `s-${key}` : `n-${key}`;
  }

  function createRefSetter(ref) {
      return (inst) => {
          if (inst) {
              ref.value = inst.$el;
          }
          else {
              ref.value = null;
          }
      };
  }

  function createInjectionKey(key) {
      return key;
  }

  function ensureValidVNode(vnodes) {
      return vnodes.some((child) => {
          if (!isVNode(child)) {
              return true;
          }
          if (child.type === Comment) {
              return false;
          }
          if (child.type === Fragment &&
              !ensureValidVNode(child.children)) {
              return false;
          }
          return true;
      })
          ? vnodes
          : null;
  }
  /**
   * We shouldn't use the following functions with slot flags `_: 1, 2, 3`
   */
  function resolveSlot(slot, fallback) {
      return (slot && ensureValidVNode(slot())) || fallback();
  }
  function resolveSlotWithProps(slot, props, fallback) {
      return (slot && ensureValidVNode(slot(props))) || fallback(props);
  }
  /**
   * Resolve slot with wrapper if content exists, no fallback
   */
  function resolveWrappedSlot(slot, wrapper) {
      const children = slot && ensureValidVNode(slot());
      return wrapper(children || null);
  }
  /*
   * Resolve slot with wrapper if content exists, no fallback
   */
  function resolveWrappedSlotWithProps(slot, props, wrapper) {
      const children = slot && ensureValidVNode(slot(props));
      return wrapper(children || null);
  }
  function isSlotEmpty(slot) {
      return !(slot && ensureValidVNode(slot()));
  }

  function mergeEventHandlers(handlers) {
      const filteredHandlers = handlers.filter((handler) => handler !== undefined);
      if (filteredHandlers.length === 0)
          return undefined;
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      if (filteredHandlers.length === 1)
          return filteredHandlers[0];
      return (e) => {
          handlers.forEach((handler) => {
              if (handler) {
                  handler(e);
              }
          });
      };
  }

  function isNodeVShowFalse(vNode) {
      var _a;
      const showDir = (_a = vNode.dirs) === null || _a === void 0 ? void 0 : _a.find(({ dir }) => dir === vShow);
      return !!(showDir && showDir.value === false);
  }

  const Wrapper = defineComponent({
      render() {
          var _a, _b;
          return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
      }
  });

  const pureNumberRegex = /^(\d|\.)+$/;
  const numberRegex = /(\d|\.)+/;
  function formatLength(length, { c = 1, offset = 0, attachPx = true } = {}) {
      if (typeof length === 'number') {
          const result = (length + offset) * c;
          if (result === 0)
              return '0';
          return `${result}px`;
      }
      else if (typeof length === 'string') {
          if (pureNumberRegex.test(length)) {
              const result = (Number(length) + offset) * c;
              if (attachPx) {
                  if (result === 0)
                      return '0';
                  return `${result}px`;
              }
              else {
                  return `${result}`;
              }
          }
          else {
              const result = numberRegex.exec(length);
              if (!result)
                  return length;
              return length.replace(numberRegex, String((Number(result[0]) + offset) * c));
          }
      }
      return length;
  }

  function color2Class(color) {
      return color.replace(/#|\(|\)|,|\s|\./g, '_');
  }

  function ampCount(selector) {
      let cnt = 0;
      for (let i = 0; i < selector.length; ++i) {
          if (selector[i] === '&')
              ++cnt;
      }
      return cnt;
  }
  /**
   * Don't just use ',' to separate css selector. For example:
   * x:(a, b) {} will be split into 'x:(a' and 'b)', which is not expected.
   * Make sure comma doesn't exist inside parentheses.
   */
  const separatorRegex = /\s*,(?![^(]*\))\s*/g;
  const extraSpaceRegex = /\s+/g;
  /**
   * selector must includes '&'
   * selector is trimmed
   * every part of amp is trimmed
   */
  function resolveSelectorWithAmp(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach(partialSelector => {
          let round = ampCount(partialSelector);
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          if (!round) {
              amp.forEach(partialAmp => {
                  nextAmp.push(
                  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                  (partialAmp && partialAmp + ' ') + partialSelector);
              });
              return;
          }
          else if (round === 1) {
              amp.forEach(partialAmp => {
                  nextAmp.push(partialSelector.replace('&', partialAmp));
              });
              return;
          }
          let partialNextAmp = [
              partialSelector
          ];
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          while (round--) {
              const nextPartialNextAmp = [];
              partialNextAmp.forEach(selectorItr => {
                  amp.forEach(partialAmp => {
                      nextPartialNextAmp.push(selectorItr.replace('&', partialAmp));
                  });
              });
              partialNextAmp = nextPartialNextAmp;
          }
          partialNextAmp.forEach(part => nextAmp.push(part));
      });
      return nextAmp;
  }
  /**
   * selector mustn't includes '&'
   * selector is trimmed
   */
  function resolveSelector(amp, selector) {
      const nextAmp = [];
      selector.split(separatorRegex).forEach(partialSelector => {
          amp.forEach(partialAmp => {
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              nextAmp.push(((partialAmp && partialAmp + ' ') + partialSelector));
          });
      });
      return nextAmp;
  }
  function parseSelectorPath(selectorPaths) {
      let amp = [''];
      selectorPaths.forEach(selector => {
          // eslint-disable-next-line
          selector = selector && selector.trim();
          if (
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          !selector) {
              /**
               * if it's a empty selector, do nothing
               */
              return;
          }
          // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
          if (selector.includes('&')) {
              amp = resolveSelectorWithAmp(amp, selector);
          }
          else {
              amp = resolveSelector(amp, selector);
          }
      });
      return amp.join(', ').replace(extraSpaceRegex, ' ');
  }

  function removeElement(el) {
      /* istanbul ignore if */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (!el)
          return;
      const parentElement = el.parentElement;
      /* istanbul ignore else */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (parentElement)
          parentElement.removeChild(el);
  }
  function queryElement(id) {
      return document.querySelector(`style[cssr-id="${id}"]`);
  }
  function createElement(id) {
      const el = document.createElement('style');
      el.setAttribute('cssr-id', id);
      return el;
  }
  function isMediaOrSupports(selector) {
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (!selector)
          return false;
      return /^\s*@(s|m)/.test(selector);
  }

  const kebabRegex = /[A-Z]/g;
  function kebabCase$2(pattern) {
      return pattern.replace(kebabRegex, match => '-' + match.toLowerCase());
  }
  /** TODO: refine it to solve nested object */
  function unwrapProperty(prop, indent = '  ') {
      if (typeof prop === 'object' && prop !== null) {
          return (' {\n' +
              Object.entries(prop).map(v => {
                  return indent + `  ${kebabCase$2(v[0])}: ${v[1]};`;
              }).join('\n') +
              '\n' + indent + '}');
      }
      return `: ${prop};`;
  }
  /** unwrap properties */
  function unwrapProperties(props, instance, params) {
      if (typeof props === 'function') {
          return props({
              context: instance.context,
              props: params
          });
      }
      return props;
  }
  function createStyle(selector, props, instance, params) {
      if (!props)
          return '';
      // eslint-disable-next-line
      const unwrappedProps = unwrapProperties(props, instance, params);
      if (!unwrappedProps)
          return '';
      if (typeof unwrappedProps === 'string') {
          return `${selector} {\n${unwrappedProps}\n}`;
      }
      const propertyNames = Object.keys(unwrappedProps);
      if (propertyNames.length === 0) {
          if (instance.config.keepEmptyBlock)
              return selector + ' {\n}';
          return '';
      }
      const statements = selector
          ? [
              selector + ' {'
          ]
          : [];
      propertyNames.forEach(propertyName => {
          const property = unwrappedProps[propertyName];
          if (propertyName === 'raw') {
              statements.push('\n' + property + '\n');
              return;
          }
          propertyName = kebabCase$2(propertyName);
          if (property !== null && property !== undefined) {
              statements.push(`  ${propertyName}${unwrapProperty(property)}`);
          }
      });
      if (selector) {
          statements.push('}');
      }
      return statements.join('\n');
  }
  function loopCNodeListWithCallback(children, options, callback) {
      /* istanbul ignore if */
      if (!children)
          return;
      children.forEach(child => {
          if (Array.isArray(child)) {
              loopCNodeListWithCallback(child, options, callback);
          }
          else if (typeof child === 'function') {
              const grandChildren = child(options);
              if (Array.isArray(grandChildren)) {
                  loopCNodeListWithCallback(grandChildren, options, callback);
              }
              else if (grandChildren) {
                  callback(grandChildren);
              }
          }
          else if (child) {
              callback(child);
          }
      });
  }
  function traverseCNode(node, selectorPaths, styles, instance, params, styleSheet) {
      const $ = node.$;
      let blockSelector = '';
      if (!$ || typeof $ === 'string') {
          if (isMediaOrSupports($)) {
              blockSelector = $;
          }
          else {
              // as a string selector
              selectorPaths.push($);
          }
      }
      else if (typeof $ === 'function') {
          const selector = $({
              context: instance.context,
              props: params
          });
          if (isMediaOrSupports(selector)) {
              blockSelector = selector;
          }
          else {
              // as a lazy selector
              selectorPaths.push(selector);
          }
      }
      else { // as a option selector
          if ($.before)
              $.before(instance.context);
          if (!$.$ || typeof $.$ === 'string') {
              if (isMediaOrSupports($.$)) {
                  blockSelector = $.$;
              }
              else {
                  // as a string selector
                  selectorPaths.push($.$);
              }
          }
          else /* istanbul ignore else */ if ($.$) {
              const selector = $.$({
                  context: instance.context,
                  props: params
              });
              if (isMediaOrSupports(selector)) {
                  blockSelector = selector;
              }
              else {
                  // as a lazy selector
                  selectorPaths.push(selector);
              }
          }
      }
      const selector = parseSelectorPath(selectorPaths);
      const style = createStyle(selector, node.props, instance, params);
      if (blockSelector) {
          styles.push(`${blockSelector} {`);
          if (styleSheet && style) {
              styleSheet.insertRule(`${blockSelector} {\n${style}\n}\n`);
          }
      }
      else {
          if (styleSheet && style) {
              styleSheet.insertRule(style);
          }
          if (!styleSheet && style.length)
              styles.push(style);
      }
      if (node.children) {
          loopCNodeListWithCallback(node.children, {
              context: instance.context,
              props: params
          }, childNode => {
              if (typeof childNode === 'string') {
                  const style = createStyle(selector, { raw: childNode }, instance, params);
                  if (styleSheet) {
                      styleSheet.insertRule(style);
                  }
                  else {
                      styles.push(style);
                  }
              }
              else {
                  traverseCNode(childNode, selectorPaths, styles, instance, params, styleSheet);
              }
          });
      }
      selectorPaths.pop();
      if (blockSelector) {
          styles.push('}');
      }
      if ($ && $.after)
          $.after(instance.context);
  }
  function render(node, instance, props, insertRule = false) {
      const styles = [];
      traverseCNode(node, [], styles, instance, props, insertRule
          ? node.instance.__styleSheet
          : undefined);
      if (insertRule)
          return '';
      return styles.join('\n\n');
  }

  /* eslint-disable */
  // Inspired by https://github.com/garycourt/murmurhash-js
  // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
  function murmur2(str) {
    // 'm' and 'r' are mixing constants generated offline.
    // They're not really 'magic', they just happen to work well.
    // const m = 0x5bd1e995;
    // const r = 24;
    // Initialize the hash
    var h = 0; // Mix 4 bytes at a time into the hash

    var k,
        i = 0,
        len = str.length;

    for (; len >= 4; ++i, len -= 4) {
      k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
      k =
      /* Math.imul(k, m): */
      (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
      k ^=
      /* k >>> r: */
      k >>> 24;
      h =
      /* Math.imul(k, m): */
      (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Handle the last few bytes of the input array


    switch (len) {
      case 3:
        h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

      case 2:
        h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

      case 1:
        h ^= str.charCodeAt(i) & 0xff;
        h =
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    } // Do a few final mixes of the hash to ensure the last few
    // bytes are well-incorporated.


    h ^= h >>> 13;
    h =
    /* Math.imul(h, m): */
    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
    return ((h ^ h >>> 15) >>> 0).toString(36);
  }

  /* eslint-disable @typescript-eslint/prefer-ts-expect-error */
  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  if (typeof window !== 'undefined') {
      window.__cssrContext = {};
  }
  function unmount(intance, node, id) {
      const { els } = node;
      // If id is undefined, unmount all styles
      if (id === undefined) {
          els.forEach(removeElement);
          node.els = [];
      }
      else {
          const target = queryElement(id);
          // eslint-disable-next-line
          if (target && els.includes(target)) {
              removeElement(target);
              node.els = els.filter((el) => el !== target);
          }
      }
  }
  function addElementToList(els, target) {
      els.push(target);
  }
  function mount(instance, node, id, props, head, silent, force, anchorMetaName, ssrAdapter
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  ) {
      if (silent && !ssrAdapter) {
          if (id === undefined) {
              // it is possible to use hash to get rid of the requirements of id
              // if you are interested in it, please create a pr
              // i have no time to impl it
              console.error('[css-render/mount]: `id` is required in `silent` mode.');
              return;
          }
          const cssrContext = window.__cssrContext;
          if (!cssrContext[id]) {
              cssrContext[id] = true;
              render(node, instance, props, silent);
          }
          return;
      }
      let style;
      if (id === undefined) {
          style = node.render(props);
          id = murmur2(style);
      }
      if (ssrAdapter) {
          ssrAdapter.adapter(id, style !== null && style !== void 0 ? style : node.render(props));
          return;
      }
      const queriedTarget = queryElement(id);
      if (queriedTarget !== null && !force) {
          return queriedTarget;
      }
      const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
      if (style === undefined)
          style = node.render(props);
      target.textContent = style;
      if (queriedTarget !== null)
          return queriedTarget;
      if (anchorMetaName) {
          const anchorMetaEl = document.head.querySelector(`meta[name="${anchorMetaName}"]`);
          if (anchorMetaEl) {
              document.head.insertBefore(target, anchorMetaEl);
              addElementToList(node.els, target);
              return target;
          }
      }
      if (head) {
          document.head.insertBefore(target, document.head.querySelector('style, link'));
      }
      else {
          document.head.appendChild(target);
      }
      addElementToList(node.els, target);
      return target;
  }

  function wrappedRender(props) {
      return render(this, this.instance, props);
  }
  // do not guard node calling, it should throw an error.
  function wrappedMount(options = {}
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  ) {
      const { id, ssr, props, head = false, silent = false, force = false, anchorMetaName } = options;
      const targetElement = mount(this.instance, this, id, props, head, silent, force, anchorMetaName, ssr);
      return targetElement;
  }
  function wrappedUnmount(options = {}) {
      /* istanbul ignore next */
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      const { id } = options;
      unmount(this.instance, this, id);
  }
  const createCNode = function (instance, $, props, children) {
      return {
          instance,
          $,
          props,
          children,
          els: [],
          render: wrappedRender,
          mount: wrappedMount,
          unmount: wrappedUnmount
      };
  };
  const c$2 = function (instance, $, props, children) {
      if (Array.isArray($)) {
          return createCNode(instance, { $: null }, null, $);
      }
      else if (Array.isArray(props)) {
          return createCNode(instance, $, null, props);
      }
      else if (Array.isArray(children)) {
          return createCNode(instance, $, props, children);
      }
      else {
          return createCNode(instance, $, props, null);
      }
  };

  function CssRender(config = {}) {
      let styleSheet = null;
      const cssr = {
          c: ((...args) => c$2(cssr, ...args)),
          use: (plugin, ...args) => plugin.install(cssr, ...args),
          find: queryElement,
          context: {},
          config,
          get __styleSheet() {
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              if (!styleSheet) {
                  const style = document.createElement('style');
                  document.head.appendChild(style);
                  styleSheet = document.styleSheets[document.styleSheets.length - 1];
                  return styleSheet;
              }
              return styleSheet;
          }
      };
      return cssr;
  }

  function exists(id, ssr) {
      if (id === undefined)
          return false;
      if (ssr) {
          const { context: { ids } } = ssr;
          return ids.has(id);
      }
      return queryElement(id) !== null;
  }

  /* eslint-disable @typescript-eslint/restrict-template-expressions */
  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  function plugin$1(options) {
      let _bPrefix = '.';
      let _ePrefix = '__';
      let _mPrefix = '--';
      let c;
      if (options) {
          let t = options.blockPrefix;
          if (t) {
              _bPrefix = t;
          }
          t = options.elementPrefix;
          if (t) {
              _ePrefix = t;
          }
          t = options.modifierPrefix;
          if (t) {
              _mPrefix = t;
          }
      }
      const _plugin = {
          install(instance) {
              c = instance.c;
              const ctx = instance.context;
              ctx.bem = {};
              ctx.bem.b = null;
              ctx.bem.els = null;
          }
      };
      function b(arg) {
          let memorizedB;
          let memorizedE;
          return {
              before(ctx) {
                  memorizedB = ctx.bem.b;
                  memorizedE = ctx.bem.els;
                  ctx.bem.els = null;
              },
              after(ctx) {
                  ctx.bem.b = memorizedB;
                  ctx.bem.els = memorizedE;
              },
              $({ context, props }) {
                  arg = typeof arg === 'string' ? arg : arg({ context, props });
                  context.bem.b = arg;
                  return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
              }
          };
      }
      function e(arg) {
          let memorizedE;
          return {
              before(ctx) {
                  memorizedE = ctx.bem.els;
              },
              after(ctx) {
                  ctx.bem.els = memorizedE;
              },
              $({ context, props }) {
                  arg = typeof arg === 'string' ? arg : arg({ context, props });
                  context.bem.els = arg.split(',').map(v => v.trim());
                  return context.bem.els
                      .map(el => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(', ');
              }
          };
      }
      function m(arg) {
          return {
              $({ context, props }) {
                  arg = typeof arg === 'string' ? arg : arg({ context, props });
                  const modifiers = arg.split(',').map(v => v.trim());
                  function elementToSelector(el) {
                      return modifiers.map(modifier => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== undefined ? `${_ePrefix}${el}` : ''}${_mPrefix}${modifier}`).join(', ');
                  }
                  const els = context.bem.els;
                  if (els !== null) {
                      return elementToSelector(els[0]);
                  }
                  else {
                      return elementToSelector();
                  }
              }
          };
      }
      function notM(arg) {
          return {
              $({ context, props }) {
                  arg = typeof arg === 'string' ? arg : arg({ context, props });
                  const els = context.bem.els;
                  return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${(els !== null && els.length > 0) ? `${_ePrefix}${els[0]}` : ''}${_mPrefix}${arg})`;
              }
          };
      }
      const cB = ((...args) => c(b(args[0]), args[1], args[2]));
      const cE = ((...args) => c(e(args[0]), args[1], args[2]));
      const cM = ((...args) => c(m(args[0]), args[1], args[2]));
      const cNotM = ((...args) => c(notM(args[0]), args[1], args[2]));
      Object.assign(_plugin, {
          cB, cE, cM, cNotM
      });
      return _plugin;
  }

  function createKey(prefix, suffix) {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      return (prefix +
          (suffix === 'default'
              ? ''
              : suffix.replace(/^[a-z]/, (startChar) => startChar.toUpperCase())));
  }
  createKey('abc', 'def');

  /* eslint-disable @typescript-eslint/restrict-template-expressions */
  const namespace = 'n';
  const prefix = `.${namespace}-`;
  const elementPrefix = '__';
  const modifierPrefix = '--';
  const cssr = CssRender();
  const plugin = plugin$1({
      blockPrefix: prefix,
      elementPrefix,
      modifierPrefix
  });
  cssr.use(plugin);
  const { c: c$1, find } = cssr;
  const { cB, cE, cM, cNotM } = plugin;
  function insideModal(style) {
      return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}modal, ${bPrefix || prefix}drawer`, [style]);
  }
  function insidePopover(style) {
      return c$1(({ props: { bPrefix } }) => `${bPrefix || prefix}popover`, [style]);
  }
  function asModal(style) {
      return c$1(({ props: { bPrefix } }) => `&${bPrefix || prefix}modal`, style);
  }
  // child block
  const cCB = ((...args) => {
      return c$1('>', [cB(...args)]);
  });

  let _isJsdom;
  function isJsdom() {
      if (_isJsdom === undefined) {
          _isJsdom =
              navigator.userAgent.includes('Node.js') ||
                  navigator.userAgent.includes('jsdom');
      }
      return _isJsdom;
  }

  const isBrowser$2 = typeof document !== 'undefined' && typeof window !== 'undefined';

  const eventSet = new WeakSet();
  function markEventEffectPerformed(event) {
      eventSet.add(event);
  }
  function eventEffectNotPerformed(event) {
      return !eventSet.has(event);
  }

  // injection.collection {
  //   key1: [insta, instb]
  //   key2: [instc]
  // }
  function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
      var _a;
      const injection = inject(injectionName, null);
      if (injection === null)
          return;
      const vm = (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
      watch(registerKeyRef, registerInstance);
      registerInstance(registerKeyRef.value);
      onBeforeUnmount(() => {
          registerInstance(undefined, registerKeyRef.value);
      });
      function registerInstance(key, oldKey) {
          if (!injection)
              return;
          const collection = injection[collectionKey];
          if (oldKey !== undefined)
              removeInstance(collection, oldKey);
          if (key !== undefined)
              addInstance(collection, key);
      }
      function removeInstance(collection, key) {
          if (!collection[key])
              collection[key] = [];
          collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
      }
      function addInstance(collection, key) {
          if (!collection[key])
              collection[key] = [];
          if (!~collection[key].findIndex((instance) => instance === vm)) {
              collection[key].push(vm);
          }
      }
  }
  // injection.collection {
  //   key1: [insta.value, instb.value]
  //   key2: [instc.value]
  // }
  function useInjectionCollection(injectionName, collectionKey, valueRef) {
      const injection = inject(injectionName, null);
      if (injection === null)
          return;
      if (!(collectionKey in injection)) {
          injection[collectionKey] = [];
      }
      injection[collectionKey].push(valueRef.value);
      watch(valueRef, (value, prevValue) => {
          const collectionArray = injection[collectionKey];
          const index = collectionArray.findIndex((collectionValue) => collectionValue === prevValue);
          if (~index)
              collectionArray.splice(index, 1);
          collectionArray.push(value);
      });
      onBeforeUnmount(() => {
          const collectionArray = injection[collectionKey];
          const index = collectionArray.findIndex((collectionValue) => collectionValue === valueRef.value);
          if (~index)
              collectionArray.splice(index, 1);
      });
  }
  // injection.collection {
  //   key1: [insta.$el, instb.$el]
  //   key2: [instc.$el]
  // }
  function useInjectionElementCollection(injectionName, collectionKey, getElement) {
      const injection = inject(injectionName, null);
      if (injection === null)
          return;
      if (!(collectionKey in injection)) {
          injection[collectionKey] = [];
      }
      onMounted(() => {
          const el = getElement();
          if (!el)
              return;
          injection[collectionKey].push(el);
      });
      onBeforeUnmount(() => {
          const collectionArray = injection[collectionKey];
          const element = getElement();
          const index = collectionArray.findIndex((collectionElement) => collectionElement === element);
          if (~index)
              collectionArray.splice(index, 1);
      });
  }

  function useDeferredTrue(valueRef, delay, shouldDelayRef) {
      if (!delay)
          return valueRef;
      const delayedRef = ref(valueRef.value);
      let timerId = null;
      watch(valueRef, (value) => {
          if (timerId !== null)
              window.clearTimeout(timerId);
          if (value === true) {
              if (shouldDelayRef && !shouldDelayRef.value) {
                  delayedRef.value = true;
              }
              else {
                  timerId = window.setTimeout(() => {
                      delayedRef.value = true;
                  }, delay);
              }
          }
          else {
              delayedRef.value = false;
          }
      });
      return delayedRef;
  }

  function useFalseUntilTruthy(originalRef) {
      const currentRef = ref(!!originalRef.value);
      if (currentRef.value)
          return readonly(currentRef);
      const stop = watch(originalRef, (value) => {
          if (value) {
              currentRef.value = true;
              stop();
          }
      });
      return readonly(currentRef);
  }

  function useMemo(getterOrOptions) {
      const computedValueRef = computed(getterOrOptions);
      // Maybe it's not possible to lazy evaluate the value, since we can't make
      // render phase capture the deps behind useMemo
      const valueRef = ref(computedValueRef.value);
      watch(computedValueRef, (value) => {
          valueRef.value = value;
      });
      if (typeof getterOrOptions === 'function') {
          return valueRef;
      }
      else {
          return {
              __v_isRef: true,
              get value() {
                  return valueRef.value;
              },
              set value(v) {
                  getterOrOptions.set(v);
              }
          };
      }
  }

  function hasInstance() {
      return getCurrentInstance() !== null;
  }
  const isBrowser$1 = typeof window !== 'undefined';

  let fontsReady;
  let isFontReady;
  const init = () => {
      var _a, _b;
      fontsReady = isBrowser$1 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : undefined;
      isFontReady = false;
      /* istanbul ignore if */
      if (fontsReady !== undefined) {
          void fontsReady.then(() => {
              isFontReady = true;
          });
      }
      else {
          isFontReady = true;
      }
  };
  init();
  /**
   * Call callback on fontsReady is resolved. If fontsReady is already resolved,
   * callback won't be called.
   */
  function onFontsReady(cb) {
      /* istanbul ignore next */
      if (isFontReady)
          return;
      let deactivated = false;
      onMounted(() => {
          /* istanbul ignore next */
          if (!isFontReady) {
              fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
                  if (deactivated)
                      return;
                  cb();
              });
          }
      });
      onBeforeUnmount(() => {
          deactivated = true;
      });
  }

  function getEventTarget(e) {
      const path = e.composedPath();
      return path[0];
  }

  const traps = {
      mousemoveoutside: new WeakMap(),
      clickoutside: new WeakMap()
  };
  function createTrapHandler(name, el, originalHandler) {
      if (name === 'mousemoveoutside') {
          const moveHandler = (e) => {
              if (el.contains(getEventTarget(e)))
                  return;
              originalHandler(e);
          };
          return {
              mousemove: moveHandler,
              touchstart: moveHandler
          };
      }
      else if (name === 'clickoutside') {
          let mouseDownOutside = false;
          const downHandler = (e) => {
              mouseDownOutside = !el.contains(getEventTarget(e));
          };
          const upHanlder = (e) => {
              if (!mouseDownOutside)
                  return;
              if (el.contains(getEventTarget(e)))
                  return;
              originalHandler(e);
          };
          return {
              mousedown: downHandler,
              mouseup: upHanlder,
              touchstart: downHandler,
              touchend: upHanlder
          };
      }
      console.error(
      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
      `[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`);
      return {};
  }
  function ensureTrapHandlers(name, el, handler) {
      const handlers = traps[name];
      let elHandlers = handlers.get(el);
      if (elHandlers === undefined) {
          handlers.set(el, (elHandlers = new WeakMap()));
      }
      let trapHandler = elHandlers.get(handler);
      if (trapHandler === undefined) {
          elHandlers.set(handler, (trapHandler = createTrapHandler(name, el, handler)));
      }
      return trapHandler;
  }
  function trapOn(name, el, handler, options) {
      if (name === 'mousemoveoutside' || name === 'clickoutside') {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
              on(key, document, trapHandlers[key], options);
          });
          return true;
      }
      return false;
  }
  function trapOff(name, el, handler, options) {
      if (name === 'mousemoveoutside' || name === 'clickoutside') {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
              off(key, document, trapHandlers[key], options);
          });
          return true;
      }
      return false;
  }

  // currently `once` and `passive` is not supported
  function createDelegate() {
      if (typeof window === 'undefined') {
          return {
              on: () => { },
              off: () => { }
          };
      }
      const propagationStopped = new WeakMap();
      const immediatePropagationStopped = new WeakMap();
      function trackPropagation() {
          propagationStopped.set(this, true);
      }
      function trackImmediate() {
          propagationStopped.set(this, true);
          immediatePropagationStopped.set(this, true);
      }
      function spy(event, propName, fn) {
          const source = event[propName];
          event[propName] = function () {
              fn.apply(event, arguments);
              return source.apply(event, arguments);
          };
          return event;
      }
      function unspy(event, propName) {
          event[propName] = Event.prototype[propName];
      }
      const currentTargets = new WeakMap();
      const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, 'currentTarget');
      function getCurrentTarget() {
          var _a;
          return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
      }
      function defineCurrentTarget(event, getter) {
          if (currentTargetDescriptor === undefined)
              return;
          Object.defineProperty(event, 'currentTarget', {
              configurable: true,
              enumerable: true,
              get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
          });
      }
      const phaseToTypeToElToHandlers = {
          bubble: {},
          capture: {}
      };
      const typeToWindowEventHandlers = {};
      function createUnifiedHandler() {
          const delegeteHandler = function (e) {
              const { type, eventPhase, bubbles } = e;
              const target = getEventTarget(e);
              if (eventPhase === 2)
                  return;
              const phase = eventPhase === 1 ? 'capture' : 'bubble';
              let cursor = target;
              const path = [];
              // collecting bubble path
              while (true) {
                  if (cursor === null)
                      cursor = window;
                  path.push(cursor);
                  if (cursor === window) {
                      break;
                  }
                  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
                  cursor = (cursor.parentNode || null);
              }
              const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
              const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
              spy(e, 'stopPropagation', trackPropagation);
              spy(e, 'stopImmediatePropagation', trackImmediate);
              defineCurrentTarget(e, getCurrentTarget);
              if (phase === 'capture') {
                  if (captureElToHandlers === undefined)
                      return;
                  // capture
                  for (let i = path.length - 1; i >= 0; --i) {
                      if (propagationStopped.has(e))
                          break;
                      const target = path[i];
                      const handlers = captureElToHandlers.get(target);
                      if (handlers !== undefined) {
                          currentTargets.set(e, target);
                          for (const handler of handlers) {
                              if (immediatePropagationStopped.has(e))
                                  break;
                              handler(e);
                          }
                      }
                      if (i === 0 && !bubbles && bubbleElToHandlers !== undefined) {
                          const bubbleHandlers = bubbleElToHandlers.get(target);
                          if (bubbleHandlers !== undefined) {
                              for (const handler of bubbleHandlers) {
                                  if (immediatePropagationStopped.has(e))
                                      break;
                                  handler(e);
                              }
                          }
                      }
                  }
              }
              else if (phase === 'bubble') {
                  if (bubbleElToHandlers === undefined)
                      return;
                  // bubble
                  for (let i = 0; i < path.length; ++i) {
                      if (propagationStopped.has(e))
                          break;
                      const target = path[i];
                      const handlers = bubbleElToHandlers.get(target);
                      if (handlers !== undefined) {
                          currentTargets.set(e, target);
                          for (const handler of handlers) {
                              if (immediatePropagationStopped.has(e))
                                  break;
                              handler(e);
                          }
                      }
                  }
              }
              unspy(e, 'stopPropagation');
              unspy(e, 'stopImmediatePropagation');
              defineCurrentTarget(e);
          };
          delegeteHandler.displayName = 'evtdUnifiedHandler';
          return delegeteHandler;
      }
      function createUnifiedWindowEventHandler() {
          const delegateHandler = function (e) {
              const { type, eventPhase } = e;
              if (eventPhase !== 2)
                  return;
              const handlers = typeToWindowEventHandlers[type];
              if (handlers === undefined)
                  return;
              handlers.forEach((handler) => handler(e));
          };
          delegateHandler.displayName = 'evtdUnifiedWindowEventHandler';
          return delegateHandler;
      }
      const unifiedHandler = createUnifiedHandler();
      const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
      function ensureElToHandlers(phase, type) {
          const phaseHandlers = phaseToTypeToElToHandlers[phase];
          if (phaseHandlers[type] === undefined) {
              phaseHandlers[type] = new Map();
              window.addEventListener(type, unifiedHandler, phase === 'capture');
          }
          return phaseHandlers[type];
      }
      function ensureWindowEventHandlers(type) {
          const windowEventHandlers = typeToWindowEventHandlers[type];
          if (windowEventHandlers === undefined) {
              typeToWindowEventHandlers[type] = new Set();
              window.addEventListener(type, unfiendWindowEventHandler);
          }
          return typeToWindowEventHandlers[type];
      }
      function ensureHandlers(elToHandlers, el) {
          let elHandlers = elToHandlers.get(el);
          if (elHandlers === undefined) {
              elToHandlers.set(el, (elHandlers = new Set()));
          }
          return elHandlers;
      }
      function handlerExist(el, phase, type, handler) {
          const elToHandlers = phaseToTypeToElToHandlers[phase][type];
          // phase ${type} event has handlers
          if (elToHandlers !== undefined) {
              const handlers = elToHandlers.get(el);
              // phase using el with ${type} event has handlers
              if (handlers !== undefined) {
                  if (handlers.has(handler))
                      return true;
              }
          }
          return false;
      }
      function windowEventHandlerExist(type, handler) {
          const handlers = typeToWindowEventHandlers[type];
          if (handlers !== undefined) {
              if (handlers.has(handler)) {
                  return true;
              }
          }
          return false;
      }
      function on(type, el, handler, options) {
          let mergedHandler;
          if (typeof options === 'object' && options.once === true) {
              mergedHandler = (e) => {
                  off(type, el, mergedHandler, options);
                  handler(e);
              };
          }
          else {
              mergedHandler = handler;
          }
          const trapped = trapOn(type, el, mergedHandler, options);
          if (trapped)
              return;
          const phase = options === true ||
              (typeof options === 'object' && options.capture === true)
              ? 'capture'
              : 'bubble';
          const elToHandlers = ensureElToHandlers(phase, type);
          const handlers = ensureHandlers(elToHandlers, el);
          if (!handlers.has(mergedHandler))
              handlers.add(mergedHandler);
          if (el === window) {
              const windowEventHandlers = ensureWindowEventHandlers(type);
              if (!windowEventHandlers.has(mergedHandler)) {
                  windowEventHandlers.add(mergedHandler);
              }
          }
      }
      function off(type, el, handler, options) {
          const trapped = trapOff(type, el, handler, options);
          if (trapped)
              return;
          const capture = options === true ||
              (typeof options === 'object' && options.capture === true);
          const phase = capture ? 'capture' : 'bubble';
          const elToHandlers = ensureElToHandlers(phase, type);
          const handlers = ensureHandlers(elToHandlers, el);
          if (el === window) {
              const mirrorPhase = capture ? 'bubble' : 'capture';
              if (!handlerExist(el, mirrorPhase, type, handler) &&
                  windowEventHandlerExist(type, handler)) {
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  const windowEventHandlers = typeToWindowEventHandlers[type];
                  windowEventHandlers.delete(handler);
                  if (windowEventHandlers.size === 0) {
                      window.removeEventListener(type, unfiendWindowEventHandler);
                      typeToWindowEventHandlers[type] = undefined;
                  }
              }
          }
          if (handlers.has(handler))
              handlers.delete(handler);
          if (handlers.size === 0) {
              elToHandlers.delete(el);
          }
          if (elToHandlers.size === 0) {
              window.removeEventListener(type, unifiedHandler, phase === 'capture');
              phaseToTypeToElToHandlers[phase][type] = undefined;
          }
      }
      return {
          on: on,
          off: off
      };
  }
  const { on, off } = createDelegate();

  const mousePositionRef = ref(null);
  function clickHandler(e) {
      if (e.clientX > 0 || e.clientY > 0) {
          mousePositionRef.value = {
              x: e.clientX,
              y: e.clientY
          };
      }
      else {
          // x = 0 & y = 0
          const { target } = e;
          if (target instanceof Element) {
              const { left, top, width, height } = target.getBoundingClientRect();
              if (left > 0 || top > 0) {
                  // impossible to be triggered by real click
                  mousePositionRef.value = {
                      x: left + width / 2,
                      y: top + height / 2
                  };
              }
              else {
                  mousePositionRef.value = { x: 0, y: 0 };
              }
          }
          else {
              mousePositionRef.value = null;
          }
      }
  }
  let usedCount$1 = 0;
  let managable$1 = true;
  function useClickPosition() {
      if (!isBrowser$1)
          return readonly(ref(null));
      if (usedCount$1 === 0)
          on('click', document, clickHandler, true);
      const setup = () => {
          usedCount$1 += 1;
      };
      if (managable$1 && (managable$1 = hasInstance())) {
          onBeforeMount(setup);
          onBeforeUnmount(() => {
              usedCount$1 -= 1;
              if (usedCount$1 === 0)
                  off('click', document, clickHandler, true);
          });
      }
      else {
          setup();
      }
      return readonly(mousePositionRef);
  }

  const clickedTimeRef = ref(undefined);
  let usedCount = 0;
  function handleClick() {
      clickedTimeRef.value = Date.now();
  }
  let managable = true;
  function useClicked(timeout) {
      if (!isBrowser$1)
          return readonly(ref(false));
      const clickedRef = ref(false);
      let timerId = null;
      function clearTimer() {
          if (timerId !== null)
              window.clearTimeout(timerId);
      }
      function clickedHandler() {
          clearTimer();
          clickedRef.value = true;
          timerId = window.setTimeout(() => {
              clickedRef.value = false;
          }, timeout);
      }
      if (usedCount === 0) {
          on('click', window, handleClick, true);
      }
      const setup = () => {
          usedCount += 1;
          on('click', window, clickedHandler, true);
      };
      if (managable && (managable = hasInstance())) {
          onBeforeMount(setup);
          onBeforeUnmount(() => {
              usedCount -= 1;
              if (usedCount === 0) {
                  off('click', window, handleClick, true);
              }
              off('click', window, clickedHandler, true);
              clearTimer();
          });
      }
      else {
          setup();
      }
      return readonly(clickedRef);
  }

  function useMergedState(controlledStateRef, uncontrolledStateRef) {
      watch(controlledStateRef, value => {
          if (value !== undefined) {
              uncontrolledStateRef.value = value;
          }
      });
      return computed(() => {
          if (controlledStateRef.value === undefined) {
              return uncontrolledStateRef.value;
          }
          return controlledStateRef.value;
      });
  }

  function isMounted() {
      const isMounted = ref(false);
      onMounted(() => { isMounted.value = true; });
      return readonly(isMounted);
  }

  function useCompitable(reactive, keys) {
      // @ts-expect-error
      return computed(() => {
          for (const key of keys) {
              if (reactive[key] !== undefined)
                  return reactive[key];
          }
          return reactive[keys[keys.length - 1]];
      });
  }

  const isIos = (typeof window === 'undefined'
      ? false
      : /iPad|iPhone|iPod/.test(navigator.platform) ||
          (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)) &&
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      !window.MSStream;
  function useIsIos() {
      return isIos;
  }

  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  const defaultBreakpointOptions = {
      // mobile
      // 0 ~ 640 doesn't mean it should display well in all the range,
      // but means you should treat it like a mobile phone.)
      xs: 0,
      s: 640,
      m: 1024,
      l: 1280,
      xl: 1536,
      '2xl': 1920 // normal desktop display
  };
  function createMediaQuery(screenWidth) {
      return `(min-width: ${screenWidth}px)`;
  }
  const mqlMap = {};
  function useBreakpoints(screens = defaultBreakpointOptions) {
      if (!isBrowser$1)
          return computed(() => []);
      // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
      if (typeof window.matchMedia !== 'function')
          return computed(() => []);
      const breakpointStatusRef = ref({});
      const breakpoints = Object.keys(screens);
      const updateBreakpoints = (e, breakpointName) => {
          if (e.matches)
              breakpointStatusRef.value[breakpointName] = true;
          else
              breakpointStatusRef.value[breakpointName] = false;
      };
      breakpoints.forEach((key) => {
          const breakpointValue = screens[key];
          let mql;
          let cbs;
          if (mqlMap[breakpointValue] === undefined) {
              mql = window.matchMedia(createMediaQuery(breakpointValue));
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              if (mql.addEventListener) {
                  mql.addEventListener('change', (e) => {
                      cbs.forEach((cb) => {
                          cb(e, key);
                      });
                  });
                  // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              }
              else if (mql.addListener) {
                  mql.addListener((e) => {
                      cbs.forEach((cb) => {
                          cb(e, key);
                      });
                  });
              }
              cbs = new Set();
              mqlMap[breakpointValue] = {
                  mql,
                  cbs
              };
          }
          else {
              mql = mqlMap[breakpointValue].mql;
              cbs = mqlMap[breakpointValue].cbs;
          }
          cbs.add(updateBreakpoints);
          if (mql.matches) {
              cbs.forEach((cb) => {
                  cb(mql, key);
              });
          }
      });
      onBeforeUnmount(() => {
          breakpoints.forEach((breakpoint) => {
              const { cbs } = mqlMap[screens[breakpoint]];
              if (cbs.has(updateBreakpoints)) {
                  cbs.delete(updateBreakpoints);
              }
          });
      });
      return computed(() => {
          const { value } = breakpointStatusRef;
          return breakpoints.filter((key) => value[key]);
      });
  }

  function useKeyboard$1(options = {}, enabledRef) {
      const state = reactive({
          ctrl: false,
          command: false,
          win: false,
          shift: false,
          tab: false
      });
      const { keydown, keyup } = options;
      const keydownHandler = (e) => {
          switch (e.key) {
              case 'Control':
                  state.ctrl = true;
                  break;
              case 'Meta':
                  state.command = true;
                  state.win = true;
                  break;
              case 'Shift':
                  state.shift = true;
                  break;
              case 'Tab':
                  state.tab = true;
                  break;
          }
          if (keydown !== undefined) {
              Object.keys(keydown).forEach(key => {
                  if (key !== e.key)
                      return;
                  const handler = keydown[key];
                  if (typeof handler === 'function') {
                      handler(e);
                  }
                  else {
                      const { stop = false, prevent = false } = handler;
                      if (stop)
                          e.stopPropagation();
                      if (prevent)
                          e.preventDefault();
                      handler.handler(e);
                  }
              });
          }
      };
      const keyupHandler = (e) => {
          switch (e.key) {
              case 'Control':
                  state.ctrl = false;
                  break;
              case 'Meta':
                  state.command = false;
                  state.win = false;
                  break;
              case 'Shift':
                  state.shift = false;
                  break;
              case 'Tab':
                  state.tab = false;
                  break;
          }
          if (keyup !== undefined) {
              Object.keys(keyup).forEach(key => {
                  if (key !== e.key)
                      return;
                  const handler = keyup[key];
                  if (typeof handler === 'function') {
                      handler(e);
                  }
                  else {
                      const { stop = false, prevent = false } = handler;
                      if (stop)
                          e.stopPropagation();
                      if (prevent)
                          e.preventDefault();
                      handler.handler(e);
                  }
              });
          }
      };
      const setup = () => {
          if (enabledRef === undefined || enabledRef.value) {
              on('keydown', document, keydownHandler);
              on('keyup', document, keyupHandler);
          }
          if (enabledRef !== undefined) {
              watch(enabledRef, value => {
                  if (value) {
                      on('keydown', document, keydownHandler);
                      on('keyup', document, keyupHandler);
                  }
                  else {
                      off('keydown', document, keydownHandler);
                      off('keyup', document, keyupHandler);
                  }
              });
          }
      };
      if (hasInstance()) {
          onBeforeMount(setup);
          onBeforeUnmount(() => {
              if (enabledRef === undefined || enabledRef.value) {
                  off('keydown', document, keydownHandler);
                  off('keyup', document, keyupHandler);
              }
          });
      }
      else {
          setup();
      }
      return readonly(state);
  }

  const internalSelectionMenuInjectionKey = createInjectionKey('n-internal-select-menu');
  const internalSelectionMenuBodyInjectionKey = createInjectionKey('n-internal-select-menu-body');

  const modalBodyInjectionKey = createInjectionKey('n-modal-body');
  const modalInjectionKey = createInjectionKey('n-modal');

  const drawerBodyInjectionKey = createInjectionKey('n-drawer-body');
  const drawerInjectionKey = createInjectionKey('n-drawer');

  const popoverBodyInjectionKey = createInjectionKey('n-popover-body');

  const teleportDisabled = '__disabled__';
  function useAdjustedTo(props) {
      const modal = inject(modalBodyInjectionKey, null);
      const drawer = inject(drawerBodyInjectionKey, null);
      const popover = inject(popoverBodyInjectionKey, null);
      const selectMenu = inject(internalSelectionMenuBodyInjectionKey, null);
      const fullscreenElementRef = ref();
      if (typeof document !== 'undefined') {
          fullscreenElementRef.value = document.fullscreenElement;
          const handleFullscreenChange = () => {
              fullscreenElementRef.value = document.fullscreenElement;
          };
          onMounted(() => {
              on('fullscreenchange', document, handleFullscreenChange);
          });
          onBeforeUnmount(() => {
              off('fullscreenchange', document, handleFullscreenChange);
          });
      }
      return useMemo(() => {
          var _a;
          const { to } = props;
          if (to !== undefined) {
              if (to === false)
                  return teleportDisabled;
              if (to === true)
                  return fullscreenElementRef.value || 'body';
              return to;
          }
          if (modal === null || modal === void 0 ? void 0 : modal.value) {
              return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
          }
          if (drawer === null || drawer === void 0 ? void 0 : drawer.value)
              return drawer.value;
          if (popover === null || popover === void 0 ? void 0 : popover.value)
              return popover.value;
          if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value)
              return selectMenu.value;
          return to !== null && to !== void 0 ? to : (fullscreenElementRef.value || 'body');
      });
  }
  // teleport disabled key
  useAdjustedTo.tdkey = teleportDisabled;
  useAdjustedTo.propTo = {
      type: [String, Object, Boolean],
      default: undefined
  };

  let houdiniRegistered = false;
  function useHoudini() {
      if (!isBrowser$2)
          return;
      if (!window.CSS)
          return;
      if (!houdiniRegistered) {
          houdiniRegistered = true;
          if ('registerProperty' in (window === null || window === void 0 ? void 0 : window.CSS)) {
              try {
                  ;
                  CSS.registerProperty({
                      name: '--n-color-start',
                      syntax: '<color>',
                      inherits: false,
                      initialValue: '#0000'
                  });
                  CSS.registerProperty({
                      name: '--n-color-end',
                      syntax: '<color>',
                      inherits: false,
                      initialValue: '#0000'
                  });
              }
              catch (e) { }
          }
      }
  }

  function getSlot(scope, slots, slotName = 'default') {
      const slot = slots[slotName];
      if (slot === undefined) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      return slot();
  }
  // o(n) flatten
  function flatten$2(vNodes, filterCommentNode = true, result = []) {
      vNodes.forEach((vNode) => {
          if (vNode === null)
              return;
          if (typeof vNode !== 'object') {
              if (typeof vNode === 'string' || typeof vNode === 'number') {
                  result.push(createTextVNode(String(vNode)));
              }
              return;
          }
          if (Array.isArray(vNode)) {
              flatten$2(vNode, filterCommentNode, result);
              return;
          }
          if (vNode.type === Fragment) {
              if (vNode.children === null)
                  return;
              if (Array.isArray(vNode.children)) {
                  flatten$2(vNode.children, filterCommentNode, result);
              }
              // rawSlot
          }
          else if (vNode.type !== Comment) {
              result.push(vNode);
          }
      });
      return result;
  }
  function getFirstVNode(scope, slots, slotName = 'default') {
      const slot = slots[slotName];
      if (slot === undefined) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
      }
      const content = flatten$2(slot());
      // vue will normalize the slot, so slot must be an array
      if (content.length === 1) {
          return content[0];
      }
      else {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
      }
  }

  let viewMeasurer = null;
  function ensureViewBoundingRect() {
      if (viewMeasurer === null) {
          viewMeasurer = document.getElementById('v-binder-view-measurer');
          if (viewMeasurer === null) {
              viewMeasurer = document.createElement('div');
              viewMeasurer.id = 'v-binder-view-measurer';
              const { style } = viewMeasurer;
              style.position = 'fixed';
              style.left = '0';
              style.right = '0';
              style.top = '0';
              style.bottom = '0';
              style.pointerEvents = 'none';
              style.visibility = 'hidden';
              document.body.appendChild(viewMeasurer);
          }
      }
      return viewMeasurer.getBoundingClientRect();
  }
  function getPointRect(x, y) {
      const viewRect = ensureViewBoundingRect();
      return {
          top: y,
          left: x,
          height: 0,
          width: 0,
          right: viewRect.width - x,
          bottom: viewRect.height - y
      };
  }
  function getRect$1(el) {
      const elRect = el.getBoundingClientRect();
      const viewRect = ensureViewBoundingRect();
      return {
          left: elRect.left - viewRect.left,
          top: elRect.top - viewRect.top,
          bottom: viewRect.height + viewRect.top - elRect.bottom,
          right: viewRect.width + viewRect.left - elRect.right,
          width: elRect.width,
          height: elRect.height
      };
  }
  function getParentNode(node) {
      // document type
      if (node.nodeType === 9) {
          return null;
      }
      return node.parentNode;
  }
  function getScrollParent(node) {
      if (node === null)
          return null;
      const parentNode = getParentNode(node);
      if (parentNode === null) {
          return null;
      }
      // Document
      if (parentNode.nodeType === 9) {
          return document;
      }
      // Element
      if (parentNode.nodeType === 1) {
          // Firefox want us to check `-x` and `-y` variations as well
          const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
          if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
              return parentNode;
          }
      }
      return getScrollParent(parentNode);
  }

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const Binder = defineComponent({
      name: 'Binder',
      props: {
          syncTargetWithParent: Boolean,
          syncTarget: {
              type: Boolean,
              default: true
          }
      },
      setup(props) {
          var _a;
          provide('VBinder', (_a = getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
          const VBinder = inject('VBinder', null);
          const targetRef = ref(null);
          /**
           * If there's no nested vbinder, we can simply set the target ref.
           *
           * However, when it comes to:
           * <VBinder> <- syncTarget = false
           *
           *              Should hold target DOM ref, but can't get it directly from
           *              its VTarget. So if there are nested VBinder, we should:
           *              1. Stop setting target DOM from level-1 VTarget
           *              2. Set target DOM from level-2 VTarget
           *              For (1), we need `syncTarget` to `false`
           *              For (2), we need to set `syncTargetWithParent` to `true` on
           *              level-2 VBinder
           *   <VTarget>
           *     <VBinder> <- syncTargetWithParent = true
           *       <VTarget>target</VTarget>
           *     </VBinder>
           *     <VFollower>
           *       content1
           *     </VFollower>
           *   </VTarget>
           *   <VFollower>
           *     content2
           *   </VFollower>
           * </VBinder>
           */
          const setTargetRef = (el) => {
              targetRef.value = el;
              // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions
              if (VBinder && props.syncTargetWithParent) {
                  VBinder.setTargetRef(el);
              }
          };
          // scroll related
          let scrollableNodes = [];
          const ensureScrollListener = () => {
              let cursor = targetRef.value;
              while (true) {
                  cursor = getScrollParent(cursor);
                  if (cursor === null)
                      break;
                  scrollableNodes.push(cursor);
              }
              for (const el of scrollableNodes) {
                  on('scroll', el, onScroll, true);
              }
          };
          const removeScrollListeners = () => {
              for (const el of scrollableNodes) {
                  off('scroll', el, onScroll, true);
              }
              scrollableNodes = [];
          };
          const followerScrollListeners = new Set();
          const addScrollListener = (listener) => {
              if (followerScrollListeners.size === 0) {
                  ensureScrollListener();
              }
              if (!followerScrollListeners.has(listener)) {
                  followerScrollListeners.add(listener);
              }
          };
          const removeScrollListener = (listener) => {
              if (followerScrollListeners.has(listener)) {
                  followerScrollListeners.delete(listener);
              }
              if (followerScrollListeners.size === 0) {
                  removeScrollListeners();
              }
          };
          const onScroll = () => {
              beforeNextFrameOnce(onScrollRaf);
          };
          const onScrollRaf = () => {
              followerScrollListeners.forEach((listener) => listener());
          };
          // resize related
          const followerResizeListeners = new Set();
          const addResizeListener = (listener) => {
              if (followerResizeListeners.size === 0) {
                  on('resize', window, onResize);
              }
              if (!followerResizeListeners.has(listener)) {
                  followerResizeListeners.add(listener);
              }
          };
          const removeResizeListener = (listener) => {
              if (followerResizeListeners.has(listener)) {
                  followerResizeListeners.delete(listener);
              }
              if (followerResizeListeners.size === 0) {
                  off('resize', window, onResize);
              }
          };
          const onResize = () => {
              followerResizeListeners.forEach((listener) => listener());
          };
          onBeforeUnmount(() => {
              off('resize', window, onResize);
              removeScrollListeners();
          });
          return {
              targetRef,
              setTargetRef,
              addScrollListener,
              removeScrollListener,
              addResizeListener,
              removeResizeListener
          };
      },
      render() {
          return getSlot('binder', this.$slots);
      }
  });
  var VBinder = Binder;

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  var VTarget = defineComponent({
      name: 'Target',
      setup() {
          const { setTargetRef, syncTarget } = inject('VBinder');
          const setTargetDirective = {
              mounted: setTargetRef,
              updated: setTargetRef
          };
          return {
              syncTarget,
              setTargetDirective
          };
      },
      render() {
          const { syncTarget, setTargetDirective } = this;
          /**
           * If you are using VBinder as a child of VBinder, the children wouldn't be
           * a valid DOM or component that can be attached to by directive.
           * So we won't sync target on those kind of situation and control the
           * target sync logic manually.
           */
          if (syncTarget) {
              return withDirectives(getFirstVNode('follower', this.$slots), [
                  [setTargetDirective]
              ]);
          }
          return getFirstVNode('follower', this.$slots);
      }
  });

  const ctxKey$1 = '@@mmoContext';
  const mousemoveoutside = {
      mounted(el, { value }) {
          el[ctxKey$1] = {
              handler: undefined
          };
          if (typeof value === 'function') {
              el[ctxKey$1].handler = value;
              on('mousemoveoutside', el, value);
          }
      },
      updated(el, { value }) {
          const ctx = el[ctxKey$1];
          if (typeof value === 'function') {
              if (ctx.handler) {
                  if (ctx.handler !== value) {
                      off('mousemoveoutside', el, ctx.handler);
                      ctx.handler = value;
                      on('mousemoveoutside', el, value);
                  }
              }
              else {
                  el[ctxKey$1].handler = value;
                  on('mousemoveoutside', el, value);
              }
          }
          else {
              if (ctx.handler) {
                  off('mousemoveoutside', el, ctx.handler);
                  ctx.handler = undefined;
              }
          }
      },
      unmounted(el) {
          const { handler } = el[ctxKey$1];
          if (handler) {
              off('mousemoveoutside', el, handler);
          }
          el[ctxKey$1].handler = undefined;
      }
  };
  var mousemoveoutside$1 = mousemoveoutside;

  const ctxKey = '@@coContext';
  const clickoutside = {
      mounted(el, { value, modifiers }) {
          el[ctxKey] = {
              handler: undefined
          };
          if (typeof value === 'function') {
              el[ctxKey].handler = value;
              on('clickoutside', el, value, {
                  capture: modifiers.capture
              });
          }
      },
      updated(el, { value, modifiers }) {
          const ctx = el[ctxKey];
          if (typeof value === 'function') {
              if (ctx.handler) {
                  if (ctx.handler !== value) {
                      off('clickoutside', el, ctx.handler, {
                          capture: modifiers.capture
                      });
                      ctx.handler = value;
                      on('clickoutside', el, value, {
                          capture: modifiers.capture
                      });
                  }
              }
              else {
                  el[ctxKey].handler = value;
                  on('clickoutside', el, value, {
                      capture: modifiers.capture
                  });
              }
          }
          else {
              if (ctx.handler) {
                  off('clickoutside', el, ctx.handler, {
                      capture: modifiers.capture
                  });
                  ctx.handler = undefined;
              }
          }
      },
      unmounted(el, { modifiers }) {
          const { handler } = el[ctxKey];
          if (handler) {
              off('clickoutside', el, handler, {
                  capture: modifiers.capture
              });
          }
          el[ctxKey].handler = undefined;
      }
  };
  var clickoutside$1 = clickoutside;

  function warn$1(location, message) {
      console.error(`[vdirs/${location}]: ${message}`);
  }

  class ZIndexManager {
      constructor() {
          this.elementZIndex = new Map();
          this.nextZIndex = 2000;
      }
      get elementCount() {
          return this.elementZIndex.size;
      }
      ensureZIndex(el, zIndex) {
          const { elementZIndex } = this;
          if (zIndex !== undefined) {
              el.style.zIndex = `${zIndex}`;
              elementZIndex.delete(el);
              return;
          }
          const { nextZIndex } = this;
          if (elementZIndex.has(el)) {
              const currentZIndex = elementZIndex.get(el);
              if (currentZIndex + 1 === this.nextZIndex)
                  return;
          }
          el.style.zIndex = `${nextZIndex}`;
          elementZIndex.set(el, nextZIndex);
          this.nextZIndex = nextZIndex + 1;
          this.squashState();
      }
      unregister(el, zIndex) {
          const { elementZIndex } = this;
          if (elementZIndex.has(el)) {
              elementZIndex.delete(el);
          }
          else if (zIndex === undefined) {
              warn$1('z-index-manager/unregister-element', 'Element not found when unregistering.');
          }
          this.squashState();
      }
      squashState() {
          const { elementCount } = this;
          if (!elementCount) {
              this.nextZIndex = 2000;
          }
          if (this.nextZIndex - elementCount > 2500)
              this.rearrange();
      }
      rearrange() {
          const elementZIndexPair = Array.from(this.elementZIndex.entries());
          elementZIndexPair.sort((pair1, pair2) => {
              return pair1[1] - pair2[1];
          });
          this.nextZIndex = 2000;
          elementZIndexPair.forEach((pair) => {
              const el = pair[0];
              const zIndex = this.nextZIndex++;
              if (`${zIndex}` !== el.style.zIndex)
                  el.style.zIndex = `${zIndex}`;
          });
      }
  }
  var zIndexManager = new ZIndexManager();

  const ctx = '@@ziContext';
  // We don't expect manually bound zindex should be changed
  const zindexable = {
      mounted(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          el[ctx] = {
              enabled: !!enabled,
              initialized: false
          };
          if (enabled) {
              zIndexManager.ensureZIndex(el, zIndex);
              el[ctx].initialized = true;
          }
      },
      updated(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          const cachedEnabled = el[ctx].enabled;
          if (enabled && !cachedEnabled) {
              zIndexManager.ensureZIndex(el, zIndex);
              el[ctx].initialized = true;
          }
          el[ctx].enabled = !!enabled;
      },
      unmounted(el, bindings) {
          if (!el[ctx].initialized)
              return;
          const { value = {} } = bindings;
          const { zIndex } = value;
          zIndexManager.unregister(el, zIndex);
      }
  };
  var zindexable$1 = zindexable;

  const ssrContextKey = Symbol('@css-render/vue3-ssr');
  function createStyleString(id, style) {
      return `<style cssr-id="${id}">\n${style}\n</style>`;
  }
  function ssrAdapter(id, style) {
      const ssrContext = inject(ssrContextKey, null);
      if (ssrContext === null) {
          console.error('[css-render/vue3-ssr]: no ssr context found.');
          return;
      }
      const { styles, ids } = ssrContext;
      // we need to impl other options to make it behaves the same as the client side
      if (ids.has(id))
          return;
      if (styles !== null) {
          ids.add(id);
          styles.push(createStyleString(id, style));
      }
  }
  const isBrowser = typeof document !== 'undefined';
  function useSsrAdapter() {
      if (isBrowser)
          return undefined;
      const context = inject(ssrContextKey, null);
      if (context === null)
          return undefined;
      return {
          adapter: ssrAdapter,
          context
      };
  }

  function warn(location, message) {
      console.error(`[vueuc/${location}]: ${message}`);
  }

  const { c } = CssRender();
  const cssrAnchorMetaName$1 = 'vueuc-style';

  function lowBit(n) {
      return n & -n;
  }
  class FinweckTree {
      /**
       * @param l length of the array
       * @param min min value of the array
       */
      constructor(l, min) {
          this.l = l;
          this.min = min;
          const ft = new Array(l + 1);
          for (let i = 0; i < l + 1; ++i) {
              ft[i] = 0;
          }
          this.ft = ft;
      }
      /**
       * Add arr[i] by n, start from 0
       * @param i the index of the element to be added
       * @param n the value to be added
       */
      add(i, n) {
          if (n === 0)
              return;
          const { l, ft } = this;
          i += 1;
          while (i <= l) {
              ft[i] += n;
              i += lowBit(i);
          }
      }
      /**
       * Get the value of index i
       * @param i index
       * @returns value of the index
       */
      get(i) {
          return this.sum(i + 1) - this.sum(i);
      }
      /**
       * Get the sum of first i elements
       * @param i count of head elements to be added
       * @returns the sum of first i elements
       */
      sum(i) {
          if (i === undefined)
              i = this.l;
          if (i <= 0)
              return 0;
          const { ft, min, l } = this;
          if (i > l)
              throw new Error('[FinweckTree.sum]: `i` is larger than length.');
          let ret = i * min;
          while (i > 0) {
              ret += ft[i];
              i -= lowBit(i);
          }
          return ret;
      }
      /**
       * Get the largest count of head elements whose sum are <= threshold
       * @param threshold
       * @returns the largest count of head elements whose sum are <= threshold
       */
      getBound(threshold) {
          let l = 0;
          let r = this.l;
          while (r > l) {
              const m = Math.floor((l + r) / 2);
              const sumM = this.sum(m);
              if (sumM > threshold) {
                  r = m;
                  continue;
              }
              else if (sumM < threshold) {
                  if (l === m) {
                      if (this.sum(l + 1) <= threshold)
                          return l + 1;
                      return m;
                  }
                  l = m;
              }
              else {
                  return m;
              }
          }
          return l;
      }
  }

  function resolveTo(selector) {
      if (typeof selector === 'string') {
          return document.querySelector(selector);
      }
      return selector();
  }

  var LazyTeleport = defineComponent({
      name: 'LazyTeleport',
      props: {
          to: {
              type: [String, Object],
              default: undefined
          },
          disabled: Boolean,
          show: {
              type: Boolean,
              required: true
          }
      },
      setup(props) {
          return {
              showTeleport: useFalseUntilTruthy(toRef(props, 'show')),
              mergedTo: computed(() => {
                  const { to } = props;
                  return to !== null && to !== void 0 ? to : 'body';
              })
          };
      },
      render() {
          return this.showTeleport
              ? this.disabled
                  ? getSlot('lazy-teleport', this.$slots)
                  : h(Teleport, {
                      disabled: this.disabled,
                      to: this.mergedTo
                  }, getSlot('lazy-teleport', this.$slots))
              : null;
      }
  });

  const oppositionPositions = {
      top: 'bottom',
      bottom: 'top',
      left: 'right',
      right: 'left'
  };
  const oppositeAligns = {
      start: 'end',
      center: 'center',
      end: 'start'
  };
  const propToCompare = {
      top: 'height',
      bottom: 'height',
      left: 'width',
      right: 'width'
  };
  const transformOrigins = {
      'bottom-start': 'top left',
      bottom: 'top center',
      'bottom-end': 'top right',
      'top-start': 'bottom left',
      top: 'bottom center',
      'top-end': 'bottom right',
      'right-start': 'top left',
      right: 'center left',
      'right-end': 'bottom left',
      'left-start': 'top right',
      left: 'center right',
      'left-end': 'bottom right'
  };
  const overlapTransformOrigin = {
      'bottom-start': 'bottom left',
      bottom: 'bottom center',
      'bottom-end': 'bottom right',
      'top-start': 'top left',
      top: 'top center',
      'top-end': 'top right',
      'right-start': 'top right',
      right: 'center right',
      'right-end': 'bottom right',
      'left-start': 'top left',
      left: 'center left',
      'left-end': 'bottom left'
  };
  const oppositeAlignCssPositionProps = {
      'bottom-start': 'right',
      'bottom-end': 'left',
      'top-start': 'right',
      'top-end': 'left',
      'right-start': 'bottom',
      'right-end': 'top',
      'left-start': 'bottom',
      'left-end': 'top'
  };
  const keepOffsetDirection = {
      top: true,
      bottom: false,
      left: true,
      right: false // left--
  };
  const cssPositionToOppositeAlign = {
      top: 'end',
      bottom: 'start',
      left: 'end',
      right: 'start'
  };
  function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
      if (!flip || overlap) {
          return { placement: placement, top: 0, left: 0 };
      }
      const [position, align] = placement.split('-');
      let properAlign = align !== null && align !== void 0 ? align : 'center';
      let properOffset = {
          top: 0,
          left: 0
      };
      const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically) => {
          let left = 0;
          let top = 0;
          const diff = followerRect[oppositeAlignCssSizeProp] -
              targetRect[alignCssPositionProp] -
              targetRect[oppositeAlignCssSizeProp];
          if (diff > 0 && shift) {
              if (offsetVertically) {
                  //       screen border
                  // |-----------------------------------------|
                  // |                    | f  |               |
                  // |                    | o  |               |
                  // |                    | l  |               |
                  // |                    | l  |----           |
                  // |                    | o  |tar |          |
                  // |                    | w  |get |          |
                  // |                    | e  |    |          |
                  // |                    | r  |----           |
                  // |                     ----                |
                  // |-----------------------------------------|
                  top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
              }
              else {
                  //       screen border
                  // |----------------------------------------|
                  // |                                        |
                  // |          ----------                    |
                  // |          | target |                    |
                  // |       ----------------------------------
                  // |       |       follower                 |
                  // |       ----------------------------------
                  // |                                        |
                  // |----------------------------------------|
                  left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
              }
          }
          return {
              left,
              top
          };
      };
      const offsetVertically = position === 'left' || position === 'right';
      // choose proper placement for non-center align
      if (properAlign !== 'center') {
          const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
          const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
          const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
          // if follower rect is larger than target rect in align direction
          // ----------[ target ]---------|
          // ----------[     follower     ]
          if (followerRect[oppositeAlignCssSizeProp] >
              targetRect[oppositeAlignCssSizeProp]) {
              if (
              // current space is not enough
              // ----------[ target ]---------|
              // -------[     follower        ]
              targetRect[oppositeAlignCssPositionProp] +
                  targetRect[oppositeAlignCssSizeProp] <
                  followerRect[oppositeAlignCssSizeProp]) {
                  const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] -
                      targetRect[oppositeAlignCssSizeProp]) /
                      2;
                  if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize ||
                      targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
                      // opposite align has larger space
                      // -------[ target ]-----------|
                      // -------[     follower     ]-|
                      if (targetRect[oppositeAlignCssPositionProp] <
                          targetRect[currentAlignCssPositionProp]) {
                          properAlign = oppositeAligns[align];
                          properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
                      }
                      else {
                          // ----------------[ target ]----|
                          // --------[   follower     ]----|
                          properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
                      }
                  }
                  else {
                      // 'center' align is better
                      // ------------[ target ]--------|
                      // -------[       follower    ]--|
                      properAlign = 'center';
                  }
              }
          }
          else if (followerRect[oppositeAlignCssSizeProp] <
              targetRect[oppositeAlignCssSizeProp]) {
              // TODO: maybe center is better
              if (targetRect[currentAlignCssPositionProp] < 0 &&
                  // opposite align has larger space
                  // ------------[   target   ]
                  // ----------------[follower]
                  targetRect[oppositeAlignCssPositionProp] >
                      targetRect[currentAlignCssPositionProp]) {
                  properAlign = oppositeAligns[align];
              }
          }
      }
      else {
          const possibleAlternativeAlignCssPositionProp1 = position === 'bottom' || position === 'top' ? 'left' : 'top';
          const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
          const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
          const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] -
              targetRect[alternativeAlignCssSizeProp]) /
              2;
          if (
          // center is not enough
          // ----------- [ target ]--|
          // -------[     follower     ]
          targetRect[possibleAlternativeAlignCssPositionProp1] <
              followerOverTargetSize ||
              targetRect[possibleAlternativeAlignCssPositionProp2] <
                  followerOverTargetSize) {
              // alternative 2 position's space is larger
              if (targetRect[possibleAlternativeAlignCssPositionProp1] >
                  targetRect[possibleAlternativeAlignCssPositionProp2]) {
                  properAlign =
                      cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
                  properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
              }
              else {
                  // alternative 1 position's space is larger
                  properAlign =
                      cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
                  properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
              }
          }
      }
      let properPosition = position;
      if (
      // space is not enough
      targetRect[position] < followerRect[propToCompare[position]] &&
          // opposite position's space is larger
          targetRect[position] < targetRect[oppositionPositions[position]]) {
          properPosition = oppositionPositions[position];
      }
      return {
          placement: properAlign !== 'center'
              ? `${properPosition}-${properAlign}`
              : properPosition,
          left: properOffset.left,
          top: properOffset.top
      };
  }
  function getProperTransformOrigin(placement, overlap) {
      if (overlap)
          return overlapTransformOrigin[placement];
      return transformOrigins[placement];
  }
  // ------------
  // |  offset  |
  // |          |
  // | [target] |
  // |          |
  // ------------
  // TODO: refactor it to remove dup logic
  function getOffset$1(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
      if (overlap) {
          switch (placement) {
              case 'bottom-start':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                      transform: 'translateY(-100%)'
                  };
              case 'bottom-end':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                      transform: 'translateX(-100%) translateY(-100%)'
                  };
              case 'top-start':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                      transform: ''
                  };
              case 'top-end':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                      transform: 'translateX(-100%)'
                  };
              case 'right-start':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                      transform: 'translateX(-100%)'
                  };
              case 'right-end':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                      transform: 'translateX(-100%) translateY(-100%)'
                  };
              case 'left-start':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                      transform: ''
                  };
              case 'left-end':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                      transform: 'translateY(-100%)'
                  };
              case 'top':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                      transform: 'translateX(-50%)'
                  };
              case 'right':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                      transform: 'translateX(-100%) translateY(-50%)'
                  };
              case 'left':
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                      transform: 'translateY(-50%)'
                  };
              case 'bottom':
              default:
                  return {
                      top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                      left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                      transform: 'translateX(-50%) translateY(-100%)'
                  };
          }
      }
      switch (placement) {
          case 'bottom-start':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
                  transform: ''
              };
          case 'bottom-end':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateX(-100%)'
              };
          case 'top-start':
              return {
                  top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
                  transform: 'translateY(-100%)'
              };
          case 'top-end':
              return {
                  top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateX(-100%) translateY(-100%)'
              };
          case 'right-start':
              return {
                  top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width +
                    offsetLeftToStandardPlacement)}px`,
                  transform: ''
              };
          case 'right-end':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateY(-100%)'
              };
          case 'left-start':
              return {
                  top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
                  transform: 'translateX(-100%)'
              };
          case 'left-end':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
                  transform: 'translateX(-100%) translateY(-100%)'
              };
          case 'top':
              return {
                  top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width / 2 +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateY(-100%) translateX(-50%)'
              };
          case 'right':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height / 2 +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateY(-50%)'
              };
          case 'left':
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height / 2 +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
                  transform: 'translateY(-50%) translateX(-100%)'
              };
          case 'bottom':
          default:
              return {
                  top: `${Math.round(targetRect.top -
                    offsetRect.top +
                    targetRect.height +
                    offsetTopToStandardPlacement)}px`,
                  left: `${Math.round(targetRect.left -
                    offsetRect.left +
                    targetRect.width / 2 +
                    offsetLeftToStandardPlacement)}px`,
                  transform: 'translateX(-50%)'
              };
      }
  }

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const style$1D = c([
      c('.v-binder-follower-container', {
          position: 'absolute',
          left: '0',
          right: '0',
          top: '0',
          height: '0',
          pointerEvents: 'none',
          zIndex: 'auto'
      }),
      c('.v-binder-follower-content', {
          position: 'absolute',
          zIndex: 'auto'
      }, [
          c('> *', {
              pointerEvents: 'all'
          })
      ])
  ]);
  var VFollower = defineComponent({
      name: 'Follower',
      inheritAttrs: false,
      props: {
          show: Boolean,
          enabled: {
              type: Boolean,
              default: undefined
          },
          placement: {
              type: String,
              default: 'bottom'
          },
          syncTrigger: {
              type: Array,
              default: ['resize', 'scroll']
          },
          to: [String, Object],
          flip: {
              type: Boolean,
              default: true
          },
          internalShift: Boolean,
          x: Number,
          y: Number,
          width: String,
          minWidth: String,
          containerClass: String,
          teleportDisabled: Boolean,
          zindexable: {
              type: Boolean,
              default: true
          },
          zIndex: Number,
          overlap: Boolean
      },
      setup(props) {
          const VBinder = inject('VBinder');
          const mergedEnabledRef = useMemo(() => {
              return props.enabled !== undefined ? props.enabled : props.show;
          });
          const followerRef = ref(null);
          const offsetContainerRef = ref(null);
          const ensureListeners = () => {
              const { syncTrigger } = props;
              if (syncTrigger.includes('scroll')) {
                  VBinder.addScrollListener(syncPosition);
              }
              if (syncTrigger.includes('resize')) {
                  VBinder.addResizeListener(syncPosition);
              }
          };
          const removeListeners = () => {
              VBinder.removeScrollListener(syncPosition);
              VBinder.removeResizeListener(syncPosition);
          };
          onMounted(() => {
              if (mergedEnabledRef.value) {
                  syncPosition();
                  ensureListeners();
              }
          });
          const ssrAdapter = useSsrAdapter();
          style$1D.mount({
              id: 'vueuc/binder',
              head: true,
              anchorMetaName: cssrAnchorMetaName$1,
              ssr: ssrAdapter
          });
          onBeforeUnmount(() => {
              removeListeners();
          });
          onFontsReady(() => {
              if (mergedEnabledRef.value) {
                  syncPosition();
              }
          });
          const syncPosition = () => {
              if (!mergedEnabledRef.value) {
                  return;
              }
              const follower = followerRef.value;
              // sometimes watched props change before its dom is ready
              // for example: show=false, x=undefined, y=undefined
              //              show=true,  x=0,         y=0
              // will cause error
              // I may optimize the watch start point later
              if (follower === null)
                  return;
              const target = VBinder.targetRef;
              const { x, y, overlap } = props;
              const targetRect = x !== undefined && y !== undefined
                  ? getPointRect(x, y)
                  : getRect$1(target);
              follower.style.setProperty('--v-target-width', `${Math.round(targetRect.width)}px`);
              follower.style.setProperty('--v-target-height', `${Math.round(targetRect.height)}px`);
              const { width, minWidth, placement, internalShift, flip } = props;
              follower.setAttribute('v-placement', placement);
              if (overlap) {
                  follower.setAttribute('v-overlap', '');
              }
              else {
                  follower.removeAttribute('v-overlap');
              }
              const { style } = follower;
              if (width === 'target') {
                  style.width = `${targetRect.width}px`;
              }
              else if (width !== undefined) {
                  style.width = width;
              }
              else {
                  style.width = '';
              }
              if (minWidth === 'target') {
                  style.minWidth = `${targetRect.width}px`;
              }
              else if (minWidth !== undefined) {
                  style.minWidth = minWidth;
              }
              else {
                  style.minWidth = '';
              }
              const followerRect = getRect$1(follower);
              const offsetContainerRect = getRect$1(offsetContainerRef.value);
              const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
              const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
              const { left, top, transform } = getOffset$1(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
              // we assume that the content size doesn't change after flip,
              // nor we need to make sync logic more complex
              follower.setAttribute('v-placement', properPlacement);
              follower.style.setProperty('--v-offset-left', `${Math.round(offsetLeftToStandardPlacement)}px`);
              follower.style.setProperty('--v-offset-top', `${Math.round(offsetTopToStandardPlacement)}px`);
              follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
              follower.style.setProperty('--v-transform-origin', properTransformOrigin);
              follower.style.transformOrigin = properTransformOrigin;
          };
          watch(mergedEnabledRef, (value) => {
              if (value) {
                  ensureListeners();
                  syncOnNextTick();
              }
              else {
                  removeListeners();
              }
          });
          const syncOnNextTick = () => {
              nextTick()
                  .then(syncPosition)
                  .catch((e) => console.error(e));
          };
          [
              'placement',
              'x',
              'y',
              'internalShift',
              'flip',
              'width',
              'overlap',
              'minWidth'
          ].forEach((prop) => {
              watch(toRef(props, prop), syncPosition);
          });
          ['teleportDisabled'].forEach((prop) => {
              watch(toRef(props, prop), syncOnNextTick);
          });
          watch(toRef(props, 'syncTrigger'), (value) => {
              if (!value.includes('resize')) {
                  VBinder.removeResizeListener(syncPosition);
              }
              else {
                  VBinder.addResizeListener(syncPosition);
              }
              if (!value.includes('scroll')) {
                  VBinder.removeScrollListener(syncPosition);
              }
              else {
                  VBinder.addScrollListener(syncPosition);
              }
          });
          const isMountedRef = isMounted();
          const mergedToRef = useMemo(() => {
              const { to } = props;
              if (to !== undefined)
                  return to;
              if (isMountedRef.value) {
                  // TODO: find proper container
                  return undefined;
              }
              return undefined;
          });
          return {
              VBinder,
              mergedEnabled: mergedEnabledRef,
              offsetContainerRef,
              followerRef,
              mergedTo: mergedToRef,
              syncPosition
          };
      },
      render() {
          return h(LazyTeleport, {
              show: this.show,
              to: this.mergedTo,
              disabled: this.teleportDisabled
          }, {
              default: () => {
                  var _a, _b;
                  const vNode = h('div', {
                      class: ['v-binder-follower-container', this.containerClass],
                      ref: 'offsetContainerRef'
                  }, [
                      h('div', {
                          class: 'v-binder-follower-content',
                          ref: 'followerRef'
                      }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
                  ]);
                  if (this.zindexable) {
                      return withDirectives(vNode, [
                          [
                              zindexable$1,
                              {
                                  enabled: this.mergedEnabled,
                                  zIndex: this.zIndex
                              }
                          ]
                      ]);
                  }
                  return vNode;
              }
          });
      }
  });

  var resizeObservers = [];

  var hasActiveObservations = function () {
      return resizeObservers.some(function (ro) { return ro.activeTargets.length > 0; });
  };

  var hasSkippedObservations = function () {
      return resizeObservers.some(function (ro) { return ro.skippedTargets.length > 0; });
  };

  var msg = 'ResizeObserver loop completed with undelivered notifications.';
  var deliverResizeLoopError = function () {
      var event;
      if (typeof ErrorEvent === 'function') {
          event = new ErrorEvent('error', {
              message: msg
          });
      }
      else {
          event = document.createEvent('Event');
          event.initEvent('error', false, false);
          event.message = msg;
      }
      window.dispatchEvent(event);
  };

  var ResizeObserverBoxOptions;
  (function (ResizeObserverBoxOptions) {
      ResizeObserverBoxOptions["BORDER_BOX"] = "border-box";
      ResizeObserverBoxOptions["CONTENT_BOX"] = "content-box";
      ResizeObserverBoxOptions["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
  })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

  var freeze = function (obj) { return Object.freeze(obj); };

  var ResizeObserverSize = (function () {
      function ResizeObserverSize(inlineSize, blockSize) {
          this.inlineSize = inlineSize;
          this.blockSize = blockSize;
          freeze(this);
      }
      return ResizeObserverSize;
  }());

  var DOMRectReadOnly = (function () {
      function DOMRectReadOnly(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.top = this.y;
          this.left = this.x;
          this.bottom = this.top + this.height;
          this.right = this.left + this.width;
          return freeze(this);
      }
      DOMRectReadOnly.prototype.toJSON = function () {
          var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
          return { x: x, y: y, top: top, right: right, bottom: bottom, left: left, width: width, height: height };
      };
      DOMRectReadOnly.fromRect = function (rectangle) {
          return new DOMRectReadOnly(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
      };
      return DOMRectReadOnly;
  }());

  var isSVG = function (target) { return target instanceof SVGElement && 'getBBox' in target; };
  var isHidden = function (target) {
      if (isSVG(target)) {
          var _a = target.getBBox(), width = _a.width, height = _a.height;
          return !width && !height;
      }
      var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
      return !(offsetWidth || offsetHeight || target.getClientRects().length);
  };
  var isElement = function (obj) {
      var _a;
      if (obj instanceof Element) {
          return true;
      }
      var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
      return !!(scope && obj instanceof scope.Element);
  };
  var isReplacedElement = function (target) {
      switch (target.tagName) {
          case 'INPUT':
              if (target.type !== 'image') {
                  break;
              }
          case 'VIDEO':
          case 'AUDIO':
          case 'EMBED':
          case 'OBJECT':
          case 'CANVAS':
          case 'IFRAME':
          case 'IMG':
              return true;
      }
      return false;
  };

  var global$1 = typeof window !== 'undefined' ? window : {};

  var cache = new WeakMap();
  var scrollRegexp = /auto|scroll/;
  var verticalRegexp = /^tb|vertical/;
  var IE = (/msie|trident/i).test(global$1.navigator && global$1.navigator.userAgent);
  var parseDimension = function (pixel) { return parseFloat(pixel || '0'); };
  var size = function (inlineSize, blockSize, switchSizes) {
      if (inlineSize === void 0) { inlineSize = 0; }
      if (blockSize === void 0) { blockSize = 0; }
      if (switchSizes === void 0) { switchSizes = false; }
      return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
  };
  var zeroBoxes = freeze({
      devicePixelContentBoxSize: size(),
      borderBoxSize: size(),
      contentBoxSize: size(),
      contentRect: new DOMRectReadOnly(0, 0, 0, 0)
  });
  var calculateBoxSizes = function (target, forceRecalculation) {
      if (forceRecalculation === void 0) { forceRecalculation = false; }
      if (cache.has(target) && !forceRecalculation) {
          return cache.get(target);
      }
      if (isHidden(target)) {
          cache.set(target, zeroBoxes);
          return zeroBoxes;
      }
      var cs = getComputedStyle(target);
      var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
      var removePadding = !IE && cs.boxSizing === 'border-box';
      var switchSizes = verticalRegexp.test(cs.writingMode || '');
      var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || '');
      var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || '');
      var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
      var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
      var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
      var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
      var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
      var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
      var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
      var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
      var horizontalPadding = paddingLeft + paddingRight;
      var verticalPadding = paddingTop + paddingBottom;
      var horizontalBorderArea = borderLeft + borderRight;
      var verticalBorderArea = borderTop + borderBottom;
      var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
      var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
      var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
      var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
      var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
      var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
      var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
      var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
      var boxes = freeze({
          devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
          borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
          contentBoxSize: size(contentWidth, contentHeight, switchSizes),
          contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
      });
      cache.set(target, boxes);
      return boxes;
  };
  var calculateBoxSize = function (target, observedBox, forceRecalculation) {
      var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
      switch (observedBox) {
          case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
              return devicePixelContentBoxSize;
          case ResizeObserverBoxOptions.BORDER_BOX:
              return borderBoxSize;
          default:
              return contentBoxSize;
      }
  };

  var ResizeObserverEntry = (function () {
      function ResizeObserverEntry(target) {
          var boxes = calculateBoxSizes(target);
          this.target = target;
          this.contentRect = boxes.contentRect;
          this.borderBoxSize = freeze([boxes.borderBoxSize]);
          this.contentBoxSize = freeze([boxes.contentBoxSize]);
          this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
      }
      return ResizeObserverEntry;
  }());

  var calculateDepthForNode = function (node) {
      if (isHidden(node)) {
          return Infinity;
      }
      var depth = 0;
      var parent = node.parentNode;
      while (parent) {
          depth += 1;
          parent = parent.parentNode;
      }
      return depth;
  };

  var broadcastActiveObservations = function () {
      var shallowestDepth = Infinity;
      var callbacks = [];
      resizeObservers.forEach(function processObserver(ro) {
          if (ro.activeTargets.length === 0) {
              return;
          }
          var entries = [];
          ro.activeTargets.forEach(function processTarget(ot) {
              var entry = new ResizeObserverEntry(ot.target);
              var targetDepth = calculateDepthForNode(ot.target);
              entries.push(entry);
              ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
              if (targetDepth < shallowestDepth) {
                  shallowestDepth = targetDepth;
              }
          });
          callbacks.push(function resizeObserverCallback() {
              ro.callback.call(ro.observer, entries, ro.observer);
          });
          ro.activeTargets.splice(0, ro.activeTargets.length);
      });
      for (var _i = 0, callbacks_1 = callbacks; _i < callbacks_1.length; _i++) {
          var callback = callbacks_1[_i];
          callback();
      }
      return shallowestDepth;
  };

  var gatherActiveObservationsAtDepth = function (depth) {
      resizeObservers.forEach(function processObserver(ro) {
          ro.activeTargets.splice(0, ro.activeTargets.length);
          ro.skippedTargets.splice(0, ro.skippedTargets.length);
          ro.observationTargets.forEach(function processTarget(ot) {
              if (ot.isActive()) {
                  if (calculateDepthForNode(ot.target) > depth) {
                      ro.activeTargets.push(ot);
                  }
                  else {
                      ro.skippedTargets.push(ot);
                  }
              }
          });
      });
  };

  var process$1 = function () {
      var depth = 0;
      gatherActiveObservationsAtDepth(depth);
      while (hasActiveObservations()) {
          depth = broadcastActiveObservations();
          gatherActiveObservationsAtDepth(depth);
      }
      if (hasSkippedObservations()) {
          deliverResizeLoopError();
      }
      return depth > 0;
  };

  var trigger;
  var callbacks = [];
  var notify = function () { return callbacks.splice(0).forEach(function (cb) { return cb(); }); };
  var queueMicroTask = function (callback) {
      if (!trigger) {
          var toggle_1 = 0;
          var el_1 = document.createTextNode('');
          var config = { characterData: true };
          new MutationObserver(function () { return notify(); }).observe(el_1, config);
          trigger = function () { el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++); };
      }
      callbacks.push(callback);
      trigger();
  };

  var queueResizeObserver = function (cb) {
      queueMicroTask(function ResizeObserver() {
          requestAnimationFrame(cb);
      });
  };

  var watching = 0;
  var isWatching = function () { return !!watching; };
  var CATCH_PERIOD = 250;
  var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
  var events = [
      'resize',
      'load',
      'transitionend',
      'animationend',
      'animationstart',
      'animationiteration',
      'keyup',
      'keydown',
      'mouseup',
      'mousedown',
      'mouseover',
      'mouseout',
      'blur',
      'focus'
  ];
  var time$1 = function (timeout) {
      if (timeout === void 0) { timeout = 0; }
      return Date.now() + timeout;
  };
  var scheduled = false;
  var Scheduler = (function () {
      function Scheduler() {
          var _this = this;
          this.stopped = true;
          this.listener = function () { return _this.schedule(); };
      }
      Scheduler.prototype.run = function (timeout) {
          var _this = this;
          if (timeout === void 0) { timeout = CATCH_PERIOD; }
          if (scheduled) {
              return;
          }
          scheduled = true;
          var until = time$1(timeout);
          queueResizeObserver(function () {
              var elementsHaveResized = false;
              try {
                  elementsHaveResized = process$1();
              }
              finally {
                  scheduled = false;
                  timeout = until - time$1();
                  if (!isWatching()) {
                      return;
                  }
                  if (elementsHaveResized) {
                      _this.run(1000);
                  }
                  else if (timeout > 0) {
                      _this.run(timeout);
                  }
                  else {
                      _this.start();
                  }
              }
          });
      };
      Scheduler.prototype.schedule = function () {
          this.stop();
          this.run();
      };
      Scheduler.prototype.observe = function () {
          var _this = this;
          var cb = function () { return _this.observer && _this.observer.observe(document.body, observerConfig); };
          document.body ? cb() : global$1.addEventListener('DOMContentLoaded', cb);
      };
      Scheduler.prototype.start = function () {
          var _this = this;
          if (this.stopped) {
              this.stopped = false;
              this.observer = new MutationObserver(this.listener);
              this.observe();
              events.forEach(function (name) { return global$1.addEventListener(name, _this.listener, true); });
          }
      };
      Scheduler.prototype.stop = function () {
          var _this = this;
          if (!this.stopped) {
              this.observer && this.observer.disconnect();
              events.forEach(function (name) { return global$1.removeEventListener(name, _this.listener, true); });
              this.stopped = true;
          }
      };
      return Scheduler;
  }());
  var scheduler = new Scheduler();
  var updateCount = function (n) {
      !watching && n > 0 && scheduler.start();
      watching += n;
      !watching && scheduler.stop();
  };

  var skipNotifyOnElement = function (target) {
      return !isSVG(target)
          && !isReplacedElement(target)
          && getComputedStyle(target).display === 'inline';
  };
  var ResizeObservation = (function () {
      function ResizeObservation(target, observedBox) {
          this.target = target;
          this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
          this.lastReportedSize = {
              inlineSize: 0,
              blockSize: 0
          };
      }
      ResizeObservation.prototype.isActive = function () {
          var size = calculateBoxSize(this.target, this.observedBox, true);
          if (skipNotifyOnElement(this.target)) {
              this.lastReportedSize = size;
          }
          if (this.lastReportedSize.inlineSize !== size.inlineSize
              || this.lastReportedSize.blockSize !== size.blockSize) {
              return true;
          }
          return false;
      };
      return ResizeObservation;
  }());

  var ResizeObserverDetail = (function () {
      function ResizeObserverDetail(resizeObserver, callback) {
          this.activeTargets = [];
          this.skippedTargets = [];
          this.observationTargets = [];
          this.observer = resizeObserver;
          this.callback = callback;
      }
      return ResizeObserverDetail;
  }());

  var observerMap = new WeakMap();
  var getObservationIndex = function (observationTargets, target) {
      for (var i = 0; i < observationTargets.length; i += 1) {
          if (observationTargets[i].target === target) {
              return i;
          }
      }
      return -1;
  };
  var ResizeObserverController = (function () {
      function ResizeObserverController() {
      }
      ResizeObserverController.connect = function (resizeObserver, callback) {
          var detail = new ResizeObserverDetail(resizeObserver, callback);
          observerMap.set(resizeObserver, detail);
      };
      ResizeObserverController.observe = function (resizeObserver, target, options) {
          var detail = observerMap.get(resizeObserver);
          var firstObservation = detail.observationTargets.length === 0;
          if (getObservationIndex(detail.observationTargets, target) < 0) {
              firstObservation && resizeObservers.push(detail);
              detail.observationTargets.push(new ResizeObservation(target, options && options.box));
              updateCount(1);
              scheduler.schedule();
          }
      };
      ResizeObserverController.unobserve = function (resizeObserver, target) {
          var detail = observerMap.get(resizeObserver);
          var index = getObservationIndex(detail.observationTargets, target);
          var lastObservation = detail.observationTargets.length === 1;
          if (index >= 0) {
              lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
              detail.observationTargets.splice(index, 1);
              updateCount(-1);
          }
      };
      ResizeObserverController.disconnect = function (resizeObserver) {
          var _this = this;
          var detail = observerMap.get(resizeObserver);
          detail.observationTargets.slice().forEach(function (ot) { return _this.unobserve(resizeObserver, ot.target); });
          detail.activeTargets.splice(0, detail.activeTargets.length);
      };
      return ResizeObserverController;
  }());

  var ResizeObserver = (function () {
      function ResizeObserver(callback) {
          if (arguments.length === 0) {
              throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (typeof callback !== 'function') {
              throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
          }
          ResizeObserverController.connect(this, callback);
      }
      ResizeObserver.prototype.observe = function (target, options) {
          if (arguments.length === 0) {
              throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
              throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.observe(this, target, options);
      };
      ResizeObserver.prototype.unobserve = function (target) {
          if (arguments.length === 0) {
              throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
              throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.unobserve(this, target);
      };
      ResizeObserver.prototype.disconnect = function () {
          ResizeObserverController.disconnect(this);
      };
      ResizeObserver.toString = function () {
          return 'function ResizeObserver () { [polyfill code] }';
      };
      return ResizeObserver;
  }());

  class ResizeObserverDelegate {
      constructor() {
          this.handleResize = this.handleResize.bind(this);
          this.observer = new ((typeof window !== 'undefined' &&
              window.ResizeObserver) ||
              ResizeObserver)(this.handleResize);
          this.elHandlersMap = new Map();
      }
      handleResize(entries) {
          for (const entry of entries) {
              const handler = this.elHandlersMap.get(entry.target);
              if (handler !== undefined) {
                  handler(entry);
              }
          }
      }
      registerHandler(el, handler) {
          this.elHandlersMap.set(el, handler);
          this.observer.observe(el);
      }
      unregisterHandler(el) {
          if (!this.elHandlersMap.has(el)) {
              return;
          }
          this.elHandlersMap.delete(el);
          this.observer.unobserve(el);
      }
  }
  var resizeObserverManager = new ResizeObserverDelegate();

  var VResizeObserver = defineComponent({
      name: 'ResizeObserver',
      props: {
          onResize: Function
      },
      setup(props) {
          let registered = false;
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const proxy = getCurrentInstance().proxy;
          function handleResize(entry) {
              const { onResize } = props;
              if (onResize !== undefined)
                  onResize(entry);
          }
          onMounted(() => {
              const el = proxy.$el;
              if (el === undefined) {
                  warn('resize-observer', '$el does not exist.');
                  return;
              }
              if (el.nextElementSibling !== el.nextSibling) {
                  if (el.nodeType === 3 && el.nodeValue !== '') {
                      warn('resize-observer', '$el can not be observed (it may be a text node).');
                      return;
                  }
              }
              if (el.nextElementSibling !== null) {
                  resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
                  registered = true;
              }
          });
          onBeforeUnmount(() => {
              if (registered) {
                  resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
              }
          });
      },
      render() {
          return renderSlot(this.$slots, 'default');
      }
  });

  let maybeTouch;
  function ensureMaybeTouch() {
      if (typeof document === 'undefined')
          return false;
      if (maybeTouch === undefined) {
          if ('matchMedia' in window) {
              maybeTouch = window.matchMedia('(pointer:coarse)').matches;
          }
          else {
              maybeTouch = false;
          }
      }
      return maybeTouch;
  }
  let wheelScale;
  function ensureWheelScale() {
      if (typeof document === 'undefined')
          return 1;
      if (wheelScale === undefined) {
          wheelScale = 'chrome' in window ? window.devicePixelRatio : 1;
      }
      return wheelScale;
  }

  /* eslint-disable no-void */
  /* eslint-disable @typescript-eslint/restrict-plus-operands */
  const styles$1 = c('.v-vl', {
      maxHeight: 'inherit',
      height: '100%',
      overflow: 'auto',
      minWidth: '1px' // a zero width container won't be scrollable
  }, [
      c('&:not(.v-vl--show-scrollbar)', {
          scrollbarWidth: 'none'
      }, [
          c('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', {
              width: 0,
              height: 0,
              display: 'none'
          })
      ])
  ]);
  var VVirtualList = defineComponent({
      name: 'VirtualList',
      inheritAttrs: false,
      props: {
          showScrollbar: {
              type: Boolean,
              default: true
          },
          items: {
              type: Array,
              default: () => []
          },
          // it is suppose to be the min height
          itemSize: {
              type: Number,
              required: true
          },
          itemResizable: Boolean,
          itemsStyle: [String, Object],
          visibleItemsTag: {
              type: [String, Object],
              default: 'div'
          },
          visibleItemsProps: Object,
          ignoreItemResize: Boolean,
          onScroll: Function,
          onWheel: Function,
          onResize: Function,
          defaultScrollKey: [Number, String],
          defaultScrollIndex: Number,
          keyField: {
              type: String,
              default: 'key'
          },
          // Whether it is a good API?
          // ResizeObserver + footer & header is not enough.
          // Too complex for simple case
          paddingTop: {
              type: [Number, String],
              default: 0
          },
          paddingBottom: {
              type: [Number, String],
              default: 0
          }
      },
      setup(props) {
          const ssrAdapter = useSsrAdapter();
          styles$1.mount({
              id: 'vueuc/virtual-list',
              head: true,
              anchorMetaName: cssrAnchorMetaName$1,
              ssr: ssrAdapter
          });
          onMounted(() => {
              const { defaultScrollIndex, defaultScrollKey } = props;
              if (defaultScrollIndex !== undefined && defaultScrollIndex !== null) {
                  scrollTo({ index: defaultScrollIndex });
              }
              else if (defaultScrollKey !== undefined && defaultScrollKey !== null) {
                  scrollTo({ key: defaultScrollKey });
              }
          });
          let isDeactivated = false;
          let activateStateInitialized = false;
          onActivated(() => {
              isDeactivated = false;
              if (!activateStateInitialized) {
                  activateStateInitialized = true;
                  return;
              }
              // remount
              scrollTo({ top: scrollTopRef.value, left: scrollLeft });
          });
          onDeactivated(() => {
              isDeactivated = true;
              if (!activateStateInitialized) {
                  activateStateInitialized = true;
              }
          });
          const keyIndexMapRef = computed(() => {
              const map = new Map();
              const { keyField } = props;
              props.items.forEach((item, index) => {
                  map.set(item[keyField], index);
              });
              return map;
          });
          const listElRef = ref(null);
          const listHeightRef = ref(undefined);
          const keyToHeightOffset = new Map();
          const finweckTreeRef = computed(() => {
              const { items, itemSize, keyField } = props;
              const ft = new FinweckTree(items.length, itemSize);
              items.forEach((item, index) => {
                  const key = item[keyField];
                  const heightOffset = keyToHeightOffset.get(key);
                  if (heightOffset !== undefined) {
                      ft.add(index, heightOffset);
                  }
              });
              return ft;
          });
          const finweckTreeUpdateTrigger = ref(0);
          let scrollLeft = 0;
          const scrollTopRef = ref(0);
          const startIndexRef = useMemo(() => {
              return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
          });
          const viewportItemsRef = computed(() => {
              const { value: listHeight } = listHeightRef;
              if (listHeight === undefined)
                  return [];
              const { items, itemSize } = props;
              const startIndex = startIndexRef.value;
              const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
              const viewportItems = [];
              for (let i = startIndex; i <= endIndex; ++i) {
                  viewportItems.push(items[i]);
              }
              return viewportItems;
          });
          const scrollTo = (options, y) => {
              if (typeof options === 'number') {
                  scrollToPosition(options, y, 'auto');
                  return;
              }
              const { left, top, index, key, position, behavior, debounce = true } = options;
              if (left !== undefined || top !== undefined) {
                  scrollToPosition(left, top, behavior);
              }
              else if (index !== undefined) {
                  scrollToIndex(index, behavior, debounce);
              }
              else if (key !== undefined) {
                  const toIndex = keyIndexMapRef.value.get(key);
                  if (toIndex !== undefined)
                      scrollToIndex(toIndex, behavior, debounce);
              }
              else if (position === 'bottom') {
                  scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
              }
              else if (position === 'top') {
                  scrollToPosition(0, 0, behavior);
              }
          };
          let anchorIndex;
          let anchorTimerId = null;
          function scrollToIndex(index, behavior, debounce) {
              const { value: ft } = finweckTreeRef;
              const targetTop = ft.sum(index) + depx(props.paddingTop);
              if (!debounce) {
                  listElRef.value.scrollTo({
                      left: 0,
                      top: targetTop,
                      behavior
                  });
              }
              else {
                  anchorIndex = index;
                  if (anchorTimerId !== null) {
                      window.clearTimeout(anchorTimerId);
                  }
                  anchorTimerId = window.setTimeout(() => {
                      anchorIndex = undefined;
                      anchorTimerId = null;
                  }, 16); // use 0 ms may be ealier than resize callback...
                  const { scrollTop, offsetHeight } = listElRef.value;
                  if (targetTop > scrollTop) {
                      const itemSize = ft.get(index);
                      if (targetTop + itemSize <= scrollTop + offsetHeight) ;
                      else {
                          listElRef.value.scrollTo({
                              left: 0,
                              top: targetTop + itemSize - offsetHeight,
                              behavior
                          });
                      }
                  }
                  else {
                      listElRef.value.scrollTo({
                          left: 0,
                          top: targetTop,
                          behavior
                      });
                  }
              }
          }
          function scrollToPosition(left, top, behavior) {
              listElRef.value.scrollTo({
                  left,
                  top,
                  behavior
              });
          }
          function handleItemResize(key, entry) {
              var _a, _b, _c;
              if (isDeactivated)
                  return;
              if (props.ignoreItemResize)
                  return;
              if (isHideByVShow(entry.target))
                  return;
              const { value: ft } = finweckTreeRef;
              const index = keyIndexMapRef.value.get(key);
              const previousHeight = ft.get(index);
              const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
              if (height === previousHeight)
                  return;
              // height offset based on itemSize
              // used when rebuild the finweck tree
              const offset = height - props.itemSize;
              if (offset === 0) {
                  keyToHeightOffset.delete(key);
              }
              else {
                  keyToHeightOffset.set(key, height - props.itemSize);
              }
              // delta height based on finweck tree data
              const delta = height - previousHeight;
              if (delta === 0)
                  return;
              ft.add(index, delta);
              const listEl = listElRef.value;
              if (listEl != null) {
                  if (anchorIndex === undefined) {
                      const previousHeightSum = ft.sum(index);
                      if (listEl.scrollTop > previousHeightSum) {
                          listEl.scrollBy(0, delta);
                      }
                  }
                  else {
                      if (index < anchorIndex) {
                          listEl.scrollBy(0, delta);
                      }
                      else if (index === anchorIndex) {
                          const previousHeightSum = ft.sum(index);
                          if (height + previousHeightSum >
                              // Note, listEl shouldn't have border, nor offsetHeight won't be
                              // correct
                              listEl.scrollTop + listEl.offsetHeight) {
                              listEl.scrollBy(0, delta);
                          }
                      }
                  }
                  syncViewport();
              }
              finweckTreeUpdateTrigger.value++;
          }
          const mayUseWheel = !ensureMaybeTouch();
          let wheelCatched = false;
          function handleListScroll(e) {
              var _a;
              (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
              if (!mayUseWheel || !wheelCatched) {
                  syncViewport();
              }
          }
          function handleListWheel(e) {
              var _a;
              (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
              if (mayUseWheel) {
                  const listEl = listElRef.value;
                  if (listEl != null) {
                      if (e.deltaX === 0) {
                          if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                              return;
                          }
                          if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight &&
                              e.deltaY >= 0) {
                              return;
                          }
                      }
                      e.preventDefault();
                      listEl.scrollTop += e.deltaY / ensureWheelScale();
                      listEl.scrollLeft += e.deltaX / ensureWheelScale();
                      syncViewport();
                      wheelCatched = true;
                      beforeNextFrameOnce(() => {
                          wheelCatched = false;
                      });
                  }
              }
          }
          function handleListResize(entry) {
              if (isDeactivated)
                  return;
              // List is HTMLElement
              if (isHideByVShow(entry.target))
                  return;
              // If height is same, return
              if (entry.contentRect.height === listHeightRef.value)
                  return;
              listHeightRef.value = entry.contentRect.height;
              const { onResize } = props;
              if (onResize !== undefined)
                  onResize(entry);
          }
          function syncViewport() {
              const { value: listEl } = listElRef;
              // sometime ref el can be null
              // https://github.com/TuSimple/naive-ui/issues/811
              if (listEl == null)
                  return;
              scrollTopRef.value = listEl.scrollTop;
              scrollLeft = listEl.scrollLeft;
          }
          function isHideByVShow(el) {
              let cursor = el;
              while (cursor !== null) {
                  if (cursor.style.display === 'none')
                      return true;
                  cursor = cursor.parentElement;
              }
              return false;
          }
          return {
              listHeight: listHeightRef,
              listStyle: {
                  overflow: 'auto'
              },
              keyToIndex: keyIndexMapRef,
              itemsStyle: computed(() => {
                  const { itemResizable } = props;
                  const height = pxfy(finweckTreeRef.value.sum());
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  finweckTreeUpdateTrigger.value;
                  return [
                      props.itemsStyle,
                      {
                          boxSizing: 'content-box',
                          height: itemResizable ? '' : height,
                          minHeight: itemResizable ? height : '',
                          paddingTop: pxfy(props.paddingTop),
                          paddingBottom: pxfy(props.paddingBottom)
                      }
                  ];
              }),
              visibleItemsStyle: computed(() => {
                  // eslint-disable-next-line @typescript-eslint/no-unused-expressions
                  finweckTreeUpdateTrigger.value;
                  return {
                      transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
                  };
              }),
              viewportItems: viewportItemsRef,
              listElRef,
              itemsElRef: ref(null),
              scrollTo,
              handleListResize,
              handleListScroll,
              handleListWheel,
              handleItemResize
          };
      },
      render() {
          const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;
          return h(VResizeObserver, {
              onResize: this.handleListResize
          }, {
              default: () => {
                  var _a, _b;
                  return h('div', mergeProps(this.$attrs, {
                      class: ['v-vl', this.showScrollbar && 'v-vl--show-scrollbar'],
                      onScroll: this.handleListScroll,
                      onWheel: this.handleListWheel,
                      ref: 'listElRef'
                  }), [
                      this.items.length !== 0
                          ? h('div', {
                              ref: 'itemsElRef',
                              class: 'v-vl-items',
                              style: this.itemsStyle
                          }, [
                              h(visibleItemsTag, Object.assign({
                                  class: 'v-vl-visible-items',
                                  style: this.visibleItemsStyle
                              }, this.visibleItemsProps), {
                                  default: () => this.viewportItems.map((item) => {
                                      const key = item[keyField];
                                      const index = keyToIndex.get(key);
                                      const itemVNode = this.$slots.default({
                                          item,
                                          index
                                      })[0];
                                      if (itemResizable) {
                                          return h(VResizeObserver, {
                                              key,
                                              onResize: (entry) => this.handleItemResize(key, entry)
                                          }, {
                                              default: () => itemVNode
                                          });
                                      }
                                      itemVNode.key = key;
                                      return itemVNode;
                                  })
                              })
                          ])
                          : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)
                  ]);
              }
          });
      }
  });

  const styles = c('.v-x-scroll', {
      overflow: 'auto',
      scrollbarWidth: 'none'
  }, [
      c('&::-webkit-scrollbar', {
          width: 0,
          height: 0
      })
  ]);
  var VXScroll = defineComponent({
      name: 'XScroll',
      props: {
          disabled: Boolean,
          onScroll: Function
      },
      setup() {
          const selfRef = ref(null);
          function handleWheel(e) {
              const preventYWheel = e.currentTarget.offsetWidth <
                  e.currentTarget.scrollWidth;
              if (!preventYWheel || e.deltaY === 0)
                  return;
              e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
              e.preventDefault();
          }
          const ssrAdapter = useSsrAdapter();
          styles.mount({
              id: 'vueuc/x-scroll',
              head: true,
              anchorMetaName: cssrAnchorMetaName$1,
              ssr: ssrAdapter
          });
          const exposedMethods = {
              scrollTo(...args) {
                  var _a;
                  (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
              }
          };
          return Object.assign({ selfRef,
              handleWheel }, exposedMethods);
      },
      render() {
          return h('div', {
              ref: 'selfRef',
              onScroll: this.onScroll,
              onWheel: this.disabled ? undefined : this.handleWheel,
              class: 'v-x-scroll'
          }, this.$slots);
      }
  });

  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  const hiddenAttr = 'v-hidden';
  const style$1C = c('[v-hidden]', {
      display: 'none!important'
  });
  var VOverflow = defineComponent({
      name: 'Overflow',
      props: {
          getCounter: Function,
          getTail: Function,
          updateCounter: Function,
          onUpdateCount: Function,
          onUpdateOverflow: Function
      },
      setup(props, { slots }) {
          const selfRef = ref(null);
          const counterRef = ref(null);
          function deriveCounter(options) {
              const { value: self } = selfRef;
              const { getCounter, getTail } = props;
              let counter;
              if (getCounter !== undefined)
                  counter = getCounter();
              else {
                  counter = counterRef.value;
              }
              if (!self || !counter)
                  return;
              if (counter.hasAttribute(hiddenAttr)) {
                  counter.removeAttribute(hiddenAttr);
              }
              const { children } = self;
              if (options.showAllItemsBeforeCalculate) {
                  for (const child of children) {
                      if (child.hasAttribute(hiddenAttr)) {
                          child.removeAttribute(hiddenAttr);
                      }
                  }
              }
              const containerWidth = self.offsetWidth;
              const childWidths = [];
              const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
              let childWidthSum = tail ? tail.offsetWidth : 0;
              let overflow = false;
              const len = self.children.length - (slots.tail ? 1 : 0);
              for (let i = 0; i < len - 1; ++i) {
                  if (i < 0)
                      continue;
                  const child = children[i];
                  if (overflow) {
                      if (!child.hasAttribute(hiddenAttr)) {
                          child.setAttribute(hiddenAttr, '');
                      }
                      continue;
                  }
                  else if (child.hasAttribute(hiddenAttr)) {
                      child.removeAttribute(hiddenAttr);
                  }
                  const childWidth = child.offsetWidth;
                  childWidthSum += childWidth;
                  childWidths[i] = childWidth;
                  if (childWidthSum > containerWidth) {
                      const { updateCounter } = props;
                      for (let j = i; j >= 0; --j) {
                          const restCount = len - 1 - j;
                          if (updateCounter !== undefined) {
                              updateCounter(restCount);
                          }
                          else {
                              counter.textContent = `${restCount}`;
                          }
                          const counterWidth = counter.offsetWidth;
                          childWidthSum -= childWidths[j];
                          if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                              overflow = true;
                              i = j - 1;
                              if (tail) {
                                  // tail too long or 1st element too long
                                  // we only consider tail now
                                  if (i === -1) {
                                      tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                                      tail.style.boxSizing = 'border-box';
                                  }
                                  else {
                                      tail.style.maxWidth = '';
                                  }
                              }
                              const { onUpdateCount } = props;
                              if (onUpdateCount)
                                  onUpdateCount(restCount);
                              break;
                          }
                      }
                  }
              }
              const { onUpdateOverflow } = props;
              if (!overflow) {
                  if (onUpdateOverflow !== undefined) {
                      onUpdateOverflow(false);
                  }
                  counter.setAttribute(hiddenAttr, '');
              }
              else {
                  if (onUpdateOverflow !== undefined) {
                      onUpdateOverflow(true);
                  }
              }
          }
          const ssrAdapter = useSsrAdapter();
          style$1C.mount({
              id: 'vueuc/overflow',
              head: true,
              anchorMetaName: cssrAnchorMetaName$1,
              ssr: ssrAdapter
          });
          onMounted(() => deriveCounter({
              showAllItemsBeforeCalculate: false
          }));
          // besides onMounted, other case should be manually triggered, or we shoud watch items
          return {
              selfRef,
              counterRef,
              sync: deriveCounter
          };
      },
      render() {
          const { $slots } = this;
          // eslint-disable-next-line @typescript-eslint/no-floating-promises
          nextTick(() => this.sync({
              showAllItemsBeforeCalculate: false
          }));
          // It shouldn't have border
          return h('div', {
              class: 'v-overflow',
              ref: 'selfRef'
          }, [
              renderSlot($slots, 'default'),
              // $slots.counter should only has 1 element
              $slots.counter
                  ? $slots.counter()
                  : h('span', {
                      style: {
                          display: 'inline-block'
                      },
                      ref: 'counterRef'
                  }),
              // $slots.tail should only has 1 element
              $slots.tail ? $slots.tail() : null
          ]);
      }
  });

  /* eslint-disable @typescript-eslint/strict-boolean-expressions */
  // ref https://www.w3.org/TR/wai-aria-practices-1.1/examples/dialog-modal/js/dialog.js
  function isHTMLElement(node) {
      return node instanceof HTMLElement;
  }
  function focusFirstDescendant(node) {
      for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];
          if (isHTMLElement(child)) {
              if (attemptFocus(child) || focusFirstDescendant(child)) {
                  return true;
              }
          }
      }
      return false;
  }
  function focusLastDescendant(element) {
      for (let i = element.childNodes.length - 1; i >= 0; i--) {
          const child = element.childNodes[i];
          if (isHTMLElement(child)) {
              if (attemptFocus(child) || focusLastDescendant(child)) {
                  return true;
              }
          }
      }
      return false;
  }
  function attemptFocus(element) {
      if (!isFocusable(element)) {
          return false;
      }
      try {
          element.focus({ preventScroll: true });
      }
      catch (e) { }
      return document.activeElement === element;
  }
  function isFocusable(element) {
      if (element.tabIndex > 0 ||
          (element.tabIndex === 0 && element.getAttribute('tabIndex') !== null)) {
          return true;
      }
      if (element.getAttribute('disabled')) {
          return false;
      }
      switch (element.nodeName) {
          case 'A':
              return (!!element.href &&
                  element.rel !== 'ignore');
          case 'INPUT':
              return (element.type !== 'hidden' &&
                  element.type !== 'file');
          case 'BUTTON':
          case 'SELECT':
          case 'TEXTAREA':
              return true;
          default:
              return false;
      }
  }

  let stack = [];
  const FocusTrap = defineComponent({
      name: 'FocusTrap',
      props: {
          disabled: Boolean,
          active: Boolean,
          autoFocus: {
              type: Boolean,
              default: true
          },
          onEsc: Function,
          initialFocusTo: String,
          finalFocusTo: String,
          returnFocusOnDeactivated: {
              type: Boolean,
              default: true
          }
      },
      setup(props) {
          const id = createId();
          const focusableStartRef = ref(null);
          const focusableEndRef = ref(null);
          let activated = false;
          let ignoreInternalFocusChange = false;
          const lastFocusedElement = typeof document === 'undefined' ? null : document.activeElement;
          function isCurrentActive() {
              const currentActiveId = stack[stack.length - 1];
              return currentActiveId === id;
          }
          function handleDocumentKeydown(e) {
              var _a;
              if (e.code === 'Escape') {
                  if (isCurrentActive()) {
                      (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
                  }
              }
          }
          onMounted(() => {
              watch(() => props.active, (value) => {
                  if (value) {
                      activate();
                      on('keydown', document, handleDocumentKeydown);
                  }
                  else {
                      off('keydown', document, handleDocumentKeydown);
                      if (activated) {
                          deactivate();
                      }
                  }
              }, {
                  immediate: true
              });
          });
          onBeforeUnmount(() => {
              off('keydown', document, handleDocumentKeydown);
              if (activated)
                  deactivate();
          });
          function handleDocumentFocus(e) {
              if (ignoreInternalFocusChange)
                  return;
              if (isCurrentActive()) {
                  const mainEl = getMainEl();
                  if (mainEl === null)
                      return;
                  if (mainEl.contains(getPreciseEventTarget(e)))
                      return;
                  // I don't handle shift + tab status since it's too tricky to handle
                  // Not impossible but I need to sleep
                  resetFocusTo('first');
              }
          }
          function getMainEl() {
              const focusableStartEl = focusableStartRef.value;
              if (focusableStartEl === null)
                  return null;
              let mainEl = focusableStartEl;
              while (true) {
                  mainEl = mainEl.nextSibling;
                  if (mainEl === null)
                      break;
                  if (mainEl instanceof Element && mainEl.tagName === 'DIV') {
                      break;
                  }
              }
              return mainEl;
          }
          function activate() {
              var _a;
              if (props.disabled)
                  return;
              stack.push(id);
              if (props.autoFocus) {
                  const { initialFocusTo } = props;
                  if (initialFocusTo === undefined) {
                      resetFocusTo('first');
                  }
                  else {
                      (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
                  }
              }
              activated = true;
              document.addEventListener('focus', handleDocumentFocus, true);
          }
          function deactivate() {
              var _a;
              if (props.disabled)
                  return;
              document.removeEventListener('focus', handleDocumentFocus, true);
              stack = stack.filter((idInStack) => idInStack !== id);
              if (isCurrentActive())
                  return;
              const { finalFocusTo } = props;
              if (finalFocusTo !== undefined) {
                  (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
              }
              else if (props.returnFocusOnDeactivated) {
                  if (lastFocusedElement instanceof HTMLElement) {
                      ignoreInternalFocusChange = true;
                      lastFocusedElement.focus({ preventScroll: true });
                      ignoreInternalFocusChange = false;
                  }
              }
          }
          function resetFocusTo(target) {
              if (!isCurrentActive())
                  return;
              if (props.active) {
                  const focusableStartEl = focusableStartRef.value;
                  const focusableEndEl = focusableEndRef.value;
                  if (focusableStartEl !== null && focusableEndEl !== null) {
                      const mainEl = getMainEl();
                      if (mainEl == null || mainEl === focusableEndEl) {
                          ignoreInternalFocusChange = true;
                          focusableStartEl.focus({ preventScroll: true });
                          ignoreInternalFocusChange = false;
                          return;
                      }
                      ignoreInternalFocusChange = true;
                      const focused = target === 'first'
                          ? focusFirstDescendant(mainEl)
                          : focusLastDescendant(mainEl);
                      ignoreInternalFocusChange = false;
                      if (!focused) {
                          ignoreInternalFocusChange = true;
                          focusableStartEl.focus({ preventScroll: true });
                          ignoreInternalFocusChange = false;
                      }
                  }
              }
          }
          function handleStartFocus(e) {
              if (ignoreInternalFocusChange)
                  return;
              const mainEl = getMainEl();
              if (mainEl === null)
                  return;
              if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
                  // if it comes from inner, focus last
                  resetFocusTo('last');
              }
              else {
                  // otherwise focus first
                  resetFocusTo('first');
              }
          }
          function handleEndFocus(e) {
              if (ignoreInternalFocusChange)
                  return;
              if (e.relatedTarget !== null &&
                  e.relatedTarget === focusableStartRef.value) {
                  // if it comes from first, focus last
                  resetFocusTo('last');
              }
              else {
                  // otherwise focus first
                  resetFocusTo('first');
              }
          }
          return {
              focusableStartRef,
              focusableEndRef,
              focusableStyle: 'position: absolute; height: 0; width: 0;',
              handleStartFocus,
              handleEndFocus
          };
      },
      render() {
          const { default: defaultSlot } = this.$slots;
          if (defaultSlot === undefined)
              return null;
          if (this.disabled)
              return defaultSlot();
          const { active, focusableStyle } = this;
          return h(Fragment, null, [
              h('div', {
                  'aria-hidden': 'true',
                  tabindex: active ? '0' : '-1',
                  ref: 'focusableStartRef',
                  style: focusableStyle,
                  onFocus: this.handleStartFocus
              }),
              defaultSlot(),
              h('div', {
                  'aria-hidden': 'true',
                  style: focusableStyle,
                  ref: 'focusableEndRef',
                  tabindex: active ? '0' : '-1',
                  onFocus: this.handleEndFocus
              })
          ]);
      }
  });

  function useOnResize(elRef, onResize) {
      // it needn't be reactive since it's for internal usage
      if (onResize) {
          onMounted(() => {
              const { value: el } = elRef;
              if (el) {
                  resizeObserverManager.registerHandler(el, onResize);
              }
          });
          onBeforeUnmount(() => {
              const { value: el } = elRef;
              if (el) {
                  resizeObserverManager.unregisterHandler(el);
              }
          });
      }
  }

  let lockCount = 0;
  let originalMarginRight = '';
  let originalOverflow = '';
  let originalOverflowX = '';
  let originalOverflowY = '';
  const lockHtmlScrollRightCompensationRef = ref('0px');
  function useLockHtmlScroll(lockRef) {
      // not browser
      if (typeof document === 'undefined')
          return;
      const el = document.documentElement;
      let watchStopHandle;
      let activated = false;
      const unlock = () => {
          el.style.marginRight = originalMarginRight;
          el.style.overflow = originalOverflow;
          el.style.overflowX = originalOverflowX;
          el.style.overflowY = originalOverflowY;
          lockHtmlScrollRightCompensationRef.value = '0px';
      };
      onMounted(() => {
          watchStopHandle = watch(lockRef, (value) => {
              if (value) {
                  if (!lockCount) {
                      const scrollbarWidth = window.innerWidth - el.offsetWidth;
                      if (scrollbarWidth > 0) {
                          originalMarginRight = el.style.marginRight;
                          el.style.marginRight = `${scrollbarWidth}px`;
                          lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
                      }
                      originalOverflow = el.style.overflow;
                      originalOverflowX = el.style.overflowX;
                      originalOverflowY = el.style.overflowY;
                      el.style.overflow = 'hidden';
                      el.style.overflowX = 'hidden';
                      el.style.overflowY = 'hidden';
                  }
                  activated = true;
                  lockCount++;
              }
              else {
                  lockCount--;
                  if (!lockCount) {
                      unlock();
                  }
                  activated = false;
              }
          }, {
              immediate: true
          });
      });
      onBeforeUnmount(() => {
          watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
          if (activated) {
              lockCount--;
              if (!lockCount) {
                  unlock();
              }
              activated = false;
          }
      });
  }

  const isComposingRef = ref(false);
  const compositionStartHandler = () => {
      isComposingRef.value = true;
  };
  const compositionEndHandler = () => {
      isComposingRef.value = false;
  };
  let mountedCount = 0;
  const useIsComposing = () => {
      if (isBrowser$2) {
          onBeforeMount(() => {
              if (!mountedCount) {
                  window.addEventListener('compositionstart', compositionStartHandler);
                  window.addEventListener('compositionend', compositionEndHandler);
              }
              mountedCount++;
          });
          onBeforeUnmount(() => {
              if (mountedCount <= 1) {
                  window.removeEventListener('compositionstart', compositionStartHandler);
                  window.removeEventListener('compositionend', compositionEndHandler);
                  mountedCount = 0;
              }
              else {
                  mountedCount--;
              }
          });
      }
      return isComposingRef;
  };

  function useReactivated(callback) {
      const isDeactivatedRef = { isDeactivated: false };
      let activateStateInitialized = false;
      onActivated(() => {
          isDeactivatedRef.isDeactivated = false;
          if (!activateStateInitialized) {
              activateStateInitialized = true;
              return;
          }
          callback();
      });
      onDeactivated(() => {
          isDeactivatedRef.isDeactivated = true;
          if (!activateStateInitialized) {
              activateStateInitialized = true;
          }
      });
      return isDeactivatedRef;
  }

  function isDocument(node) {
      return node.nodeName === '#document';
  }

  const formItemInjectionKey = createInjectionKey('n-form-item');
  function useFormItem(props, { defaultSize = 'medium', mergedSize, mergedDisabled } = {}) {
      const NFormItem = inject(formItemInjectionKey, null);
      provide(formItemInjectionKey, null);
      const mergedSizeRef = computed(mergedSize
          ? () => mergedSize(NFormItem)
          : () => {
              const { size } = props;
              if (size)
                  return size;
              if (NFormItem) {
                  const { mergedSize } = NFormItem;
                  if (mergedSize.value !== undefined) {
                      return mergedSize.value;
                  }
              }
              return defaultSize;
          });
      const mergedDisabledRef = computed(mergedDisabled
          ? () => mergedDisabled(NFormItem)
          : () => {
              const { disabled } = props;
              if (disabled !== undefined) {
                  return disabled;
              }
              if (NFormItem) {
                  return NFormItem.disabled.value;
              }
              return false;
          });
      const mergedStatusRef = computed(() => {
          const { status } = props;
          if (status)
              return status;
          return NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.mergedValidationStatus.value;
      });
      onBeforeUnmount(() => {
          if (NFormItem) {
              NFormItem.restoreValidation();
          }
      });
      return {
          mergedSizeRef,
          mergedDisabledRef,
          mergedStatusRef,
          nTriggerFormBlur() {
              if (NFormItem) {
                  NFormItem.handleContentBlur();
              }
          },
          nTriggerFormChange() {
              if (NFormItem) {
                  NFormItem.handleContentChange();
              }
          },
          nTriggerFormFocus() {
              if (NFormItem) {
                  NFormItem.handleContentFocus();
              }
          },
          nTriggerFormInput() {
              if (NFormItem) {
                  NFormItem.handleContentInput();
              }
          }
      };
  }

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  var freeGlobal$1 = freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal$1 || freeSelf || Function('return this')();

  var root$1 = root;

  /** Built-in value references. */
  var Symbol$1 = root$1.Symbol;

  var Symbol$2 = Symbol$1;

  /** Used for built-in method references. */
  var objectProto$e = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$b = objectProto$e.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$e.toString;

  /** Built-in value references. */
  var symToStringTag$1 = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag(value) {
    var isOwn = hasOwnProperty$b.call(value, symToStringTag$1),
        tag = value[symToStringTag$1];

    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}

    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$d = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$d.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
      undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = Symbol$2 ? Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return (symToStringTag && symToStringTag in Object(value))
      ? getRawTag(value)
      : objectToString(value);
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return value != null && typeof value == 'object';
  }

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol(value) {
    return typeof value == 'symbol' ||
      (isObjectLike(value) && baseGetTag(value) == symbolTag$1);
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray = Array.isArray;

  var isArray$1 = isArray;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
      symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$1(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap(value, baseToString) + '';
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
  }

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == 'object' || type == 'function');
  }

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? (other + '') : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return (isBinary || reIsOctal.test(value))
      ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
      : (reIsBadHex.test(value) ? NAN : +value);
  }

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0,
      MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY$1 || value === -INFINITY$1) {
      var sign = (value < 0 ? -1 : 1);
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger$3(value) {
    var result = toFinite(value),
        remainder = result % 1;

    return result === result ? (remainder ? result - remainder : result) : 0;
  }

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
      funcTag$1 = '[object Function]',
      genTag = '[object GeneratorFunction]',
      proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root$1['__core-js_shared__'];

  var coreJsData$1 = coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /** Used for built-in method references. */
  var funcProto$2 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$2 = funcProto$2.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString$2.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype,
      objectProto$c = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$a = objectProto$c.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue$1(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /* Built-in method references that are verified to be native. */
  var WeakMap$1 = getNative(root$1, 'WeakMap');

  var WeakMap$2 = WeakMap$1;

  /** Built-in value references. */
  var objectCreate = Object.create;

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} proto The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function object() {}
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object;
      object.prototype = undefined;
      return result;
    };
  }());

  var baseCreate$1 = baseCreate;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut(func) {
    var count = 0,
        lastCalled = 0;

    return function() {
      var stamp = nativeNow(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  var defineProperty = (function() {
    try {
      var func = getNative(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }());

  var defineProperty$1 = defineProperty;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString = !defineProperty$1 ? identity : function(func, string) {
    return defineProperty$1(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };

  var baseSetToString$1 = baseSetToString;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString = shortOut(baseSetToString$1);

  var setToString$1 = setToString;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER$1 : length;

    return !!length &&
      (type == 'number' ||
        (type != 'symbol' && reIsUint.test(value))) &&
          (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * The base implementation of `assignValue` and `assignMergeValue` without
   * value checks.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function baseAssignValue(object, key, value) {
    if (key == '__proto__' && defineProperty$1) {
      defineProperty$1(object, key, {
        'configurable': true,
        'enumerable': true,
        'value': value,
        'writable': true
      });
    } else {
      object[key] = value;
    }
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$9 = objectProto$b.hasOwnProperty;

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      if (newValue === undefined) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest(func, start, transform) {
    start = nativeMax$1(start === undefined ? (func.length - 1) : start, 0);
    return function() {
      var args = arguments,
          index = -1,
          length = nativeMax$1(args.length - start, 0),
          array = Array(length);

      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest(func, start) {
    return setToString$1(overRest(func, start, identity), func + '');
  }

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }

  /**
   * Checks if the given arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
   *  else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number'
          ? (isArrayLike(object) && isIndex(index, object.length))
          : (type == 'string' && index in object)
        ) {
      return eq(object[index], value);
    }
    return false;
  }

  /**
   * Creates a function like `_.assign`.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1,
          length = sources.length,
          customizer = length > 1 ? sources[length - 1] : undefined,
          guard = length > 2 ? sources[2] : undefined;

      customizer = (assigner.length > 3 && typeof customizer == 'function')
        ? (length--, customizer)
        : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto$a;

    return value === proto;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag$2;
  }

  /** Used for built-in method references. */
  var objectProto$9 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$9.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty$8.call(value, 'callee') &&
      !propertyIsEnumerable$1.call(value, 'callee');
  };

  var isArguments$1 = isArguments;

  function getDefaultExportFromCjs (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  /** Detect free variable `exports`. */
  var freeExports$2 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$2 = freeExports$2 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;

  /** Built-in value references. */
  var Buffer$1 = moduleExports$2 ? root$1.Buffer : undefined;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined;

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  var isBuffer$1 = isBuffer;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
      arrayTag$1 = '[object Array]',
      boolTag$1 = '[object Boolean]',
      dateTag$1 = '[object Date]',
      errorTag$1 = '[object Error]',
      funcTag = '[object Function]',
      mapTag$2 = '[object Map]',
      numberTag$1 = '[object Number]',
      objectTag$3 = '[object Object]',
      regexpTag$1 = '[object RegExp]',
      setTag$2 = '[object Set]',
      stringTag$1 = '[object String]',
      weakMapTag$1 = '[object WeakMap]';

  var arrayBufferTag$1 = '[object ArrayBuffer]',
      dataViewTag$2 = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] =
  typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] =
  typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] =
  typedArrayTags[errorTag$1] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] =
  typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] =
  typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] =
  typedArrayTags[weakMapTag$1] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray(value) {
    return isObjectLike(value) &&
      isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /** Detect free variable `exports`. */
  var freeExports$1 = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule$1 = freeExports$1 && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports$1 && freeGlobal$1.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule$1 && freeModule$1.require && freeModule$1.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  var nodeUtil$1 = nodeUtil;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil$1 && nodeUtil$1.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  var isTypedArray$1 = isTypedArray;

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$8.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray$1(value),
        isArg = !isArr && isArguments$1(value),
        isBuff = !isArr && !isArg && isBuffer$1(value),
        isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
        skipIndexes = isArr || isArg || isBuff || isType,
        result = skipIndexes ? baseTimes(value.length, String) : [],
        length = result.length;

    for (var key in value) {
      if ((inherited || hasOwnProperty$7.call(value, key)) &&
          !(skipIndexes && (
             // Safari 9 has enumerable `arguments.length` in strict mode.
             key == 'length' ||
             // Node.js 0.10 has enumerable non-index properties on buffers.
             (isBuff && (key == 'offset' || key == 'parent')) ||
             // PhantomJS 2 has enumerable non-index properties on typed arrays.
             (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
             // Skip index properties.
             isIndex(key, length)
          ))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys = overArg(Object.keys, Object);

  var nativeKeys$1 = nativeKeys;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$7.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys$1(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$6.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This function is like
   * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * except that it includes inherited enumerable properties.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$6.hasOwnProperty;

  /**
   * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object),
        result = [];

    for (var key in object) {
      if (!(key == 'constructor' && (isProto || !hasOwnProperty$5.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey(value, object) {
    if (isArray$1(value)) {
      return false;
    }
    var type = typeof value;
    if (type == 'number' || type == 'symbol' || type == 'boolean' ||
        value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
      (object != null && value in Object(object));
  }

  /* Built-in method references that are verified to be native. */
  var nativeCreate = getNative(Object, 'create');

  var nativeCreate$1 = nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate$1) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$4.call(data, key) ? data[key] : undefined;
  }

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate$1 ? (data[key] !== undefined) : hasOwnProperty$3.call(data, key);
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
    return this;
  }

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /* Built-in method references that are verified to be native. */
  var Map$1 = getNative(root$1, 'Map');

  var Map$2 = Map$1;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$2 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    var result = getMapData(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    var data = getMapData(this, key),
        size = data.size;

    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries == null ? 0 : entries.length;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$2 = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize(func, resolver) {
    if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
      throw new TypeError(FUNC_ERROR_TEXT$2);
    }
    var memoized = function() {
      var args = arguments,
          key = resolver ? resolver.apply(this, args) : args[0],
          cache = memoized.cache;

      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache);
    return memoized;
  }

  // Expose `MapCache`.
  memoize.Cache = MapCache;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped(func) {
    var result = memoize(func, function(key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });

    var cache = result.cache;
    return result;
  }

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath = memoizeCapped(function(string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function(match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
    });
    return result;
  });

  var stringToPath$1 = stringToPath;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString(value) {
    return value == null ? '' : baseToString(value);
  }

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath(value, object) {
    if (isArray$1(value)) {
      return value;
    }
    return isKey(value, object) ? [value] : stringToPath$1(toString(value));
  }

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey(value) {
    if (typeof value == 'string' || isSymbol(value)) {
      return value;
    }
    var result = (value + '');
    return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  }

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet(object, path) {
    path = castPath(path, object);

    var index = 0,
        length = path.length;

    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return (index && index == length) ? object : undefined;
  }

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet(object, path);
    return result === undefined ? defaultValue : result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /** Built-in value references. */
  var getPrototype = overArg(Object.getPrototypeOf, Object);

  var getPrototype$1 = getPrototype;

  /** `Object#toString` result references. */
  var objectTag$2 = '[object Object]';

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
      objectProto$3 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$3.hasOwnProperty;

  /** Used to infer the `Object` constructor. */
  var objectCtorString = funcToString.call(Object);

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * @static
   * @memberOf _
   * @since 0.8.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
      return false;
    }
    var proto = getPrototype$1(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty$2.call(proto, 'constructor') && proto.constructor;
    return typeof Ctor == 'function' && Ctor instanceof Ctor &&
      funcToString.call(Ctor) == objectCtorString;
  }

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return (!start && end >= length) ? array : baseSlice(array, start, end);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = '\\ud800-\\udfff',
      rsComboMarksRange$3 = '\\u0300-\\u036f',
      reComboHalfMarksRange$3 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$3 = '\\u20d0-\\u20ff',
      rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
      rsVarRange$2 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsZWJ$2 = '\\u200d';

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2  + rsComboRange$3 + rsVarRange$2 + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = '\\ud800-\\udfff',
      rsComboMarksRange$2 = '\\u0300-\\u036f',
      reComboHalfMarksRange$2 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$2 = '\\u20d0-\\u20ff',
      rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
      rsVarRange$1 = '\\ufe0e\\ufe0f';

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
      rsCombo$2 = '[' + rsComboRange$2 + ']',
      rsFitz$1 = '\\ud83c[\\udffb-\\udfff]',
      rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
      rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
      rsRegional$1 = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair$1 = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsZWJ$1 = '\\u200d';

  /** Used to compose unicode regexes. */
  var reOptMod$1 = rsModifier$1 + '?',
      rsOptVar$1 = '[' + rsVarRange$1 + ']?',
      rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
      rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
      rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst(methodName) {
    return function(string) {
      string = toString(string);

      var strSymbols = hasUnicode(string)
        ? stringToArray(string)
        : undefined;

      var chr = strSymbols
        ? strSymbols[0]
        : string.charAt(0);

      var trailing = strSymbols
        ? castSlice(strSymbols, 1).join('')
        : string.slice(1);

      return chr[methodName]() + trailing;
    };
  }

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst = createCaseFirst('toUpperCase');

  var upperFirst$1 = upperFirst;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize(string) {
    return upperFirst$1(toString(string).toLowerCase());
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  var deburrLetter$1 = deburrLetter;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange$1 = '\\u0300-\\u036f',
      reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
      rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

  /** Used to compose unicode capture groups. */
  var rsCombo$1 = '[' + rsComboRange$1 + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo$1, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('dj vu');
   * // => 'deja vu'
   */
  function deburr(string) {
    string = toString(string);
    return string && string.replace(reLatin, deburrLetter$1).replace(reComboMark, '');
  }

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos$1 = "['\u2019]",
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words(string, pattern, guard) {
    string = toString(string);
    pattern = guard ? undefined : pattern;

    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder(callback) {
    return function(string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function(result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });

  var camelCase$1 = camelCase;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeIsFinite = root$1.isFinite,
      nativeMin$1 = Math.min;

  /**
   * Creates a function like `_.round`.
   *
   * @private
   * @param {string} methodName The name of the `Math` method to use when rounding.
   * @returns {Function} Returns the new round function.
   */
  function createRound(methodName) {
    var func = Math[methodName];
    return function(number, precision) {
      number = toNumber(number);
      precision = precision == null ? 0 : nativeMin$1(toInteger$3(precision), 292);
      if (precision && nativeIsFinite(number)) {
        // Shift with exponential notation to avoid floating-point issues.
        // See [MDN](https://mdn.io/round#Examples) for more details.
        var pair = (toString(number) + 'e').split('e'),
            value = func(pair[0] + 'e' + (+pair[1] + precision));

        pair = (toString(value) + 'e').split('e');
        return +(pair[0] + 'e' + (+pair[1] - precision));
      }
      return func(number);
    };
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
    this.size = 0;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    var data = this.__data__,
        result = data['delete'](key);

    this.size = data.size;
    return result;
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map$2 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Built-in value references. */
  var Buffer = moduleExports ? root$1.Buffer : undefined,
      allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length,
        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

    buffer.copy(result);
    return result;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function(symbol) {
      return propertyIsEnumerable.call(object, symbol);
    });
  };

  var getSymbols$1 = getSymbols;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys, getSymbols$1);
  }

  /* Built-in method references that are verified to be native. */
  var DataView = getNative(root$1, 'DataView');

  var DataView$1 = DataView;

  /* Built-in method references that are verified to be native. */
  var Promise$1 = getNative(root$1, 'Promise');

  var Promise$2 = Promise$1;

  /* Built-in method references that are verified to be native. */
  var Set$1 = getNative(root$1, 'Set');

  var Set$2 = Set$1;

  /** `Object#toString` result references. */
  var mapTag$1 = '[object Map]',
      objectTag$1 = '[object Object]',
      promiseTag = '[object Promise]',
      setTag$1 = '[object Set]',
      weakMapTag = '[object WeakMap]';

  var dataViewTag$1 = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView$1),
      mapCtorString = toSource(Map$2),
      promiseCtorString = toSource(Promise$2),
      setCtorString = toSource(Set$2),
      weakMapCtorString = toSource(WeakMap$2);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$1) ||
      (Map$2 && getTag(new Map$2) != mapTag$1) ||
      (Promise$2 && getTag(Promise$2.resolve()) != promiseTag) ||
      (Set$2 && getTag(new Set$2) != setTag$1) ||
      (WeakMap$2 && getTag(new WeakMap$2) != weakMapTag)) {
    getTag = function(value) {
      var result = baseGetTag(value),
          Ctor = result == objectTag$1 ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : '';

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag$1;
          case mapCtorString: return mapTag$1;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag$1;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  var getTag$1 = getTag;

  /** Built-in value references. */
  var Uint8Array = root$1.Uint8Array;

  var Uint8Array$1 = Uint8Array;

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate$1(getPrototype$1(object))
      : {};
  }

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas(value) {
    return this.__data__.has(value);
  }

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var index = -1,
        length = values == null ? 0 : values.length;

    this.__data__ = new MapCache;
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
      COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
        arrLength = array.length,
        othLength = other.length;

    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
        result = true,
        seen = (bitmask & COMPARE_UNORDERED_FLAG$3) ? new SetCache : undefined;

    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, arrValue, index, other, array, stack)
          : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function(othValue, othIndex) {
              if (!cacheHas(seen, othIndex) &&
                  (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
          result = false;
          break;
        }
      } else if (!(
            arrValue === othValue ||
              equalFunc(arrValue, othValue, bitmask, customizer, stack)
          )) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
      COMPARE_UNORDERED_FLAG$2 = 2;

  /** `Object#toString` result references. */
  var boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$2 ? Symbol$2.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag:
        if ((object.byteLength != other.byteLength) ||
            (object.byteOffset != other.byteOffset)) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;

      case arrayBufferTag:
        if ((object.byteLength != other.byteLength) ||
            !equalFunc(new Uint8Array$1(object), new Uint8Array$1(other))) {
          return false;
        }
        return true;

      case boolTag:
      case dateTag:
      case numberTag:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == (other + '');

      case mapTag:
        var convert = mapToArray;

      case setTag:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);

        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;

      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
        objProps = getAllKeys(object),
        objLength = objProps.length,
        othProps = getAllKeys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);

    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
          othValue = other[key];

      if (customizer) {
        var compared = isPartial
          ? customizer(othValue, objValue, key, other, object, stack)
          : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined
            ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
            : compared
          )) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      objectTag = '[object Object]';

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$1(object),
        othIsArr = isArray$1(other),
        objTag = objIsArr ? arrayTag : getTag$1(object),
        othTag = othIsArr ? arrayTag : getTag$1(other);

    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;

    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && isBuffer$1(object)) {
      if (!isBuffer$1(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack);
      return (objIsArr || isTypedArray$1(object))
        ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
        : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
          othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
            othUnwrapped = othIsWrapped ? other.value() : other;

        stack || (stack = new Stack);
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack);
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
      COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length,
        length = index,
        noCustomizer = !customizer;

    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if ((noCustomizer && data[2])
            ? data[1] !== object[data[0]]
            : !(data[0] in object)
          ) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
          objValue = object[key],
          srcValue = data[1];

      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack;
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined
              ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack)
              : result
            )) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData(object) {
    var result = keys(object),
        length = result.length;

    while (length--) {
      var key = result[length],
          value = object[key];

      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue &&
        (srcValue !== undefined || (key in Object(object)));
    };
  }

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath(object, path, hasFunc) {
    path = castPath(path, object);

    var index = -1,
        length = path.length,
        result = false;

    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) &&
      (isArray$1(object) || isArguments$1(object));
  }

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return (objValue === undefined && objValue === srcValue)
        ? hasIn(object, path)
        : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == 'object') {
      return isArray$1(value)
        ? baseMatchesProperty(value[0], value[1])
        : baseMatches(value);
    }
    return property(value);
  }

  /**
   * Creates a base function for methods like `_.forIn` and `_.forOwn`.
   *
   * @private
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1,
          iterable = Object(object),
          props = keysFunc(object),
          length = props.length;

      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }

  /**
   * The base implementation of `baseForOwn` which iterates over `object`
   * properties returned by `keysFunc` and invokes `iteratee` for each property.
   * Iteratee functions may exit iteration early by explicitly returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  var baseFor = createBaseFor();

  var baseFor$1 = baseFor;

  /**
   * The base implementation of `_.forOwn` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return object && baseFor$1(object, iteratee, keys);
  }

  /**
   * Creates a `baseEach` or `baseEachRight` function.
   *
   * @private
   * @param {Function} eachFunc The function to iterate over a collection.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {Function} Returns the new base function.
   */
  function createBaseEach(eachFunc, fromRight) {
    return function(collection, iteratee) {
      if (collection == null) {
        return collection;
      }
      if (!isArrayLike(collection)) {
        return eachFunc(collection, iteratee);
      }
      var length = collection.length,
          index = fromRight ? length : -1,
          iterable = Object(collection);

      while ((fromRight ? index-- : ++index < length)) {
        if (iteratee(iterable[index], index, iterable) === false) {
          break;
        }
      }
      return collection;
    };
  }

  /**
   * The base implementation of `_.forEach` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object} Returns `collection`.
   */
  var baseEach = createBaseEach(baseForOwn);

  var baseEach$1 = baseEach;

  /**
   * Gets the timestamp of the number of milliseconds that have elapsed since
   * the Unix epoch (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Date
   * @returns {number} Returns the timestamp.
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => Logs the number of milliseconds it took for the deferred invocation.
   */
  var now = function() {
    return root$1.Date.now();
  };

  var now$1 = now;

  /** Error message constants. */
  var FUNC_ERROR_TEXT$1 = 'Expected a function';

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max,
      nativeMin = Math.min;

  /**
   * Creates a debounced function that delays invoking `func` until after `wait`
   * milliseconds have elapsed since the last time the debounced function was
   * invoked. The debounced function comes with a `cancel` method to cancel
   * delayed `func` invocations and a `flush` method to immediately invoke them.
   * Provide `options` to indicate whether `func` should be invoked on the
   * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
   * with the last arguments provided to the debounced function. Subsequent
   * calls to the debounced function return the result of the last `func`
   * invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the debounced function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.debounce` and `_.throttle`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to debounce.
   * @param {number} [wait=0] The number of milliseconds to delay.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=false]
   *  Specify invoking on the leading edge of the timeout.
   * @param {number} [options.maxWait]
   *  The maximum time `func` is allowed to be delayed before it's invoked.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // Avoid costly calculations while the window size is in flux.
   * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
   *
   * // Invoke `sendMail` when clicked, debouncing subsequent calls.
   * jQuery(element).on('click', _.debounce(sendMail, 300, {
   *   'leading': true,
   *   'trailing': false
   * }));
   *
   * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
   * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
   * var source = new EventSource('/stream');
   * jQuery(source).on('message', debounced);
   *
   * // Cancel the trailing debounced invocation.
   * jQuery(window).on('popstate', debounced.cancel);
   */
  function debounce(func, wait, options) {
    var lastArgs,
        lastThis,
        maxWait,
        result,
        timerId,
        lastCallTime,
        lastInvokeTime = 0,
        leading = false,
        maxing = false,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT$1);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = 'maxWait' in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }

    function invokeFunc(time) {
      var args = lastArgs,
          thisArg = lastThis;

      lastArgs = lastThis = undefined;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }

    function leadingEdge(time) {
      // Reset any `maxWait` timer.
      lastInvokeTime = time;
      // Start the timer for the trailing edge.
      timerId = setTimeout(timerExpired, wait);
      // Invoke the leading edge.
      return leading ? invokeFunc(time) : result;
    }

    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime,
          timeWaiting = wait - timeSinceLastCall;

      return maxing
        ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
        : timeWaiting;
    }

    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime,
          timeSinceLastInvoke = time - lastInvokeTime;

      // Either this is the first call, activity has stopped and we're at the
      // trailing edge, the system time has gone backwards and we're treating
      // it as the trailing edge, or we've hit the `maxWait` limit.
      return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
        (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
    }

    function timerExpired() {
      var time = now$1();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      // Restart the timer.
      timerId = setTimeout(timerExpired, remainingWait(time));
    }

    function trailingEdge(time) {
      timerId = undefined;

      // Only invoke if we have `lastArgs` which means `func` has been
      // debounced at least once.
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = undefined;
      return result;
    }

    function cancel() {
      if (timerId !== undefined) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = undefined;
    }

    function flush() {
      return timerId === undefined ? result : trailingEdge(now$1());
    }

    function debounced() {
      var time = now$1(),
          isInvoking = shouldInvoke(time);

      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;

      if (isInvoking) {
        if (timerId === undefined) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          // Handle invocations in a tight loop.
          clearTimeout(timerId);
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === undefined) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }

  /**
   * This function is like `assignValue` except that it doesn't assign
   * `undefined` values.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignMergeValue(object, key, value) {
    if ((value !== undefined && !eq(object[key], value)) ||
        (value === undefined && !(key in object))) {
      baseAssignValue(object, key, value);
    }
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function safeGet(object, key) {
    if (key === 'constructor' && typeof object[key] === 'function') {
      return;
    }

    if (key == '__proto__') {
      return;
    }

    return object[key];
  }

  /**
   * Converts `value` to a plain object flattening inherited enumerable string
   * keyed properties of `value` to own properties of the plain object.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {Object} Returns the converted plain object.
   * @example
   *
   * function Foo() {
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.assign({ 'a': 1 }, new Foo);
   * // => { 'a': 1, 'b': 2 }
   *
   * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
   * // => { 'a': 1, 'b': 2, 'c': 3 }
   */
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }

  /**
   * A specialized version of `baseMerge` for arrays and objects which performs
   * deep merges and tracks traversed objects enabling objects with circular
   * references to be merged.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {string} key The key of the value to merge.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} mergeFunc The function to merge values.
   * @param {Function} [customizer] The function to customize assigned values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key),
        srcValue = safeGet(source, key),
        stacked = stack.get(srcValue);

    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer
      ? customizer(objValue, srcValue, (key + ''), object, source, stack)
      : undefined;

    var isCommon = newValue === undefined;

    if (isCommon) {
      var isArr = isArray$1(srcValue),
          isBuff = !isArr && isBuffer$1(srcValue),
          isTyped = !isArr && !isBuff && isTypedArray$1(srcValue);

      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray$1(objValue)) {
          newValue = objValue;
        }
        else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        }
        else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        }
        else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        }
        else {
          newValue = [];
        }
      }
      else if (isPlainObject(srcValue) || isArguments$1(srcValue)) {
        newValue = objValue;
        if (isArguments$1(objValue)) {
          newValue = toPlainObject(objValue);
        }
        else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      }
      else {
        isCommon = false;
      }
    }
    if (isCommon) {
      // Recursively merge objects and arrays (susceptible to call stack limits).
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack['delete'](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }

  /**
   * The base implementation of `_.merge` without support for multiple sources.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {number} srcIndex The index of `source`.
   * @param {Function} [customizer] The function to customize merged values.
   * @param {Object} [stack] Tracks traversed source values and their merged
   *  counterparts.
   */
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor$1(source, function(srcValue, key) {
      stack || (stack = new Stack);
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      }
      else {
        var newValue = customizer
          ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
          : undefined;

        if (newValue === undefined) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }

  /**
   * The base implementation of `_.map` without support for iteratee shorthands.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var index = -1,
        result = isArrayLike(collection) ? Array(collection.length) : [];

    baseEach$1(collection, function(value, key, collection) {
      result[++index] = iteratee(value, key, collection);
    });
    return result;
  }

  /**
   * Creates an array of values by running each element in `collection` thru
   * `iteratee`. The iteratee is invoked with three arguments:
   * (value, index|key, collection).
   *
   * Many lodash methods are guarded to work as iteratees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
   * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
   * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
   * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Collection
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function square(n) {
   *   return n * n;
   * }
   *
   * _.map([4, 8], square);
   * // => [16, 64]
   *
   * _.map({ 'a': 4, 'b': 8 }, square);
   * // => [16, 64] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // The `_.property` iteratee shorthand.
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee) {
    var func = isArray$1(collection) ? arrayMap : baseMap;
    return func(collection, baseIteratee(iteratee));
  }

  /**
   * Converts `string` to
   * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the kebab cased string.
   * @example
   *
   * _.kebabCase('Foo Bar');
   * // => 'foo-bar'
   *
   * _.kebabCase('fooBar');
   * // => 'foo-bar'
   *
   * _.kebabCase('__FOO_BAR__');
   * // => 'foo-bar'
   */
  var kebabCase = createCompounder(function(result, word, index) {
    return result + (index ? '-' : '') + word.toLowerCase();
  });

  var kebabCase$1 = kebabCase;

  /**
   * This method is like `_.assign` except that it recursively merges own and
   * inherited enumerable string keyed properties of source objects into the
   * destination object. Source properties that resolve to `undefined` are
   * skipped if a destination value exists. Array and plain object properties
   * are merged recursively. Other objects and value types are overridden by
   * assignment. Source objects are applied from left to right. Subsequent
   * sources overwrite property assignments of previous sources.
   *
   * **Note:** This method mutates `object`.
   *
   * @static
   * @memberOf _
   * @since 0.5.0
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var object = {
   *   'a': [{ 'b': 2 }, { 'd': 4 }]
   * };
   *
   * var other = {
   *   'a': [{ 'c': 3 }, { 'e': 5 }]
   * };
   *
   * _.merge(object, other);
   * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
   */
  var merge$1 = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });

  var merge$2 = merge$1;

  /**
   * Computes `number` rounded to `precision`.
   *
   * @static
   * @memberOf _
   * @since 3.10.0
   * @category Math
   * @param {number} number The number to round.
   * @param {number} [precision=0] The precision to round to.
   * @returns {number} Returns the rounded number.
   * @example
   *
   * _.round(4.006);
   * // => 4
   *
   * _.round(4.006, 2);
   * // => 4.01
   *
   * _.round(4060, -2);
   * // => 4100
   */
  var round = createRound('round');

  var round$1 = round;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a throttled function that only invokes `func` at most once per
   * every `wait` milliseconds. The throttled function comes with a `cancel`
   * method to cancel delayed `func` invocations and a `flush` method to
   * immediately invoke them. Provide `options` to indicate whether `func`
   * should be invoked on the leading and/or trailing edge of the `wait`
   * timeout. The `func` is invoked with the last arguments provided to the
   * throttled function. Subsequent calls to the throttled function return the
   * result of the last `func` invocation.
   *
   * **Note:** If `leading` and `trailing` options are `true`, `func` is
   * invoked on the trailing edge of the timeout only if the throttled function
   * is invoked more than once during the `wait` timeout.
   *
   * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
   * until to the next tick, similar to `setTimeout` with a timeout of `0`.
   *
   * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
   * for details over the differences between `_.throttle` and `_.debounce`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to throttle.
   * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
   * @param {Object} [options={}] The options object.
   * @param {boolean} [options.leading=true]
   *  Specify invoking on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true]
   *  Specify invoking on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // Avoid excessively updating the position while scrolling.
   * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
   *
   * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
   * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
   * jQuery(element).on('click', throttled);
   *
   * // Cancel the trailing throttled invocation.
   * jQuery(window).on('popstate', throttled.cancel);
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = 'leading' in options ? !!options.leading : leading;
      trailing = 'trailing' in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      'leading': leading,
      'maxWait': wait,
      'trailing': trailing
    });
  }

  var commonVariables$m = {
      fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
      fontFamilyMono: 'v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace',
      fontWeight: '400',
      fontWeightStrong: '500',
      cubicBezierEaseInOut: 'cubic-bezier(.4, 0, .2, 1)',
      cubicBezierEaseOut: 'cubic-bezier(0, 0, .2, 1)',
      cubicBezierEaseIn: 'cubic-bezier(.4, 0, 1, 1)',
      borderRadius: '3px',
      borderRadiusSmall: '2px',
      fontSize: '14px',
      fontSizeMini: '12px',
      fontSizeTiny: '12px',
      fontSizeSmall: '14px',
      fontSizeMedium: '14px',
      fontSizeLarge: '15px',
      fontSizeHuge: '16px',
      lineHeight: '1.6',
      heightMini: '16px', // private now, it's too small
      heightTiny: '22px',
      heightSmall: '28px',
      heightMedium: '34px',
      heightLarge: '40px',
      heightHuge: '46px'
  };

  const {
    fontSize,
    fontFamily,
    lineHeight: lineHeight$1
  } = commonVariables$m;
  // All the components need the style
  // It is static and won't be changed in the app's lifetime
  // If user want to overrides it they need to use `n-global-style` is provided
  //
  // Technically we can remove font-size & font-family & line-height to make
  // it pure. However the coding cost doesn't worth it.
  //
  // -webkit-tap-hilight-color:
  // https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-tap-highlight-color
  // In some android devices, there will be the style.
  var globalStyle = c$1('body', `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight$1};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1('input', `
 font-family: inherit;
 font-size: inherit;
 `)]);

  const configProviderInjectionKey = createInjectionKey('n-config-provider');

  const cssrAnchorMetaName = 'naive-ui-style';

  /* eslint-disable @typescript-eslint/consistent-type-assertions */
  function createTheme(theme) {
      return theme;
  }
  function useTheme(resolveId, mountId, style, defaultTheme, props, clsPrefixRef) {
      const ssrAdapter = useSsrAdapter();
      const NConfigProvider = inject(configProviderInjectionKey, null);
      if (style) {
          const mountStyle = () => {
              const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
              style.mount({
                  id: clsPrefix === undefined ? mountId : clsPrefix + mountId,
                  head: true,
                  props: {
                      bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
                  },
                  anchorMetaName: cssrAnchorMetaName,
                  ssr: ssrAdapter
              });
              if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
                  globalStyle.mount({
                      id: 'n-global',
                      head: true,
                      anchorMetaName: cssrAnchorMetaName,
                      ssr: ssrAdapter
                  });
              }
          };
          if (ssrAdapter) {
              mountStyle();
          }
          else {
              onBeforeMount(mountStyle);
          }
      }
      const mergedThemeRef = computed(() => {
          var _a;
          // keep props to make theme overrideable
          const { theme: { common: selfCommon, self, peers = {} } = {}, themeOverrides: selfOverrides = {}, builtinThemeOverrides: builtinOverrides = {} } = props;
          const { common: selfCommonOverrides, peers: peersOverrides } = selfOverrides;
          const { common: globalCommon = undefined, [resolveId]: { common: globalSelfCommon = undefined, self: globalSelf = undefined, peers: globalPeers = {} } = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value) || {};
          const { common: globalCommonOverrides = undefined, [resolveId]: globalSelfOverrides = {} } = (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value) || {};
          const { common: globalSelfCommonOverrides, peers: globalPeersOverrides = {} } = globalSelfOverrides;
          const mergedCommon = merge$2({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
          const mergedSelf = merge$2(
          // {}, executed every time, no need for empty obj
          (_a = (self || globalSelf || defaultTheme.self)) === null || _a === void 0 ? void 0 : _a(mergedCommon), builtinOverrides, globalSelfOverrides, selfOverrides);
          return {
              common: mergedCommon,
              self: mergedSelf,
              peers: merge$2({}, defaultTheme.peers, globalPeers, peers),
              peerOverrides: merge$2({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
          };
      });
      return mergedThemeRef;
  }
  useTheme.props = {
      theme: Object,
      themeOverrides: Object,
      builtinThemeOverrides: Object
  };

  const defaultClsPrefix = 'n';
  function useConfig(props = {}, options = {
      defaultBordered: true
  }) {
      const NConfigProvider = inject(configProviderInjectionKey, null);
      return {
          // NConfigProvider,
          inlineThemeDisabled: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled,
          mergedRtlRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef,
          mergedComponentPropsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef,
          mergedBreakpointsRef: NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef,
          mergedBorderedRef: computed(() => {
              var _a, _b;
              const { bordered } = props;
              if (bordered !== undefined)
                  return bordered;
              return ((_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true);
          }),
          mergedClsPrefixRef: NConfigProvider
              ? NConfigProvider.mergedClsPrefixRef
              : shallowRef(defaultClsPrefix),
          namespaceRef: computed(() => NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value)
      };
  }
  function useMergedClsPrefix() {
      const NConfigProvider = inject(configProviderInjectionKey, null);
      return NConfigProvider
          ? NConfigProvider.mergedClsPrefixRef
          : shallowRef(defaultClsPrefix);
  }

  const enUS$1 = {
      name: 'en-US',
      global: {
          undo: 'Undo',
          redo: 'Redo',
          confirm: 'Confirm',
          clear: 'Clear'
      },
      Popconfirm: {
          positiveText: 'Confirm',
          negativeText: 'Cancel'
      },
      Cascader: {
          placeholder: 'Please Select',
          loading: 'Loading',
          loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
      },
      Time: {
          dateFormat: 'yyyy-MM-dd',
          dateTimeFormat: 'yyyy-MM-dd HH:mm:ss'
      },
      DatePicker: {
          yearFormat: 'yyyy',
          monthFormat: 'MMM',
          dayFormat: 'eeeeee',
          yearTypeFormat: 'yyyy',
          monthTypeFormat: 'yyyy-MM',
          dateFormat: 'yyyy-MM-dd',
          dateTimeFormat: 'yyyy-MM-dd HH:mm:ss',
          quarterFormat: 'yyyy-qqq',
          clear: 'Clear',
          now: 'Now',
          confirm: 'Confirm',
          selectTime: 'Select Time',
          selectDate: 'Select Date',
          datePlaceholder: 'Select Date',
          datetimePlaceholder: 'Select Date and Time',
          monthPlaceholder: 'Select Month',
          yearPlaceholder: 'Select Year',
          quarterPlaceholder: 'Select Quarter',
          startDatePlaceholder: 'Start Date',
          endDatePlaceholder: 'End Date',
          startDatetimePlaceholder: 'Start Date and Time',
          endDatetimePlaceholder: 'End Date and Time',
          startMonthPlaceholder: 'Start Month',
          endMonthPlaceholder: 'End Month',
          monthBeforeYear: true,
          firstDayOfWeek: 6,
          today: 'Today'
      },
      DataTable: {
          checkTableAll: 'Select all in the table',
          uncheckTableAll: 'Unselect all in the table',
          confirm: 'Confirm',
          clear: 'Clear'
      },
      LegacyTransfer: {
          sourceTitle: 'Source',
          targetTitle: 'Target'
      },
      Transfer: {
          selectAll: 'Select all',
          unselectAll: 'Unselect all',
          clearAll: 'Clear',
          total: (num) => `Total ${num} items`,
          selected: (num) => `${num} items selected`
      },
      Empty: {
          description: 'No Data'
      },
      Select: {
          placeholder: 'Please Select'
      },
      TimePicker: {
          placeholder: 'Select Time',
          positiveText: 'OK',
          negativeText: 'Cancel',
          now: 'Now'
      },
      Pagination: {
          goto: 'Goto',
          selectionSuffix: 'page'
      },
      DynamicTags: {
          add: 'Add'
      },
      Log: {
          loading: 'Loading'
      },
      Input: {
          placeholder: 'Please Input'
      },
      InputNumber: {
          placeholder: 'Please Input'
      },
      DynamicInput: {
          create: 'Create'
      },
      ThemeEditor: {
          title: 'Theme Editor',
          clearAllVars: 'Clear All Variables',
          clearSearch: 'Clear Search',
          filterCompName: 'Filter Component Name',
          filterVarName: 'Filter Variable Name',
          import: 'Import',
          export: 'Export',
          restore: 'Reset to Default'
      },
      Image: {
          tipPrevious: 'Previous picture ()',
          tipNext: 'Next picture ()',
          tipCounterclockwise: 'Counterclockwise',
          tipClockwise: 'Clockwise',
          tipZoomOut: 'Zoom out',
          tipZoomIn: 'Zoom in',
          tipDownload: 'Download',
          tipClose: 'Close (Esc)',
          // TODO: translation
          tipOriginalSize: 'Zoom to original size'
      }
  };
  var enUS$2 = enUS$1;

  function buildFormatLongFn$1(args) {
    return function () {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      // TODO: Remove String()
      var width = options.width ? String(options.width) : args.defaultWidth;
      var format = args.formats[width] || args.formats[args.defaultWidth];
      return format;
    };
  }

  function requiredArgs$1(required, args) {
    if (args.length < required) {
      throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
    }
  }

  function _typeof$1(o) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, _typeof$1(o);
  }

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   *
   * @param {Date|Number} argument - the value to convert
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Clone the date:
   * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert the timestamp to date:
   * const result = toDate(1392098430000)
   * //=> Tue Feb 11 2014 11:30:30
   */
  function toDate$2(argument) {
    requiredArgs$1(1, arguments);
    var argStr = Object.prototype.toString.call(argument);

    // Clone the date
    if (argument instanceof Date || _typeof$1(argument) === 'object' && argStr === '[object Date]') {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime());
    } else if (typeof argument === 'number' || argStr === '[object Number]') {
      return new Date(argument);
    } else {
      if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
        // eslint-disable-next-line no-console
        console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
        // eslint-disable-next-line no-console
        console.warn(new Error().stack);
      }
      return new Date(NaN);
    }
  }

  function toInteger$2(dirtyNumber) {
    if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
      return NaN;
    }
    var number = Number(dirtyNumber);
    if (isNaN(number)) {
      return number;
    }
    return number < 0 ? Math.ceil(number) : Math.floor(number);
  }

  var defaultOptions$2 = {};
  function getDefaultOptions$1() {
    return defaultOptions$2;
  }

  function startOfUTCWeek$1(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs$1(1, arguments);
    var defaultOptions = getDefaultOptions$1();
    var weekStartsOn = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    var date = toDate$2(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }

  function buildLocalizeFn$1(args) {
    return function (dirtyIndex, options) {
      var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
      var valuesArray;
      if (context === 'formatting' && args.formattingValues) {
        var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        var _defaultWidth = args.defaultWidth;
        var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[_width] || args.values[_defaultWidth];
      }
      var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
      // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
      return valuesArray[index];
    };
  }

  function buildMatchFn$1(args) {
    return function (string) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var width = options.width;
      var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      var matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      var matchedString = matchResult[0];
      var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      }) : findKey(parsePatterns, function (pattern) {
        return pattern.test(matchedString);
      });
      var value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value: value,
        rest: rest
      };
    };
  }
  function findKey(object, predicate) {
    for (var key in object) {
      if (object.hasOwnProperty(key) && predicate(object[key])) {
        return key;
      }
    }
    return undefined;
  }
  function findIndex(array, predicate) {
    for (var key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return undefined;
  }

  function buildMatchPatternFn$1(args) {
    return function (string) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var matchResult = string.match(args.matchPattern);
      if (!matchResult) return null;
      var matchedString = matchResult[0];
      var parseResult = string.match(args.parsePattern);
      if (!parseResult) return null;
      var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      var rest = string.slice(matchedString.length);
      return {
        value: value,
        rest: rest
      };
    };
  }

  var formatDistanceLocale = {
    lessThanXSeconds: {
      one: 'less than a second',
      other: 'less than {{count}} seconds'
    },
    xSeconds: {
      one: '1 second',
      other: '{{count}} seconds'
    },
    halfAMinute: 'half a minute',
    lessThanXMinutes: {
      one: 'less than a minute',
      other: 'less than {{count}} minutes'
    },
    xMinutes: {
      one: '1 minute',
      other: '{{count}} minutes'
    },
    aboutXHours: {
      one: 'about 1 hour',
      other: 'about {{count}} hours'
    },
    xHours: {
      one: '1 hour',
      other: '{{count}} hours'
    },
    xDays: {
      one: '1 day',
      other: '{{count}} days'
    },
    aboutXWeeks: {
      one: 'about 1 week',
      other: 'about {{count}} weeks'
    },
    xWeeks: {
      one: '1 week',
      other: '{{count}} weeks'
    },
    aboutXMonths: {
      one: 'about 1 month',
      other: 'about {{count}} months'
    },
    xMonths: {
      one: '1 month',
      other: '{{count}} months'
    },
    aboutXYears: {
      one: 'about 1 year',
      other: 'about {{count}} years'
    },
    xYears: {
      one: '1 year',
      other: '{{count}} years'
    },
    overXYears: {
      one: 'over 1 year',
      other: 'over {{count}} years'
    },
    almostXYears: {
      one: 'almost 1 year',
      other: 'almost {{count}} years'
    }
  };
  var formatDistance$1 = function formatDistance(token, count, options) {
    var result;
    var tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === 'string') {
      result = tokenValue;
    } else if (count === 1) {
      result = tokenValue.one;
    } else {
      result = tokenValue.other.replace('{{count}}', count.toString());
    }
    if (options !== null && options !== void 0 && options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return 'in ' + result;
      } else {
        return result + ' ago';
      }
    }
    return result;
  };
  var formatDistance$2 = formatDistance$1;

  var dateFormats = {
    full: 'EEEE, MMMM do, y',
    long: 'MMMM do, y',
    medium: 'MMM d, y',
    short: 'MM/dd/yyyy'
  };
  var timeFormats = {
    full: 'h:mm:ss a zzzz',
    long: 'h:mm:ss a z',
    medium: 'h:mm:ss a',
    short: 'h:mm a'
  };
  var dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: '{{date}}, {{time}}',
    short: '{{date}}, {{time}}'
  };
  var formatLong$1 = {
    date: buildFormatLongFn$1({
      formats: dateFormats,
      defaultWidth: 'full'
    }),
    time: buildFormatLongFn$1({
      formats: timeFormats,
      defaultWidth: 'full'
    }),
    dateTime: buildFormatLongFn$1({
      formats: dateTimeFormats,
      defaultWidth: 'full'
    })
  };
  var formatLong$2 = formatLong$1;

  var formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: 'P'
  };
  var formatRelative$1 = function formatRelative(token, _date, _baseDate, _options) {
    return formatRelativeLocale[token];
  };
  var formatRelative$2 = formatRelative$1;

  var eraValues = {
    narrow: ['B', 'A'],
    abbreviated: ['BC', 'AD'],
    wide: ['Before Christ', 'Anno Domini']
  };
  var quarterValues = {
    narrow: ['1', '2', '3', '4'],
    abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
    wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
  };

  // Note: in English, the names of days of the week and months are capitalized.
  // If you are making a new locale based on this one, check if the same is true for the language you're working on.
  // Generally, formatted dates should look like they are in the middle of a sentence,
  // e.g. in Spanish language the weekdays and months should be in the lowercase.
  var monthValues = {
    narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
    abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
    wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  };
  var dayValues = {
    narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
    short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
    abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
    wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  };
  var dayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'morning',
      afternoon: 'afternoon',
      evening: 'evening',
      night: 'night'
    }
  };
  var formattingDayPeriodValues = {
    narrow: {
      am: 'a',
      pm: 'p',
      midnight: 'mi',
      noon: 'n',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    abbreviated: {
      am: 'AM',
      pm: 'PM',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    },
    wide: {
      am: 'a.m.',
      pm: 'p.m.',
      midnight: 'midnight',
      noon: 'noon',
      morning: 'in the morning',
      afternoon: 'in the afternoon',
      evening: 'in the evening',
      night: 'at night'
    }
  };
  var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
    var number = Number(dirtyNumber);

    // If ordinal numbers depend on context, for example,
    // if they are different for different grammatical genders,
    // use `options.unit`.
    //
    // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
    // 'day', 'hour', 'minute', 'second'.

    var rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + 'st';
        case 2:
          return number + 'nd';
        case 3:
          return number + 'rd';
      }
    }
    return number + 'th';
  };
  var localize$1 = {
    ordinalNumber: ordinalNumber,
    era: buildLocalizeFn$1({
      values: eraValues,
      defaultWidth: 'wide'
    }),
    quarter: buildLocalizeFn$1({
      values: quarterValues,
      defaultWidth: 'wide',
      argumentCallback: function argumentCallback(quarter) {
        return quarter - 1;
      }
    }),
    month: buildLocalizeFn$1({
      values: monthValues,
      defaultWidth: 'wide'
    }),
    day: buildLocalizeFn$1({
      values: dayValues,
      defaultWidth: 'wide'
    }),
    dayPeriod: buildLocalizeFn$1({
      values: dayPeriodValues,
      defaultWidth: 'wide',
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: 'wide'
    })
  };
  var localize$2 = localize$1;

  var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  var parseOrdinalNumberPattern = /\d+/i;
  var matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  var parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  var matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  var parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  var matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  var parseMonthPatterns = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  };
  var matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  var parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  var matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  var parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  var match$1 = {
    ordinalNumber: buildMatchPatternFn$1({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: function valueCallback(value) {
        return parseInt(value, 10);
      }
    }),
    era: buildMatchFn$1({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseEraPatterns,
      defaultParseWidth: 'any'
    }),
    quarter: buildMatchFn$1({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: 'any',
      valueCallback: function valueCallback(index) {
        return index + 1;
      }
    }),
    month: buildMatchFn$1({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: 'any'
    }),
    day: buildMatchFn$1({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: 'wide',
      parsePatterns: parseDayPatterns,
      defaultParseWidth: 'any'
    }),
    dayPeriod: buildMatchFn$1({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: 'any',
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: 'any'
    })
  };
  var match$2 = match$1;

  /**
   * @type {Locale}
   * @category Locales
   * @summary English locale (United States).
   * @language English
   * @iso-639-2 eng
   * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
   * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
   */
  var locale = {
    code: 'en-US',
    formatDistance: formatDistance$2,
    formatLong: formatLong$2,
    formatRelative: formatRelative$2,
    localize: localize$2,
    match: match$2,
    options: {
      weekStartsOn: 0 /* Sunday */,
      firstWeekContainsDate: 1
    }
  };
  var defaultLocale$1 = locale;

  const dateEnUs = {
      name: 'en-US',
      locale: defaultLocale$1
  };
  var dateEnUS = dateEnUs;

  /**
   * @name addDays
   * @category Day Helpers
   * @summary Add the specified number of days to the given date.
   *
   * @description
   * Add the specified number of days to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of days to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} - the new date with the days added
   * @throws {TypeError} - 2 arguments required
   *
   * @example
   * // Add 10 days to 1 September 2014:
   * const result = addDays(new Date(2014, 8, 1), 10)
   * //=> Thu Sep 11 2014 00:00:00
   */
  function addDays(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var amount = toInteger$2(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      // If 0 days, no-op to avoid changing times in the hour before end of DST
      return date;
    }
    date.setDate(date.getDate() + amount);
    return date;
  }

  /**
   * @name addMonths
   * @category Month Helpers
   * @summary Add the specified number of months to the given date.
   *
   * @description
   * Add the specified number of months to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of months to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} the new date with the months added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 5 months to 1 September 2014:
   * const result = addMonths(new Date(2014, 8, 1), 5)
   * //=> Sun Feb 01 2015 00:00:00
   */
  function addMonths(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var amount = toInteger$2(dirtyAmount);
    if (isNaN(amount)) {
      return new Date(NaN);
    }
    if (!amount) {
      // If 0 months, no-op to avoid changing times in the hour before end of DST
      return date;
    }
    var dayOfMonth = date.getDate();

    // The JS Date object supports date math by accepting out-of-bounds values for
    // month, day, etc. For example, new Date(2020, 0, 0) returns 31 Dec 2019 and
    // new Date(2020, 13, 1) returns 1 Feb 2021.  This is *almost* the behavior we
    // want except that dates will wrap around the end of a month, meaning that
    // new Date(2020, 13, 31) will return 3 Mar 2021 not 28 Feb 2021 as desired. So
    // we'll default to the end of the desired month by adding 1 to the desired
    // month and using a date of 0 to back up one day to the end of the desired
    // month.
    var endOfDesiredMonth = new Date(date.getTime());
    endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
    var daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      // If we're already at the end of the month, then this is the correct date
      // and we're done.
      return endOfDesiredMonth;
    } else {
      // Otherwise, we now know that setting the original day-of-month value won't
      // cause an overflow, so set the desired day-of-month. Note that we can't
      // just set the date of `endOfDesiredMonth` because that object may have had
      // its time changed in the unusual case where where a DST transition was on
      // the last day of the month and its local time was in the hour skipped or
      // repeated next to a DST transition.  So we use `date` instead which is
      // guaranteed to still have the original time.
      date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
      return date;
    }
  }

  /**
   * @name addMilliseconds
   * @category Millisecond Helpers
   * @summary Add the specified number of milliseconds to the given date.
   *
   * @description
   * Add the specified number of milliseconds to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} the new date with the milliseconds added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
   * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:30.750
   */
  function addMilliseconds$1(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var timestamp = toDate$2(dirtyDate).getTime();
    var amount = toInteger$2(dirtyAmount);
    return new Date(timestamp + amount);
  }

  /**
   * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
   * They usually appear for dates that denote time before the timezones were introduced
   * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
   * and GMT+01:00:00 after that date)
   *
   * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
   * which would lead to incorrect calculations.
   *
   * This function returns the timezone offset in milliseconds that takes seconds in account.
   */
  function getTimezoneOffsetInMilliseconds$2(date) {
    var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
    utcDate.setUTCFullYear(date.getFullYear());
    return date.getTime() - utcDate.getTime();
  }

  /**
   * @name startOfDay
   * @category Day Helpers
   * @summary Return the start of a day for the given date.
   *
   * @description
   * Return the start of a day for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a day
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a day for 2 September 2014 11:55:00:
   * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Sep 02 2014 00:00:00
   */
  function startOfDay(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name addQuarters
   * @category Quarter Helpers
   * @summary Add the specified number of year quarters to the given date.
   *
   * @description
   * Add the specified number of year quarters to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of quarters to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} the new date with the quarters added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 1 quarter to 1 September 2014:
   * const result = addQuarters(new Date(2014, 8, 1), 1)
   * //=> Mon Dec 01 2014 00:00:00
   */
  function addQuarters(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var amount = toInteger$2(dirtyAmount);
    var months = amount * 3;
    return addMonths(dirtyDate, months);
  }

  /**
   * @name addYears
   * @category Year Helpers
   * @summary Add the specified number of years to the given date.
   *
   * @description
   * Add the specified number of years to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of years to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} the new date with the years added
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Add 5 years to 1 September 2014:
   * const result = addYears(new Date(2014, 8, 1), 5)
   * //=> Sun Sep 01 2019 00:00:00
   */
  function addYears(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var amount = toInteger$2(dirtyAmount);
    return addMonths(dirtyDate, amount * 12);
  }

  /**
   * @name compareAsc
   * @category Common Helpers
   * @summary Compare the two dates and return -1, 0 or 1.
   *
   * @description
   * Compare the two dates and return 1 if the first date is after the second,
   * -1 if the first date is before the second or 0 if dates are equal.
   *
   * @param {Date|Number} dateLeft - the first date to compare
   * @param {Date|Number} dateRight - the second date to compare
   * @returns {Number} the result of the comparison
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Compare 11 February 1987 and 10 July 1989:
   * const result = compareAsc(new Date(1987, 1, 11), new Date(1989, 6, 10))
   * //=> -1
   *
   * @example
   * // Sort the array of dates:
   * const result = [
   *   new Date(1995, 6, 2),
   *   new Date(1987, 1, 11),
   *   new Date(1989, 6, 10)
   * ].sort(compareAsc)
   * //=> [
   * //   Wed Feb 11 1987 00:00:00,
   * //   Mon Jul 10 1989 00:00:00,
   * //   Sun Jul 02 1995 00:00:00
   * // ]
   */
  function compareAsc(dirtyDateLeft, dirtyDateRight) {
    requiredArgs$1(2, arguments);
    var dateLeft = toDate$2(dirtyDateLeft);
    var dateRight = toDate$2(dirtyDateRight);
    var diff = dateLeft.getTime() - dateRight.getTime();
    if (diff < 0) {
      return -1;
    } else if (diff > 0) {
      return 1;
      // Return 0 if diff is 0; return NaN if diff is NaN
    } else {
      return diff;
    }
  }

  /**
   * Days in 1 week.
   *
   * @name daysInWeek
   * @constant
   * @type {number}
   * @default
   */

  /**
   * Milliseconds in 1 minute
   *
   * @name millisecondsInMinute
   * @constant
   * @type {number}
   * @default
   */
  var millisecondsInMinute = 60000;

  /**
   * Milliseconds in 1 hour
   *
   * @name millisecondsInHour
   * @constant
   * @type {number}
   * @default
   */
  var millisecondsInHour = 3600000;

  /**
   * Milliseconds in 1 second
   *
   * @name millisecondsInSecond
   * @constant
   * @type {number}
   * @default
   */
  var millisecondsInSecond = 1000;

  /**
   * @name isSameDay
   * @category Day Helpers
   * @summary Are the given dates in the same day (and year and month)?
   *
   * @description
   * Are the given dates in the same day (and year and month)?
   *
   * @param {Date|Number} dateLeft - the first date to check
   * @param {Date|Number} dateRight - the second date to check
   * @returns {Boolean} the dates are in the same day (and year and month)
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
   * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
   * //=> true
   *
   * @example
   * // Are 4 September and 4 October in the same day?
   * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
   * //=> false
   *
   * @example
   * // Are 4 September, 2014 and 4 September, 2015 in the same day?
   * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
   * //=> false
   */
  function isSameDay(dirtyDateLeft, dirtyDateRight) {
    requiredArgs$1(2, arguments);
    var dateLeftStartOfDay = startOfDay(dirtyDateLeft);
    var dateRightStartOfDay = startOfDay(dirtyDateRight);
    return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
  }

  /**
   * @name isDate
   * @category Common Helpers
   * @summary Is the given value a date?
   *
   * @description
   * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
   *
   * @param {*} value - the value to check
   * @returns {boolean} true if the given value is a date
   * @throws {TypeError} 1 arguments required
   *
   * @example
   * // For a valid date:
   * const result = isDate(new Date())
   * //=> true
   *
   * @example
   * // For an invalid date:
   * const result = isDate(new Date(NaN))
   * //=> true
   *
   * @example
   * // For some value:
   * const result = isDate('2014-02-31')
   * //=> false
   *
   * @example
   * // For an object:
   * const result = isDate({})
   * //=> false
   */
  function isDate$1(value) {
    requiredArgs$1(1, arguments);
    return value instanceof Date || _typeof$1(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
  }

  /**
   * @name isValid
   * @category Common Helpers
   * @summary Is the given date valid?
   *
   * @description
   * Returns false if argument is Invalid Date and true otherwise.
   * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * Invalid Date is a Date, whose time value is NaN.
   *
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {*} date - the date to check
   * @returns {Boolean} the date is valid
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // For the valid date:
   * const result = isValid(new Date(2014, 1, 31))
   * //=> true
   *
   * @example
   * // For the value, convertable into a date:
   * const result = isValid(1393804800000)
   * //=> true
   *
   * @example
   * // For the invalid date:
   * const result = isValid(new Date(''))
   * //=> false
   */
  function isValid$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    if (!isDate$1(dirtyDate) && typeof dirtyDate !== 'number') {
      return false;
    }
    var date = toDate$2(dirtyDate);
    return !isNaN(Number(date));
  }

  /**
   * @name getQuarter
   * @category Quarter Helpers
   * @summary Get the year quarter of the given date.
   *
   * @description
   * Get the year quarter of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the quarter
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Which quarter is 2 July 2014?
   * const result = getQuarter(new Date(2014, 6, 2))
   * //=> 3
   */
  function getQuarter(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var quarter = Math.floor(date.getMonth() / 3) + 1;
    return quarter;
  }

  /**
   * @name startOfMinute
   * @category Minute Helpers
   * @summary Return the start of a minute for the given date.
   *
   * @description
   * Return the start of a minute for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a minute
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a minute for 1 December 2014 22:15:45.400:
   * const result = startOfMinute(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:00
   */
  function startOfMinute(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    date.setSeconds(0, 0);
    return date;
  }

  /**
   * @name startOfQuarter
   * @category Quarter Helpers
   * @summary Return the start of a year quarter for the given date.
   *
   * @description
   * Return the start of a year quarter for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a quarter
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a quarter for 2 September 2014 11:55:00:
   * const result = startOfQuarter(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Tue Jul 01 2014 00:00:00
   */
  function startOfQuarter(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var currentMonth = date.getMonth();
    var month = currentMonth - currentMonth % 3;
    date.setMonth(month, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name startOfMonth
   * @category Month Helpers
   * @summary Return the start of a month for the given date.
   *
   * @description
   * Return the start of a month for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a month
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a month for 2 September 2014 11:55:00:
   * const result = startOfMonth(new Date(2014, 8, 2, 11, 55, 0))
   * //=> Mon Sep 01 2014 00:00:00
   */
  function startOfMonth(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    date.setDate(1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name startOfYear
   * @category Year Helpers
   * @summary Return the start of a year for the given date.
   *
   * @description
   * Return the start of a year for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a year
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a year for 2 September 2014 11:55:00:
   * const result = startOfYear(new Date(2014, 8, 2, 11, 55, 00))
   * //=> Wed Jan 01 2014 00:00:00
   */
  function startOfYear(dirtyDate) {
    requiredArgs$1(1, arguments);
    var cleanDate = toDate$2(dirtyDate);
    var date = new Date(0);
    date.setFullYear(cleanDate.getFullYear(), 0, 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }

  /**
   * @name subMilliseconds
   * @category Millisecond Helpers
   * @summary Subtract the specified number of milliseconds from the given date.
   *
   * @description
   * Subtract the specified number of milliseconds from the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
   * @returns {Date} the new date with the milliseconds subtracted
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
   * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
   * //=> Thu Jul 10 2014 12:45:29.250
   */
  function subMilliseconds$1(dirtyDate, dirtyAmount) {
    requiredArgs$1(2, arguments);
    var amount = toInteger$2(dirtyAmount);
    return addMilliseconds$1(dirtyDate, -amount);
  }

  var MILLISECONDS_IN_DAY = 86400000;
  function getUTCDayOfYear$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var timestamp = date.getTime();
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
    var startOfYearTimestamp = date.getTime();
    var difference = timestamp - startOfYearTimestamp;
    return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  }

  function startOfUTCISOWeek$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    var weekStartsOn = 1;
    var date = toDate$2(dirtyDate);
    var day = date.getUTCDay();
    var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    date.setUTCDate(date.getUTCDate() - diff);
    date.setUTCHours(0, 0, 0, 0);
    return date;
  }

  function getUTCISOWeekYear$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var year = date.getUTCFullYear();
    var fourthOfJanuaryOfNextYear = new Date(0);
    fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCISOWeek$1(fourthOfJanuaryOfNextYear);
    var fourthOfJanuaryOfThisYear = new Date(0);
    fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCISOWeek$1(fourthOfJanuaryOfThisYear);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  function startOfUTCISOWeekYear$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    var year = getUTCISOWeekYear$1(dirtyDate);
    var fourthOfJanuary = new Date(0);
    fourthOfJanuary.setUTCFullYear(year, 0, 4);
    fourthOfJanuary.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCISOWeek$1(fourthOfJanuary);
    return date;
  }

  var MILLISECONDS_IN_WEEK$1 = 604800000;
  function getUTCISOWeek$1(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var diff = startOfUTCISOWeek$1(date).getTime() - startOfUTCISOWeekYear$1(date).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
  }

  function getUTCWeekYear$1(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var year = date.getUTCFullYear();
    var defaultOptions = getDefaultOptions$1();
    var firstWeekContainsDate = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

    // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }
    var firstWeekOfNextYear = new Date(0);
    firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
    var startOfNextYear = startOfUTCWeek$1(firstWeekOfNextYear, options);
    var firstWeekOfThisYear = new Date(0);
    firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
    var startOfThisYear = startOfUTCWeek$1(firstWeekOfThisYear, options);
    if (date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }

  function startOfUTCWeekYear$1(dirtyDate, options) {
    var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs$1(1, arguments);
    var defaultOptions = getDefaultOptions$1();
    var firstWeekContainsDate = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
    var year = getUTCWeekYear$1(dirtyDate, options);
    var firstWeek = new Date(0);
    firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setUTCHours(0, 0, 0, 0);
    var date = startOfUTCWeek$1(firstWeek, options);
    return date;
  }

  var MILLISECONDS_IN_WEEK = 604800000;
  function getUTCWeek$1(dirtyDate, options) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var diff = startOfUTCWeek$1(date, options).getTime() - startOfUTCWeekYear$1(date, options).getTime();

    // Round the number of days to the nearest integer
    // because the number of milliseconds in a week is not constant
    // (e.g. it's different in the week of the daylight saving time clock shift)
    return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  }

  function addLeadingZeros$2(number, targetLength) {
    var sign = number < 0 ? '-' : '';
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = '0' + output;
    }
    return sign + output;
  }

  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* |                                |
   * |  d  | Day of month                   |  D  |                                |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  m  | Minute                         |  M  | Month                          |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  y  | Year (abs)                     |  Y  |                                |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   */
  var formatters$5 = {
    // Year
    y: function y(date, token) {
      // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
      // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
      // |----------|-------|----|-------|-------|-------|
      // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
      // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
      // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
      // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
      // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

      var signedYear = date.getUTCFullYear();
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros$2(token === 'yy' ? year % 100 : year, token.length);
    },
    // Month
    M: function M(date, token) {
      var month = date.getUTCMonth();
      return token === 'M' ? String(month + 1) : addLeadingZeros$2(month + 1, 2);
    },
    // Day of the month
    d: function d(date, token) {
      return addLeadingZeros$2(date.getUTCDate(), token.length);
    },
    // AM or PM
    a: function a(date, token) {
      var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
      switch (token) {
        case 'a':
        case 'aa':
          return dayPeriodEnumValue.toUpperCase();
        case 'aaa':
          return dayPeriodEnumValue;
        case 'aaaaa':
          return dayPeriodEnumValue[0];
        case 'aaaa':
        default:
          return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
      }
    },
    // Hour [1-12]
    h: function h(date, token) {
      return addLeadingZeros$2(date.getUTCHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H: function H(date, token) {
      return addLeadingZeros$2(date.getUTCHours(), token.length);
    },
    // Minute
    m: function m(date, token) {
      return addLeadingZeros$2(date.getUTCMinutes(), token.length);
    },
    // Second
    s: function s(date, token) {
      return addLeadingZeros$2(date.getUTCSeconds(), token.length);
    },
    // Fraction of second
    S: function S(date, token) {
      var numberOfDigits = token.length;
      var milliseconds = date.getUTCMilliseconds();
      var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
      return addLeadingZeros$2(fractionalSeconds, token.length);
    }
  };
  var formatters$6 = formatters$5;

  var dayPeriodEnum = {
    am: 'am',
    pm: 'pm',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  };
  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
   * |  p! | Long localized time            |  P! | Long localized date            |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   * - `P` is long localized date format
   * - `p` is long localized time format
   */

  var formatters$3 = {
    // Era
    G: function G(date, token, localize) {
      var era = date.getUTCFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return localize.era(era, {
            width: 'abbreviated'
          });
        // A, B
        case 'GGGGG':
          return localize.era(era, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ
        case 'GGGG':
        default:
          return localize.era(era, {
            width: 'wide'
          });
      }
    },
    // Year
    y: function y(date, token, localize) {
      // Ordinal number
      if (token === 'yo') {
        var signedYear = date.getUTCFullYear();
        // Returns 1 for 1 BC (which is year 0 in JavaScript)
        var year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize.ordinalNumber(year, {
          unit: 'year'
        });
      }
      return formatters$6.y(date, token);
    },
    // Local week-numbering year
    Y: function Y(date, token, localize, options) {
      var signedWeekYear = getUTCWeekYear$1(date, options);
      // Returns 1 for 1 BC (which is year 0 in JavaScript)
      var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

      // Two digit year
      if (token === 'YY') {
        var twoDigitYear = weekYear % 100;
        return addLeadingZeros$2(twoDigitYear, 2);
      }

      // Ordinal number
      if (token === 'Yo') {
        return localize.ordinalNumber(weekYear, {
          unit: 'year'
        });
      }

      // Padding
      return addLeadingZeros$2(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function R(date, token) {
      var isoWeekYear = getUTCISOWeekYear$1(date);

      // Padding
      return addLeadingZeros$2(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function u(date, token) {
      var year = date.getUTCFullYear();
      return addLeadingZeros$2(year, token.length);
    },
    // Quarter
    Q: function Q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
          return String(quarter);
        // 01, 02, 03, 04
        case 'QQ':
          return addLeadingZeros$2(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case 'Qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'QQQ':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'QQQQQ':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...
        case 'QQQQ':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone quarter
    q: function q(date, token, localize) {
      var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
          return String(quarter);
        // 01, 02, 03, 04
        case 'qq':
          return addLeadingZeros$2(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case 'qo':
          return localize.ordinalNumber(quarter, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4
        case 'qqq':
          return localize.quarter(quarter, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case 'qqqqq':
          return localize.quarter(quarter, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...
        case 'qqqq':
        default:
          return localize.quarter(quarter, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Month
    M: function M(date, token, localize) {
      var month = date.getUTCMonth();
      switch (token) {
        case 'M':
        case 'MM':
          return formatters$6.M(date, token);
        // 1st, 2nd, ..., 12th
        case 'Mo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec
        case 'MMM':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // J, F, ..., D
        case 'MMMMM':
          return localize.month(month, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December
        case 'MMMM':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone month
    L: function L(date, token, localize) {
      var month = date.getUTCMonth();
      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return String(month + 1);
        // 01, 02, ..., 12
        case 'LL':
          return addLeadingZeros$2(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case 'Lo':
          return localize.ordinalNumber(month + 1, {
            unit: 'month'
          });
        // Jan, Feb, ..., Dec
        case 'LLL':
          return localize.month(month, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // J, F, ..., D
        case 'LLLLL':
          return localize.month(month, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December
        case 'LLLL':
        default:
          return localize.month(month, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // Local week of year
    w: function w(date, token, localize, options) {
      var week = getUTCWeek$1(date, options);
      if (token === 'wo') {
        return localize.ordinalNumber(week, {
          unit: 'week'
        });
      }
      return addLeadingZeros$2(week, token.length);
    },
    // ISO week of year
    I: function I(date, token, localize) {
      var isoWeek = getUTCISOWeek$1(date);
      if (token === 'Io') {
        return localize.ordinalNumber(isoWeek, {
          unit: 'week'
        });
      }
      return addLeadingZeros$2(isoWeek, token.length);
    },
    // Day of the month
    d: function d(date, token, localize) {
      if (token === 'do') {
        return localize.ordinalNumber(date.getUTCDate(), {
          unit: 'date'
        });
      }
      return formatters$6.d(date, token);
    },
    // Day of year
    D: function D(date, token, localize) {
      var dayOfYear = getUTCDayOfYear$1(date);
      if (token === 'Do') {
        return localize.ordinalNumber(dayOfYear, {
          unit: 'dayOfYear'
        });
      }
      return addLeadingZeros$2(dayOfYear, token.length);
    },
    // Day of week
    E: function E(date, token, localize) {
      var dayOfWeek = date.getUTCDay();
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T
        case 'EEEEE':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'EEEEEE':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday
        case 'EEEE':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Local day of week
    e: function e(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case 'e':
          return String(localDayOfWeek);
        // Padded numerical value
        case 'ee':
          return addLeadingZeros$2(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case 'eo':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });
        case 'eee':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T
        case 'eeeee':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'eeeeee':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday
        case 'eeee':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Stand-alone local day of week
    c: function c(date, token, localize, options) {
      var dayOfWeek = date.getUTCDay();
      var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case 'c':
          return String(localDayOfWeek);
        // Padded numerical value
        case 'cc':
          return addLeadingZeros$2(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case 'co':
          return localize.ordinalNumber(localDayOfWeek, {
            unit: 'day'
          });
        case 'ccc':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'standalone'
          });
        // T
        case 'ccccc':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu
        case 'cccccc':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'standalone'
          });
        // Tuesday
        case 'cccc':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'standalone'
          });
      }
    },
    // ISO day of week
    i: function i(date, token, localize) {
      var dayOfWeek = date.getUTCDay();
      var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case 'i':
          return String(isoDayOfWeek);
        // 02
        case 'ii':
          return addLeadingZeros$2(isoDayOfWeek, token.length);
        // 2nd
        case 'io':
          return localize.ordinalNumber(isoDayOfWeek, {
            unit: 'day'
          });
        // Tue
        case 'iii':
          return localize.day(dayOfWeek, {
            width: 'abbreviated',
            context: 'formatting'
          });
        // T
        case 'iiiii':
          return localize.day(dayOfWeek, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu
        case 'iiiiii':
          return localize.day(dayOfWeek, {
            width: 'short',
            context: 'formatting'
          });
        // Tuesday
        case 'iiii':
        default:
          return localize.day(dayOfWeek, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM or PM
    a: function a(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
      switch (token) {
        case 'a':
        case 'aa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });
        case 'aaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          }).toLowerCase();
        case 'aaaaa':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'aaaa':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // AM, PM, midnight, noon
    b: function b(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
      }
      switch (token) {
        case 'b':
        case 'bb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });
        case 'bbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          }).toLowerCase();
        case 'bbbbb':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'bbbb':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function B(date, token, localize) {
      var hours = date.getUTCHours();
      var dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'abbreviated',
            context: 'formatting'
          });
        case 'BBBBB':
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'narrow',
            context: 'formatting'
          });
        case 'BBBB':
        default:
          return localize.dayPeriod(dayPeriodEnumValue, {
            width: 'wide',
            context: 'formatting'
          });
      }
    },
    // Hour [1-12]
    h: function h(date, token, localize) {
      if (token === 'ho') {
        var hours = date.getUTCHours() % 12;
        if (hours === 0) hours = 12;
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }
      return formatters$6.h(date, token);
    },
    // Hour [0-23]
    H: function H(date, token, localize) {
      if (token === 'Ho') {
        return localize.ordinalNumber(date.getUTCHours(), {
          unit: 'hour'
        });
      }
      return formatters$6.H(date, token);
    },
    // Hour [0-11]
    K: function K(date, token, localize) {
      var hours = date.getUTCHours() % 12;
      if (token === 'Ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }
      return addLeadingZeros$2(hours, token.length);
    },
    // Hour [1-24]
    k: function k(date, token, localize) {
      var hours = date.getUTCHours();
      if (hours === 0) hours = 24;
      if (token === 'ko') {
        return localize.ordinalNumber(hours, {
          unit: 'hour'
        });
      }
      return addLeadingZeros$2(hours, token.length);
    },
    // Minute
    m: function m(date, token, localize) {
      if (token === 'mo') {
        return localize.ordinalNumber(date.getUTCMinutes(), {
          unit: 'minute'
        });
      }
      return formatters$6.m(date, token);
    },
    // Second
    s: function s(date, token, localize) {
      if (token === 'so') {
        return localize.ordinalNumber(date.getUTCSeconds(), {
          unit: 'second'
        });
      }
      return formatters$6.s(date, token);
    },
    // Fraction of second
    S: function S(date, token) {
      return formatters$6.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function X(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return 'Z';
      }
      switch (token) {
        // Hours and optional minutes
        case 'X':
          return formatTimezoneWithOptionalMinutes$1(timezoneOffset);

        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case 'XXXX':
        case 'XX':
          // Hours and minutes without `:` delimiter
          return formatTimezone$1(timezoneOffset);

        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case 'XXXXX':
        case 'XXX': // Hours and minutes with `:` delimiter
        default:
          return formatTimezone$1(timezoneOffset, ':');
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function x(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        // Hours and optional minutes
        case 'x':
          return formatTimezoneWithOptionalMinutes$1(timezoneOffset);

        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case 'xxxx':
        case 'xx':
          // Hours and minutes without `:` delimiter
          return formatTimezone$1(timezoneOffset);

        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case 'xxxxx':
        case 'xxx': // Hours and minutes with `:` delimiter
        default:
          return formatTimezone$1(timezoneOffset, ':');
      }
    },
    // Timezone (GMT)
    O: function O(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        // Short
        case 'O':
        case 'OO':
        case 'OOO':
          return 'GMT' + formatTimezoneShort$1(timezoneOffset, ':');
        // Long
        case 'OOOO':
        default:
          return 'GMT' + formatTimezone$1(timezoneOffset, ':');
      }
    },
    // Timezone (specific non-location)
    z: function z(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timezoneOffset = originalDate.getTimezoneOffset();
      switch (token) {
        // Short
        case 'z':
        case 'zz':
        case 'zzz':
          return 'GMT' + formatTimezoneShort$1(timezoneOffset, ':');
        // Long
        case 'zzzz':
        default:
          return 'GMT' + formatTimezone$1(timezoneOffset, ':');
      }
    },
    // Seconds timestamp
    t: function t(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = Math.floor(originalDate.getTime() / 1000);
      return addLeadingZeros$2(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function T(date, token, _localize, options) {
      var originalDate = options._originalDate || date;
      var timestamp = originalDate.getTime();
      return addLeadingZeros$2(timestamp, token.length);
    }
  };
  function formatTimezoneShort$1(offset, dirtyDelimiter) {
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    var delimiter = dirtyDelimiter || '';
    return sign + String(hours) + delimiter + addLeadingZeros$2(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes$1(offset, dirtyDelimiter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? '-' : '+';
      return sign + addLeadingZeros$2(Math.abs(offset) / 60, 2);
    }
    return formatTimezone$1(offset, dirtyDelimiter);
  }
  function formatTimezone$1(offset, dirtyDelimiter) {
    var delimiter = dirtyDelimiter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = addLeadingZeros$2(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros$2(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  var formatters$4 = formatters$3;

  var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'P':
        return formatLong.date({
          width: 'short'
        });
      case 'PP':
        return formatLong.date({
          width: 'medium'
        });
      case 'PPP':
        return formatLong.date({
          width: 'long'
        });
      case 'PPPP':
      default:
        return formatLong.date({
          width: 'full'
        });
    }
  };
  var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
    switch (pattern) {
      case 'p':
        return formatLong.time({
          width: 'short'
        });
      case 'pp':
        return formatLong.time({
          width: 'medium'
        });
      case 'ppp':
        return formatLong.time({
          width: 'long'
        });
      case 'pppp':
      default:
        return formatLong.time({
          width: 'full'
        });
    }
  };
  var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
    var matchResult = pattern.match(/(P+)(p+)?/) || [];
    var datePattern = matchResult[1];
    var timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong);
    }
    var dateTimeFormat;
    switch (datePattern) {
      case 'P':
        dateTimeFormat = formatLong.dateTime({
          width: 'short'
        });
        break;
      case 'PP':
        dateTimeFormat = formatLong.dateTime({
          width: 'medium'
        });
        break;
      case 'PPP':
        dateTimeFormat = formatLong.dateTime({
          width: 'long'
        });
        break;
      case 'PPPP':
      default:
        dateTimeFormat = formatLong.dateTime({
          width: 'full'
        });
        break;
    }
    return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
  };
  var longFormatters$1 = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  var longFormatters$2 = longFormatters$1;

  var protectedDayOfYearTokens$1 = ['D', 'DD'];
  var protectedWeekYearTokens$1 = ['YY', 'YYYY'];
  function isProtectedDayOfYearToken$1(token) {
    return protectedDayOfYearTokens$1.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken$1(token) {
    return protectedWeekYearTokens$1.indexOf(token) !== -1;
  }
  function throwProtectedError$1(token, format, input) {
    if (token === 'YYYY') {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'YY') {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'D') {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'DD') {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    }
  }

  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps
  var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

  // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
  var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp$1 = /^'([^]*?)'?$/;
  var doubleQuoteRegExp$1 = /''/g;
  var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;

  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | AM, PM                          | a..aa   | AM, PM                            |       |
   * |                                 | aaa     | am, pm                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
   * |                                 | bbb     | am, pm, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 01, 02, ..., 11, 00               |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 001, ..., 999                |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
   * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 04/29/1453                        | 7     |
   * |                                 | PP      | Apr 29, 1453                      | 7     |
   * |                                 | PPP     | April 29th, 1453                  | 7     |
   * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
   * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
   *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
   *
   * 6. Specific non-location timezones are currently unavailable in `date-fns`,
   *    so right now these tokens fall back to GMT timezones.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * @param {Date|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `date` must not be Invalid Date
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */

  function format$4(dirtyDate, dirtyFormatStr, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    requiredArgs$1(2, arguments);
    var formatStr = String(dirtyFormatStr);
    var defaultOptions = getDefaultOptions$1();
    var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
    var firstWeekContainsDate = toInteger$2((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

    // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }
    var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    if (!locale.localize) {
      throw new RangeError('locale must contain localize property');
    }
    if (!locale.formatLong) {
      throw new RangeError('locale must contain formatLong property');
    }
    var originalDate = toDate$2(dirtyDate);
    if (!isValid$1(originalDate)) {
      throw new RangeError('Invalid time value');
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    // This ensures that when UTC functions will be implemented, locales will be compatible with them.
    // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
    var timezoneOffset = getTimezoneOffsetInMilliseconds$2(originalDate);
    var utcDate = subMilliseconds$1(originalDate, timezoneOffset);
    var formatterOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale,
      _originalDate: originalDate
    };
    var result = formatStr.match(longFormattingTokensRegExp$1).map(function (substring) {
      var firstCharacter = substring[0];
      if (firstCharacter === 'p' || firstCharacter === 'P') {
        var longFormatter = longFormatters$2[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join('').match(formattingTokensRegExp$1).map(function (substring) {
      // Replace two single quote characters with one single quote character
      if (substring === "''") {
        return "'";
      }
      var firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return cleanEscapedString$1(substring);
      }
      var formatter = formatters$4[firstCharacter];
      if (formatter) {
        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(substring)) {
          throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
        }
        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(substring)) {
          throwProtectedError$1(substring, dirtyFormatStr, String(dirtyDate));
        }
        return formatter(utcDate, substring, locale.localize, formatterOptions);
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
        throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
      }
      return substring;
    }).join('');
    return result;
  }
  function cleanEscapedString$1(input) {
    var matched = input.match(escapedStringRegExp$1);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp$1, "'");
  }

  function assign$1(target, object) {
    if (target == null) {
      throw new TypeError('assign requires that input parameter not be null or undefined');
    }
    for (var property in object) {
      if (Object.prototype.hasOwnProperty.call(object, property)) {
        target[property] = object[property];
      }
    }
    return target;
  }

  function cloneObject$2(object) {
    return assign$1({}, object);
  }

  var MILLISECONDS_IN_MINUTE$3 = 1000 * 60;
  var MINUTES_IN_DAY = 60 * 24;
  var MINUTES_IN_MONTH = MINUTES_IN_DAY * 30;
  var MINUTES_IN_YEAR = MINUTES_IN_DAY * 365;

  /**
   * @name formatDistanceStrict
   * @category Common Helpers
   * @summary Return the distance between the given dates in words.
   *
   * @description
   * Return the distance between the given dates in words, using strict units.
   * This is like `formatDistance`, but does not use helpers like 'almost', 'over',
   * 'less than' and the like.
   *
   * | Distance between dates | Result              |
   * |------------------------|---------------------|
   * | 0 ... 59 secs          | [0..59] seconds     |
   * | 1 ... 59 mins          | [1..59] minutes     |
   * | 1 ... 23 hrs           | [1..23] hours       |
   * | 1 ... 29 days          | [1..29] days        |
   * | 1 ... 11 months        | [1..11] months      |
   * | 1 ... N years          | [1..N]  years       |
   *
   * @param {Date|Number} date - the date
   * @param {Date|Number} baseDate - the date to compare with
   * @param {Object} [options] - an object with options.
   * @param {Boolean} [options.addSuffix=false] - result indicates if the second date is earlier or later than the first
   * @param {'second'|'minute'|'hour'|'day'|'month'|'year'} [options.unit] - if specified, will force a unit
   * @param {'floor'|'ceil'|'round'} [options.roundingMethod='round'] - which way to round partial units
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @returns {String} the distance in words
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `date` must not be Invalid Date
   * @throws {RangeError} `baseDate` must not be Invalid Date
   * @throws {RangeError} `options.roundingMethod` must be 'floor', 'ceil' or 'round'
   * @throws {RangeError} `options.unit` must be 'second', 'minute', 'hour', 'day', 'month' or 'year'
   * @throws {RangeError} `options.locale` must contain `formatDistance` property
   *
   * @example
   * // What is the distance between 2 July 2014 and 1 January 2015?
   * const result = formatDistanceStrict(new Date(2014, 6, 2), new Date(2015, 0, 2))
   * //=> '6 months'
   *
   * @example
   * // What is the distance between 1 January 2015 00:00:15
   * // and 1 January 2015 00:00:00?
   * const result = formatDistanceStrict(
   *   new Date(2015, 0, 1, 0, 0, 15),
   *   new Date(2015, 0, 1, 0, 0, 0)
   * )
   * //=> '15 seconds'
   *
   * @example
   * // What is the distance from 1 January 2016
   * // to 1 January 2015, with a suffix?
   * const result = formatDistanceStrict(new Date(2015, 0, 1), new Date(2016, 0, 1), {
   *   addSuffix: true
   * })
   * //=> '1 year ago'
   *
   * @example
   * // What is the distance from 1 January 2016
   * // to 1 January 2015, in minutes?
   * const result = formatDistanceStrict(new Date(2016, 0, 1), new Date(2015, 0, 1), {
   *   unit: 'minute'
   * })
   * //=> '525600 minutes'
   *
   * @example
   * // What is the distance from 1 January 2015
   * // to 28 January 2015, in months, rounded up?
   * const result = formatDistanceStrict(new Date(2015, 0, 28), new Date(2015, 0, 1), {
   *   unit: 'month',
   *   roundingMethod: 'ceil'
   * })
   * //=> '1 month'
   *
   * @example
   * // What is the distance between 1 August 2016 and 1 January 2015 in Esperanto?
   * import { eoLocale } from 'date-fns/locale/eo'
   * const result = formatDistanceStrict(new Date(2016, 7, 1), new Date(2015, 0, 1), {
   *   locale: eoLocale
   * })
   * //=> '1 jaro'
   */

  function formatDistanceStrict(dirtyDate, dirtyBaseDate, options) {
    var _ref, _options$locale, _options$roundingMeth;
    requiredArgs$1(2, arguments);
    var defaultOptions = getDefaultOptions$1();
    var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
    if (!locale.formatDistance) {
      throw new RangeError('locale must contain localize.formatDistance property');
    }
    var comparison = compareAsc(dirtyDate, dirtyBaseDate);
    if (isNaN(comparison)) {
      throw new RangeError('Invalid time value');
    }
    var localizeOptions = assign$1(cloneObject$2(options), {
      addSuffix: Boolean(options === null || options === void 0 ? void 0 : options.addSuffix),
      comparison: comparison
    });
    var dateLeft;
    var dateRight;
    if (comparison > 0) {
      dateLeft = toDate$2(dirtyBaseDate);
      dateRight = toDate$2(dirtyDate);
    } else {
      dateLeft = toDate$2(dirtyDate);
      dateRight = toDate$2(dirtyBaseDate);
    }
    var roundingMethod = String((_options$roundingMeth = options === null || options === void 0 ? void 0 : options.roundingMethod) !== null && _options$roundingMeth !== void 0 ? _options$roundingMeth : 'round');
    var roundingMethodFn;
    if (roundingMethod === 'floor') {
      roundingMethodFn = Math.floor;
    } else if (roundingMethod === 'ceil') {
      roundingMethodFn = Math.ceil;
    } else if (roundingMethod === 'round') {
      roundingMethodFn = Math.round;
    } else {
      throw new RangeError("roundingMethod must be 'floor', 'ceil' or 'round'");
    }
    var milliseconds = dateRight.getTime() - dateLeft.getTime();
    var minutes = milliseconds / MILLISECONDS_IN_MINUTE$3;
    var timezoneOffset = getTimezoneOffsetInMilliseconds$2(dateRight) - getTimezoneOffsetInMilliseconds$2(dateLeft);

    // Use DST-normalized difference in minutes for years, months and days;
    // use regular difference in minutes for hours, minutes and seconds.
    var dstNormalizedMinutes = (milliseconds - timezoneOffset) / MILLISECONDS_IN_MINUTE$3;
    var defaultUnit = options === null || options === void 0 ? void 0 : options.unit;
    var unit;
    if (!defaultUnit) {
      if (minutes < 1) {
        unit = 'second';
      } else if (minutes < 60) {
        unit = 'minute';
      } else if (minutes < MINUTES_IN_DAY) {
        unit = 'hour';
      } else if (dstNormalizedMinutes < MINUTES_IN_MONTH) {
        unit = 'day';
      } else if (dstNormalizedMinutes < MINUTES_IN_YEAR) {
        unit = 'month';
      } else {
        unit = 'year';
      }
    } else {
      unit = String(defaultUnit);
    }

    // 0 up to 60 seconds
    if (unit === 'second') {
      var seconds = roundingMethodFn(milliseconds / 1000);
      return locale.formatDistance('xSeconds', seconds, localizeOptions);

      // 1 up to 60 mins
    } else if (unit === 'minute') {
      var roundedMinutes = roundingMethodFn(minutes);
      return locale.formatDistance('xMinutes', roundedMinutes, localizeOptions);

      // 1 up to 24 hours
    } else if (unit === 'hour') {
      var hours = roundingMethodFn(minutes / 60);
      return locale.formatDistance('xHours', hours, localizeOptions);

      // 1 up to 30 days
    } else if (unit === 'day') {
      var days = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_DAY);
      return locale.formatDistance('xDays', days, localizeOptions);

      // 1 up to 12 months
    } else if (unit === 'month') {
      var months = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_MONTH);
      return months === 12 && defaultUnit !== 'month' ? locale.formatDistance('xYears', 1, localizeOptions) : locale.formatDistance('xMonths', months, localizeOptions);

      // 1 year up to max Date
    } else if (unit === 'year') {
      var years = roundingMethodFn(dstNormalizedMinutes / MINUTES_IN_YEAR);
      return locale.formatDistance('xYears', years, localizeOptions);
    }
    throw new RangeError("unit must be 'second', 'minute', 'hour', 'day', 'month' or 'year'");
  }

  /**
   * @name fromUnixTime
   * @category Timestamp Helpers
   * @summary Create a date from a Unix timestamp.
   *
   * @description
   * Create a date from a Unix timestamp (in seconds). Decimal values will be discarded.
   *
   * @param {Number} unixTime - the given Unix timestamp (in seconds)
   * @returns {Date} the date
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Create the date 29 February 2012 11:45:05:
   * const result = fromUnixTime(1330515905)
   * //=> Wed Feb 29 2012 11:45:05
   */
  function fromUnixTime(dirtyUnixTime) {
    requiredArgs$1(1, arguments);
    var unixTime = toInteger$2(dirtyUnixTime);
    return toDate$2(unixTime * 1000);
  }

  /**
   * @name getDate
   * @category Day Helpers
   * @summary Get the day of the month of the given date.
   *
   * @description
   * Get the day of the month of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the day of month
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Which day of the month is 29 February 2012?
   * const result = getDate(new Date(2012, 1, 29))
   * //=> 29
   */
  function getDate(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var dayOfMonth = date.getDate();
    return dayOfMonth;
  }

  /**
   * @name getDay
   * @category Weekday Helpers
   * @summary Get the day of the week of the given date.
   *
   * @description
   * Get the day of the week of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {0|1|2|3|4|5|6} the day of week, 0 represents Sunday
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Which day of the week is 29 February 2012?
   * const result = getDay(new Date(2012, 1, 29))
   * //=> 3
   */
  function getDay(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var day = date.getDay();
    return day;
  }

  /**
   * @name getDaysInMonth
   * @category Month Helpers
   * @summary Get the number of days in a month of the given date.
   *
   * @description
   * Get the number of days in a month of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the number of days in a month
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // How many days are in February 2000?
   * const result = getDaysInMonth(new Date(2000, 1))
   * //=> 29
   */
  function getDaysInMonth(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var year = date.getFullYear();
    var monthIndex = date.getMonth();
    var lastDayOfMonth = new Date(0);
    lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
    lastDayOfMonth.setHours(0, 0, 0, 0);
    return lastDayOfMonth.getDate();
  }

  /**
   * @name getHours
   * @category Hour Helpers
   * @summary Get the hours of the given date.
   *
   * @description
   * Get the hours of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the hours
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Get the hours of 29 February 2012 11:45:00:
   * const result = getHours(new Date(2012, 1, 29, 11, 45))
   * //=> 11
   */
  function getHours(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var hours = date.getHours();
    return hours;
  }

  /**
   * @name getMinutes
   * @category Minute Helpers
   * @summary Get the minutes of the given date.
   *
   * @description
   * Get the minutes of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the minutes
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Get the minutes of 29 February 2012 11:45:05:
   * const result = getMinutes(new Date(2012, 1, 29, 11, 45, 5))
   * //=> 45
   */
  function getMinutes(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var minutes = date.getMinutes();
    return minutes;
  }

  /**
   * @name getMonth
   * @category Month Helpers
   * @summary Get the month of the given date.
   *
   * @description
   * Get the month of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the month
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Which month is 29 February 2012?
   * const result = getMonth(new Date(2012, 1, 29))
   * //=> 1
   */
  function getMonth(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var month = date.getMonth();
    return month;
  }

  /**
   * @name getSeconds
   * @category Second Helpers
   * @summary Get the seconds of the given date.
   *
   * @description
   * Get the seconds of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the seconds
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Get the seconds of 29 February 2012 11:45:05.123:
   * const result = getSeconds(new Date(2012, 1, 29, 11, 45, 5, 123))
   * //=> 5
   */
  function getSeconds(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var seconds = date.getSeconds();
    return seconds;
  }

  /**
   * @name getTime
   * @category Timestamp Helpers
   * @summary Get the milliseconds timestamp of the given date.
   *
   * @description
   * Get the milliseconds timestamp of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the timestamp
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Get the timestamp of 29 February 2012 11:45:05.123:
   * const result = getTime(new Date(2012, 1, 29, 11, 45, 5, 123))
   * //=> 1330515905123
   */
  function getTime(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    var timestamp = date.getTime();
    return timestamp;
  }

  /**
   * @name getYear
   * @category Year Helpers
   * @summary Get the year of the given date.
   *
   * @description
   * Get the year of the given date.
   *
   * @param {Date|Number} date - the given date
   * @returns {Number} the year
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // Which year is 2 July 2014?
   * const result = getYear(new Date(2014, 6, 2))
   * //=> 2014
   */
  function getYear(dirtyDate) {
    requiredArgs$1(1, arguments);
    return toDate$2(dirtyDate).getFullYear();
  }

  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
    return arr2;
  }

  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
  }

  function _createForOfIteratorHelper(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (!it) {
      if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        var F = function F() {};
        return {
          s: F,
          n: function n() {
            if (i >= o.length) return {
              done: true
            };
            return {
              done: false,
              value: o[i++]
            };
          },
          e: function e(_e) {
            throw _e;
          },
          f: F
        };
      }
      throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    var normalCompletion = true,
      didErr = false,
      err;
    return {
      s: function s() {
        it = it.call(o);
      },
      n: function n() {
        var step = it.next();
        normalCompletion = step.done;
        return step;
      },
      e: function e(_e2) {
        didErr = true;
        err = _e2;
      },
      f: function f() {
        try {
          if (!normalCompletion && it["return"] != null) it["return"]();
        } finally {
          if (didErr) throw err;
        }
      }
    };
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
  }

  function _setPrototypeOf$1(o, p) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf$1(o, p);
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass) _setPrototypeOf$1(subClass, superClass);
  }

  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf$1(o);
  }

  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
      return call;
    } else if (call !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized(self);
  }

  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived),
        result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function toPrimitive(t, r) {
    if ("object" != _typeof$1(t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _typeof$1(i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }

  function toPropertyKey(t) {
    var i = toPrimitive(t, "string");
    return "symbol" == _typeof$1(i) ? i : String(i);
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  var TIMEZONE_UNIT_PRIORITY = 10;
  var Setter = /*#__PURE__*/function () {
    function Setter() {
      _classCallCheck(this, Setter);
      _defineProperty(this, "priority", void 0);
      _defineProperty(this, "subPriority", 0);
    }
    _createClass(Setter, [{
      key: "validate",
      value: function validate(_utcDate, _options) {
        return true;
      }
    }]);
    return Setter;
  }();
  var ValueSetter = /*#__PURE__*/function (_Setter) {
    _inherits(ValueSetter, _Setter);
    var _super = _createSuper(ValueSetter);
    function ValueSetter(value, validateValue, setValue, priority, subPriority) {
      var _this;
      _classCallCheck(this, ValueSetter);
      _this = _super.call(this);
      _this.value = value;
      _this.validateValue = validateValue;
      _this.setValue = setValue;
      _this.priority = priority;
      if (subPriority) {
        _this.subPriority = subPriority;
      }
      return _this;
    }
    _createClass(ValueSetter, [{
      key: "validate",
      value: function validate(utcDate, options) {
        return this.validateValue(utcDate, this.value, options);
      }
    }, {
      key: "set",
      value: function set(utcDate, flags, options) {
        return this.setValue(utcDate, flags, this.value, options);
      }
    }]);
    return ValueSetter;
  }(Setter);
  var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
    _inherits(DateToSystemTimezoneSetter, _Setter2);
    var _super2 = _createSuper(DateToSystemTimezoneSetter);
    function DateToSystemTimezoneSetter() {
      var _this2;
      _classCallCheck(this, DateToSystemTimezoneSetter);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this2 = _super2.call.apply(_super2, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
      _defineProperty(_assertThisInitialized(_this2), "subPriority", -1);
      return _this2;
    }
    _createClass(DateToSystemTimezoneSetter, [{
      key: "set",
      value: function set(date, flags) {
        if (flags.timestampIsSet) {
          return date;
        }
        var convertedDate = new Date(0);
        convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
        convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
        return convertedDate;
      }
    }]);
    return DateToSystemTimezoneSetter;
  }(Setter);

  var Parser = /*#__PURE__*/function () {
    function Parser() {
      _classCallCheck(this, Parser);
      _defineProperty(this, "incompatibleTokens", void 0);
      _defineProperty(this, "priority", void 0);
      _defineProperty(this, "subPriority", void 0);
    }
    _createClass(Parser, [{
      key: "run",
      value: function run(dateString, token, match, options) {
        var result = this.parse(dateString, token, match, options);
        if (!result) {
          return null;
        }
        return {
          setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
          rest: result.rest
        };
      }
    }, {
      key: "validate",
      value: function validate(_utcDate, _value, _options) {
        return true;
      }
    }]);
    return Parser;
  }();

  var EraParser = /*#__PURE__*/function (_Parser) {
    _inherits(EraParser, _Parser);
    var _super = _createSuper(EraParser);
    function EraParser() {
      var _this;
      _classCallCheck(this, EraParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 140);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);
      return _this;
    }
    _createClass(EraParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          // AD, BC
          case 'G':
          case 'GG':
          case 'GGG':
            return match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
          // A, B
          case 'GGGGG':
            return match.era(dateString, {
              width: 'narrow'
            });
          // Anno Domini, Before Christ
          case 'GGGG':
          default:
            return match.era(dateString, {
              width: 'wide'
            }) || match.era(dateString, {
              width: 'abbreviated'
            }) || match.era(dateString, {
              width: 'narrow'
            });
        }
      }
    }, {
      key: "set",
      value: function set(date, flags, value) {
        flags.era = value;
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return EraParser;
  }(Parser);

  var numericPatterns = {
    month: /^(1[0-2]|0?\d)/,
    // 0 to 12
    date: /^(3[0-1]|[0-2]?\d)/,
    // 0 to 31
    dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
    // 0 to 366
    week: /^(5[0-3]|[0-4]?\d)/,
    // 0 to 53
    hour23h: /^(2[0-3]|[0-1]?\d)/,
    // 0 to 23
    hour24h: /^(2[0-4]|[0-1]?\d)/,
    // 0 to 24
    hour11h: /^(1[0-1]|0?\d)/,
    // 0 to 11
    hour12h: /^(1[0-2]|0?\d)/,
    // 0 to 12
    minute: /^[0-5]?\d/,
    // 0 to 59
    second: /^[0-5]?\d/,
    // 0 to 59

    singleDigit: /^\d/,
    // 0 to 9
    twoDigits: /^\d{1,2}/,
    // 0 to 99
    threeDigits: /^\d{1,3}/,
    // 0 to 999
    fourDigits: /^\d{1,4}/,
    // 0 to 9999

    anyDigitsSigned: /^-?\d+/,
    singleDigitSigned: /^-?\d/,
    // 0 to 9, -0 to -9
    twoDigitsSigned: /^-?\d{1,2}/,
    // 0 to 99, -0 to -99
    threeDigitsSigned: /^-?\d{1,3}/,
    // 0 to 999, -0 to -999
    fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999
  };

  var timezonePatterns = {
    basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
    basic: /^([+-])(\d{2})(\d{2})|Z/,
    basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
    extended: /^([+-])(\d{2}):(\d{2})|Z/,
    extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
  };

  function mapValue(parseFnResult, mapFn) {
    if (!parseFnResult) {
      return parseFnResult;
    }
    return {
      value: mapFn(parseFnResult.value),
      rest: parseFnResult.rest
    };
  }
  function parseNumericPattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }
    return {
      value: parseInt(matchResult[0], 10),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseTimezonePattern(pattern, dateString) {
    var matchResult = dateString.match(pattern);
    if (!matchResult) {
      return null;
    }

    // Input is 'Z'
    if (matchResult[0] === 'Z') {
      return {
        value: 0,
        rest: dateString.slice(1)
      };
    }
    var sign = matchResult[1] === '+' ? 1 : -1;
    var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
    var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
    var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
    return {
      value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
      rest: dateString.slice(matchResult[0].length)
    };
  }
  function parseAnyDigitsSigned(dateString) {
    return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
  }
  function parseNDigits(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigit, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigits, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigits, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigits, dateString);
      default:
        return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
    }
  }
  function parseNDigitsSigned(n, dateString) {
    switch (n) {
      case 1:
        return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
      case 2:
        return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
      case 3:
        return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
      case 4:
        return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
      default:
        return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
    }
  }
  function dayPeriodEnumToHours(dayPeriod) {
    switch (dayPeriod) {
      case 'morning':
        return 4;
      case 'evening':
        return 17;
      case 'pm':
      case 'noon':
      case 'afternoon':
        return 12;
      case 'am':
      case 'midnight':
      case 'night':
      default:
        return 0;
    }
  }
  function normalizeTwoDigitYear(twoDigitYear, currentYear) {
    var isCommonEra = currentYear > 0;
    // Absolute number of the current year:
    // 1 -> 1 AC
    // 0 -> 1 BC
    // -1 -> 2 BC
    var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
    var result;
    if (absCurrentYear <= 50) {
      result = twoDigitYear || 100;
    } else {
      var rangeEnd = absCurrentYear + 50;
      var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
      var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
      result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
    }
    return isCommonEra ? result : 1 - result;
  }
  function isLeapYearIndex$1(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }

  // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
  // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
  // |----------|-------|----|-------|-------|-------|
  // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
  // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
  // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
  // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
  // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
  var YearParser = /*#__PURE__*/function (_Parser) {
    _inherits(YearParser, _Parser);
    var _super = _createSuper(YearParser);
    function YearParser() {
      var _this;
      _classCallCheck(this, YearParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 130);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(YearParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'yy'
          };
        };
        switch (token) {
          case 'y':
            return mapValue(parseNDigits(4, dateString), valueCallback);
          case 'yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);
          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set(date, flags, value) {
        var currentYear = date.getUTCFullYear();
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
          date.setUTCHours(0, 0, 0, 0);
          return date;
        }
        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return YearParser;
  }(Parser);

  // Local week-numbering year
  var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
    _inherits(LocalWeekYearParser, _Parser);
    var _super = _createSuper(LocalWeekYearParser);
    function LocalWeekYearParser() {
      var _this;
      _classCallCheck(this, LocalWeekYearParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 130);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      return _this;
    }
    _createClass(LocalWeekYearParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(year) {
          return {
            year: year,
            isTwoDigitYear: token === 'YY'
          };
        };
        switch (token) {
          case 'Y':
            return mapValue(parseNDigits(4, dateString), valueCallback);
          case 'Yo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'year'
            }), valueCallback);
          default:
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value.isTwoDigitYear || value.year > 0;
      }
    }, {
      key: "set",
      value: function set(date, flags, value, options) {
        var currentYear = getUTCWeekYear$1(date, options);
        if (value.isTwoDigitYear) {
          var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
          date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
          date.setUTCHours(0, 0, 0, 0);
          return startOfUTCWeek$1(date, options);
        }
        var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
        date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek$1(date, options);
      }
    }]);
    return LocalWeekYearParser;
  }(Parser);

  var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
    _inherits(ISOWeekYearParser, _Parser);
    var _super = _createSuper(ISOWeekYearParser);
    function ISOWeekYearParser() {
      var _this;
      _classCallCheck(this, ISOWeekYearParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 130);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(ISOWeekYearParser, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === 'R') {
          return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        var firstWeekOfYear = new Date(0);
        firstWeekOfYear.setUTCFullYear(value, 0, 4);
        firstWeekOfYear.setUTCHours(0, 0, 0, 0);
        return startOfUTCISOWeek$1(firstWeekOfYear);
      }
    }]);
    return ISOWeekYearParser;
  }(Parser);

  var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
    _inherits(ExtendedYearParser, _Parser);
    var _super = _createSuper(ExtendedYearParser);
    function ExtendedYearParser() {
      var _this;
      _classCallCheck(this, ExtendedYearParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 130);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(ExtendedYearParser, [{
      key: "parse",
      value: function parse(dateString, token) {
        if (token === 'u') {
          return parseNDigitsSigned(4, dateString);
        }
        return parseNDigitsSigned(token.length, dateString);
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCFullYear(value, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return ExtendedYearParser;
  }(Parser);

  var QuarterParser = /*#__PURE__*/function (_Parser) {
    _inherits(QuarterParser, _Parser);
    var _super = _createSuper(QuarterParser);
    function QuarterParser() {
      var _this;
      _classCallCheck(this, QuarterParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 120);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(QuarterParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'Q':
          case 'QQ':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th
          case 'Qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4
          case 'QQQ':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case 'QQQQQ':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // 1st quarter, 2nd quarter, ...
          case 'QQQQ':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return QuarterParser;
  }(Parser);

  var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
    _inherits(StandAloneQuarterParser, _Parser);
    var _super = _createSuper(StandAloneQuarterParser);
    function StandAloneQuarterParser() {
      var _this;
      _classCallCheck(this, StandAloneQuarterParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 120);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(StandAloneQuarterParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          // 1, 2, 3, 4
          case 'q':
          case 'qq':
            // 01, 02, 03, 04
            return parseNDigits(token.length, dateString);
          // 1st, 2nd, 3rd, 4th
          case 'qo':
            return match.ordinalNumber(dateString, {
              unit: 'quarter'
            });
          // Q1, Q2, Q3, Q4
          case 'qqq':
            return match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1, 2, 3, 4 (narrow quarter; could be not numerical)
          case 'qqqqq':
            return match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // 1st quarter, 2nd quarter, ...
          case 'qqqq':
          default:
            return match.quarter(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.quarter(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 4;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMonth((value - 1) * 3, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneQuarterParser;
  }(Parser);

  var MonthParser = /*#__PURE__*/function (_Parser) {
    _inherits(MonthParser, _Parser);
    var _super = _createSuper(MonthParser);
    function MonthParser() {
      var _this;
      _classCallCheck(this, MonthParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      _defineProperty(_assertThisInitialized(_this), "priority", 110);
      return _this;
    }
    _createClass(MonthParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };
        switch (token) {
          // 1, 2, ..., 12
          case 'M':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12
          case 'MM':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th
          case 'Mo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec
          case 'MMM':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // J, F, ..., D
          case 'MMMMM':
            return match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // January, February, ..., December
          case 'MMMM':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return MonthParser;
  }(Parser);

  var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
    _inherits(StandAloneMonthParser, _Parser);
    var _super = _createSuper(StandAloneMonthParser);
    function StandAloneMonthParser() {
      var _this;
      _classCallCheck(this, StandAloneMonthParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 110);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(StandAloneMonthParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value) {
          return value - 1;
        };
        switch (token) {
          // 1, 2, ..., 12
          case 'L':
            return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
          // 01, 02, ..., 12
          case 'LL':
            return mapValue(parseNDigits(2, dateString), valueCallback);
          // 1st, 2nd, ..., 12th
          case 'Lo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'month'
            }), valueCallback);
          // Jan, Feb, ..., Dec
          case 'LLL':
            return match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // J, F, ..., D
          case 'LLLLL':
            return match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // January, February, ..., December
          case 'LLLL':
          default:
            return match.month(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.month(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMonth(value, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneMonthParser;
  }(Parser);

  function setUTCWeek(dirtyDate, dirtyWeek, options) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var week = toInteger$2(dirtyWeek);
    var diff = getUTCWeek$1(date, options) - week;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  var LocalWeekParser = /*#__PURE__*/function (_Parser) {
    _inherits(LocalWeekParser, _Parser);
    var _super = _createSuper(LocalWeekParser);
    function LocalWeekParser() {
      var _this;
      _classCallCheck(this, LocalWeekParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 100);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);
      return _this;
    }
    _createClass(LocalWeekParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'w':
            return parseNumericPattern(numericPatterns.week, dateString);
          case 'wo':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value, options) {
        return startOfUTCWeek$1(setUTCWeek(date, value, options), options);
      }
    }]);
    return LocalWeekParser;
  }(Parser);

  function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var isoWeek = toInteger$2(dirtyISOWeek);
    var diff = getUTCISOWeek$1(date) - isoWeek;
    date.setUTCDate(date.getUTCDate() - diff * 7);
    return date;
  }

  var ISOWeekParser = /*#__PURE__*/function (_Parser) {
    _inherits(ISOWeekParser, _Parser);
    var _super = _createSuper(ISOWeekParser);
    function ISOWeekParser() {
      var _this;
      _classCallCheck(this, ISOWeekParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 100);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(ISOWeekParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'I':
            return parseNumericPattern(numericPatterns.week, dateString);
          case 'Io':
            return match.ordinalNumber(dateString, {
              unit: 'week'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 53;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        return startOfUTCISOWeek$1(setUTCISOWeek(date, value));
      }
    }]);
    return ISOWeekParser;
  }(Parser);

  var DAYS_IN_MONTH$1 = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR$1 = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  // Day of the month
  var DateParser = /*#__PURE__*/function (_Parser) {
    _inherits(DateParser, _Parser);
    var _super = _createSuper(DateParser);
    function DateParser() {
      var _this;
      _classCallCheck(this, DateParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "subPriority", 1);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(DateParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'd':
            return parseNumericPattern(numericPatterns.date, dateString);
          case 'do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex$1(year);
        var month = date.getUTCMonth();
        if (isLeapYear) {
          return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR$1[month];
        } else {
          return value >= 1 && value <= DAYS_IN_MONTH$1[month];
        }
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCDate(value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DateParser;
  }(Parser);

  var DayOfYearParser = /*#__PURE__*/function (_Parser) {
    _inherits(DayOfYearParser, _Parser);
    var _super = _createSuper(DayOfYearParser);
    function DayOfYearParser() {
      var _this;
      _classCallCheck(this, DayOfYearParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "subpriority", 1);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(DayOfYearParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'D':
          case 'DD':
            return parseNumericPattern(numericPatterns.dayOfYear, dateString);
          case 'Do':
            return match.ordinalNumber(dateString, {
              unit: 'date'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(date, value) {
        var year = date.getUTCFullYear();
        var isLeapYear = isLeapYearIndex$1(year);
        if (isLeapYear) {
          return value >= 1 && value <= 366;
        } else {
          return value >= 1 && value <= 365;
        }
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMonth(0, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DayOfYearParser;
  }(Parser);

  function setUTCDay(dirtyDate, dirtyDay, options) {
    var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
    requiredArgs$1(2, arguments);
    var defaultOptions = getDefaultOptions$1();
    var weekStartsOn = toInteger$2((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    var date = toDate$2(dirtyDate);
    var day = toInteger$2(dirtyDay);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }

  var DayParser = /*#__PURE__*/function (_Parser) {
    _inherits(DayParser, _Parser);
    var _super = _createSuper(DayParser);
    function DayParser() {
      var _this;
      _classCallCheck(this, DayParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(DayParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          // Tue
          case 'E':
          case 'EE':
          case 'EEE':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T
          case 'EEEEE':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu
          case 'EEEEEE':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday
          case 'EEEE':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return DayParser;
  }(Parser);

  var LocalDayParser = /*#__PURE__*/function (_Parser) {
    _inherits(LocalDayParser, _Parser);
    var _super = _createSuper(LocalDayParser);
    function LocalDayParser() {
      var _this;
      _classCallCheck(this, LocalDayParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);
      return _this;
    }
    _createClass(LocalDayParser, [{
      key: "parse",
      value: function parse(dateString, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          // 3
          case 'e':
          case 'ee':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd
          case 'eo':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue
          case 'eee':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // T
          case 'eeeee':
            return match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tu
          case 'eeeeee':
            return match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          // Tuesday
          case 'eeee':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return LocalDayParser;
  }(Parser);

  var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
    _inherits(StandAloneLocalDayParser, _Parser);
    var _super = _createSuper(StandAloneLocalDayParser);
    function StandAloneLocalDayParser() {
      var _this;
      _classCallCheck(this, StandAloneLocalDayParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);
      return _this;
    }
    _createClass(StandAloneLocalDayParser, [{
      key: "parse",
      value: function parse(dateString, token, match, options) {
        var valueCallback = function valueCallback(value) {
          var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
          return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
        };
        switch (token) {
          // 3
          case 'c':
          case 'cc':
            // 03
            return mapValue(parseNDigits(token.length, dateString), valueCallback);
          // 3rd
          case 'co':
            return mapValue(match.ordinalNumber(dateString, {
              unit: 'day'
            }), valueCallback);
          // Tue
          case 'ccc':
            return match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // T
          case 'ccccc':
            return match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tu
          case 'cccccc':
            return match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
          // Tuesday
          case 'cccc':
          default:
            return match.day(dateString, {
              width: 'wide',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'short',
              context: 'standalone'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'standalone'
            });
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 6;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value, options) {
        date = setUTCDay(date, value, options);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return StandAloneLocalDayParser;
  }(Parser);

  function setUTCISODay(dirtyDate, dirtyDay) {
    requiredArgs$1(2, arguments);
    var day = toInteger$2(dirtyDay);
    if (day % 7 === 0) {
      day = day - 7;
    }
    var weekStartsOn = 1;
    var date = toDate$2(dirtyDate);
    var currentDay = date.getUTCDay();
    var remainder = day % 7;
    var dayIndex = (remainder + 7) % 7;
    var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }

  var ISODayParser = /*#__PURE__*/function (_Parser) {
    _inherits(ISODayParser, _Parser);
    var _super = _createSuper(ISODayParser);
    function ISODayParser() {
      var _this;
      _classCallCheck(this, ISODayParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 90);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);
      return _this;
    }
    _createClass(ISODayParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        var valueCallback = function valueCallback(value) {
          if (value === 0) {
            return 7;
          }
          return value;
        };
        switch (token) {
          // 2
          case 'i':
          case 'ii':
            // 02
            return parseNDigits(token.length, dateString);
          // 2nd
          case 'io':
            return match.ordinalNumber(dateString, {
              unit: 'day'
            });
          // Tue
          case 'iii':
            return mapValue(match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // T
          case 'iiiii':
            return mapValue(match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tu
          case 'iiiiii':
            return mapValue(match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
          // Tuesday
          case 'iiii':
          default:
            return mapValue(match.day(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'short',
              context: 'formatting'
            }) || match.day(dateString, {
              width: 'narrow',
              context: 'formatting'
            }), valueCallback);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 7;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date = setUTCISODay(date, value);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
    }]);
    return ISODayParser;
  }(Parser);

  var AMPMParser = /*#__PURE__*/function (_Parser) {
    _inherits(AMPMParser, _Parser);
    var _super = _createSuper(AMPMParser);
    function AMPMParser() {
      var _this;
      _classCallCheck(this, AMPMParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 80);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);
      return _this;
    }
    _createClass(AMPMParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'a':
          case 'aa':
          case 'aaa':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'aaaaa':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'aaaa':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return AMPMParser;
  }(Parser);

  var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
    _inherits(AMPMMidnightParser, _Parser);
    var _super = _createSuper(AMPMMidnightParser);
    function AMPMMidnightParser() {
      var _this;
      _classCallCheck(this, AMPMMidnightParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 80);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);
      return _this;
    }
    _createClass(AMPMMidnightParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'b':
          case 'bb':
          case 'bbb':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'bbbbb':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'bbbb':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return AMPMMidnightParser;
  }(Parser);

  var DayPeriodParser = /*#__PURE__*/function (_Parser) {
    _inherits(DayPeriodParser, _Parser);
    var _super = _createSuper(DayPeriodParser);
    function DayPeriodParser() {
      var _this;
      _classCallCheck(this, DayPeriodParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 80);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);
      return _this;
    }
    _createClass(DayPeriodParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'B':
          case 'BB':
          case 'BBB':
            return match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'BBBBB':
            return match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
          case 'BBBB':
          default:
            return match.dayPeriod(dateString, {
              width: 'wide',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'abbreviated',
              context: 'formatting'
            }) || match.dayPeriod(dateString, {
              width: 'narrow',
              context: 'formatting'
            });
        }
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
        return date;
      }
    }]);
    return DayPeriodParser;
  }(Parser);

  var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
    _inherits(Hour1to12Parser, _Parser);
    var _super = _createSuper(Hour1to12Parser);
    function Hour1to12Parser() {
      var _this;
      _classCallCheck(this, Hour1to12Parser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 70);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);
      return _this;
    }
    _createClass(Hour1to12Parser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'h':
            return parseNumericPattern(numericPatterns.hour12h, dateString);
          case 'ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 12;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else if (!isPM && value === 12) {
          date.setUTCHours(0, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }
        return date;
      }
    }]);
    return Hour1to12Parser;
  }(Parser);

  var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
    _inherits(Hour0to23Parser, _Parser);
    var _super = _createSuper(Hour0to23Parser);
    function Hour0to23Parser() {
      var _this;
      _classCallCheck(this, Hour0to23Parser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 70);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);
      return _this;
    }
    _createClass(Hour0to23Parser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'H':
            return parseNumericPattern(numericPatterns.hour23h, dateString);
          case 'Ho':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 23;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCHours(value, 0, 0, 0);
        return date;
      }
    }]);
    return Hour0to23Parser;
  }(Parser);

  var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
    _inherits(Hour0To11Parser, _Parser);
    var _super = _createSuper(Hour0To11Parser);
    function Hour0To11Parser() {
      var _this;
      _classCallCheck(this, Hour0To11Parser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 70);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);
      return _this;
    }
    _createClass(Hour0To11Parser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'K':
            return parseNumericPattern(numericPatterns.hour11h, dateString);
          case 'Ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 11;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        var isPM = date.getUTCHours() >= 12;
        if (isPM && value < 12) {
          date.setUTCHours(value + 12, 0, 0, 0);
        } else {
          date.setUTCHours(value, 0, 0, 0);
        }
        return date;
      }
    }]);
    return Hour0To11Parser;
  }(Parser);

  var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
    _inherits(Hour1To24Parser, _Parser);
    var _super = _createSuper(Hour1To24Parser);
    function Hour1To24Parser() {
      var _this;
      _classCallCheck(this, Hour1To24Parser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 70);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);
      return _this;
    }
    _createClass(Hour1To24Parser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'k':
            return parseNumericPattern(numericPatterns.hour24h, dateString);
          case 'ko':
            return match.ordinalNumber(dateString, {
              unit: 'hour'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 1 && value <= 24;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        var hours = value <= 24 ? value % 24 : value;
        date.setUTCHours(hours, 0, 0, 0);
        return date;
      }
    }]);
    return Hour1To24Parser;
  }(Parser);

  var MinuteParser = /*#__PURE__*/function (_Parser) {
    _inherits(MinuteParser, _Parser);
    var _super = _createSuper(MinuteParser);
    function MinuteParser() {
      var _this;
      _classCallCheck(this, MinuteParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 60);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
      return _this;
    }
    _createClass(MinuteParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 'm':
            return parseNumericPattern(numericPatterns.minute, dateString);
          case 'mo':
            return match.ordinalNumber(dateString, {
              unit: 'minute'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMinutes(value, 0, 0);
        return date;
      }
    }]);
    return MinuteParser;
  }(Parser);

  var SecondParser = /*#__PURE__*/function (_Parser) {
    _inherits(SecondParser, _Parser);
    var _super = _createSuper(SecondParser);
    function SecondParser() {
      var _this;
      _classCallCheck(this, SecondParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 50);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
      return _this;
    }
    _createClass(SecondParser, [{
      key: "parse",
      value: function parse(dateString, token, match) {
        switch (token) {
          case 's':
            return parseNumericPattern(numericPatterns.second, dateString);
          case 'so':
            return match.ordinalNumber(dateString, {
              unit: 'second'
            });
          default:
            return parseNDigits(token.length, dateString);
        }
      }
    }, {
      key: "validate",
      value: function validate(_date, value) {
        return value >= 0 && value <= 59;
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCSeconds(value, 0);
        return date;
      }
    }]);
    return SecondParser;
  }(Parser);

  var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
    _inherits(FractionOfSecondParser, _Parser);
    var _super = _createSuper(FractionOfSecondParser);
    function FractionOfSecondParser() {
      var _this;
      _classCallCheck(this, FractionOfSecondParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 30);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T']);
      return _this;
    }
    _createClass(FractionOfSecondParser, [{
      key: "parse",
      value: function parse(dateString, token) {
        var valueCallback = function valueCallback(value) {
          return Math.floor(value * Math.pow(10, -token.length + 3));
        };
        return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }, {
      key: "set",
      value: function set(date, _flags, value) {
        date.setUTCMilliseconds(value);
        return date;
      }
    }]);
    return FractionOfSecondParser;
  }(Parser);

  var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
    _inherits(ISOTimezoneWithZParser, _Parser);
    var _super = _createSuper(ISOTimezoneWithZParser);
    function ISOTimezoneWithZParser() {
      var _this;
      _classCallCheck(this, ISOTimezoneWithZParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 10);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'x']);
      return _this;
    }
    _createClass(ISOTimezoneWithZParser, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case 'X':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
          case 'XX':
            return parseTimezonePattern(timezonePatterns.basic, dateString);
          case 'XXXX':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
          case 'XXXXX':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
          case 'XXX':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value);
      }
    }]);
    return ISOTimezoneWithZParser;
  }(Parser);

  var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
    _inherits(ISOTimezoneParser, _Parser);
    var _super = _createSuper(ISOTimezoneParser);
    function ISOTimezoneParser() {
      var _this;
      _classCallCheck(this, ISOTimezoneParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 10);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", ['t', 'T', 'X']);
      return _this;
    }
    _createClass(ISOTimezoneParser, [{
      key: "parse",
      value: function parse(dateString, token) {
        switch (token) {
          case 'x':
            return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
          case 'xx':
            return parseTimezonePattern(timezonePatterns.basic, dateString);
          case 'xxxx':
            return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
          case 'xxxxx':
            return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
          case 'xxx':
          default:
            return parseTimezonePattern(timezonePatterns.extended, dateString);
        }
      }
    }, {
      key: "set",
      value: function set(date, flags, value) {
        if (flags.timestampIsSet) {
          return date;
        }
        return new Date(date.getTime() - value);
      }
    }]);
    return ISOTimezoneParser;
  }(Parser);

  var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
    _inherits(TimestampSecondsParser, _Parser);
    var _super = _createSuper(TimestampSecondsParser);
    function TimestampSecondsParser() {
      var _this;
      _classCallCheck(this, TimestampSecondsParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 40);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
      return _this;
    }
    _createClass(TimestampSecondsParser, [{
      key: "parse",
      value: function parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        return [new Date(value * 1000), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampSecondsParser;
  }(Parser);

  var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
    _inherits(TimestampMillisecondsParser, _Parser);
    var _super = _createSuper(TimestampMillisecondsParser);
    function TimestampMillisecondsParser() {
      var _this;
      _classCallCheck(this, TimestampMillisecondsParser);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      _this = _super.call.apply(_super, [this].concat(args));
      _defineProperty(_assertThisInitialized(_this), "priority", 20);
      _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');
      return _this;
    }
    _createClass(TimestampMillisecondsParser, [{
      key: "parse",
      value: function parse(dateString) {
        return parseAnyDigitsSigned(dateString);
      }
    }, {
      key: "set",
      value: function set(_date, _flags, value) {
        return [new Date(value), {
          timestampIsSet: true
        }];
      }
    }]);
    return TimestampMillisecondsParser;
  }(Parser);

  /*
   * |     | Unit                           |     | Unit                           |
   * |-----|--------------------------------|-----|--------------------------------|
   * |  a  | AM, PM                         |  A* | Milliseconds in day            |
   * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
   * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
   * |  d  | Day of month                   |  D  | Day of year                    |
   * |  e  | Local day of week              |  E  | Day of week                    |
   * |  f  |                                |  F* | Day of week in month           |
   * |  g* | Modified Julian day            |  G  | Era                            |
   * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
   * |  i! | ISO day of week                |  I! | ISO week of year               |
   * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
   * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
   * |  l* | (deprecated)                   |  L  | Stand-alone month              |
   * |  m  | Minute                         |  M  | Month                          |
   * |  n  |                                |  N  |                                |
   * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
   * |  p  |                                |  P  |                                |
   * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
   * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
   * |  s  | Second                         |  S  | Fraction of second             |
   * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
   * |  u  | Extended year                  |  U* | Cyclic year                    |
   * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
   * |  w  | Local week of year             |  W* | Week of month                  |
   * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
   * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
   * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
   *
   * Letters marked by * are not implemented but reserved by Unicode standard.
   *
   * Letters marked by ! are non-standard, but implemented by date-fns:
   * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
   * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
   *   i.e. 7 for Sunday, 1 for Monday, etc.
   * - `I` is ISO week of year, as opposed to `w` which is local week of year.
   * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
   *   `R` is supposed to be used in conjunction with `I` and `i`
   *   for universal ISO week-numbering date, whereas
   *   `Y` is supposed to be used in conjunction with `w` and `e`
   *   for week-numbering date specific to the locale.
   */
  var parsers = {
    G: new EraParser(),
    y: new YearParser(),
    Y: new LocalWeekYearParser(),
    R: new ISOWeekYearParser(),
    u: new ExtendedYearParser(),
    Q: new QuarterParser(),
    q: new StandAloneQuarterParser(),
    M: new MonthParser(),
    L: new StandAloneMonthParser(),
    w: new LocalWeekParser(),
    I: new ISOWeekParser(),
    d: new DateParser(),
    D: new DayOfYearParser(),
    E: new DayParser(),
    e: new LocalDayParser(),
    c: new StandAloneLocalDayParser(),
    i: new ISODayParser(),
    a: new AMPMParser(),
    b: new AMPMMidnightParser(),
    B: new DayPeriodParser(),
    h: new Hour1to12Parser(),
    H: new Hour0to23Parser(),
    K: new Hour0To11Parser(),
    k: new Hour1To24Parser(),
    m: new MinuteParser(),
    s: new SecondParser(),
    S: new FractionOfSecondParser(),
    X: new ISOTimezoneWithZParser(),
    x: new ISOTimezoneParser(),
    t: new TimestampSecondsParser(),
    T: new TimestampMillisecondsParser()
  };

  // - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  //   (one of the certain letters followed by `o`)
  // - (\w)\1* matches any sequences of the same letter
  // - '' matches two quote characters in a row
  // - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  //   except a single quote symbol, which ends the sequence.
  //   Two quote characters do not end the sequence.
  //   If there is no matching single quote
  //   then the sequence will continue until the end of the string.
  // - . matches any single character unmatched by previous parts of the RegExps
  var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

  // This RegExp catches symbols escaped by quotes, and also
  // sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
  var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  var escapedStringRegExp = /^'([^]*?)'?$/;
  var doubleQuoteRegExp = /''/g;
  var notWhitespaceRegExp = /\S/;
  var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

  /**
   * @name parse
   * @category Common Helpers
   * @summary Parse the date.
   *
   * @description
   * Return the date parsed from string using the given format string.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * The characters in the format string wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   *
   * Format of the format string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 5 below the table).
   *
   * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
   * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
   *
   * ```javascript
   * parse('23 AM', 'HH a', new Date())
   * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
   * ```
   *
   * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
   *
   * Accepted format string patterns:
   * | Unit                            |Prior| Pattern | Result examples                   | Notes |
   * |---------------------------------|-----|---------|-----------------------------------|-------|
   * | Era                             | 140 | G..GGG  | AD, BC                            |       |
   * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 |     | GGGGG   | A, B                              |       |
   * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
   * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
   * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
   * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
   * |                                 |     | yyyyy   | ...                               | 2,4   |
   * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
   * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
   * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
   * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
   * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
   * |                                 |     | YYYYY   | ...                               | 2,4   |
   * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
   * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
   * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
   * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
   * |                                 |     | RRRRR   | ...                               | 2,4,5 |
   * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
   * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
   * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
   * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
   * |                                 |     | uuuuu   | ...                               | 2,4   |
   * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
   * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
   * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
   * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
   * |                                 |     | qq      | 01, 02, 03, 04                    |       |
   * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
   * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
   * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | MM      | 01, 02, ..., 12                   |       |
   * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | MMMM    | January, February, ..., December  | 2     |
   * |                                 |     | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
   * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
   * |                                 |     | LL      | 01, 02, ..., 12                   |       |
   * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 |     | LLLL    | January, February, ..., December  | 2     |
   * |                                 |     | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
   * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
   * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
   * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
   * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
   * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
   * |                                 |     | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
   * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
   * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
   * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 |     | DDDD    | ...                               | 2     |
   * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
   * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
   * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
   * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
   * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
   * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
   * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
   * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | ee      | 02, 03, ..., 01                   |       |
   * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
   * |                                 |     | cc      | 02, 03, ..., 01                   |       |
   * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
   * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
   * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
   * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
   * |                                 |     | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 |     | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
   * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
   * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
   * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
   * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
   * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
   * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
   * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | mm      | 00, 01, ..., 59                   |       |
   * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
   * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
   * |                                 |     | ss      | 00, 01, ..., 59                   |       |
   * | Seconds timestamp               |  40 | t       | 512969520                         |       |
   * |                                 |     | tt      | ...                               | 2     |
   * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
   * |                                 |     | SS      | 00, 01, ..., 99                   |       |
   * |                                 |     | SSS     | 000, 001, ..., 999                |       |
   * |                                 |     | SSSS    | ...                               | 2     |
   * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
   * |                                 |     | TT      | ...                               | 2     |
   * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
   * |                                 |     | XX      | -0800, +0530, Z                   |       |
   * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
   * |                                 |     | xx      | -0800, +0530, +0000               |       |
   * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
   * |                                 |     | PP      | May 29, 1453                      |       |
   * |                                 |     | PPP     | May 29th, 1453                    |       |
   * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
   * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
   * |                                 |     | pp      | 12:00:00 AM                       |       |
   * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
   * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
   * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
   * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular.
   *    In `format` function, they will produce different result:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   *    `parse` will try to match both formatting and stand-alone units interchangably.
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table:
   *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
   *      as wide as the sequence
   *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
   *      These variations are marked with "2" in the last column of the table.
   *
   * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 4. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
   *
   *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
   *
   *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
   *
   *    while `uu` will just assign the year as is:
   *
   *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
   *
   *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
   *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
   *
   * 5. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
   *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
   *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   *
   * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
   *    on the given locale.
   *
   *    using `en-US` locale: `P` => `MM/dd/yyyy`
   *    using `en-US` locale: `p` => `hh:mm a`
   *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
   *    using `pt-BR` locale: `p` => `HH:mm`
   *
   * Values will be assigned to the date in the descending order of its unit's priority.
   * Units of an equal priority overwrite each other in the order of appearance.
   *
   * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
   * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
   *
   * `referenceDate` must be passed for correct work of the function.
   * If you're not sure which `referenceDate` to supply, create a new instance of Date:
   * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
   * In this case parsing will be done in the context of the current date.
   * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
   * then `Invalid Date` will be returned.
   *
   * The result may vary by locale.
   *
   * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
   *
   * If parsing failed, `Invalid Date` will be returned.
   * Invalid Date is a Date, whose time value is NaN.
   * Time value of Date: http://es5.github.io/#x15.9.1.1
   *
   * @param {String} dateString - the string to parse
   * @param {String} formatString - the string of tokens
   * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
   * @param {Object} [options] - an object with options.
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
   * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
   *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @returns {Date} the parsed date
   * @throws {TypeError} 3 arguments required
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} `options.locale` must contain `match` property
   * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
   * @throws {RangeError} format string contains an unescaped latin alphabet character
   *
   * @example
   * // Parse 11 February 2014 from middle-endian format:
   * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
   * //=> Tue Feb 11 2014 00:00:00
   *
   * @example
   * // Parse 28th of February in Esperanto locale in the context of 2010 year:
   * import eo from 'date-fns/locale/eo'
   * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
   *   locale: eo
   * })
   * //=> Sun Feb 28 2010 00:00:00
   */
  function parse$1(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
    var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
    requiredArgs$1(3, arguments);
    var dateString = String(dirtyDateString);
    var formatString = String(dirtyFormatString);
    var defaultOptions = getDefaultOptions$1();
    var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : defaultLocale$1;
    if (!locale.match) {
      throw new RangeError('locale must contain match property');
    }
    var firstWeekContainsDate = toInteger$2((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

    // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
    if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
      throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
    }
    var weekStartsOn = toInteger$2((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

    // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
    if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
      throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
    }
    if (formatString === '') {
      if (dateString === '') {
        return toDate$2(dirtyReferenceDate);
      } else {
        return new Date(NaN);
      }
    }
    var subFnOptions = {
      firstWeekContainsDate: firstWeekContainsDate,
      weekStartsOn: weekStartsOn,
      locale: locale
    };

    // If timezone isn't specified, it will be set to the system timezone
    var setters = [new DateToSystemTimezoneSetter()];
    var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
      var firstCharacter = substring[0];
      if (firstCharacter in longFormatters$2) {
        var longFormatter = longFormatters$2[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join('').match(formattingTokensRegExp);
    var usedTokens = [];
    var _iterator = _createForOfIteratorHelper(tokens),
      _step;
    try {
      var _loop = function _loop() {
        var token = _step.value;
        if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(token)) {
          throwProtectedError$1(token, formatString, dirtyDateString);
        }
        if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(token)) {
          throwProtectedError$1(token, formatString, dirtyDateString);
        }
        var firstCharacter = token[0];
        var parser = parsers[firstCharacter];
        if (parser) {
          var incompatibleTokens = parser.incompatibleTokens;
          if (Array.isArray(incompatibleTokens)) {
            var incompatibleToken = usedTokens.find(function (usedToken) {
              return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
            });
            if (incompatibleToken) {
              throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
            }
          } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
            throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
          }
          usedTokens.push({
            token: firstCharacter,
            fullToken: token
          });
          var parseResult = parser.run(dateString, token, locale.match, subFnOptions);
          if (!parseResult) {
            return {
              v: new Date(NaN)
            };
          }
          setters.push(parseResult.setter);
          dateString = parseResult.rest;
        } else {
          if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
            throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
          }

          // Replace two single quote characters with one single quote character
          if (token === "''") {
            token = "'";
          } else if (firstCharacter === "'") {
            token = cleanEscapedString(token);
          }

          // Cut token from string, or, if string doesn't match the token, return Invalid Date
          if (dateString.indexOf(token) === 0) {
            dateString = dateString.slice(token.length);
          } else {
            return {
              v: new Date(NaN)
            };
          }
        }
      };
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var _ret = _loop();
        if (_typeof$1(_ret) === "object") return _ret.v;
      }

      // Check if the remaining input contains something other than whitespace
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
    if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
      return new Date(NaN);
    }
    var uniquePrioritySetters = setters.map(function (setter) {
      return setter.priority;
    }).sort(function (a, b) {
      return b - a;
    }).filter(function (priority, index, array) {
      return array.indexOf(priority) === index;
    }).map(function (priority) {
      return setters.filter(function (setter) {
        return setter.priority === priority;
      }).sort(function (a, b) {
        return b.subPriority - a.subPriority;
      });
    }).map(function (setterArray) {
      return setterArray[0];
    });
    var date = toDate$2(dirtyReferenceDate);
    if (isNaN(date.getTime())) {
      return new Date(NaN);
    }

    // Convert the date in system timezone to the same date in UTC+00:00 timezone.
    var utcDate = subMilliseconds$1(date, getTimezoneOffsetInMilliseconds$2(date));
    var flags = {};
    var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
      _step2;
    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var setter = _step2.value;
        if (!setter.validate(utcDate, subFnOptions)) {
          return new Date(NaN);
        }
        var result = setter.set(utcDate, flags, subFnOptions);
        // Result is tuple (date, flags)
        if (Array.isArray(result)) {
          utcDate = result[0];
          assign$1(flags, result[1]);
          // Result is date
        } else {
          utcDate = result;
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
    return utcDate;
  }
  function cleanEscapedString(input) {
    return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
  }

  /**
   * @name startOfHour
   * @category Hour Helpers
   * @summary Return the start of an hour for the given date.
   *
   * @description
   * Return the start of an hour for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of an hour
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of an hour for 2 September 2014 11:55:00:
   * const result = startOfHour(new Date(2014, 8, 2, 11, 55))
   * //=> Tue Sep 02 2014 11:00:00
   */
  function startOfHour(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    date.setMinutes(0, 0, 0);
    return date;
  }

  /**
   * @name isSameMonth
   * @category Month Helpers
   * @summary Are the given dates in the same month (and year)?
   *
   * @description
   * Are the given dates in the same month (and year)?
   *
   * @param {Date|Number} dateLeft - the first date to check
   * @param {Date|Number} dateRight - the second date to check
   * @returns {Boolean} the dates are in the same month (and year)
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Are 2 September 2014 and 25 September 2014 in the same month?
   * const result = isSameMonth(new Date(2014, 8, 2), new Date(2014, 8, 25))
   * //=> true
   *
   * @example
   * // Are 2 September 2014 and 25 September 2015 in the same month?
   * const result = isSameMonth(new Date(2014, 8, 2), new Date(2015, 8, 25))
   * //=> false
   */
  function isSameMonth(dirtyDateLeft, dirtyDateRight) {
    requiredArgs$1(2, arguments);
    var dateLeft = toDate$2(dirtyDateLeft);
    var dateRight = toDate$2(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear() && dateLeft.getMonth() === dateRight.getMonth();
  }

  /**
   * @name isSameQuarter
   * @category Quarter Helpers
   * @summary Are the given dates in the same quarter (and year)?
   *
   * @description
   * Are the given dates in the same quarter (and year)?
   *
   * @param {Date|Number} dateLeft - the first date to check
   * @param {Date|Number} dateRight - the second date to check
   * @returns {Boolean} the dates are in the same quarter (and year)
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Are 1 January 2014 and 8 March 2014 in the same quarter?
   * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2014, 2, 8))
   * //=> true
   *
   * @example
   * // Are 1 January 2014 and 1 January 2015 in the same quarter?
   * const result = isSameQuarter(new Date(2014, 0, 1), new Date(2015, 0, 1))
   * //=> false
   */
  function isSameQuarter(dirtyDateLeft, dirtyDateRight) {
    requiredArgs$1(2, arguments);
    var dateLeftStartOfQuarter = startOfQuarter(dirtyDateLeft);
    var dateRightStartOfQuarter = startOfQuarter(dirtyDateRight);
    return dateLeftStartOfQuarter.getTime() === dateRightStartOfQuarter.getTime();
  }

  /**
   * @name startOfSecond
   * @category Second Helpers
   * @summary Return the start of a second for the given date.
   *
   * @description
   * Return the start of a second for the given date.
   * The result will be in the local timezone.
   *
   * @param {Date|Number} date - the original date
   * @returns {Date} the start of a second
   * @throws {TypeError} 1 argument required
   *
   * @example
   * // The start of a second for 1 December 2014 22:15:45.400:
   * const result = startOfSecond(new Date(2014, 11, 1, 22, 15, 45, 400))
   * //=> Mon Dec 01 2014 22:15:45.000
   */
  function startOfSecond(dirtyDate) {
    requiredArgs$1(1, arguments);
    var date = toDate$2(dirtyDate);
    date.setMilliseconds(0);
    return date;
  }

  /**
   * @name isSameYear
   * @category Year Helpers
   * @summary Are the given dates in the same year?
   *
   * @description
   * Are the given dates in the same year?
   *
   * @param {Date|Number} dateLeft - the first date to check
   * @param {Date|Number} dateRight - the second date to check
   * @returns {Boolean} the dates are in the same year
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Are 2 September 2014 and 25 September 2014 in the same year?
   * const result = isSameYear(new Date(2014, 8, 2), new Date(2014, 8, 25))
   * //=> true
   */
  function isSameYear(dirtyDateLeft, dirtyDateRight) {
    requiredArgs$1(2, arguments);
    var dateLeft = toDate$2(dirtyDateLeft);
    var dateRight = toDate$2(dirtyDateRight);
    return dateLeft.getFullYear() === dateRight.getFullYear();
  }

  /**
   * @name setMonth
   * @category Month Helpers
   * @summary Set the month to the given date.
   *
   * @description
   * Set the month to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} month - the month of the new date
   * @returns {Date} the new date with the month set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set February to 1 September 2014:
   * const result = setMonth(new Date(2014, 8, 1), 1)
   * //=> Sat Feb 01 2014 00:00:00
   */
  function setMonth(dirtyDate, dirtyMonth) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var month = toInteger$2(dirtyMonth);
    var year = date.getFullYear();
    var day = date.getDate();
    var dateWithDesiredMonth = new Date(0);
    dateWithDesiredMonth.setFullYear(year, month, 15);
    dateWithDesiredMonth.setHours(0, 0, 0, 0);
    var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
    // Set the last day of the new month
    // if the original date was the last day of the longer month
    date.setMonth(month, Math.min(day, daysInMonth));
    return date;
  }

  /**
   * @name set
   * @category Common Helpers
   * @summary Set date values to a given date.
   *
   * @description
   * Set date values to a given date.
   *
   * Sets time values to date from object `values`.
   * A value is not set if it is undefined or null or doesn't exist in `values`.
   *
   * Note about bundle size: `set` does not internally use `setX` functions from date-fns but instead opts
   * to use native `Date#setX` methods. If you use this function, you may not want to include the
   * other `setX` functions that date-fns provides if you are concerned about the bundle size.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Object} values - an object with options
   * @param {Number} [values.year] - the number of years to be set
   * @param {Number} [values.month] - the number of months to be set
   * @param {Number} [values.date] - the number of days to be set
   * @param {Number} [values.hours] - the number of hours to be set
   * @param {Number} [values.minutes] - the number of minutes to be set
   * @param {Number} [values.seconds] - the number of seconds to be set
   * @param {Number} [values.milliseconds] - the number of milliseconds to be set
   * @returns {Date} the new date with options set
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `values` must be an object
   *
   * @example
   * // Transform 1 September 2014 into 20 October 2015 in a single line:
   * const result = set(new Date(2014, 8, 20), { year: 2015, month: 9, date: 20 })
   * //=> Tue Oct 20 2015 00:00:00
   *
   * @example
   * // Set 12 PM to 1 September 2014 01:23:45 to 1 September 2014 12:00:00:
   * const result = set(new Date(2014, 8, 1, 1, 23, 45), { hours: 12 })
   * //=> Mon Sep 01 2014 12:23:45
   */
  function set(dirtyDate, values) {
    requiredArgs$1(2, arguments);
    if (_typeof$1(values) !== 'object' || values === null) {
      throw new RangeError('values parameter must be an object');
    }
    var date = toDate$2(dirtyDate);

    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(date.getTime())) {
      return new Date(NaN);
    }
    if (values.year != null) {
      date.setFullYear(values.year);
    }
    if (values.month != null) {
      date = setMonth(date, values.month);
    }
    if (values.date != null) {
      date.setDate(toInteger$2(values.date));
    }
    if (values.hours != null) {
      date.setHours(toInteger$2(values.hours));
    }
    if (values.minutes != null) {
      date.setMinutes(toInteger$2(values.minutes));
    }
    if (values.seconds != null) {
      date.setSeconds(toInteger$2(values.seconds));
    }
    if (values.milliseconds != null) {
      date.setMilliseconds(toInteger$2(values.milliseconds));
    }
    return date;
  }

  /**
   * @name setHours
   * @category Hour Helpers
   * @summary Set the hours to the given date.
   *
   * @description
   * Set the hours to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} hours - the hours of the new date
   * @returns {Date} the new date with the hours set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set 4 hours to 1 September 2014 11:30:00:
   * const result = setHours(new Date(2014, 8, 1, 11, 30), 4)
   * //=> Mon Sep 01 2014 04:30:00
   */
  function setHours(dirtyDate, dirtyHours) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var hours = toInteger$2(dirtyHours);
    date.setHours(hours);
    return date;
  }

  /**
   * @name setMinutes
   * @category Minute Helpers
   * @summary Set the minutes to the given date.
   *
   * @description
   * Set the minutes to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} minutes - the minutes of the new date
   * @returns {Date} the new date with the minutes set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set 45 minutes to 1 September 2014 11:30:40:
   * const result = setMinutes(new Date(2014, 8, 1, 11, 30, 40), 45)
   * //=> Mon Sep 01 2014 11:45:40
   */
  function setMinutes(dirtyDate, dirtyMinutes) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var minutes = toInteger$2(dirtyMinutes);
    date.setMinutes(minutes);
    return date;
  }

  /**
   * @name setQuarter
   * @category Quarter Helpers
   * @summary Set the year quarter to the given date.
   *
   * @description
   * Set the year quarter to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} quarter - the quarter of the new date
   * @returns {Date} the new date with the quarter set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set the 2nd quarter to 2 July 2014:
   * const result = setQuarter(new Date(2014, 6, 2), 2)
   * //=> Wed Apr 02 2014 00:00:00
   */
  function setQuarter(dirtyDate, dirtyQuarter) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var quarter = toInteger$2(dirtyQuarter);
    var oldQuarter = Math.floor(date.getMonth() / 3) + 1;
    var diff = quarter - oldQuarter;
    return setMonth(date, date.getMonth() + diff * 3);
  }

  /**
   * @name setSeconds
   * @category Second Helpers
   * @summary Set the seconds to the given date.
   *
   * @description
   * Set the seconds to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} seconds - the seconds of the new date
   * @returns {Date} the new date with the seconds set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set 45 seconds to 1 September 2014 11:30:40:
   * const result = setSeconds(new Date(2014, 8, 1, 11, 30, 40), 45)
   * //=> Mon Sep 01 2014 11:30:45
   */
  function setSeconds(dirtyDate, dirtySeconds) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var seconds = toInteger$2(dirtySeconds);
    date.setSeconds(seconds);
    return date;
  }

  /**
   * @name setYear
   * @category Year Helpers
   * @summary Set the year to the given date.
   *
   * @description
   * Set the year to the given date.
   *
   * @param {Date|Number} date - the date to be changed
   * @param {Number} year - the year of the new date
   * @returns {Date} the new date with the year set
   * @throws {TypeError} 2 arguments required
   *
   * @example
   * // Set year 2013 to 1 September 2014:
   * const result = setYear(new Date(2014, 8, 1), 2013)
   * //=> Sun Sep 01 2013 00:00:00
   */
  function setYear(dirtyDate, dirtyYear) {
    requiredArgs$1(2, arguments);
    var date = toDate$2(dirtyDate);
    var year = toInteger$2(dirtyYear);

    // Check if date is Invalid Date because Date.prototype.setFullYear ignores the value of Invalid Date
    if (isNaN(date.getTime())) {
      return new Date(NaN);
    }
    date.setFullYear(year);
    return date;
  }

  function useLocale(ns) {
      const { mergedLocaleRef, mergedDateLocaleRef } = inject(configProviderInjectionKey, null) || {};
      const localeRef = computed(() => {
          var _a, _b;
          return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$2[ns];
      });
      const dateLocaleRef = computed(() => {
          var _a;
          return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUS;
      });
      return {
          dateLocaleRef,
          localeRef
      };
  }

  function useStyle(mountId, style, clsPrefixRef) {
      if (!style) {
          return;
      }
      const ssrAdapter = useSsrAdapter();
      const NConfigProvider = inject(configProviderInjectionKey, null);
      const mountStyle = () => {
          const clsPrefix = clsPrefixRef.value;
          style.mount({
              id: clsPrefix === undefined ? mountId : clsPrefix + mountId,
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              props: {
                  bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
              },
              ssr: ssrAdapter
          });
          if (!(NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled)) {
              globalStyle.mount({
                  id: 'n-global',
                  head: true,
                  anchorMetaName: cssrAnchorMetaName,
                  ssr: ssrAdapter
              });
          }
      };
      if (ssrAdapter) {
          mountStyle();
      }
      else {
          onBeforeMount(mountStyle);
      }
  }

  function useHljs(props, shouldHighlightRef) {
      const NConfigProvider = inject(configProviderInjectionKey, null);
      return computed(() => {
          return props.hljs || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value);
      });
  }

  function useThemeClass(componentName, hashRef, cssVarsRef, props) {
      var _a;
      if (!cssVarsRef)
          throwError('useThemeClass', 'cssVarsRef is not passed');
      const mergedThemeHashRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedThemeHashRef;
      const themeClassRef = ref('');
      const ssrAdapter = useSsrAdapter();
      let renderCallback;
      const hashClassPrefix = `__${componentName}`;
      const mountStyle = () => {
          let finalThemeHash = hashClassPrefix;
          const hashValue = hashRef ? hashRef.value : undefined;
          const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
          if (themeHash)
              finalThemeHash += '-' + themeHash;
          if (hashValue)
              finalThemeHash += '-' + hashValue;
          const { themeOverrides, builtinThemeOverrides } = props;
          if (themeOverrides) {
              finalThemeHash += '-' + murmur2(JSON.stringify(themeOverrides));
          }
          if (builtinThemeOverrides) {
              finalThemeHash += '-' + murmur2(JSON.stringify(builtinThemeOverrides));
          }
          themeClassRef.value = finalThemeHash;
          renderCallback = () => {
              const cssVars = cssVarsRef.value;
              let style = '';
              for (const key in cssVars) {
                  style += `${key}: ${cssVars[key]};`;
              }
              c$1(`.${finalThemeHash}`, style).mount({
                  id: finalThemeHash,
                  ssr: ssrAdapter
              });
              renderCallback = undefined;
          };
      };
      watchEffect(() => {
          mountStyle();
      });
      return {
          themeClass: themeClassRef,
          onRender: () => {
              renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
          }
      };
  }

  function useRtl(mountId, rtlStateRef, clsPrefixRef) {
      if (!rtlStateRef)
          return undefined;
      const ssrAdapter = useSsrAdapter();
      const componentRtlStateRef = computed(() => {
          const { value: rtlState } = rtlStateRef;
          if (!rtlState) {
              return undefined;
          }
          const componentRtlState = rtlState[mountId];
          if (!componentRtlState) {
              return undefined;
          }
          return componentRtlState;
      });
      const mountStyle = () => {
          watchEffect(() => {
              const { value: clsPrefix } = clsPrefixRef;
              const id = `${clsPrefix}${mountId}Rtl`;
              // if it already exists, we only need to watch clsPrefix, although in most
              // of time it's unnecessary... However we can at least listen less
              // handlers, which is great.
              if (exists(id, ssrAdapter))
                  return;
              const { value: componentRtlState } = componentRtlStateRef;
              if (!componentRtlState)
                  return;
              componentRtlState.style.mount({
                  id,
                  head: true,
                  anchorMetaName: cssrAnchorMetaName,
                  props: {
                      bPrefix: clsPrefix ? `.${clsPrefix}-` : undefined
                  },
                  ssr: ssrAdapter
              });
          });
      };
      if (ssrAdapter) {
          mountStyle();
      }
      else {
          onBeforeMount(mountStyle);
      }
      return componentRtlStateRef;
  }

  function getScrollTop(target) {
      return target instanceof HTMLElement ? target.scrollTop : window.scrollY;
  }
  function getRect(target) {
      return target instanceof HTMLElement
          ? target.getBoundingClientRect()
          : { top: 0, bottom: window.innerHeight };
  }

  var style$1B = cB('affix', [cM('affixed', {
    position: 'fixed'
  }, [cM('absolute-positioned', {
    position: 'absolute'
  })])]);

  const affixProps = {
      listenTo: [String, Object, Function],
      top: Number,
      bottom: Number,
      triggerTop: Number,
      triggerBottom: Number,
      position: {
          type: String,
          default: 'fix'
      },
      // deprecated
      offsetTop: {
          type: Number,
          validator: () => {
              return true;
          },
          default: undefined
      },
      offsetBottom: {
          type: Number,
          validator: () => {
              return true;
          },
          default: undefined
      },
      target: {
          type: Function,
          validator: () => {
              return true;
          },
          default: undefined
      }
  };
  const affixPropKeys = keysOf(affixProps);
  var NAffix = defineComponent({
      name: 'Affix',
      props: affixProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useStyle('-affix', style$1B, mergedClsPrefixRef);
          let scrollTarget = null;
          const stickToTopRef = ref(false);
          const stickToBottomRef = ref(false);
          const bottomAffixedTriggerScrollTopRef = ref(null);
          const topAffixedTriggerScrollTopRef = ref(null);
          const affixedRef = computed(() => {
              return stickToBottomRef.value || stickToTopRef.value;
          });
          const mergedOffsetTopRef = computed(() => {
              var _a, _b;
              return (_b = (_a = props.triggerTop) !== null && _a !== void 0 ? _a : props.offsetTop) !== null && _b !== void 0 ? _b : props.top;
          });
          const mergedTopRef = computed(() => {
              var _a, _b;
              return (_b = (_a = props.top) !== null && _a !== void 0 ? _a : props.triggerTop) !== null && _b !== void 0 ? _b : props.offsetTop;
          });
          const mergedBottomRef = computed(() => {
              var _a, _b;
              return (_b = (_a = props.bottom) !== null && _a !== void 0 ? _a : props.triggerBottom) !== null && _b !== void 0 ? _b : props.offsetBottom;
          });
          const mergedOffsetBottomRef = computed(() => {
              var _a, _b;
              return (_b = (_a = props.triggerBottom) !== null && _a !== void 0 ? _a : props.offsetBottom) !== null && _b !== void 0 ? _b : props.bottom;
          });
          const selfRef = ref(null);
          const init = () => {
              const { target: getScrollTarget, listenTo } = props;
              if (getScrollTarget) {
                  // deprecated
                  scrollTarget = getScrollTarget();
              }
              else if (listenTo) {
                  scrollTarget = unwrapElement(listenTo);
              }
              else {
                  scrollTarget = document;
              }
              if (scrollTarget) {
                  scrollTarget.addEventListener('scroll', handleScroll);
                  handleScroll();
              }
          };
          function handleScroll() {
              beforeNextFrameOnce(_handleScroll);
          }
          function _handleScroll() {
              const { value: selfEl } = selfRef;
              if (!scrollTarget || !selfEl)
                  return;
              const scrollTop = getScrollTop(scrollTarget);
              if (affixedRef.value) {
                  if (topAffixedTriggerScrollTopRef.value !== null &&
                      scrollTop < topAffixedTriggerScrollTopRef.value) {
                      stickToTopRef.value = false;
                      topAffixedTriggerScrollTopRef.value = null;
                  }
                  if (bottomAffixedTriggerScrollTopRef.value !== null &&
                      scrollTop > bottomAffixedTriggerScrollTopRef.value) {
                      stickToBottomRef.value = false;
                      bottomAffixedTriggerScrollTopRef.value = null;
                  }
                  return;
              }
              const containerRect = getRect(scrollTarget);
              const affixRect = selfEl.getBoundingClientRect();
              const pxToTop = affixRect.top - containerRect.top;
              const pxToBottom = containerRect.bottom - affixRect.bottom;
              const mergedOffsetTop = mergedOffsetTopRef.value;
              const mergedOffsetBottom = mergedOffsetBottomRef.value;
              if (mergedOffsetTop !== undefined && pxToTop <= mergedOffsetTop) {
                  stickToTopRef.value = true;
                  topAffixedTriggerScrollTopRef.value =
                      scrollTop - (mergedOffsetTop - pxToTop);
              }
              else {
                  stickToTopRef.value = false;
                  topAffixedTriggerScrollTopRef.value = null;
              }
              if (mergedOffsetBottom !== undefined &&
                  pxToBottom <= mergedOffsetBottom) {
                  stickToBottomRef.value = true;
                  bottomAffixedTriggerScrollTopRef.value =
                      scrollTop + mergedOffsetBottom - pxToBottom;
              }
              else {
                  stickToBottomRef.value = false;
                  bottomAffixedTriggerScrollTopRef.value = null;
              }
          }
          onMounted(() => {
              init();
          });
          onBeforeUnmount(() => {
              if (!scrollTarget)
                  return;
              scrollTarget.removeEventListener('scroll', handleScroll);
          });
          return {
              selfRef,
              affixed: affixedRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedstyle: computed(() => {
                  const style = {};
                  if (stickToTopRef.value &&
                      mergedOffsetTopRef.value !== undefined &&
                      mergedTopRef.value !== undefined) {
                      style.top = `${mergedTopRef.value}px`;
                  }
                  if (stickToBottomRef.value &&
                      mergedOffsetBottomRef.value !== undefined &&
                      mergedBottomRef.value !== undefined) {
                      style.bottom = `${mergedBottomRef.value}px`;
                  }
                  return style;
              })
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { ref: "selfRef", class: [
                  `${mergedClsPrefix}-affix`,
                  {
                      [`${mergedClsPrefix}-affix--affixed`]: this.affixed,
                      [`${mergedClsPrefix}-affix--absolute-positioned`]: this.position === 'absolute'
                  }
              ], style: this.mergedstyle }, this.$slots));
      }
  });

  var AddIcon = defineComponent({
      name: 'Add',
      render() {
          return (h("svg", { width: "512", height: "512", viewBox: "0 0 512 512", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M256 112V400M400 256H112", stroke: "currentColor", "stroke-width": "32", "stroke-linecap": "round", "stroke-linejoin": "round" })));
      }
  });

  var ArrowDownIcon = defineComponent({
      name: 'ArrowDown',
      render() {
          return (h("svg", { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
              h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
                  h("g", { "fill-rule": "nonzero" },
                      h("path", { d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z" })))));
      }
  });

  var ArrowUpIcon = defineComponent({
      name: 'ArrowUp',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
              h("g", { fill: "none" },
                  h("path", { d: "M3.13 9.163a.5.5 0 1 0 .74.674L9.5 3.67V17.5a.5.5 0 0 0 1 0V3.672l5.63 6.165a.5.5 0 0 0 .738-.674l-6.315-6.916a.746.746 0 0 0-.632-.24a.746.746 0 0 0-.476.24L3.131 9.163z", fill: "currentColor" }))));
      }
  });

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function replaceable(name, icon) {
      return defineComponent({
          name: upperFirst$1(name),
          setup() {
              var _a;
              const mergedIconsRef = (_a = inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
              return () => {
                  var _a;
                  const iconOverride = (_a = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a === void 0 ? void 0 : _a[name];
                  return iconOverride ? iconOverride() : icon;
              };
          }
      });
  }

  var AttachIcon = replaceable('attach', h("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M3.25735931,8.70710678 L7.85355339,4.1109127 C8.82986412,3.13460197 10.4127766,3.13460197 11.3890873,4.1109127 C12.365398,5.08722343 12.365398,6.67013588 11.3890873,7.64644661 L6.08578644,12.9497475 C5.69526215,13.3402718 5.06209717,13.3402718 4.67157288,12.9497475 C4.28104858,12.5592232 4.28104858,11.9260582 4.67157288,11.5355339 L9.97487373,6.23223305 C10.1701359,6.0369709 10.1701359,5.72038841 9.97487373,5.52512627 C9.77961159,5.32986412 9.4630291,5.32986412 9.26776695,5.52512627 L3.96446609,10.8284271 C3.18341751,11.6094757 3.18341751,12.8758057 3.96446609,13.6568542 C4.74551468,14.4379028 6.01184464,14.4379028 6.79289322,13.6568542 L12.0961941,8.35355339 C13.4630291,6.98671837 13.4630291,4.77064094 12.0961941,3.40380592 C10.7293591,2.0369709 8.51328163,2.0369709 7.14644661,3.40380592 L2.55025253,8 C2.35499039,8.19526215 2.35499039,8.51184464 2.55025253,8.70710678 C2.74551468,8.90236893 3.06209717,8.90236893 3.25735931,8.70710678 Z" })))));

  var BackwardIcon = defineComponent({
      name: 'Backward',
      render() {
          return (h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z", fill: "currentColor" })));
      }
  });

  var DateIcon = replaceable('date', h("svg", { width: "28px", height: "28px", viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { "fill-rule": "nonzero" },
              h("path", { d: "M21.75,3 C23.5449254,3 25,4.45507456 25,6.25 L25,21.75 C25,23.5449254 23.5449254,25 21.75,25 L6.25,25 C4.45507456,25 3,23.5449254 3,21.75 L3,6.25 C3,4.45507456 4.45507456,3 6.25,3 L21.75,3 Z M23.5,9.503 L4.5,9.503 L4.5,21.75 C4.5,22.7164983 5.28350169,23.5 6.25,23.5 L21.75,23.5 C22.7164983,23.5 23.5,22.7164983 23.5,21.75 L23.5,9.503 Z M21.75,4.5 L6.25,4.5 C5.28350169,4.5 4.5,5.28350169 4.5,6.25 L4.5,8.003 L23.5,8.003 L23.5,6.25 C23.5,5.28350169 22.7164983,4.5 21.75,4.5 Z" })))));

  var FinishedIcon = defineComponent({
      name: 'Checkmark',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
              h("g", { fill: "none" },
                  h("path", { d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z", fill: "currentColor" }))));
      }
  });

  var ChevronLeftIcon = defineComponent({
      name: 'ChevronLeft',
      render() {
          return (h("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M10.3536 3.14645C10.5488 3.34171 10.5488 3.65829 10.3536 3.85355L6.20711 8L10.3536 12.1464C10.5488 12.3417 10.5488 12.6583 10.3536 12.8536C10.1583 13.0488 9.84171 13.0488 9.64645 12.8536L5.14645 8.35355C4.95118 8.15829 4.95118 7.84171 5.14645 7.64645L9.64645 3.14645C9.84171 2.95118 10.1583 2.95118 10.3536 3.14645Z", fill: "currentColor" })));
      }
  });

  var ChevronRightIcon = defineComponent({
      name: 'ChevronRight',
      render() {
          return (h("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z", fill: "currentColor" })));
      }
  });

  var ErrorIcon$1 = replaceable('close', h("svg", { viewBox: "0 0 12 12", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "aria-hidden": true },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z" })))));

  var EyeIcon = defineComponent({
      name: 'Eye',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
              h("path", { d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z", fill: "none", stroke: "currentColor", "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": "32" }),
              h("circle", { cx: "256", cy: "256", r: "80", fill: "none", stroke: "currentColor", "stroke-miterlimit": "10", "stroke-width": "32" })));
      }
  });

  var EyeOffIcon = defineComponent({
      name: 'EyeOff',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
              h("path", { d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z", fill: "currentColor" }),
              h("path", { d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z", fill: "currentColor" }),
              h("path", { d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z", fill: "currentColor" }),
              h("path", { d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z", fill: "currentColor" }),
              h("path", { d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z", fill: "currentColor" })));
      }
  });

  var TrashIcon = replaceable('trash', h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
      h("path", { d: "M432,144,403.33,419.74A32,32,0,0,1,371.55,448H140.46a32,32,0,0,1-31.78-28.26L80,144", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
      h("rect", { x: "32", y: "64", width: "448", height: "80", rx: "16", ry: "16", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
      h("line", { x1: "312", y1: "240", x2: "200", y2: "352", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" }),
      h("line", { x1: "312", y1: "352", x2: "200", y2: "240", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" })));

  var DownloadIcon = replaceable('download', h("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M3.5,13 L12.5,13 C12.7761424,13 13,13.2238576 13,13.5 C13,13.7454599 12.8231248,13.9496084 12.5898756,13.9919443 L12.5,14 L3.5,14 C3.22385763,14 3,13.7761424 3,13.5 C3,13.2545401 3.17687516,13.0503916 3.41012437,13.0080557 L3.5,13 L12.5,13 L3.5,13 Z M7.91012437,1.00805567 L8,1 C8.24545989,1 8.44960837,1.17687516 8.49194433,1.41012437 L8.5,1.5 L8.5,10.292 L11.1819805,7.6109127 C11.3555469,7.43734635 11.6249713,7.4180612 11.8198394,7.55305725 L11.8890873,7.6109127 C12.0626536,7.78447906 12.0819388,8.05390346 11.9469427,8.2487716 L11.8890873,8.31801948 L8.35355339,11.8535534 C8.17998704,12.0271197 7.91056264,12.0464049 7.7156945,11.9114088 L7.64644661,11.8535534 L4.1109127,8.31801948 C3.91565056,8.12275734 3.91565056,7.80617485 4.1109127,7.6109127 C4.28447906,7.43734635 4.55390346,7.4180612 4.7487716,7.55305725 L4.81801948,7.6109127 L7.5,10.292 L7.5,1.5 C7.5,1.25454011 7.67687516,1.05039163 7.91012437,1.00805567 L8,1 L7.91012437,1.00805567 Z" })))));

  var EmptyIcon = defineComponent({
      name: 'Empty',
      render() {
          return (h("svg", { viewBox: "0 0 28 28", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z", fill: "currentColor" }),
              h("path", { d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z", fill: "currentColor" })));
      }
  });

  var ErrorIcon = replaceable('error', h("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { "fill-rule": "nonzero" },
              h("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z" })))));

  var FastBackwardIcon = defineComponent({
      name: 'FastBackward',
      render() {
          return (h("svg", { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
              h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
                  h("g", { fill: "currentColor", "fill-rule": "nonzero" },
                      h("path", { d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z" })))));
      }
  });

  var FastForwardIcon = defineComponent({
      name: 'FastForward',
      render() {
          return (h("svg", { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
              h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
                  h("g", { fill: "currentColor", "fill-rule": "nonzero" },
                      h("path", { d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z" })))));
      }
  });

  var FilterIcon = defineComponent({
      name: 'Filter',
      render() {
          return (h("svg", { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
              h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
                  h("g", { "fill-rule": "nonzero" },
                      h("path", { d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z" })))));
      }
  });

  var ForwardIcon = defineComponent({
      name: 'Forward',
      render() {
          return (h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z", fill: "currentColor" })));
      }
  });

  var InfoIcon = replaceable('info', h("svg", { viewBox: "0 0 28 28", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { "fill-rule": "nonzero" },
              h("path", { d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z" })))));

  var MoreIcon = defineComponent({
      name: 'More',
      render() {
          return (h("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
              h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
                  h("g", { fill: "currentColor", "fill-rule": "nonzero" },
                      h("path", { d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z" })))));
      }
  });

  var RemoveIcon = defineComponent({
      name: 'Remove',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
              h("line", { x1: "400", y1: "256", x2: "112", y2: "256", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })));
      }
  });

  var SearchIcon = defineComponent({
      name: 'Search',
      render() {
          return (h("svg", { version: "1.1", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512", style: "enable-background: new 0 0 512 512" },
              h("path", { d: "M443.5,420.2L336.7,312.4c20.9-26.2,33.5-59.4,33.5-95.5c0-84.5-68.5-153-153.1-153S64,132.5,64,217s68.5,153,153.1,153\n  c36.6,0,70.1-12.8,96.5-34.2l106.1,107.1c3.2,3.4,7.6,5.1,11.9,5.1c4.1,0,8.2-1.5,11.3-4.5C449.5,437.2,449.7,426.8,443.5,420.2z\n   M217.1,337.1c-32.1,0-62.3-12.5-85-35.2c-22.7-22.7-35.2-52.9-35.2-84.9c0-32.1,12.5-62.3,35.2-84.9c22.7-22.7,52.9-35.2,85-35.2\n  c32.1,0,62.3,12.5,85,35.2c22.7,22.7,35.2,52.9,35.2,84.9c0,32.1-12.5,62.3-35.2,84.9C279.4,324.6,249.2,337.1,217.1,337.1z" })));
      }
  });

  var SuccessIcon = replaceable('success', h("svg", { viewBox: "0 0 48 48", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { "fill-rule": "nonzero" },
              h("path", { d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z" })))));

  var SwitcherIcon = defineComponent({
      name: 'Switcher',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
              h("path", { d: "M12 8l10 8l-10 8z" })));
      }
  });

  var TimeIcon = replaceable('time', h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
      h("path", { d: "M256,64C150,64,64,150,64,256s86,192,192,192,192-86,192-192S362,64,256,64Z", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-miterlimit: 10;\n        stroke-width: 32px;\n      " }),
      h("polyline", { points: "256 128 256 272 352 272", style: "\n        fill: none;\n        stroke: currentColor;\n        stroke-linecap: round;\n        stroke-linejoin: round;\n        stroke-width: 32px;\n      " })));

  var WarningIcon = replaceable('warning', h("svg", { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { "fill-rule": "nonzero" },
              h("path", { d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z" })))));

  var CancelIcon = replaceable('cancel', h("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M2.58859116,2.7156945 L2.64644661,2.64644661 C2.82001296,2.47288026 3.08943736,2.45359511 3.2843055,2.58859116 L3.35355339,2.64644661 L8,7.293 L12.6464466,2.64644661 C12.8417088,2.45118446 13.1582912,2.45118446 13.3535534,2.64644661 C13.5488155,2.84170876 13.5488155,3.15829124 13.3535534,3.35355339 L8.707,8 L13.3535534,12.6464466 C13.5271197,12.820013 13.5464049,13.0894374 13.4114088,13.2843055 L13.3535534,13.3535534 C13.179987,13.5271197 12.9105626,13.5464049 12.7156945,13.4114088 L12.6464466,13.3535534 L8,8.707 L3.35355339,13.3535534 C3.15829124,13.5488155 2.84170876,13.5488155 2.64644661,13.3535534 C2.45118446,13.1582912 2.45118446,12.8417088 2.64644661,12.6464466 L7.293,8 L2.64644661,3.35355339 C2.47288026,3.17998704 2.45359511,2.91056264 2.58859116,2.7156945 L2.64644661,2.64644661 L2.58859116,2.7156945 Z" })))));

  var ChevronDownIcon = defineComponent({
      name: 'ChevronDown',
      render() {
          return (h("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z", fill: "currentColor" })));
      }
  });

  var ClearIcon = replaceable('clear', h("svg", { viewBox: "0 0 16 16", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z" })))));

  var ChevronDownFilledIcon = defineComponent({
      name: 'ChevronDownFilled',
      render() {
          return (h("svg", { viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
              h("path", { d: "M3.20041 5.73966C3.48226 5.43613 3.95681 5.41856 4.26034 5.70041L8 9.22652L11.7397 5.70041C12.0432 5.41856 12.5177 5.43613 12.7996 5.73966C13.0815 6.0432 13.0639 6.51775 12.7603 6.7996L8.51034 10.7996C8.22258 11.0668 7.77743 11.0668 7.48967 10.7996L3.23966 6.7996C2.93613 6.51775 2.91856 6.0432 3.20041 5.73966Z", fill: "currentColor" })));
      }
  });

  var ToIcon = replaceable('to', h("svg", { viewBox: "0 0 20 20", version: "1.1", xmlns: "http://www.w3.org/2000/svg" },
      h("g", { stroke: "none", "stroke-width": "1", fill: "none", "fill-rule": "evenodd" },
          h("g", { fill: "currentColor", "fill-rule": "nonzero" },
              h("path", { d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z" })))));

  var RetryIcon = replaceable('retry', h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 512 512" },
      h("path", { d: "M320,146s24.36-12-64-12A160,160,0,1,0,416,294", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-miterlimit: 10; stroke-width: 32px;" }),
      h("polyline", { points: "256 58 336 138 256 218", style: "fill: none; stroke: currentcolor; stroke-linecap: round; stroke-linejoin: round; stroke-width: 32px;" })));

  var ArrowBackIcon = defineComponent({
      name: 'ArrowBack',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" },
              h("path", { d: "M0 0h24v24H0V0z", fill: "none" }),
              h("path", { d: "M19 11H7.83l4.88-4.88c.39-.39.39-1.03 0-1.42-.39-.39-1.02-.39-1.41 0l-6.59 6.59c-.39.39-.39 1.02 0 1.41l6.59 6.59c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L7.83 13H19c.55 0 1-.45 1-1s-.45-1-1-1z" })));
      }
  });

  var RotateClockwiseIcon = replaceable('rotateClockwise', h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M3 10C3 6.13401 6.13401 3 10 3C13.866 3 17 6.13401 17 10C17 12.7916 15.3658 15.2026 13 16.3265V14.5C13 14.2239 12.7761 14 12.5 14C12.2239 14 12 14.2239 12 14.5V17.5C12 17.7761 12.2239 18 12.5 18H15.5C15.7761 18 16 17.7761 16 17.5C16 17.2239 15.7761 17 15.5 17H13.8758C16.3346 15.6357 18 13.0128 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 10.2761 2.22386 10.5 2.5 10.5C2.77614 10.5 3 10.2761 3 10Z", fill: "currentColor" }),
      h("path", { d: "M10 12C11.1046 12 12 11.1046 12 10C12 8.89543 11.1046 8 10 8C8.89543 8 8 8.89543 8 10C8 11.1046 8.89543 12 10 12ZM10 11C9.44772 11 9 10.5523 9 10C9 9.44772 9.44772 9 10 9C10.5523 9 11 9.44772 11 10C11 10.5523 10.5523 11 10 11Z", fill: "currentColor" })));

  var RotateCounterclockwiseIcon = replaceable('rotateClockwise', h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M17 10C17 6.13401 13.866 3 10 3C6.13401 3 3 6.13401 3 10C3 12.7916 4.63419 15.2026 7 16.3265V14.5C7 14.2239 7.22386 14 7.5 14C7.77614 14 8 14.2239 8 14.5V17.5C8 17.7761 7.77614 18 7.5 18H4.5C4.22386 18 4 17.7761 4 17.5C4 17.2239 4.22386 17 4.5 17H6.12422C3.66539 15.6357 2 13.0128 2 10C2 5.58172 5.58172 2 10 2C14.4183 2 18 5.58172 18 10C18 10.2761 17.7761 10.5 17.5 10.5C17.2239 10.5 17 10.2761 17 10Z", fill: "currentColor" }),
      h("path", { d: "M10 12C8.89543 12 8 11.1046 8 10C8 8.89543 8.89543 8 10 8C11.1046 8 12 8.89543 12 10C12 11.1046 11.1046 12 10 12ZM10 11C10.5523 11 11 10.5523 11 10C11 9.44772 10.5523 9 10 9C9.44772 9 9 9.44772 9 10C9 10.5523 9.44772 11 10 11Z", fill: "currentColor" })));

  var ZoomInIcon = replaceable('zoomIn', h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M11.5 8.5C11.5 8.22386 11.2761 8 11 8H9V6C9 5.72386 8.77614 5.5 8.5 5.5C8.22386 5.5 8 5.72386 8 6V8H6C5.72386 8 5.5 8.22386 5.5 8.5C5.5 8.77614 5.72386 9 6 9H8V11C8 11.2761 8.22386 11.5 8.5 11.5C8.77614 11.5 9 11.2761 9 11V9H11C11.2761 9 11.5 8.77614 11.5 8.5Z", fill: "currentColor" }),
      h("path", { d: "M8.5 3C11.5376 3 14 5.46243 14 8.5C14 9.83879 13.5217 11.0659 12.7266 12.0196L16.8536 16.1464C17.0488 16.3417 17.0488 16.6583 16.8536 16.8536C16.68 17.0271 16.4106 17.0464 16.2157 16.9114L16.1464 16.8536L12.0196 12.7266C11.0659 13.5217 9.83879 14 8.5 14C5.46243 14 3 11.5376 3 8.5C3 5.46243 5.46243 3 8.5 3ZM8.5 4C6.01472 4 4 6.01472 4 8.5C4 10.9853 6.01472 13 8.5 13C10.9853 13 13 10.9853 13 8.5C13 6.01472 10.9853 4 8.5 4Z", fill: "currentColor" })));

  var ZoomOutIcon = replaceable('zoomOut', h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M11 8C11.2761 8 11.5 8.22386 11.5 8.5C11.5 8.77614 11.2761 9 11 9H6C5.72386 9 5.5 8.77614 5.5 8.5C5.5 8.22386 5.72386 8 6 8H11Z", fill: "currentColor" }),
      h("path", { d: "M14 8.5C14 5.46243 11.5376 3 8.5 3C5.46243 3 3 5.46243 3 8.5C3 11.5376 5.46243 14 8.5 14C9.83879 14 11.0659 13.5217 12.0196 12.7266L16.1464 16.8536L16.2157 16.9114C16.4106 17.0464 16.68 17.0271 16.8536 16.8536C17.0488 16.6583 17.0488 16.3417 16.8536 16.1464L12.7266 12.0196C13.5217 11.0659 14 9.83879 14 8.5ZM4 8.5C4 6.01472 6.01472 4 8.5 4C10.9853 4 13 6.01472 13 8.5C13 10.9853 10.9853 13 8.5 13C6.01472 13 4 10.9853 4 8.5Z", fill: "currentColor" })));

  var ResizeSmallIcon = defineComponent({
      name: 'ResizeSmall',
      render() {
          return (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20" },
              h("g", { fill: "none" },
                  h("path", { d: "M5.5 4A1.5 1.5 0 0 0 4 5.5v1a.5.5 0 0 1-1 0v-1A2.5 2.5 0 0 1 5.5 3h1a.5.5 0 0 1 0 1h-1zM16 5.5A1.5 1.5 0 0 0 14.5 4h-1a.5.5 0 0 1 0-1h1A2.5 2.5 0 0 1 17 5.5v1a.5.5 0 0 1-1 0v-1zm0 9a1.5 1.5 0 0 1-1.5 1.5h-1a.5.5 0 0 0 0 1h1a2.5 2.5 0 0 0 2.5-2.5v-1a.5.5 0 0 0-1 0v1zm-12 0A1.5 1.5 0 0 0 5.5 16h1.25a.5.5 0 0 1 0 1H5.5A2.5 2.5 0 0 1 3 14.5v-1.25a.5.5 0 0 1 1 0v1.25zM8.5 7A1.5 1.5 0 0 0 7 8.5v3A1.5 1.5 0 0 0 8.5 13h3a1.5 1.5 0 0 0 1.5-1.5v-3A1.5 1.5 0 0 0 11.5 7h-3zM8 8.5a.5.5 0 0 1 .5-.5h3a.5.5 0 0 1 .5.5v3a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-3z", fill: "currentColor" }))));
      }
  });

  var NIconSwitchTransition = defineComponent({
      name: 'BaseIconSwitchTransition',
      setup(_, { slots }) {
          const isMountedRef = isMounted();
          return () => (h(Transition, { name: "icon-switch-transition", appear: isMountedRef.value }, slots));
      }
  });

  var NFadeInExpandTransition = defineComponent({
      name: 'FadeInExpandTransition',
      props: {
          appear: Boolean,
          group: Boolean,
          mode: String,
          onLeave: Function,
          onAfterLeave: Function,
          onAfterEnter: Function,
          width: Boolean,
          // reverse mode is only used in tree
          // it make it from expanded to collapsed after mounted
          reverse: Boolean
      },
      setup(props, { slots }) {
          function handleBeforeLeave(el) {
              if (props.width) {
                  el.style.maxWidth = `${el.offsetWidth}px`;
              }
              else {
                  el.style.maxHeight = `${el.offsetHeight}px`;
              }
              void el.offsetWidth;
          }
          function handleLeave(el) {
              if (props.width) {
                  el.style.maxWidth = '0';
              }
              else {
                  el.style.maxHeight = '0';
              }
              void el.offsetWidth;
              const { onLeave } = props;
              if (onLeave)
                  onLeave();
          }
          function handleAfterLeave(el) {
              if (props.width) {
                  el.style.maxWidth = '';
              }
              else {
                  el.style.maxHeight = '';
              }
              const { onAfterLeave } = props;
              if (onAfterLeave)
                  onAfterLeave();
          }
          function handleEnter(el) {
              el.style.transition = 'none';
              if (props.width) {
                  const memorizedWidth = el.offsetWidth;
                  el.style.maxWidth = '0';
                  void el.offsetWidth;
                  el.style.transition = '';
                  el.style.maxWidth = `${memorizedWidth}px`;
              }
              else {
                  if (props.reverse) {
                      el.style.maxHeight = `${el.offsetHeight}px`;
                      void el.offsetHeight;
                      el.style.transition = '';
                      el.style.maxHeight = '0';
                  }
                  else {
                      const memorizedHeight = el.offsetHeight;
                      el.style.maxHeight = '0';
                      void el.offsetWidth;
                      el.style.transition = '';
                      el.style.maxHeight = `${memorizedHeight}px`;
                  }
              }
              void el.offsetWidth;
          }
          function handleAfterEnter(el) {
              var _a;
              if (props.width) {
                  el.style.maxWidth = '';
              }
              else {
                  if (!props.reverse) {
                      el.style.maxHeight = '';
                  }
              }
              (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return () => {
              const { group, width, appear, mode } = props;
              const type = group ? TransitionGroup : Transition;
              const resolvedProps = {
                  name: width
                      ? 'fade-in-width-expand-transition'
                      : 'fade-in-height-expand-transition',
                  appear,
                  onEnter: handleEnter,
                  onAfterEnter: handleAfterEnter,
                  onBeforeLeave: handleBeforeLeave,
                  onLeave: handleLeave,
                  onAfterLeave: handleAfterLeave
              };
              if (!group) {
                  resolvedProps.mode = mode;
              }
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              return h(type, resolvedProps, slots);
          };
      }
  });

  var style$1A = cB('base-icon', `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [c$1('svg', `
 height: 1em;
 width: 1em;
 `)]);

  var NBaseIcon = defineComponent({
      name: 'BaseIcon',
      props: {
          role: String,
          ariaLabel: String,
          ariaDisabled: {
              type: Boolean,
              default: undefined
          },
          ariaHidden: {
              type: Boolean,
              default: undefined
          },
          clsPrefix: {
              type: String,
              required: true
          },
          onClick: Function,
          onMousedown: Function,
          onMouseup: Function
      },
      setup(props) {
          useStyle('-base-icon', style$1A, toRef(props, 'clsPrefix'));
      },
      render() {
          return (h("i", { class: `${this.clsPrefix}-base-icon`, onClick: this.onClick, onMousedown: this.onMousedown, onMouseup: this.onMouseup, role: this.role, "aria-label": this.ariaLabel, "aria-hidden": this.ariaHidden, "aria-disabled": this.ariaDisabled }, this.$slots));
      }
  });

  // vars:
  // --n-close-border-radius
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-close-icon-color-disabled
  var style$1z = cB('base-close', `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM('absolute', `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1('&::before', `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM('disabled', [c$1('&:hover', `
 color: var(--n-close-icon-color-hover);
 `), c$1('&:hover::before', `
 background-color: var(--n-close-color-hover);
 `), c$1('&:focus::before', `
 background-color: var(--n-close-color-hover);
 `), c$1('&:active', `
 color: var(--n-close-icon-color-pressed);
 `), c$1('&:active::before', `
 background-color: var(--n-close-color-pressed);
 `)]), cM('disabled', `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM('round', [c$1('&::before', `
 border-radius: 50%;
 `)])]);

  var NBaseClose = defineComponent({
      name: 'BaseClose',
      props: {
          isButtonTag: {
              type: Boolean,
              default: true
          },
          clsPrefix: {
              type: String,
              required: true
          },
          disabled: {
              type: Boolean,
              default: undefined
          },
          focusable: {
              type: Boolean,
              default: true
          },
          round: Boolean,
          onClick: Function,
          absolute: Boolean
      },
      setup(props) {
          useStyle('-base-close', style$1z, toRef(props, 'clsPrefix'));
          return () => {
              const { clsPrefix, disabled, absolute, round, isButtonTag } = props;
              const Tag = isButtonTag ? 'button' : 'div';
              return (h(Tag, { type: isButtonTag ? 'button' : undefined, tabindex: disabled || !props.focusable ? -1 : 0, "aria-disabled": disabled, "aria-label": "close", role: isButtonTag ? undefined : 'button', disabled: disabled, class: [
                      `${clsPrefix}-base-close`,
                      absolute && `${clsPrefix}-base-close--absolute`,
                      disabled && `${clsPrefix}-base-close--disabled`,
                      round && `${clsPrefix}-base-close--round`
                  ], onMousedown: (e) => {
                      if (!props.focusable) {
                          e.preventDefault();
                      }
                  }, onClick: props.onClick },
                  h(NBaseIcon, { clsPrefix: clsPrefix }, {
                      default: () => h(ErrorIcon$1, null)
                  })));
          };
      }
  });

  var FocusDetector = defineComponent({
      props: {
          onFocus: Function,
          onBlur: Function
      },
      setup(props) {
          return () => (h("div", { style: "width: 0; height: 0", tabindex: 0, onFocus: props.onFocus, onBlur: props.onBlur }));
      }
  });

  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$4
  } = commonVariables$m;
  function iconSwitchTransition({
    originalTransform = '',
    left = 0,
    top = 0,
    transition = `all .3s ${cubicBezierEaseInOut$4} !important`
  } = {}) {
    return [c$1('&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to', {
      transform: originalTransform + ' scale(0.75)',
      left,
      top,
      opacity: 0
    }), c$1('&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from', {
      transform: `scale(1) ${originalTransform}`,
      left,
      top,
      opacity: 1
    }), c$1('&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active', {
      transformOrigin: 'center',
      position: 'absolute',
      left,
      top,
      transition
    })];
  }

  var style$1y = c$1([c$1('@keyframes loading-container-rotate', `
 to {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }
 `), c$1('@keyframes loading-layer-rotate', `
 12.5% {
 -webkit-transform: rotate(135deg);
 transform: rotate(135deg);
 }
 25% {
 -webkit-transform: rotate(270deg);
 transform: rotate(270deg);
 }
 37.5% {
 -webkit-transform: rotate(405deg);
 transform: rotate(405deg);
 }
 50% {
 -webkit-transform: rotate(540deg);
 transform: rotate(540deg);
 }
 62.5% {
 -webkit-transform: rotate(675deg);
 transform: rotate(675deg);
 }
 75% {
 -webkit-transform: rotate(810deg);
 transform: rotate(810deg);
 }
 87.5% {
 -webkit-transform: rotate(945deg);
 transform: rotate(945deg);
 }
 100% {
 -webkit-transform: rotate(1080deg);
 transform: rotate(1080deg);
 } 
 `), c$1('@keyframes loading-left-spin', `
 from {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 50% {
 -webkit-transform: rotate(130deg);
 transform: rotate(130deg);
 }
 to {
 -webkit-transform: rotate(265deg);
 transform: rotate(265deg);
 }
 `), c$1('@keyframes loading-right-spin', `
 from {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 50% {
 -webkit-transform: rotate(-130deg);
 transform: rotate(-130deg);
 }
 to {
 -webkit-transform: rotate(-265deg);
 transform: rotate(-265deg);
 }
 `), cB('base-loading', `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE('transition-wrapper', `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE('container', `
 display: inline-flex;
 position: relative;
 direction: ltr;
 line-height: 0;
 animation: loading-container-rotate 1568.2352941176ms linear infinite;
 font-size: 0;
 letter-spacing: 0;
 white-space: nowrap;
 opacity: 1;
 width: 100%;
 height: 100%;
 `, [cE('svg', `
 stroke: var(--n-text-color);
 fill: transparent;
 position: absolute;
 height: 100%;
 overflow: hidden;
 `), cE('container-layer', `
 position: absolute;
 width: 100%;
 height: 100%;
 animation: loading-layer-rotate 5332ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 `, [cE('container-layer-left', `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE('svg', `
 animation: loading-left-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 width: 200%;
 `)]), cE('container-layer-patch', `
 position: absolute;
 top: 0;
 left: 47.5%;
 box-sizing: border-box;
 width: 5%;
 height: 100%;
 overflow: hidden;
 `, [cE('svg', `
 left: -900%;
 width: 2000%;
 transform: rotate(180deg);
 `)]), cE('container-layer-right', `
 display: inline-flex;
 position: relative;
 width: 50%;
 height: 100%;
 overflow: hidden;
 `, [cE('svg', `
 animation: loading-right-spin 1333ms cubic-bezier(0.4, 0, 0.2, 1) infinite both;
 left: -100%;
 width: 200%;
 `)])])]), cE('placeholder', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
    left: '50%',
    top: '50%',
    originalTransform: 'translateX(-50%) translateY(-50%)'
  })])])]);

  const exposedLoadingProps = {
      strokeWidth: {
          type: Number,
          default: 28
      },
      stroke: {
          type: String,
          default: undefined
      }
  };
  var NBaseLoading = defineComponent({
      name: 'BaseLoading',
      props: Object.assign({ clsPrefix: {
              type: String,
              required: true
          }, show: {
              type: Boolean,
              default: true
          }, scale: {
              type: Number,
              default: 1
          }, radius: {
              type: Number,
              default: 100
          } }, exposedLoadingProps),
      setup(props) {
          useStyle('-base-loading', style$1y, toRef(props, 'clsPrefix'));
      },
      render() {
          const { clsPrefix, radius, strokeWidth, stroke, scale } = this;
          const scaledRadius = radius / scale;
          return (h("div", { class: `${clsPrefix}-base-loading`, role: "img", "aria-label": "loading" },
              h(NIconSwitchTransition, null, {
                  default: () => this.show ? (h("div", { key: "icon", class: `${clsPrefix}-base-loading__transition-wrapper` },
                      h("div", { class: `${clsPrefix}-base-loading__container` },
                          h("div", { class: `${clsPrefix}-base-loading__container-layer` },
                              h("div", { class: `${clsPrefix}-base-loading__container-layer-left` },
                                  h("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius }))),
                              h("div", { class: `${clsPrefix}-base-loading__container-layer-patch` },
                                  h("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius }))),
                              h("div", { class: `${clsPrefix}-base-loading__container-layer-right` },
                                  h("svg", { class: `${clsPrefix}-base-loading__svg`, viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`, xmlns: "http://www.w3.org/2000/svg", style: { color: stroke } },
                                      h("circle", { fill: "none", stroke: "currentColor", "stroke-width": strokeWidth, "stroke-linecap": "round", cx: scaledRadius, cy: scaledRadius, r: radius - strokeWidth / 2, "stroke-dasharray": 4.91 * radius, "stroke-dashoffset": 2.46 * radius }))))))) : (h("div", { key: "placeholder", class: `${clsPrefix}-base-loading__placeholder` }, this.$slots))
              })));
      }
  });

  function toArray(arg) {
      if (Array.isArray(arg))
          return arg;
      return [arg];
  }
  // Do not use enum for lint plugin has error
  const TRAVERSE_COMMAND = {
      STOP: 'STOP'
  };
  function traverseWithCb(treeNode, callback) {
      const command = callback(treeNode);
      if (treeNode.children !== undefined && command !== TRAVERSE_COMMAND.STOP) {
          treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
      }
  }
  function getNonLeafKeys(treeNodes, options = {}) {
      const { preserveGroup = false } = options;
      const keys = [];
      const cb = preserveGroup
          ? (node) => {
              if (!node.isLeaf) {
                  keys.push(node.key);
                  traverse(node.children);
              }
          }
          : (node) => {
              if (!node.isLeaf) {
                  if (!node.isGroup)
                      keys.push(node.key);
                  traverse(node.children);
              }
          };
      function traverse(nodes) {
          nodes.forEach(cb);
      }
      traverse(treeNodes);
      return keys;
  }
  function isLeaf(rawNode, getChildren) {
      const { isLeaf } = rawNode;
      if (isLeaf !== undefined)
          return isLeaf;
      else if (!getChildren(rawNode))
          return true;
      return false;
  }
  function defaultGetChildren(node) {
      return node.children;
  }
  function defaultGetKey(node) {
      return node.key;
  }
  function isIgnored() {
      return false;
  }
  function isShallowLoaded(rawNode, getChildren) {
      const { isLeaf } = rawNode;
      if (isLeaf === false && !Array.isArray(getChildren(rawNode)))
          return false;
      return true;
  }
  function isDisabled(rawNode) {
      return rawNode.disabled === true;
  }
  function isExpilicitlyNotLoaded(rawNode, getChildren) {
      return (rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode)));
  }
  function unwrapCheckedKeys(result) {
      var _a;
      if (result === undefined || result === null)
          return [];
      if (Array.isArray(result))
          return result;
      return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
  }
  function unwrapIndeterminateKeys(result) {
      var _a;
      if (result === undefined || result === null || Array.isArray(result)) {
          return [];
      }
      return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
  }
  function merge(originalKeys, keysToAdd) {
      const set = new Set(originalKeys);
      keysToAdd.forEach((key) => {
          if (!set.has(key)) {
              set.add(key);
          }
      });
      return Array.from(set);
  }
  function minus(originalKeys, keysToRemove) {
      const set = new Set(originalKeys);
      keysToRemove.forEach((key) => {
          if (set.has(key)) {
              set.delete(key);
          }
      });
      return Array.from(set);
  }
  function isGroup(rawNode) {
      return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === 'group';
  }
  function createIndexGetter(treeNodes) {
      const map = new Map();
      treeNodes.forEach((treeNode, i) => {
          map.set(treeNode.key, i);
      });
      return (key) => { var _a; return (_a = map.get(key)) !== null && _a !== void 0 ? _a : null; };
  }

  class SubtreeNotLoadedError extends Error {
      constructor() {
          super();
          this.message =
              'SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.';
      }
  }
  function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
  }
  function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
      const visitedKeys = new Set();
      uncheckedKeys.forEach((uncheckedKey) => {
          const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
          if (uncheckedTreeNode !== undefined) {
              let nodeCursor = uncheckedTreeNode.parent;
              while (nodeCursor !== null) {
                  if (nodeCursor.disabled)
                      break;
                  if (visitedKeys.has(nodeCursor.key))
                      break;
                  else {
                      visitedKeys.add(nodeCursor.key);
                  }
                  nodeCursor = nodeCursor.parent;
              }
          }
      });
      return visitedKeys;
  }
  function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
      const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
      const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
      const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
      const keysToRemove = [];
      extendedCheckedKeySet.forEach((key) => {
          if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
              keysToRemove.push(key);
          }
      });
      keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
      return extendedCheckedKeySet;
  }
  function getCheckedKeys(options, treeMate) {
      const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
      if (!cascade) {
          if (keysToCheck !== undefined) {
              return {
                  checkedKeys: merge(checkedKeys, keysToCheck),
                  indeterminateKeys: Array.from(indeterminateKeys)
              };
          }
          else if (keysToUncheck !== undefined) {
              return {
                  checkedKeys: minus(checkedKeys, keysToUncheck),
                  indeterminateKeys: Array.from(indeterminateKeys)
              };
          }
          else {
              return {
                  checkedKeys: Array.from(checkedKeys),
                  indeterminateKeys: Array.from(indeterminateKeys)
              };
          }
      }
      const { levelTreeNodeMap } = treeMate;
      let extendedCheckedKeySet;
      if (keysToUncheck !== undefined) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
      }
      else if (keysToCheck !== undefined) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
      }
      else {
          extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
      }
      const checkStrategyIsParent = checkStrategy === 'parent';
      const checkStrategyIsChild = checkStrategy === 'child' || leafOnly;
      const syntheticCheckedKeySet = extendedCheckedKeySet;
      const syntheticIndeterminateKeySet = new Set();
      const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
      // cascade check
      // 1. if tree is fully loaded, it just works
      // 2. if the tree is not fully loaded, we assume that keys which is in not
      //    loaded tree are not in checked keys
      //    for example:
      //    a -- b(fully-loaded)   -- c(fully-loaded)
      //      |- d(partial-loaded) -- ?e(not-loaded)
      //    in the case, `e` is assumed not to be checked, nor we can't calc `d`'s
      //    and `a`'s status
      for (let level = maxLevel; level >= 0; level -= 1) {
          const levelIsZero = level === 0;
          // it should exists, nor it is a bug
          const levelTreeNodes = levelTreeNodeMap.get(level);
          for (const levelTreeNode of levelTreeNodes) {
              if (levelTreeNode.isLeaf)
                  continue;
              const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
              if (checkStrategyIsChild && shallowLoaded) {
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  levelTreeNode.children.forEach((v) => {
                      if (!v.disabled &&
                          !v.isLeaf &&
                          v.shallowLoaded &&
                          syntheticCheckedKeySet.has(v.key)) {
                          syntheticCheckedKeySet.delete(v.key);
                      }
                  });
              }
              if (levelTreeNode.disabled || !shallowLoaded) {
                  continue;
              }
              let fullyChecked = true;
              let partialChecked = false;
              let allDisabled = true;
              // it is shallow loaded, so `children` must exist
              for (const childNode of levelTreeNode.children) {
                  const childKey = childNode.key;
                  if (childNode.disabled)
                      continue;
                  if (allDisabled)
                      allDisabled = false;
                  if (syntheticCheckedKeySet.has(childKey)) {
                      partialChecked = true;
                  }
                  else if (syntheticIndeterminateKeySet.has(childKey)) {
                      partialChecked = true;
                      fullyChecked = false;
                      break;
                  }
                  else {
                      fullyChecked = false;
                      if (partialChecked) {
                          break;
                      }
                  }
              }
              if (fullyChecked && !allDisabled) {
                  if (checkStrategyIsParent) {
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      levelTreeNode.children.forEach((v) => {
                          if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                              syntheticCheckedKeySet.delete(v.key);
                          }
                      });
                  }
                  syntheticCheckedKeySet.add(levelTreeNodeKey);
              }
              else if (partialChecked) {
                  syntheticIndeterminateKeySet.add(levelTreeNodeKey);
              }
              if (levelIsZero &&
                  checkStrategyIsChild &&
                  syntheticCheckedKeySet.has(levelTreeNodeKey)) {
                  syntheticCheckedKeySet.delete(levelTreeNodeKey);
              }
          }
      }
      return {
          checkedKeys: Array.from(syntheticCheckedKeySet),
          indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
      };
  }
  // unchecking is safe when doing cascade uncheck in async mode
  function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
      const { treeNodeMap, getChildren } = treeMate;
      const visitedKeySet = new Set();
      const extendedKeySet = new Set(checkedKeys);
      checkedKeys.forEach((checkedKey) => {
          const checkedTreeNode = treeNodeMap.get(checkedKey);
          if (checkedTreeNode !== undefined) {
              traverseWithCb(checkedTreeNode, (treeNode) => {
                  if (treeNode.disabled) {
                      return TRAVERSE_COMMAND.STOP;
                  }
                  const { key } = treeNode;
                  if (visitedKeySet.has(key))
                      return;
                  visitedKeySet.add(key);
                  // Adding keys before loaded check is okay, since if not valid error
                  // would be thrown
                  extendedKeySet.add(key);
                  if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
                      if (isUnchecking) {
                          return TRAVERSE_COMMAND.STOP;
                      }
                      else if (!allowNotLoaded) {
                          throw new SubtreeNotLoadedError();
                      }
                  }
              });
          }
      });
      return extendedKeySet;
  }

  function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
      var _a;
      const treeNodeMap = treeMate.treeNodeMap;
      let treeNode = key === null || key === undefined ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
      const mergedPath = {
          keyPath: [],
          treeNodePath: [],
          treeNode: treeNode
      };
      if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
          mergedPath.treeNode = null;
          return mergedPath;
      }
      while (treeNode) {
          if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
              mergedPath.treeNodePath.push(treeNode);
          }
          treeNode = treeNode.parent;
      }
      mergedPath.treeNodePath.reverse();
      if (!includeSelf)
          mergedPath.treeNodePath.pop();
      mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode) => treeNode.key);
      return mergedPath;
  }

  function getFirstAvailableNode(nodes) {
      if (nodes.length === 0)
          return null;
      const node = nodes[0];
      if (node.isGroup || node.ignored || node.disabled) {
          return node.getNext();
      }
      return node;
  }
  function rawGetNext(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const { index } = node;
      if (loop) {
          return sibs[(index + 1) % l];
      }
      else {
          if (index === sibs.length - 1)
              return null;
          return sibs[index + 1];
      }
  }
  function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
      const iterate = dir === 'prev' ? rawGetPrev : rawGetNext;
      const getChildOptions = {
          reverse: dir === 'prev'
      };
      let meet = false;
      let endNode = null;
      function traverse(node) {
          if (node === null)
              return;
          if (node === fromNode) {
              if (!meet) {
                  meet = true;
              }
              else if (!fromNode.disabled && !fromNode.isGroup) {
                  endNode = fromNode;
                  return;
              }
          }
          else {
              if ((!node.disabled || includeDisabled) &&
                  !node.ignored &&
                  !node.isGroup) {
                  endNode = node;
                  return;
              }
          }
          if (node.isGroup) {
              const child = getChild(node, getChildOptions);
              if (child !== null) {
                  endNode = child;
              }
              else {
                  traverse(iterate(node, loop));
              }
          }
          else {
              const nextNode = iterate(node, false);
              if (nextNode !== null) {
                  traverse(nextNode);
              }
              else {
                  const parent = rawGetParent(node);
                  if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
                      traverse(iterate(parent, loop));
                  }
                  else if (loop) {
                      traverse(iterate(node, true));
                  }
              }
          }
      }
      traverse(fromNode);
      return endNode;
  }
  function rawGetPrev(node, loop) {
      const sibs = node.siblings;
      const l = sibs.length;
      const { index } = node;
      if (loop) {
          return sibs[(index - 1 + l) % l];
      }
      else {
          if (index === 0)
              return null;
          return sibs[index - 1];
      }
  }
  function rawGetParent(node) {
      return node.parent;
  }
  function getChild(node, options = {}) {
      const { reverse = false } = options;
      const { children } = node;
      if (children) {
          const { length } = children;
          const start = reverse ? length - 1 : 0;
          const end = reverse ? -1 : length;
          const delta = reverse ? -1 : 1;
          for (let i = start; i !== end; i += delta) {
              const child = children[i];
              if (!child.disabled && !child.ignored) {
                  if (child.isGroup) {
                      const childInGroup = getChild(child, options);
                      if (childInGroup !== null)
                          return childInGroup;
                  }
                  else {
                      return child;
                  }
              }
          }
      }
      return null;
  }
  const moveMethods = {
      getChild() {
          if (this.ignored)
              return null;
          return getChild(this);
      },
      getParent() {
          const { parent } = this;
          if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
              return parent.getParent();
          }
          return parent;
      },
      getNext(options = {}) {
          return move(this, 'next', options);
      },
      getPrev(options = {}) {
          return move(this, 'prev', options);
      }
  };

  function flatten$1(treeNodes, expandedKeys) {
      const expandedKeySet = expandedKeys ? new Set(expandedKeys) : undefined;
      const flattenedNodes = [];
      function traverse(treeNodes) {
          treeNodes.forEach((treeNode) => {
              flattenedNodes.push(treeNode);
              if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
                  return;
              if (treeNode.isGroup) {
                  // group node shouldn't be expanded
                  traverse(treeNode.children);
              }
              else if (
              // normal non-leaf node
              expandedKeySet === undefined ||
                  expandedKeySet.has(treeNode.key)) {
                  traverse(treeNode.children);
              }
          });
      }
      traverse(treeNodes);
      return flattenedNodes;
  }

  function contains(parent, child) {
      const parentKey = parent.key;
      // eslint-disable-next-line no-unmodified-loop-condition
      while (child) {
          if (child.key === parentKey)
              return true;
          child = child.parent;
      }
      return false;
  }

  function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
      const treeNodes = [];
      rawNodes.forEach((rawNode, index) => {
          var _a;
          const treeNode = Object.create(nodeProto);
          treeNode.rawNode = rawNode;
          treeNode.siblings = treeNodes;
          treeNode.level = level;
          treeNode.index = index;
          treeNode.isFirstChild = index === 0;
          treeNode.isLastChild = index + 1 === rawNodes.length;
          treeNode.parent = parent;
          if (!treeNode.ignored) {
              const rawChildren = getChildren(rawNode);
              if (Array.isArray(rawChildren)) {
                  treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
              }
          }
          treeNodes.push(treeNode);
          treeNodeMap.set(treeNode.key, treeNode);
          if (!levelTreeNodeMap.has(level))
              levelTreeNodeMap.set(level, []);
          (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
      });
      return treeNodes;
  }
  function createTreeMate(rawNodes, options = {}) {
      var _a;
      const treeNodeMap = new Map();
      const levelTreeNodeMap = new Map();
      const { getDisabled = isDisabled, getIgnored = isIgnored, getIsGroup = isGroup, getKey = defaultGetKey } = options;
      const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
      const getChildren = options.ignoreEmptyChildren
          ? (node) => {
              const children = _getChildren(node);
              if (Array.isArray(children)) {
                  if (!children.length)
                      return null;
                  return children;
              }
              return children;
          }
          : _getChildren;
      const nodeProto = Object.assign({
          get key() {
              // do not pass parent or related things to it
              // the key need to be specified explicitly
              return getKey(this.rawNode);
          },
          get disabled() {
              return getDisabled(this.rawNode);
          },
          get isGroup() {
              return getIsGroup(this.rawNode);
          },
          get isLeaf() {
              return isLeaf(this.rawNode, getChildren);
          },
          get shallowLoaded() {
              return isShallowLoaded(this.rawNode, getChildren);
          },
          get ignored() {
              return getIgnored(this.rawNode);
          },
          contains(node) {
              return contains(this, node);
          }
      }, moveMethods);
      const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
      function getNode(key) {
          if (key === null || key === undefined)
              return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
              return tmNode;
          }
          return null;
      }
      function _getNode(key) {
          if (key === null || key === undefined)
              return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.ignored) {
              return tmNode;
          }
          return null;
      }
      function getPrev(key, options) {
          const node = _getNode(key);
          if (!node)
              return null;
          return node.getPrev(options);
      }
      function getNext(key, options) {
          const node = _getNode(key);
          if (!node)
              return null;
          return node.getNext(options);
      }
      function getParent(key) {
          const node = _getNode(key);
          if (!node)
              return null;
          return node.getParent();
      }
      function getChild(key) {
          const node = _getNode(key);
          if (!node)
              return null;
          return node.getChild();
      }
      const treemate = {
          treeNodes,
          treeNodeMap,
          levelTreeNodeMap,
          maxLevel: Math.max(...levelTreeNodeMap.keys()),
          getChildren,
          getFlattenedNodes(expandedKeys) {
              return flatten$1(treeNodes, expandedKeys);
          },
          getNode,
          getPrev,
          getNext,
          getParent,
          getChild,
          getFirstAvailableNode() {
              return getFirstAvailableNode(treeNodes);
          },
          getPath(key, options = {}) {
              return getPath(key, options, treemate);
          },
          getCheckedKeys(checkedKeys, options = {}) {
              const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;
              return getCheckedKeys({
                  checkedKeys: unwrapCheckedKeys(checkedKeys),
                  indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
                  cascade,
                  leafOnly,
                  checkStrategy,
                  allowNotLoaded
              }, treemate);
          },
          check(keysToCheck, checkedKeys, options = {}) {
              const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;
              return getCheckedKeys({
                  checkedKeys: unwrapCheckedKeys(checkedKeys),
                  indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
                  keysToCheck: keysToCheck === undefined || keysToCheck === null
                      ? []
                      : toArray(keysToCheck),
                  cascade,
                  leafOnly,
                  checkStrategy,
                  allowNotLoaded
              }, treemate);
          },
          uncheck(keysToUncheck, checkedKeys, options = {}) {
              const { cascade = true, leafOnly = false, checkStrategy = 'all', allowNotLoaded = false } = options;
              return getCheckedKeys({
                  checkedKeys: unwrapCheckedKeys(checkedKeys),
                  indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
                  keysToUncheck: keysToUncheck === null || keysToUncheck === undefined
                      ? []
                      : toArray(keysToUncheck),
                  cascade,
                  leafOnly,
                  checkStrategy,
                  allowNotLoaded
              }, treemate);
          },
          getNonLeafKeys(options = {}) {
              return getNonLeafKeys(treeNodes, options);
          }
      };
      return treemate;
  }

  const base = {
      neutralBase: '#FFF',
      neutralInvertBase: '#000',
      neutralTextBase: '#000',
      neutralPopover: '#fff',
      neutralCard: '#fff',
      neutralModal: '#fff',
      neutralBody: '#fff',
      alpha1: '0.82',
      alpha2: '0.72',
      alpha3: '0.38',
      alpha4: '0.24', // disabled text, placeholder, icon
      alpha5: '0.18', // disabled placeholder
      alphaClose: '0.6',
      alphaDisabled: '0.5',
      alphaDisabledInput: '0.02',
      alphaPending: '0.05',
      alphaTablePending: '0.02',
      alphaPressed: '0.07',
      alphaAvatar: '0.2',
      alphaRail: '0.14',
      alphaProgressRail: '.08',
      alphaBorder: '0.12',
      alphaDivider: '0.06',
      alphaInput: '0',
      alphaAction: '0.02',
      alphaTab: '0.04',
      alphaScrollbar: '0.25',
      alphaScrollbarHover: '0.4',
      alphaCode: '0.05',
      alphaTag: '0.02',
      // primary
      primaryHover: '#36ad6a',
      primaryDefault: '#18a058',
      primaryActive: '#0c7a43',
      primarySuppl: '#36ad6a',
      // info
      infoHover: '#4098fc',
      infoDefault: '#2080f0',
      infoActive: '#1060c9',
      infoSuppl: '#4098fc',
      // error
      errorHover: '#de576d',
      errorDefault: '#d03050',
      errorActive: '#ab1f3f',
      errorSuppl: '#de576d',
      // warning
      warningHover: '#fcb040',
      warningDefault: '#f0a020',
      warningActive: '#c97c10',
      warningSuppl: '#fcb040',
      // success
      successHover: '#36ad6a',
      successDefault: '#18a058',
      successActive: '#0c7a43',
      successSuppl: '#36ad6a'
  };
  const baseBackgroundRgb = rgba(base.neutralBase);
  const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
  const overlayPrefix = 'rgba(' + baseInvertBackgroundRgb.slice(0, 3).join(', ') + ', ';
  function overlay(alpha) {
      return overlayPrefix + String(alpha) + ')';
  }
  function neutral(alpha) {
      const overlayRgba = Array.from(baseInvertBackgroundRgb);
      overlayRgba[3] = Number(alpha);
      return composite(baseBackgroundRgb, overlayRgba);
  }
  const derived = Object.assign(Object.assign({ name: 'common' }, commonVariables$m), { baseColor: base.neutralBase, 
      // primary color
      primaryColor: base.primaryDefault, primaryColorHover: base.primaryHover, primaryColorPressed: base.primaryActive, primaryColorSuppl: base.primarySuppl, 
      // info color
      infoColor: base.infoDefault, infoColorHover: base.infoHover, infoColorPressed: base.infoActive, infoColorSuppl: base.infoSuppl, 
      // success color
      successColor: base.successDefault, successColorHover: base.successHover, successColorPressed: base.successActive, successColorSuppl: base.successSuppl, 
      // warning color
      warningColor: base.warningDefault, warningColorHover: base.warningHover, warningColorPressed: base.warningActive, warningColorSuppl: base.warningSuppl, 
      // error color
      errorColor: base.errorDefault, errorColorHover: base.errorHover, errorColorPressed: base.errorActive, errorColorSuppl: base.errorSuppl, 
      // text color
      textColorBase: base.neutralTextBase, textColor1: 'rgb(31, 34, 37)', textColor2: 'rgb(51, 54, 57)', textColor3: 'rgb(118, 124, 130)', 
      // textColor4: neutral(base.alpha4), // disabled, placeholder, icon
      // textColor5: neutral(base.alpha5),
      textColorDisabled: neutral(base.alpha4), placeholderColor: neutral(base.alpha4), placeholderColorDisabled: neutral(base.alpha5), iconColor: neutral(base.alpha4), iconColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }), iconColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }), iconColorDisabled: neutral(base.alpha5), opacity1: base.alpha1, opacity2: base.alpha2, opacity3: base.alpha3, opacity4: base.alpha4, opacity5: base.alpha5, dividerColor: 'rgb(239, 239, 245)', borderColor: 'rgb(224, 224, 230)', 
      // close
      closeIconColor: neutral(Number(base.alphaClose)), closeIconColorHover: neutral(Number(base.alphaClose)), closeIconColorPressed: neutral(Number(base.alphaClose)), closeColorHover: 'rgba(0, 0, 0, .09)', closeColorPressed: 'rgba(0, 0, 0, .13)', 
      // clear
      clearColor: neutral(base.alpha4), clearColorHover: scaleColor(neutral(base.alpha4), { lightness: 0.75 }), clearColorPressed: scaleColor(neutral(base.alpha4), { lightness: 0.9 }), scrollbarColor: overlay(base.alphaScrollbar), scrollbarColorHover: overlay(base.alphaScrollbarHover), scrollbarWidth: '5px', scrollbarHeight: '5px', scrollbarBorderRadius: '5px', progressRailColor: neutral(base.alphaProgressRail), railColor: 'rgb(219, 219, 223)', popoverColor: base.neutralPopover, tableColor: base.neutralCard, cardColor: base.neutralCard, modalColor: base.neutralModal, bodyColor: base.neutralBody, tagColor: '#eee', avatarColor: neutral(base.alphaAvatar), invertedColor: 'rgb(0, 20, 40)', inputColor: neutral(base.alphaInput), codeColor: 'rgb(244, 244, 248)', tabColor: 'rgb(247, 247, 250)', actionColor: 'rgb(250, 250, 252)', tableHeaderColor: 'rgb(250, 250, 252)', hoverColor: 'rgb(243, 243, 245)', 
      // use color with alpha since it can be nested with header filter & sorter effect
      tableColorHover: 'rgba(0, 0, 100, 0.03)', tableColorStriped: 'rgba(0, 0, 100, 0.02)', pressedColor: 'rgb(237, 237, 239)', opacityDisabled: base.alphaDisabled, inputColorDisabled: 'rgb(250, 250, 252)', 
      // secondary button color
      // can also be used in tertiary button & quaternary button
      buttonColor2: 'rgba(46, 51, 56, .05)', buttonColor2Hover: 'rgba(46, 51, 56, .09)', buttonColor2Pressed: 'rgba(46, 51, 56, .13)', boxShadow1: '0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)', boxShadow2: '0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)', boxShadow3: '0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)' });
  var commonLight = derived;

  var commonVars$c = {
      iconSizeSmall: '34px',
      iconSizeMedium: '40px',
      iconSizeLarge: '46px',
      iconSizeHuge: '52px'
  };

  const self$1e = (vars) => {
      const { textColorDisabled, iconColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge } = vars;
      return Object.assign(Object.assign({}, commonVars$c), { fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge, textColor: textColorDisabled, iconColor, extraTextColor: textColor2 });
  };
  const emptyLight = {
      name: 'Empty',
      common: commonLight,
      self: self$1e
  };
  var emptyLight$1 = emptyLight;

  // vars:
  // --n-font-size
  // --n-icon-size
  // --n-icon-color
  // --n-bezier
  // --n-text-color
  // --n-extra-text-color
  var style$1x = cB('empty', `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE('icon', `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c$1('+', [cE('description', `
 margin-top: 8px;
 `)])]), cE('description', `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE('extra', `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);

  const emptyProps = Object.assign(Object.assign({}, useTheme.props), { description: String, showDescription: {
          type: Boolean,
          default: true
      }, showIcon: {
          type: Boolean,
          default: true
      }, size: {
          type: String,
          default: 'medium'
      }, renderIcon: Function });
  var NEmpty = defineComponent({
      name: 'Empty',
      props: emptyProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Empty', '-empty', style$1x, emptyLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale('Empty');
          const NConfigProvider = inject(configProviderInjectionKey, null);
          const mergedDescriptionRef = computed(() => {
              var _a, _b, _c;
              return ((_a = props.description) !== null && _a !== void 0 ? _a : (_c = (_b = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _b === void 0 ? void 0 : _b.Empty) === null || _c === void 0 ? void 0 : _c.description);
          });
          const mergedRenderIconRef = computed(() => {
              var _a, _b;
              return ((_b = (_a = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Empty) === null || _b === void 0 ? void 0 : _b.renderIcon) ||
                  (() => h(EmptyIcon, null));
          });
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { common: { cubicBezierEaseInOut }, self: { [createKey('iconSize', size)]: iconSize, [createKey('fontSize', size)]: fontSize, textColor, iconColor, extraTextColor } } = themeRef.value;
              return {
                  '--n-icon-size': iconSize,
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-icon-color': iconColor,
                  '--n-extra-text-color': extraTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('empty', computed(() => {
                  let hash = '';
                  const { size } = props;
                  hash += size[0];
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedRenderIcon: mergedRenderIconRef,
              localizedDescription: computed(() => {
                  return mergedDescriptionRef.value || localeRef.value.description;
              }),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [`${mergedClsPrefix}-empty`, this.themeClass], style: this.cssVars },
              this.showIcon ? (h("div", { class: `${mergedClsPrefix}-empty__icon` }, $slots.icon ? ($slots.icon()) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: this.mergedRenderIcon })))) : null,
              this.showDescription ? (h("div", { class: `${mergedClsPrefix}-empty__description` }, $slots.default ? $slots.default() : this.localizedDescription)) : null,
              $slots.extra ? (h("div", { class: `${mergedClsPrefix}-empty__extra` }, $slots.extra())) : null));
      }
  });

  const self$1d = (vars) => {
      const { scrollbarColor, scrollbarColorHover } = vars;
      return {
          color: scrollbarColor,
          colorHover: scrollbarColorHover
      };
  };
  const scrollbarLight = {
      name: 'Scrollbar',
      common: commonLight,
      self: self$1d
  };
  var scrollbarLight$1 = scrollbarLight;

  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$3
  } = commonVariables$m;
  function fadeInTransition({
    name = 'fade-in',
    enterDuration = '0.2s',
    leaveDuration = '0.2s',
    enterCubicBezier = cubicBezierEaseInOut$3,
    leaveCubicBezier = cubicBezierEaseInOut$3
  } = {}) {
    return [c$1(`&.${name}-transition-enter-active`, {
      transition: `all ${enterDuration} ${enterCubicBezier}!important`
    }), c$1(`&.${name}-transition-leave-active`, {
      transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
    }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
      opacity: 0
    }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
      opacity: 1
    })];
  }

  // vars:
  // --n-scrollbar-bezier
  // --n-scrollbar-color
  // --n-scrollbar-color-hover
  // --n-scrollbar-width
  // --n-scrollbar-height
  // --n-scrollbar-border-radius
  var style$1w = cB('scrollbar', `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1('>', [cB('scrollbar-container', `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', `
 width: 0;
 height: 0;
 display: none;
 `), c$1('>', [cB('scrollbar-content', `
 box-sizing: border-box;
 min-width: 100%;
 `)])])]), c$1('>, +', [cB('scrollbar-rail', `
 position: absolute;
 pointer-events: none;
 user-select: none;
 -webkit-user-select: none;
 `, [cM('horizontal', `
 left: 2px;
 right: 2px;
 bottom: 4px;
 height: var(--n-scrollbar-height);
 `, [c$1('>', [cE('scrollbar', `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM('vertical', `
 right: 4px;
 top: 2px;
 bottom: 2px;
 width: var(--n-scrollbar-width);
 `, [c$1('>', [cE('scrollbar', `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM('disabled', [c$1('>', [cE('scrollbar', {
    pointerEvents: 'none'
  })])]), c$1('>', [cE('scrollbar', `
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1('&:hover', {
    backgroundColor: 'var(--n-scrollbar-color-hover)'
  })])])])])]);

  const scrollbarProps$1 = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: Number,
          default: 5
      }, duration: {
          type: Number,
          default: 0
      }, scrollable: {
          type: Boolean,
          default: true
      }, xScrollable: Boolean, trigger: {
          type: String,
          default: 'hover'
      }, useUnifiedContainer: Boolean, triggerDisplayManually: Boolean, 
      // If container is set, resize observer won't not attached
      container: Function, content: Function, containerClass: String, containerStyle: [String, Object], contentClass: String, contentStyle: [String, Object], horizontalRailStyle: [String, Object], verticalRailStyle: [String, Object], onScroll: Function, onWheel: Function, onResize: Function, internalOnUpdateScrollLeft: Function, internalHoistYRail: Boolean });
  const Scrollbar$2 = defineComponent({
      name: 'Scrollbar',
      props: scrollbarProps$1,
      inheritAttrs: false,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('Scrollbar', mergedRtlRef, mergedClsPrefixRef);
          // dom ref
          const wrapperRef = ref(null);
          const containerRef = ref(null);
          const contentRef = ref(null);
          const yRailRef = ref(null);
          const xRailRef = ref(null);
          // data ref
          const contentHeightRef = ref(null);
          const contentWidthRef = ref(null);
          const containerHeightRef = ref(null);
          const containerWidthRef = ref(null);
          const yRailSizeRef = ref(null);
          const xRailSizeRef = ref(null);
          const containerScrollTopRef = ref(0);
          const containerScrollLeftRef = ref(0);
          const isShowXBarRef = ref(false);
          const isShowYBarRef = ref(false);
          let yBarPressed = false;
          let xBarPressed = false;
          let xBarVanishTimerId;
          let yBarVanishTimerId;
          let memoYTop = 0;
          let memoXLeft = 0;
          let memoMouseX = 0;
          let memoMouseY = 0;
          const isIos = useIsIos();
          const yBarSizeRef = computed(() => {
              const { value: containerHeight } = containerHeightRef;
              const { value: contentHeight } = contentHeightRef;
              const { value: yRailSize } = yRailSizeRef;
              if (containerHeight === null ||
                  contentHeight === null ||
                  yRailSize === null) {
                  return 0;
              }
              else {
                  return Math.min(containerHeight, (yRailSize * containerHeight) / contentHeight + props.size * 1.5);
              }
          });
          const yBarSizePxRef = computed(() => {
              return `${yBarSizeRef.value}px`;
          });
          const xBarSizeRef = computed(() => {
              const { value: containerWidth } = containerWidthRef;
              const { value: contentWidth } = contentWidthRef;
              const { value: xRailSize } = xRailSizeRef;
              if (containerWidth === null ||
                  contentWidth === null ||
                  xRailSize === null) {
                  return 0;
              }
              else {
                  return (xRailSize * containerWidth) / contentWidth + props.size * 1.5;
              }
          });
          const xBarSizePxRef = computed(() => {
              return `${xBarSizeRef.value}px`;
          });
          const yBarTopRef = computed(() => {
              const { value: containerHeight } = containerHeightRef;
              const { value: containerScrollTop } = containerScrollTopRef;
              const { value: contentHeight } = contentHeightRef;
              const { value: yRailSize } = yRailSizeRef;
              if (containerHeight === null ||
                  contentHeight === null ||
                  yRailSize === null) {
                  return 0;
              }
              else {
                  const heightDiff = contentHeight - containerHeight;
                  if (!heightDiff)
                      return 0;
                  return ((containerScrollTop / heightDiff) * (yRailSize - yBarSizeRef.value));
              }
          });
          const yBarTopPxRef = computed(() => {
              return `${yBarTopRef.value}px`;
          });
          const xBarLeftRef = computed(() => {
              const { value: containerWidth } = containerWidthRef;
              const { value: containerScrollLeft } = containerScrollLeftRef;
              const { value: contentWidth } = contentWidthRef;
              const { value: xRailSize } = xRailSizeRef;
              if (containerWidth === null ||
                  contentWidth === null ||
                  xRailSize === null) {
                  return 0;
              }
              else {
                  const widthDiff = contentWidth - containerWidth;
                  if (!widthDiff)
                      return 0;
                  return ((containerScrollLeft / widthDiff) * (xRailSize - xBarSizeRef.value));
              }
          });
          const xBarLeftPxRef = computed(() => {
              return `${xBarLeftRef.value}px`;
          });
          const needYBarRef = computed(() => {
              const { value: containerHeight } = containerHeightRef;
              const { value: contentHeight } = contentHeightRef;
              return (containerHeight !== null &&
                  contentHeight !== null &&
                  contentHeight > containerHeight);
          });
          const needXBarRef = computed(() => {
              const { value: containerWidth } = containerWidthRef;
              const { value: contentWidth } = contentWidthRef;
              return (containerWidth !== null &&
                  contentWidth !== null &&
                  contentWidth > containerWidth);
          });
          const mergedShowXBarRef = computed(() => {
              const { trigger } = props;
              return trigger === 'none' || isShowXBarRef.value;
          });
          const mergedShowYBarRef = computed(() => {
              const { trigger } = props;
              return trigger === 'none' || isShowYBarRef.value;
          });
          const mergedContainerRef = computed(() => {
              const { container } = props;
              if (container)
                  return container();
              return containerRef.value;
          });
          const mergedContentRef = computed(() => {
              const { content } = props;
              if (content)
                  return content();
              return contentRef.value;
          });
          const activateState = useReactivated(() => {
              // Only restore for builtin container & content
              if (!props.container) {
                  // remount
                  scrollTo({
                      top: containerScrollTopRef.value,
                      left: containerScrollLeftRef.value
                  });
              }
          });
          // methods
          const handleContentResize = () => {
              if (activateState.isDeactivated)
                  return;
              sync();
          };
          const handleContainerResize = (e) => {
              if (activateState.isDeactivated)
                  return;
              const { onResize } = props;
              if (onResize)
                  onResize(e);
              sync();
          };
          const scrollTo = (options, y) => {
              if (!props.scrollable)
                  return;
              if (typeof options === 'number') {
                  scrollToPosition(y !== null && y !== void 0 ? y : 0, options, 0, false, 'auto');
                  return;
              }
              const { left, top, index, elSize, position, behavior, el, debounce = true } = options;
              if (left !== undefined || top !== undefined) {
                  scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
              }
              if (el !== undefined) {
                  scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce, behavior);
              }
              else if (index !== undefined && elSize !== undefined) {
                  scrollToPosition(0, index * elSize, elSize, debounce, behavior);
              }
              else if (position === 'bottom') {
                  scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
              }
              else if (position === 'top') {
                  scrollToPosition(0, 0, 0, false, behavior);
              }
          };
          const scrollBy = (options, y) => {
              if (!props.scrollable)
                  return;
              const { value: container } = mergedContainerRef;
              if (!container)
                  return;
              if (typeof options === 'object') {
                  container.scrollBy(options);
              }
              else {
                  container.scrollBy(options, y || 0);
              }
          };
          function scrollToPosition(left, top, elSize, debounce, behavior) {
              const { value: container } = mergedContainerRef;
              if (!container)
                  return;
              if (debounce) {
                  const { scrollTop, offsetHeight } = container;
                  if (top > scrollTop) {
                      if (top + elSize <= scrollTop + offsetHeight) ;
                      else {
                          container.scrollTo({
                              left,
                              top: top + elSize - offsetHeight,
                              behavior
                          });
                      }
                      return;
                  }
              }
              container.scrollTo({
                  left,
                  top,
                  behavior
              });
          }
          function handleMouseEnterWrapper() {
              showXBar();
              showYBar();
              sync();
          }
          function handleMouseLeaveWrapper() {
              hideBar();
          }
          function hideBar() {
              hideYBar();
              hideXBar();
          }
          function hideYBar() {
              if (yBarVanishTimerId !== undefined) {
                  window.clearTimeout(yBarVanishTimerId);
              }
              yBarVanishTimerId = window.setTimeout(() => {
                  isShowYBarRef.value = false;
              }, props.duration);
          }
          function hideXBar() {
              if (xBarVanishTimerId !== undefined) {
                  window.clearTimeout(xBarVanishTimerId);
              }
              xBarVanishTimerId = window.setTimeout(() => {
                  isShowXBarRef.value = false;
              }, props.duration);
          }
          function showXBar() {
              if (xBarVanishTimerId !== undefined) {
                  window.clearTimeout(xBarVanishTimerId);
              }
              isShowXBarRef.value = true;
          }
          function showYBar() {
              if (yBarVanishTimerId !== undefined) {
                  window.clearTimeout(yBarVanishTimerId);
              }
              isShowYBarRef.value = true;
          }
          function handleScroll(e) {
              const { onScroll } = props;
              if (onScroll)
                  onScroll(e);
              syncScrollState();
          }
          function syncScrollState() {
              // only collect scroll state, do not trigger any dom event
              const { value: container } = mergedContainerRef;
              if (container) {
                  containerScrollTopRef.value = container.scrollTop;
                  containerScrollLeftRef.value =
                      container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
              }
          }
          function syncPositionState() {
              // only collect position state, do not trigger any dom event
              // Don't use getClientBoundingRect because element may be scale transformed
              const { value: content } = mergedContentRef;
              if (content) {
                  contentHeightRef.value = content.offsetHeight;
                  contentWidthRef.value = content.offsetWidth;
              }
              const { value: container } = mergedContainerRef;
              if (container) {
                  containerHeightRef.value = container.offsetHeight;
                  containerWidthRef.value = container.offsetWidth;
              }
              const { value: xRailEl } = xRailRef;
              const { value: yRailEl } = yRailRef;
              if (xRailEl) {
                  xRailSizeRef.value = xRailEl.offsetWidth;
              }
              if (yRailEl) {
                  yRailSizeRef.value = yRailEl.offsetHeight;
              }
          }
          /**
           * Sometimes there's only one element that we can scroll,
           * For example for textarea, there won't be a content element.
           */
          function syncUnifiedContainer() {
              const { value: container } = mergedContainerRef;
              if (container) {
                  containerScrollTopRef.value = container.scrollTop;
                  containerScrollLeftRef.value =
                      container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
                  containerHeightRef.value = container.offsetHeight;
                  containerWidthRef.value = container.offsetWidth;
                  contentHeightRef.value = container.scrollHeight;
                  contentWidthRef.value = container.scrollWidth;
              }
              const { value: xRailEl } = xRailRef;
              const { value: yRailEl } = yRailRef;
              if (xRailEl) {
                  xRailSizeRef.value = xRailEl.offsetWidth;
              }
              if (yRailEl) {
                  yRailSizeRef.value = yRailEl.offsetHeight;
              }
          }
          function sync() {
              if (!props.scrollable)
                  return;
              if (props.useUnifiedContainer) {
                  syncUnifiedContainer();
              }
              else {
                  syncPositionState();
                  syncScrollState();
              }
          }
          function isMouseUpAway(e) {
              var _a;
              return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
          }
          function handleXScrollMouseDown(e) {
              e.preventDefault();
              e.stopPropagation();
              xBarPressed = true;
              on('mousemove', window, handleXScrollMouseMove, true);
              on('mouseup', window, handleXScrollMouseUp, true);
              memoXLeft = containerScrollLeftRef.value;
              memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value)
                  ? window.innerWidth - e.clientX
                  : e.clientX;
          }
          function handleXScrollMouseMove(e) {
              if (!xBarPressed)
                  return;
              if (xBarVanishTimerId !== undefined) {
                  window.clearTimeout(xBarVanishTimerId);
              }
              if (yBarVanishTimerId !== undefined) {
                  window.clearTimeout(yBarVanishTimerId);
              }
              const { value: containerWidth } = containerWidthRef;
              const { value: contentWidth } = contentWidthRef;
              const { value: xBarSize } = xBarSizeRef;
              if (containerWidth === null || contentWidth === null)
                  return;
              const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value)
                  ? window.innerWidth - e.clientX - memoMouseX
                  : e.clientX - memoMouseX;
              const dScrollLeft = (dX * (contentWidth - containerWidth)) / (containerWidth - xBarSize);
              const toScrollLeftUpperBound = contentWidth - containerWidth;
              let toScrollLeft = memoXLeft + dScrollLeft;
              toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
              toScrollLeft = Math.max(toScrollLeft, 0);
              const { value: container } = mergedContainerRef;
              if (container) {
                  container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
                  const { internalOnUpdateScrollLeft } = props;
                  if (internalOnUpdateScrollLeft)
                      internalOnUpdateScrollLeft(toScrollLeft);
              }
          }
          function handleXScrollMouseUp(e) {
              e.preventDefault();
              e.stopPropagation();
              off('mousemove', window, handleXScrollMouseMove, true);
              off('mouseup', window, handleXScrollMouseUp, true);
              xBarPressed = false;
              sync();
              if (isMouseUpAway(e)) {
                  hideBar();
              }
          }
          function handleYScrollMouseDown(e) {
              e.preventDefault();
              e.stopPropagation();
              yBarPressed = true;
              on('mousemove', window, handleYScrollMouseMove, true);
              on('mouseup', window, handleYScrollMouseUp, true);
              memoYTop = containerScrollTopRef.value;
              memoMouseY = e.clientY;
          }
          function handleYScrollMouseMove(e) {
              if (!yBarPressed)
                  return;
              if (xBarVanishTimerId !== undefined) {
                  window.clearTimeout(xBarVanishTimerId);
              }
              if (yBarVanishTimerId !== undefined) {
                  window.clearTimeout(yBarVanishTimerId);
              }
              const { value: containerHeight } = containerHeightRef;
              const { value: contentHeight } = contentHeightRef;
              const { value: yBarSize } = yBarSizeRef;
              if (containerHeight === null || contentHeight === null)
                  return;
              const dY = e.clientY - memoMouseY;
              const dScrollTop = (dY * (contentHeight - containerHeight)) / (containerHeight - yBarSize);
              const toScrollTopUpperBound = contentHeight - containerHeight;
              let toScrollTop = memoYTop + dScrollTop;
              toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
              toScrollTop = Math.max(toScrollTop, 0);
              const { value: container } = mergedContainerRef;
              if (container) {
                  container.scrollTop = toScrollTop;
              }
          }
          function handleYScrollMouseUp(e) {
              e.preventDefault();
              e.stopPropagation();
              off('mousemove', window, handleYScrollMouseMove, true);
              off('mouseup', window, handleYScrollMouseUp, true);
              yBarPressed = false;
              sync();
              if (isMouseUpAway(e)) {
                  hideBar();
              }
          }
          watchEffect(() => {
              const { value: needXBar } = needXBarRef;
              const { value: needYBar } = needYBarRef;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              const { value: xRailEl } = xRailRef;
              const { value: yRailEl } = yRailRef;
              if (xRailEl) {
                  if (!needXBar) {
                      xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                  }
                  else {
                      xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                  }
              }
              if (yRailEl) {
                  if (!needYBar) {
                      yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                  }
                  else {
                      yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
                  }
              }
          });
          onMounted(() => {
              // if container exist, it always can't be resolved when scrollbar is mounted
              // for example:
              // - component
              //   - scrollbar
              //     - inner
              // if you pass inner to scrollbar, you may use a ref inside component
              // however, when scrollbar is mounted, ref is not ready at component
              // you need to init by yourself
              if (props.container)
                  return;
              sync();
          });
          onBeforeUnmount(() => {
              if (xBarVanishTimerId !== undefined) {
                  window.clearTimeout(xBarVanishTimerId);
              }
              if (yBarVanishTimerId !== undefined) {
                  window.clearTimeout(yBarVanishTimerId);
              }
              off('mousemove', window, handleYScrollMouseMove, true);
              off('mouseup', window, handleYScrollMouseUp, true);
          });
          const themeRef = useTheme('Scrollbar', '-scrollbar', style$1w, scrollbarLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut, scrollbarBorderRadius, scrollbarHeight, scrollbarWidth }, self: { color, colorHover } } = themeRef.value;
              return {
                  '--n-scrollbar-bezier': cubicBezierEaseInOut,
                  '--n-scrollbar-color': color,
                  '--n-scrollbar-color-hover': colorHover,
                  '--n-scrollbar-border-radius': scrollbarBorderRadius,
                  '--n-scrollbar-width': scrollbarWidth,
                  '--n-scrollbar-height': scrollbarHeight
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('scrollbar', undefined, cssVarsRef, props)
              : undefined;
          const exposedMethods = {
              scrollTo,
              scrollBy,
              sync,
              syncUnifiedContainer,
              handleMouseEnterWrapper,
              handleMouseLeaveWrapper
          };
          return Object.assign(Object.assign({}, exposedMethods), { mergedClsPrefix: mergedClsPrefixRef, rtlEnabled: rtlEnabledRef, containerScrollTop: containerScrollTopRef, wrapperRef,
              containerRef,
              contentRef,
              yRailRef,
              xRailRef, needYBar: needYBarRef, needXBar: needXBarRef, yBarSizePx: yBarSizePxRef, xBarSizePx: xBarSizePxRef, yBarTopPx: yBarTopPxRef, xBarLeftPx: xBarLeftPxRef, isShowXBar: mergedShowXBarRef, isShowYBar: mergedShowYBarRef, isIos,
              handleScroll,
              handleContentResize,
              handleContainerResize,
              handleYScrollMouseDown,
              handleXScrollMouseDown, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a;
          const { $slots, mergedClsPrefix, triggerDisplayManually, rtlEnabled, internalHoistYRail } = this;
          if (!this.scrollable)
              return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
          const triggerIsNone = this.trigger === 'none';
          const createYRail = (className, style) => {
              return (h("div", { ref: "yRailRef", class: [
                      `${mergedClsPrefix}-scrollbar-rail`,
                      `${mergedClsPrefix}-scrollbar-rail--vertical`,
                      className
                  ], "data-scrollbar-rail": true, style: [style || '', this.verticalRailStyle], "aria-hiddens": true }, h(
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              (triggerIsNone ? Wrapper : Transition), triggerIsNone ? null : { name: 'fade-in-transition' }, {
                  default: () => this.needYBar && this.isShowYBar && !this.isIos ? (h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                          height: this.yBarSizePx,
                          top: this.yBarTopPx
                      }, onMousedown: this.handleYScrollMouseDown })) : null
              })));
          };
          const createChildren = () => {
              var _a, _b;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return h('div', mergeProps(this.$attrs, {
                  role: 'none',
                  ref: 'wrapperRef',
                  class: [
                      `${mergedClsPrefix}-scrollbar`,
                      this.themeClass,
                      rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`
                  ],
                  style: this.cssVars,
                  onMouseenter: triggerDisplayManually
                      ? undefined
                      : this.handleMouseEnterWrapper,
                  onMouseleave: triggerDisplayManually
                      ? undefined
                      : this.handleMouseLeaveWrapper
              }), [
                  this.container ? ((_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots)) : (h("div", { role: "none", ref: "containerRef", class: [
                          `${mergedClsPrefix}-scrollbar-container`,
                          this.containerClass
                      ], style: this.containerStyle, onScroll: this.handleScroll, onWheel: this.onWheel },
                      h(VResizeObserver, { onResize: this.handleContentResize }, {
                          default: () => (h("div", { ref: "contentRef", role: "none", style: [
                                  {
                                      width: this.xScrollable ? 'fit-content' : null
                                  },
                                  this.contentStyle
                              ], class: [
                                  `${mergedClsPrefix}-scrollbar-content`,
                                  this.contentClass
                              ] }, $slots))
                      }))),
                  internalHoistYRail ? null : createYRail(undefined, undefined),
                  this.xScrollable && (h("div", { ref: "xRailRef", class: [
                          `${mergedClsPrefix}-scrollbar-rail`,
                          `${mergedClsPrefix}-scrollbar-rail--horizontal`
                      ], style: this.horizontalRailStyle, "data-scrollbar-rail": true, "aria-hidden": true }, h(
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  (triggerIsNone ? Wrapper : Transition), triggerIsNone ? null : { name: 'fade-in-transition' }, {
                      default: () => this.needXBar && this.isShowXBar && !this.isIos ? (h("div", { class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`, style: {
                              width: this.xBarSizePx,
                              right: rtlEnabled ? this.xBarLeftPx : undefined,
                              left: rtlEnabled ? undefined : this.xBarLeftPx
                          }, onMousedown: this.handleXScrollMouseDown })) : null
                  })))
              ]);
          };
          const scrollbarNode = this.container ? (createChildren()) : (h(VResizeObserver, { onResize: this.handleContainerResize }, {
              default: createChildren
          }));
          if (internalHoistYRail) {
              return (h(Fragment, null,
                  scrollbarNode,
                  createYRail(this.themeClass, this.cssVars)));
          }
          else {
              return scrollbarNode;
          }
      }
  });
  var NScrollbar = Scrollbar$2;
  const XScrollbar = Scrollbar$2;

  var commonVariables$l = {
      height: 'calc(var(--n-option-height) * 7.6)',
      paddingSmall: '4px 0',
      paddingMedium: '4px 0',
      paddingLarge: '4px 0',
      paddingHuge: '4px 0',
      optionPaddingSmall: '0 12px',
      optionPaddingMedium: '0 12px',
      optionPaddingLarge: '0 12px',
      optionPaddingHuge: '0 12px',
      loadingSize: '18px'
  };

  const self$1c = (vars) => {
      const { borderRadius, popoverColor, textColor3, dividerColor, textColor2, primaryColorPressed, textColorDisabled, primaryColor, opacityDisabled, hoverColor, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge } = vars;
      return Object.assign(Object.assign({}, commonVariables$l), { optionFontSizeSmall: fontSizeSmall, optionFontSizeMedium: fontSizeMedium, optionFontSizeLarge: fontSizeLarge, optionFontSizeHuge: fontSizeHuge, optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius, color: popoverColor, groupHeaderTextColor: textColor3, actionDividerColor: dividerColor, optionTextColor: textColor2, optionTextColorPressed: primaryColorPressed, optionTextColorDisabled: textColorDisabled, optionTextColorActive: primaryColor, optionOpacityDisabled: opacityDisabled, optionCheckColor: primaryColor, optionColorPending: hoverColor, optionColorActive: 'rgba(0, 0, 0, 0)', optionColorActivePending: hoverColor, actionTextColor: textColor2, loadingColor: primaryColor });
  };
  const internalSelectMenuLight = createTheme({
      name: 'InternalSelectMenu',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1
      },
      self: self$1c
  });
  var internalSelectMenuLight$1 = internalSelectMenuLight;

  function renderCheckMark(show, clsPrefix) {
      return (h(Transition, { name: "fade-in-scale-up-transition" }, {
          default: () => show ? (h(NBaseIcon, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-select-option__check` }, {
              default: () => h(FinishedIcon)
          })) : null
      }));
  }
  var NSelectOption = defineComponent({
      name: 'NBaseSelectOption',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          const { valueRef, pendingTmNodeRef, multipleRef, valueSetRef, renderLabelRef, renderOptionRef, labelFieldRef, valueFieldRef, showCheckmarkRef, nodePropsRef, handleOptionClick, handleOptionMouseEnter
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(internalSelectionMenuInjectionKey);
          const isPendingRef = useMemo(() => {
              const { value: pendingTmNode } = pendingTmNodeRef;
              if (!pendingTmNode)
                  return false;
              return props.tmNode.key === pendingTmNode.key;
          });
          function handleClick(e) {
              const { tmNode } = props;
              if (tmNode.disabled)
                  return;
              handleOptionClick(e, tmNode);
          }
          function handleMouseEnter(e) {
              const { tmNode } = props;
              if (tmNode.disabled)
                  return;
              handleOptionMouseEnter(e, tmNode);
          }
          function handleMouseMove(e) {
              const { tmNode } = props;
              const { value: isPending } = isPendingRef;
              if (tmNode.disabled || isPending)
                  return;
              handleOptionMouseEnter(e, tmNode);
          }
          return {
              multiple: multipleRef,
              isGrouped: useMemo(() => {
                  const { tmNode } = props;
                  const { parent } = tmNode;
                  return parent && parent.rawNode.type === 'group';
              }),
              showCheckmark: showCheckmarkRef,
              nodeProps: nodePropsRef,
              isPending: isPendingRef,
              isSelected: useMemo(() => {
                  const { value } = valueRef;
                  const { value: multiple } = multipleRef;
                  if (value === null)
                      return false;
                  const optionValue = props.tmNode.rawNode[valueFieldRef.value];
                  if (multiple) {
                      const { value: valueSet } = valueSetRef;
                      return valueSet.has(optionValue);
                  }
                  else {
                      return value === optionValue;
                  }
              }),
              labelField: labelFieldRef,
              renderLabel: renderLabelRef,
              renderOption: renderOptionRef,
              handleMouseMove,
              handleMouseEnter,
              handleClick
          };
      },
      render() {
          const { clsPrefix, tmNode: { rawNode }, isSelected, isPending, isGrouped, showCheckmark, nodeProps, renderOption, renderLabel, handleClick, handleMouseEnter, handleMouseMove } = this;
          const checkmark = renderCheckMark(isSelected, clsPrefix);
          const children = renderLabel
              ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark]
              : [
                  render$1(rawNode[this.labelField], rawNode, isSelected),
                  showCheckmark && checkmark
              ];
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = (h("div", Object.assign({}, attrs, { class: [
                  `${clsPrefix}-base-select-option`,
                  rawNode.class,
                  attrs === null || attrs === void 0 ? void 0 : attrs.class,
                  {
                      [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
                      [`${clsPrefix}-base-select-option--selected`]: isSelected,
                      [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
                      [`${clsPrefix}-base-select-option--pending`]: isPending,
                      [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
                  }
              ], style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || '', rawNode.style || ''], onClick: mergeEventHandlers([handleClick, attrs === null || attrs === void 0 ? void 0 : attrs.onClick]), onMouseenter: mergeEventHandlers([
                  handleMouseEnter,
                  attrs === null || attrs === void 0 ? void 0 : attrs.onMouseenter
              ]), onMousemove: mergeEventHandlers([handleMouseMove, attrs === null || attrs === void 0 ? void 0 : attrs.onMousemove]) }),
              h("div", { class: `${clsPrefix}-base-select-option__content` }, children)));
          return rawNode.render
              ? rawNode.render({ node, option: rawNode, selected: isSelected })
              : renderOption
                  ? renderOption({ node, option: rawNode, selected: isSelected })
                  : node;
      }
  });

  var NSelectGroupHeader = defineComponent({
      name: 'NBaseSelectGroupHeader',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup() {
          const { renderLabelRef, renderOptionRef, labelFieldRef, nodePropsRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(internalSelectionMenuInjectionKey);
          return {
              labelField: labelFieldRef,
              nodeProps: nodePropsRef,
              renderLabel: renderLabelRef,
              renderOption: renderOptionRef
          };
      },
      render() {
          const { clsPrefix, renderLabel, renderOption, nodeProps, tmNode: { rawNode } } = this;
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const children = renderLabel
              ? renderLabel(rawNode, false)
              : render$1(rawNode[this.labelField], rawNode, false);
          const node = (h("div", Object.assign({}, attrs, { class: [`${clsPrefix}-base-select-group-header`, attrs === null || attrs === void 0 ? void 0 : attrs.class] }), children));
          return rawNode.render
              ? rawNode.render({ node, option: rawNode })
              : renderOption
                  ? renderOption({ node, option: rawNode, selected: false })
                  : node;
      }
  });

  const {
    cubicBezierEaseIn: cubicBezierEaseIn$5,
    cubicBezierEaseOut: cubicBezierEaseOut$6
  } = commonVariables$m;
  function fadeInScaleUpTransition({
    transformOrigin = 'inherit',
    duration = '.2s',
    enterScale = '.9',
    originalTransform = '',
    originalTransition = ''
  } = {}) {
    return [c$1('&.fade-in-scale-up-transition-leave-active', {
      transformOrigin,
      transition: `opacity ${duration} ${cubicBezierEaseIn$5}, transform ${duration} ${cubicBezierEaseIn$5} ${originalTransition && ',' + originalTransition}`
    }), c$1('&.fade-in-scale-up-transition-enter-active', {
      transformOrigin,
      transition: `opacity ${duration} ${cubicBezierEaseOut$6}, transform ${duration} ${cubicBezierEaseOut$6} ${originalTransition && ',' + originalTransition}`
    }), c$1('&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to', {
      opacity: 0,
      transform: `${originalTransform} scale(${enterScale})`
    }), c$1('&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to', {
      opacity: 1,
      transform: `${originalTransform} scale(1)`
    })];
  }

  // --n-loading-color
  // --n-loading-size
  // --n-option-padding-right
  var style$1v = cB('base-select-menu', `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [cB('scrollbar', `
 max-height: var(--n-height);
 `), cB('virtual-list', `
 max-height: var(--n-height);
 `), cB('base-select-option', `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [cE('content', `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), cB('base-select-group-header', `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), cB('base-select-menu-option-wrapper', `
 position: relative;
 width: 100%;
 `), cE('loading, empty', `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE('loading', `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), cE('header', `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cE('action', `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cB('base-select-group-header', `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), cB('base-select-option', `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [cM('show-checkmark', `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), c$1('&::before', `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), c$1('&:active', `
 color: var(--n-option-text-color-pressed);
 `), cM('grouped', `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), cM('pending', [c$1('&::before', `
 background-color: var(--n-option-color-pending);
 `)]), cM('selected', `
 color: var(--n-option-text-color-active);
 `, [c$1('&::before', `
 background-color: var(--n-option-color-active);
 `), cM('pending', [c$1('&::before', `
 background-color: var(--n-option-color-active-pending);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 `, [cNotM('selected', `
 color: var(--n-option-text-color-disabled);
 `), cM('selected', `
 opacity: var(--n-option-opacity-disabled);
 `)]), cE('check', `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [fadeInScaleUpTransition({
    enterScale: '0.5'
  })])])]);

  var NInternalSelectMenu = defineComponent({
      name: 'InternalSelectMenu',
      props: Object.assign(Object.assign({}, useTheme.props), { clsPrefix: {
              type: String,
              required: true
          }, scrollable: {
              type: Boolean,
              default: true
          }, treeMate: {
              type: Object,
              required: true
          }, multiple: Boolean, size: {
              type: String,
              default: 'medium'
          }, value: {
              type: [String, Number, Array],
              default: null
          }, autoPending: Boolean, virtualScroll: {
              type: Boolean,
              default: true
          }, 
          // show is used to toggle pending state initialization
          show: {
              type: Boolean,
              default: true
          }, labelField: {
              type: String,
              default: 'label'
          }, valueField: {
              type: String,
              default: 'value'
          }, loading: Boolean, focusable: Boolean, renderLabel: Function, renderOption: Function, nodeProps: Function, showCheckmark: { type: Boolean, default: true }, onMousedown: Function, onScroll: Function, onFocus: Function, onBlur: Function, onKeyup: Function, onKeydown: Function, onTabOut: Function, onMouseenter: Function, onMouseleave: Function, onResize: Function, resetMenuOnOptionsChange: {
              type: Boolean,
              default: true
          }, inlineThemeDisabled: Boolean, 
          // deprecated
          onToggle: Function }),
      setup(props) {
          const themeRef = useTheme('InternalSelectMenu', '-internal-select-menu', style$1v, internalSelectMenuLight$1, props, toRef(props, 'clsPrefix'));
          const selfRef = ref(null);
          const virtualListRef = ref(null);
          const scrollbarRef = ref(null);
          const flattenedNodesRef = computed(() => props.treeMate.getFlattenedNodes());
          const fIndexGetterRef = computed(() => createIndexGetter(flattenedNodesRef.value));
          const pendingNodeRef = ref(null);
          function initPendingNode() {
              const { treeMate } = props;
              let defaultPendingNode = null;
              const { value } = props;
              if (value === null) {
                  defaultPendingNode = treeMate.getFirstAvailableNode();
              }
              else {
                  if (props.multiple) {
                      defaultPendingNode = treeMate.getNode((value || [])[(value || []).length - 1]);
                  }
                  else {
                      defaultPendingNode = treeMate.getNode(value);
                  }
                  if (!defaultPendingNode || defaultPendingNode.disabled) {
                      defaultPendingNode = treeMate.getFirstAvailableNode();
                  }
              }
              if (defaultPendingNode) {
                  setPendingTmNode(defaultPendingNode);
              }
              else {
                  setPendingTmNode(null);
              }
          }
          function clearPendingNodeIfInvalid() {
              const { value: pendingNode } = pendingNodeRef;
              if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
                  pendingNodeRef.value = null;
              }
          }
          let initPendingNodeWatchStopHandle;
          watch(() => props.show, (show) => {
              if (show) {
                  initPendingNodeWatchStopHandle = watch(() => props.treeMate, () => {
                      if (props.resetMenuOnOptionsChange) {
                          if (props.autoPending) {
                              initPendingNode();
                          }
                          else {
                              clearPendingNodeIfInvalid();
                          }
                          void nextTick(scrollToPendingNode);
                      }
                      else {
                          clearPendingNodeIfInvalid();
                      }
                  }, {
                      immediate: true
                  });
              }
              else {
                  initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
              }
          }, {
              immediate: true
          });
          onBeforeUnmount(() => {
              initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
          });
          const itemSizeRef = computed(() => {
              return depx(themeRef.value.self[createKey('optionHeight', props.size)]);
          });
          const paddingRef = computed(() => {
              return getMargin(themeRef.value.self[createKey('padding', props.size)]);
          });
          const valueSetRef = computed(() => {
              if (props.multiple && Array.isArray(props.value)) {
                  return new Set(props.value);
              }
              return new Set();
          });
          const emptyRef = computed(() => {
              const tmNodes = flattenedNodesRef.value;
              return tmNodes && tmNodes.length === 0;
          });
          function doToggle(tmNode) {
              const { onToggle } = props;
              if (onToggle)
                  onToggle(tmNode);
          }
          function doScroll(e) {
              const { onScroll } = props;
              if (onScroll)
                  onScroll(e);
          }
          // required, scroller sync need to be triggered manually
          function handleVirtualListScroll(e) {
              var _a;
              (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
              doScroll(e);
          }
          function handleVirtualListResize() {
              var _a;
              (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function getPendingTmNode() {
              const { value: pendingTmNode } = pendingNodeRef;
              if (pendingTmNode)
                  return pendingTmNode;
              return null;
          }
          function handleOptionMouseEnter(e, tmNode) {
              if (tmNode.disabled)
                  return;
              setPendingTmNode(tmNode, false);
          }
          function handleOptionClick(e, tmNode) {
              if (tmNode.disabled)
                  return;
              doToggle(tmNode);
          }
          // keyboard related methods
          function handleKeyUp(e) {
              var _a;
              if (happensIn(e, 'action'))
                  return;
              (_a = props.onKeyup) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleKeyDown(e) {
              var _a;
              if (happensIn(e, 'action'))
                  return;
              (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleMouseDown(e) {
              var _a;
              (_a = props.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props, e);
              if (props.focusable)
                  return;
              e.preventDefault();
          }
          function next() {
              const { value: pendingTmNode } = pendingNodeRef;
              if (pendingTmNode) {
                  setPendingTmNode(pendingTmNode.getNext({ loop: true }), true);
              }
          }
          function prev() {
              const { value: pendingTmNode } = pendingNodeRef;
              if (pendingTmNode) {
                  setPendingTmNode(pendingTmNode.getPrev({ loop: true }), true);
              }
          }
          function setPendingTmNode(tmNode, doScroll = false) {
              pendingNodeRef.value = tmNode;
              if (doScroll)
                  scrollToPendingNode();
          }
          function scrollToPendingNode() {
              var _a, _b;
              const tmNode = pendingNodeRef.value;
              if (!tmNode)
                  return;
              const fIndex = fIndexGetterRef.value(tmNode.key);
              if (fIndex === null)
                  return;
              if (props.virtualScroll) {
                  (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ index: fIndex });
              }
              else {
                  (_b = scrollbarRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
                      index: fIndex,
                      elSize: itemSizeRef.value
                  });
              }
          }
          function handleFocusin(e) {
              var _a, _b;
              if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
                  (_b = props.onFocus) === null || _b === void 0 ? void 0 : _b.call(props, e);
              }
          }
          function handleFocusout(e) {
              var _a, _b;
              if (!((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
                  (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, e);
              }
          }
          provide(internalSelectionMenuInjectionKey, {
              handleOptionMouseEnter,
              handleOptionClick,
              valueSetRef,
              pendingTmNodeRef: pendingNodeRef,
              nodePropsRef: toRef(props, 'nodeProps'),
              showCheckmarkRef: toRef(props, 'showCheckmark'),
              multipleRef: toRef(props, 'multiple'),
              valueRef: toRef(props, 'value'),
              renderLabelRef: toRef(props, 'renderLabel'),
              renderOptionRef: toRef(props, 'renderOption'),
              labelFieldRef: toRef(props, 'labelField'),
              valueFieldRef: toRef(props, 'valueField')
          });
          provide(internalSelectionMenuBodyInjectionKey, selfRef);
          onMounted(() => {
              const { value } = scrollbarRef;
              if (value)
                  value.sync();
          });
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { common: { cubicBezierEaseInOut }, self: { height, borderRadius, color, groupHeaderTextColor, actionDividerColor, optionTextColorPressed, optionTextColor, optionTextColorDisabled, optionTextColorActive, optionOpacityDisabled, optionCheckColor, actionTextColor, optionColorPending, optionColorActive, loadingColor, loadingSize, optionColorActivePending, [createKey('optionFontSize', size)]: fontSize, [createKey('optionHeight', size)]: optionHeight, [createKey('optionPadding', size)]: optionPadding } } = themeRef.value;
              return {
                  '--n-height': height,
                  '--n-action-divider-color': actionDividerColor,
                  '--n-action-text-color': actionTextColor,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-color': color,
                  '--n-option-font-size': fontSize,
                  '--n-group-header-text-color': groupHeaderTextColor,
                  '--n-option-check-color': optionCheckColor,
                  '--n-option-color-pending': optionColorPending,
                  '--n-option-color-active': optionColorActive,
                  '--n-option-color-active-pending': optionColorActivePending,
                  '--n-option-height': optionHeight,
                  '--n-option-opacity-disabled': optionOpacityDisabled,
                  '--n-option-text-color': optionTextColor,
                  '--n-option-text-color-active': optionTextColorActive,
                  '--n-option-text-color-disabled': optionTextColorDisabled,
                  '--n-option-text-color-pressed': optionTextColorPressed,
                  '--n-option-padding': optionPadding,
                  '--n-option-padding-left': getMargin(optionPadding, 'left'),
                  '--n-option-padding-right': getMargin(optionPadding, 'right'),
                  '--n-loading-color': loadingColor,
                  '--n-loading-size': loadingSize
              };
          });
          const { inlineThemeDisabled } = props;
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('internal-select-menu', computed(() => props.size[0]), cssVarsRef, props)
              : undefined;
          const exposedProps = {
              selfRef,
              next,
              prev,
              getPendingTmNode
          };
          useOnResize(selfRef, props.onResize);
          return Object.assign({ mergedTheme: themeRef, virtualListRef,
              scrollbarRef, itemSize: itemSizeRef, padding: paddingRef, flattenedNodes: flattenedNodesRef, empty: emptyRef, virtualListContainer() {
                  const { value } = virtualListRef;
                  return value === null || value === void 0 ? void 0 : value.listElRef;
              },
              virtualListContent() {
                  const { value } = virtualListRef;
                  return value === null || value === void 0 ? void 0 : value.itemsElRef;
              },
              doScroll,
              handleFocusin,
              handleFocusout,
              handleKeyUp,
              handleKeyDown,
              handleMouseDown,
              handleVirtualListResize,
              handleVirtualListScroll, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedProps);
      },
      render() {
          const { $slots, virtualScroll, clsPrefix, mergedTheme, themeClass, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: this.focusable ? 0 : -1, class: [
                  `${clsPrefix}-base-select-menu`,
                  themeClass,
                  this.multiple && `${clsPrefix}-base-select-menu--multiple`
              ], style: this.cssVars, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeyup: this.handleKeyUp, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
              resolveWrappedSlot($slots.header, (children) => children && (h("div", { class: `${clsPrefix}-base-select-menu__header`, "data-header": true, key: "header" }, children))),
              this.loading ? (h("div", { class: `${clsPrefix}-base-select-menu__loading` },
                  h(NBaseLoading, { clsPrefix: clsPrefix, strokeWidth: 20 }))) : !this.empty ? (h(NScrollbar, { ref: "scrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, scrollable: this.scrollable, container: virtualScroll ? this.virtualListContainer : undefined, content: virtualScroll ? this.virtualListContent : undefined, onScroll: virtualScroll ? undefined : this.doScroll }, {
                  default: () => {
                      return virtualScroll ? (h(VVirtualList, { ref: "virtualListRef", class: `${clsPrefix}-virtual-list`, items: this.flattenedNodes, itemSize: this.itemSize, showScrollbar: false, paddingTop: this.padding.top, paddingBottom: this.padding.bottom, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemResizable: true }, {
                          default: ({ item: tmNode }) => {
                              return tmNode.isGroup ? (h(NSelectGroupHeader, { key: tmNode.key, clsPrefix: clsPrefix, tmNode: tmNode })) : tmNode.ignored ? null : (h(NSelectOption, { clsPrefix: clsPrefix, key: tmNode.key, tmNode: tmNode }));
                          }
                      })) : (h("div", { class: `${clsPrefix}-base-select-menu-option-wrapper`, style: {
                              paddingTop: this.padding.top,
                              paddingBottom: this.padding.bottom
                          } }, this.flattenedNodes.map((tmNode) => tmNode.isGroup ? (h(NSelectGroupHeader, { key: tmNode.key, clsPrefix: clsPrefix, tmNode: tmNode })) : (h(NSelectOption, { clsPrefix: clsPrefix, key: tmNode.key, tmNode: tmNode })))));
                  }
              })) : (h("div", { class: `${clsPrefix}-base-select-menu__empty`, "data-empty": true, "data-action": true }, resolveSlot($slots.empty, () => [
                  h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
              ]))),
              resolveWrappedSlot($slots.action, (children) => children && [
                  h("div", { class: `${clsPrefix}-base-select-menu__action`, "data-action": true, key: "action" }, children),
                  h(FocusDetector, { onFocus: this.onTabOut, key: "focus-detector" })
              ])));
      }
  });

  var style$1u = cB('base-wave', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);

  var NBaseWave = defineComponent({
      name: 'BaseWave',
      props: {
          clsPrefix: {
              type: String,
              required: true
          }
      },
      setup(props) {
          useStyle('-base-wave', style$1u, toRef(props, 'clsPrefix'));
          const selfRef = ref(null);
          const activeRef = ref(false);
          let animationTimerId = null;
          onBeforeUnmount(() => {
              if (animationTimerId !== null) {
                  window.clearTimeout(animationTimerId);
              }
          });
          return {
              active: activeRef,
              selfRef,
              play() {
                  if (animationTimerId !== null) {
                      window.clearTimeout(animationTimerId);
                      activeRef.value = false;
                      animationTimerId = null;
                  }
                  void nextTick(() => {
                      var _a;
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
                      activeRef.value = true;
                      animationTimerId = window.setTimeout(() => {
                          activeRef.value = false;
                          animationTimerId = null;
                      }, 1000);
                  });
              }
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { ref: "selfRef", "aria-hidden": true, class: [
                  `${clsPrefix}-base-wave`,
                  this.active && `${clsPrefix}-base-wave--active`
              ] }));
      }
  });

  var style$1t = cB('base-menu-mask', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 text-align: center;
 padding: 14px;
 overflow: hidden;
`, [fadeInTransition()]);

  var NBaseMenuMask = defineComponent({
      name: 'BaseMenuMask',
      props: {
          clsPrefix: {
              type: String,
              required: true
          }
      },
      setup(props) {
          useStyle('-base-menu-mask', style$1t, toRef(props, 'clsPrefix'));
          const messageRef = ref(null);
          let timerId = null;
          const uncontrolledShowRef = ref(false);
          onBeforeUnmount(() => {
              if (timerId !== null) {
                  window.clearTimeout(timerId);
              }
          });
          const exposedRef = {
              showOnce(message, duration = 1500) {
                  if (timerId)
                      window.clearTimeout(timerId);
                  uncontrolledShowRef.value = true;
                  messageRef.value = message;
                  timerId = window.setTimeout(() => {
                      uncontrolledShowRef.value = false;
                      messageRef.value = null;
                  }, duration);
              }
          };
          return Object.assign({ message: messageRef, show: uncontrolledShowRef }, exposedRef);
      },
      render() {
          return (h(Transition, { name: "fade-in-transition" }, {
              default: () => this.show ? (h("div", { class: `${this.clsPrefix}-base-menu-mask` }, this.message)) : null
          }));
      }
  });

  var commonVariables$k = {
      space: '6px',
      spaceArrow: '10px',
      arrowOffset: '10px',
      arrowOffsetVertical: '10px',
      arrowHeight: '6px',
      padding: '8px 14px'
  };

  const self$1b = (vars) => {
      const { boxShadow2, popoverColor, textColor2, borderRadius, fontSize, dividerColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$k), { fontSize,
          borderRadius, color: popoverColor, dividerColor, textColor: textColor2, boxShadow: boxShadow2 });
  };
  const popoverLight = {
      name: 'Popover',
      common: commonLight,
      self: self$1b
  };
  var popoverLight$1 = popoverLight;

  const oppositePlacement = {
    top: 'bottom',
    bottom: 'top',
    left: 'right',
    right: 'left'
  };
  const arrowSize = 'var(--n-arrow-height) * 1.414';
  // vars:
  // --n-bezier
  // --n-bezier-ease-in
  // --n-bezier-ease-out
  // --n-font-size
  // --n-text-color
  // --n-color
  // --n-border-radius
  // --n-arrow-height
  // --n-arrow-offset
  // --n-arrow-offset-vertical
  // --n-padding
  // --n-space
  // --n-space-arrow
  // --n-divider-color
  var style$1s = c$1([cB('popover', `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1('>', [cB('scrollbar', `
 height: inherit;
 max-height: inherit;
 `)]), cNotM('raw', `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM('scrollable', [cNotM('show-header-or-footer', 'padding: var(--n-padding);')])]), cE('header', `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE('footer', `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM('scrollable, show-header-or-footer', [cE('content', `
 padding: var(--n-padding);
 `)])]), cB('popover-shared', `
 transform-origin: inherit;
 `, [cB('popover-arrow-wrapper', `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB('popover-arrow', `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
  // body transition
  c$1('&.popover-transition-enter-from, &.popover-transition-leave-to', `
 opacity: 0;
 transform: scale(.85);
 `), c$1('&.popover-transition-enter-to, &.popover-transition-leave-from', `
 transform: scale(1);
 opacity: 1;
 `), c$1('&.popover-transition-enter-active', `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `), c$1('&.popover-transition-leave-active', `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)]), placementStyle('top-start', `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset('top-start')} - var(--v-offset-left));
 `), placementStyle('top', `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle('top-end', `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset('top-end')} + var(--v-offset-left));
 `), placementStyle('bottom-start', `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset('bottom-start')} - var(--v-offset-left));
 `), placementStyle('bottom', `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle('bottom-end', `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset('bottom-end')} + var(--v-offset-left));
 `), placementStyle('left-start', `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset('left-start')} - var(--v-offset-top));
 `), placementStyle('left', `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle('left-end', `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset('left-end')} + var(--v-offset-top));
 `), placementStyle('right-start', `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset('right-start')} - var(--v-offset-top));
 `), placementStyle('right', `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle('right-end', `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset('right-end')} + var(--v-offset-top));
 `), ...map({
    top: ['right-start', 'left-start'],
    right: ['top-end', 'bottom-end'],
    bottom: ['right-end', 'left-end'],
    left: ['top-start', 'bottom-start']
  }, (placements, direction) => {
    const isVertical = ['right', 'left'].includes(direction);
    const sizeType = isVertical ? 'width' : 'height';
    return placements.map(placement => {
      const isReverse = placement.split('-')[1] === 'end';
      const targetSize = `var(--v-target-${sizeType}, 0px)`;
      const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
      const offset = getArrowOffset(placement);
      return c$1(`[v-placement="${placement}"] >`, [cB('popover-shared', [cM('center-arrow', [cB('popover-arrow', `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? '+' : '-'} var(--v-offset-${isVertical ? 'left' : 'top'}));`)])])]);
    });
  })]);
  function getArrowOffset(placement) {
    return ['top', 'bottom'].includes(placement.split('-')[0]) ? 'var(--n-arrow-offset)' : 'var(--n-arrow-offset-vertical)';
  }
  function placementStyle(placement, arrowStyleLiteral) {
    const position = placement.split('-')[0];
    const sizeStyle = ['top', 'bottom'].includes(position) ? 'height: var(--n-space-arrow);' : 'width: var(--n-space-arrow);';
    return c$1(`[v-placement="${placement}"] >`, [cB('popover-shared', `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM('show-arrow', `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM('overlap', `
 margin: 0;
 `), cCB('popover-arrow-wrapper', `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB('popover-arrow', arrowStyleLiteral)])])]);
  }

  const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, show: Boolean, trigger: String, showArrow: Boolean, delay: Number, duration: Number, raw: Boolean, arrowPointToCenter: Boolean, arrowClass: String, arrowStyle: [String, Object], arrowWrapperClass: String, arrowWrapperStyle: [String, Object], displayDirective: String, x: Number, y: Number, flip: Boolean, overlap: Boolean, placement: String, width: [Number, String], keepAliveOnHover: Boolean, scrollable: Boolean, contentClass: String, contentStyle: [Object, String], headerClass: String, headerStyle: [Object, String], footerClass: String, footerStyle: [Object, String], 
      // private
      internalDeactivateImmediately: Boolean, animated: Boolean, onClickoutside: Function, internalTrapFocus: Boolean, internalOnAfterLeave: Function, 
      // deprecated
      minWidth: Number, maxWidth: Number });
  const renderArrow = ({ arrowClass, arrowStyle, arrowWrapperClass, arrowWrapperStyle, clsPrefix }) => {
      return (h("div", { key: "__popover-arrow__", style: arrowWrapperStyle, class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass] },
          h("div", { class: [`${clsPrefix}-popover-arrow`, arrowClass], style: arrowStyle })));
  };
  var NPopoverBody = defineComponent({
      name: 'PopoverBody',
      inheritAttrs: false,
      props: popoverBodyProps,
      setup(props, { slots, attrs }) {
          const { namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Popover', '-popover', style$1s, popoverLight$1, props, mergedClsPrefixRef);
          const followerRef = ref(null);
          // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
          const NPopover = inject('NPopover');
          const bodyRef = ref(null);
          const followerEnabledRef = ref(props.show);
          const displayedRef = ref(false);
          watchEffect(() => {
              const { show } = props;
              if (show && !isJsdom() && !props.internalDeactivateImmediately) {
                  displayedRef.value = true;
              }
          });
          const directivesRef = computed(() => {
              const { trigger, onClickoutside } = props;
              const directives = [];
              const { positionManuallyRef: { value: positionManually } } = NPopover;
              if (!positionManually) {
                  if (trigger === 'click' && !onClickoutside) {
                      directives.push([
                          clickoutside$1,
                          handleClickOutside,
                          undefined,
                          { capture: true }
                      ]);
                  }
                  if (trigger === 'hover') {
                      directives.push([mousemoveoutside$1, handleMouseMoveOutside]);
                  }
              }
              if (onClickoutside) {
                  directives.push([
                      clickoutside$1,
                      handleClickOutside,
                      undefined,
                      { capture: true }
                  ]);
              }
              if (props.displayDirective === 'show' ||
                  (props.animated && displayedRef.value)) {
                  directives.push([vShow, props.show]);
              }
              return directives;
          });
          const styleRef = computed(() => {
              const width = props.width === 'trigger' ? undefined : formatLength(props.width);
              const style = [];
              if (width) {
                  style.push({ width });
              }
              const { maxWidth, minWidth } = props;
              if (maxWidth) {
                  style.push({ maxWidth: formatLength(maxWidth) });
              }
              if (minWidth) {
                  style.push({ maxWidth: formatLength(minWidth) });
              }
              if (!inlineThemeDisabled) {
                  style.push(cssVarsRef.value);
              }
              return style;
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut }, self: { space, spaceArrow, padding, fontSize, textColor, dividerColor, color, boxShadow, borderRadius, arrowHeight, arrowOffset, arrowOffsetVertical } } = themeRef.value;
              return {
                  '--n-box-shadow': boxShadow,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-bezier-ease-in': cubicBezierEaseIn,
                  '--n-bezier-ease-out': cubicBezierEaseOut,
                  '--n-font-size': fontSize,
                  '--n-text-color': textColor,
                  '--n-color': color,
                  '--n-divider-color': dividerColor,
                  '--n-border-radius': borderRadius,
                  '--n-arrow-height': arrowHeight,
                  '--n-arrow-offset': arrowOffset,
                  '--n-arrow-offset-vertical': arrowOffsetVertical,
                  '--n-padding': padding,
                  '--n-space': space,
                  '--n-space-arrow': spaceArrow
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('popover', undefined, cssVarsRef, props)
              : undefined;
          NPopover.setBodyInstance({
              syncPosition
          });
          onBeforeUnmount(() => {
              NPopover.setBodyInstance(null);
          });
          watch(toRef(props, 'show'), (value) => {
              // If no animation, no transition component will be applied to the
              // component. So we need to trigger follower manaully.
              if (props.animated)
                  return;
              if (value) {
                  followerEnabledRef.value = true;
              }
              else {
                  followerEnabledRef.value = false;
              }
          });
          function syncPosition() {
              var _a;
              (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleMouseEnter(e) {
              if (props.trigger === 'hover' && props.keepAliveOnHover && props.show) {
                  NPopover.handleMouseEnter(e);
              }
          }
          function handleMouseLeave(e) {
              if (props.trigger === 'hover' && props.keepAliveOnHover) {
                  NPopover.handleMouseLeave(e);
              }
          }
          function handleMouseMoveOutside(e) {
              if (props.trigger === 'hover' &&
                  !getTriggerElement().contains(getPreciseEventTarget(e))) {
                  NPopover.handleMouseMoveOutside(e);
              }
          }
          function handleClickOutside(e) {
              if ((props.trigger === 'click' &&
                  !getTriggerElement().contains(getPreciseEventTarget(e))) ||
                  props.onClickoutside) {
                  NPopover.handleClickOutside(e);
              }
          }
          function getTriggerElement() {
              return NPopover.getTriggerElement();
          }
          provide(popoverBodyInjectionKey, bodyRef);
          provide(drawerBodyInjectionKey, null);
          provide(modalBodyInjectionKey, null);
          function renderContentNode() {
              themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
              const shouldRenderDom = props.displayDirective === 'show' ||
                  props.show ||
                  (props.animated && displayedRef.value);
              if (!shouldRenderDom) {
                  return null;
              }
              let contentNode;
              const renderBody = NPopover.internalRenderBodyRef.value;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              if (!renderBody) {
                  const { value: extraClass } = NPopover.extraClassRef;
                  const { internalTrapFocus } = props;
                  const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
                  const renderContentInnerNode = () => {
                      var _a, _b;
                      const body = hasHeaderOrFooter ? (h(Fragment, null,
                          resolveWrappedSlot(slots.header, (children) => {
                              return children ? (h("div", { class: [
                                      `${mergedClsPrefix}-popover__header`,
                                      props.headerClass
                                  ], style: props.headerStyle }, children)) : null;
                          }),
                          resolveWrappedSlot(slots.default, (children) => {
                              return children ? (h("div", { class: [
                                      `${mergedClsPrefix}-popover__content`,
                                      props.contentClass
                                  ], style: props.contentStyle }, slots)) : null;
                          }),
                          resolveWrappedSlot(slots.footer, (children) => {
                              return children ? (h("div", { class: [
                                      `${mergedClsPrefix}-popover__footer`,
                                      props.footerClass
                                  ], style: props.footerStyle }, children)) : null;
                          }))) : props.scrollable ? ((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots)) : (h("div", { class: [
                              `${mergedClsPrefix}-popover__content`,
                              props.contentClass
                          ], style: props.contentStyle }, slots));
                      const maybeScrollableBody = props.scrollable ? (h(XScrollbar, { contentClass: hasHeaderOrFooter
                              ? undefined
                              : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ''}`, contentStyle: hasHeaderOrFooter ? undefined : props.contentStyle }, {
                          default: () => body
                      })) : (body);
                      const arrow = props.showArrow
                          ? renderArrow({
                              arrowClass: props.arrowClass,
                              arrowStyle: props.arrowStyle,
                              arrowWrapperClass: props.arrowWrapperClass,
                              arrowWrapperStyle: props.arrowWrapperStyle,
                              clsPrefix: mergedClsPrefix
                          })
                          : null;
                      return [maybeScrollableBody, arrow];
                  };
                  contentNode = h('div', mergeProps({
                      class: [
                          `${mergedClsPrefix}-popover`,
                          `${mergedClsPrefix}-popover-shared`,
                          themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                          extraClass.map((v) => `${mergedClsPrefix}-${v}`),
                          {
                              [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
                              [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
                              [`${mergedClsPrefix}-popover--raw`]: props.raw,
                              [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
                              [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
                              [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
                          }
                      ],
                      ref: bodyRef,
                      style: styleRef.value,
                      onKeydown: NPopover.handleKeydown,
                      onMouseenter: handleMouseEnter,
                      onMouseleave: handleMouseLeave
                  }, attrs), internalTrapFocus ? (h(FocusTrap, { active: props.show, autoFocus: true }, { default: renderContentInnerNode })) : (renderContentInnerNode()));
              }
              else {
                  contentNode = renderBody(
                  // The popover class and overlap class must exists, they will be used
                  // to place the body & transition animation.
                  // Shadow class exists for reuse box-shadow.
                  [
                      `${mergedClsPrefix}-popover-shared`,
                      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value,
                      props.overlap && `${mergedClsPrefix}-popover-shared--overlap`,
                      props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`,
                      props.arrowPointToCenter &&
                          `${mergedClsPrefix}-popover-shared--center-arrow`
                  ], bodyRef, styleRef.value, handleMouseEnter, handleMouseLeave);
              }
              return withDirectives(contentNode, directivesRef.value);
          }
          return {
              displayed: displayedRef,
              namespace: namespaceRef,
              isMounted: NPopover.isMountedRef,
              zIndex: NPopover.zIndexRef,
              followerRef,
              adjustedTo: useAdjustedTo(props),
              followerEnabled: followerEnabledRef,
              renderContentNode
          };
      },
      render() {
          return (h(VFollower, { ref: "followerRef", zIndex: this.zIndex, show: this.show, enabled: this.followerEnabled, to: this.adjustedTo, x: this.x, y: this.y, flip: this.flip, placement: this.placement, containerClass: this.namespace, overlap: this.overlap, width: this.width === 'trigger' ? 'target' : undefined, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
              default: () => {
                  return this.animated ? (h(Transition, { name: "popover-transition", appear: this.isMounted, 
                      // Don't use watch to enable follower, since the transition may
                      // make position sync timing very subtle and buggy.
                      onEnter: () => {
                          this.followerEnabled = true;
                      }, onAfterLeave: () => {
                          var _a;
                          (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
                          this.followerEnabled = false;
                          this.displayed = false;
                      } }, {
                      default: this.renderContentNode
                  })) : (this.renderContentNode());
              }
          }));
      }
  });

  const bodyPropKeys = Object.keys(popoverBodyProps);
  const triggerEventMap = {
      focus: ['onFocus', 'onBlur'],
      click: ['onClick'],
      hover: ['onMouseenter', 'onMouseleave'],
      manual: [],
      nested: ['onFocus', 'onBlur', 'onMouseenter', 'onMouseleave', 'onClick']
  };
  function appendEvents(vNode, trigger, events) {
      triggerEventMap[trigger].forEach((eventName) => {
          if (!vNode.props)
              vNode.props = {};
          else {
              vNode.props = Object.assign({}, vNode.props);
          }
          const originalHandler = vNode.props[eventName];
          const handler = events[eventName];
          if (!originalHandler)
              vNode.props[eventName] = handler;
          else {
              vNode.props[eventName] = (...args) => {
                  originalHandler(...args);
                  handler(...args);
              };
          }
      });
  }
  const popoverBaseProps = {
      show: {
          type: Boolean,
          default: undefined
      },
      defaultShow: Boolean,
      showArrow: {
          type: Boolean,
          default: true
      },
      trigger: {
          type: String,
          default: 'hover'
      },
      delay: {
          type: Number,
          default: 100
      },
      duration: {
          type: Number,
          default: 100
      },
      raw: Boolean,
      placement: {
          type: String,
          default: 'top'
      },
      x: Number,
      y: Number,
      arrowPointToCenter: Boolean,
      disabled: Boolean,
      getDisabled: Function,
      displayDirective: {
          type: String,
          default: 'if'
      },
      arrowClass: String,
      arrowStyle: [String, Object],
      arrowWrapperClass: String,
      arrowWrapperStyle: [String, Object],
      flip: {
          type: Boolean,
          default: true
      },
      animated: {
          type: Boolean,
          default: true
      },
      width: {
          type: [Number, String],
          default: undefined
      },
      overlap: Boolean,
      keepAliveOnHover: {
          type: Boolean,
          default: true
      },
      zIndex: Number,
      to: useAdjustedTo.propTo,
      scrollable: Boolean,
      contentClass: String,
      contentStyle: [Object, String],
      headerClass: String,
      headerStyle: [Object, String],
      footerClass: String,
      footerStyle: [Object, String],
      // events
      onClickoutside: Function,
      'onUpdate:show': [Function, Array],
      onUpdateShow: [Function, Array],
      // internal
      internalDeactivateImmediately: Boolean,
      internalSyncTargetWithParent: Boolean,
      internalInheritedEventHandlers: {
          type: Array,
          default: () => []
      },
      internalTrapFocus: Boolean,
      internalExtraClass: {
          type: Array,
          default: () => []
      },
      // deprecated
      onShow: [Function, Array],
      onHide: [Function, Array],
      arrow: {
          type: Boolean,
          default: undefined
      },
      minWidth: Number,
      maxWidth: Number
  };
  const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { internalOnAfterLeave: Function, internalRenderBody: Function });
  var NPopover = defineComponent({
      name: 'Popover',
      inheritAttrs: false,
      props: popoverProps,
      __popover__: true,
      setup(props) {
          const isMountedRef = isMounted();
          const binderInstRef = ref(null);
          // setup show
          const controlledShowRef = computed(() => props.show);
          const uncontrolledShowRef = ref(props.defaultShow);
          const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const mergedShowConsideringDisabledPropRef = useMemo(() => {
              if (props.disabled)
                  return false;
              return mergedShowWithoutDisabledRef.value;
          });
          const getMergedDisabled = () => {
              if (props.disabled)
                  return true;
              const { getDisabled } = props;
              if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled())
                  return true;
              return false;
          };
          const getMergedShow = () => {
              if (getMergedDisabled())
                  return false;
              return mergedShowWithoutDisabledRef.value;
          };
          // setup show-arrow
          const compatibleShowArrowRef = useCompitable(props, ['arrow', 'showArrow']);
          const mergedShowArrowRef = computed(() => {
              if (props.overlap)
                  return false;
              return compatibleShowArrowRef.value;
          });
          // bodyInstance
          let bodyInstance = null;
          const showTimerIdRef = ref(null);
          const hideTimerIdRef = ref(null);
          const positionManuallyRef = useMemo(() => {
              return props.x !== undefined && props.y !== undefined;
          });
          // methods
          function doUpdateShow(value) {
              const { 'onUpdate:show': _onUpdateShow, onUpdateShow, onShow, onHide } = props;
              uncontrolledShowRef.value = value;
              if (_onUpdateShow) {
                  call(_onUpdateShow, value);
              }
              if (onUpdateShow) {
                  call(onUpdateShow, value);
              }
              if (value && onShow) {
                  call(onShow, true);
              }
              if (value && onHide) {
                  call(onHide, false);
              }
          }
          function syncPosition() {
              if (bodyInstance) {
                  bodyInstance.syncPosition();
              }
          }
          function clearShowTimer() {
              const { value: showTimerId } = showTimerIdRef;
              if (showTimerId) {
                  window.clearTimeout(showTimerId);
                  showTimerIdRef.value = null;
              }
          }
          function clearHideTimer() {
              const { value: hideTimerId } = hideTimerIdRef;
              if (hideTimerId) {
                  window.clearTimeout(hideTimerId);
                  hideTimerIdRef.value = null;
              }
          }
          function handleFocus() {
              const mergedDisabled = getMergedDisabled();
              if (props.trigger === 'focus' && !mergedDisabled) {
                  if (getMergedShow())
                      return;
                  doUpdateShow(true);
              }
          }
          function handleBlur() {
              const mergedDisabled = getMergedDisabled();
              if (props.trigger === 'focus' && !mergedDisabled) {
                  if (!getMergedShow())
                      return;
                  doUpdateShow(false);
              }
          }
          function handleMouseEnter() {
              const mergedDisabled = getMergedDisabled();
              if (props.trigger === 'hover' && !mergedDisabled) {
                  clearHideTimer();
                  if (showTimerIdRef.value !== null)
                      return;
                  if (getMergedShow())
                      return;
                  const delayCallback = () => {
                      doUpdateShow(true);
                      showTimerIdRef.value = null;
                  };
                  const { delay } = props;
                  if (delay === 0) {
                      delayCallback();
                  }
                  else {
                      showTimerIdRef.value = window.setTimeout(delayCallback, delay);
                  }
              }
          }
          function handleMouseLeave() {
              const mergedDisabled = getMergedDisabled();
              if (props.trigger === 'hover' && !mergedDisabled) {
                  clearShowTimer();
                  if (hideTimerIdRef.value !== null)
                      return;
                  if (!getMergedShow())
                      return;
                  const delayedCallback = () => {
                      doUpdateShow(false);
                      hideTimerIdRef.value = null;
                  };
                  const { duration } = props;
                  if (duration === 0) {
                      delayedCallback();
                  }
                  else {
                      hideTimerIdRef.value = window.setTimeout(delayedCallback, duration);
                  }
              }
          }
          // will be called in popover-content
          function handleMouseMoveOutside() {
              handleMouseLeave();
          }
          // will be called in popover-content
          function handleClickOutside(e) {
              var _a;
              if (!getMergedShow())
                  return;
              if (props.trigger === 'click') {
                  clearShowTimer();
                  clearHideTimer();
                  doUpdateShow(false);
              }
              (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleClick() {
              if (props.trigger === 'click' && !getMergedDisabled()) {
                  clearShowTimer();
                  clearHideTimer();
                  const nextShow = !getMergedShow();
                  doUpdateShow(nextShow);
              }
          }
          function handleKeydown(e) {
              if (!props.internalTrapFocus)
                  return;
              if (e.key === 'Escape') {
                  clearShowTimer();
                  clearHideTimer();
                  doUpdateShow(false);
              }
          }
          function setShow(value) {
              uncontrolledShowRef.value = value;
          }
          function getTriggerElement() {
              var _a;
              // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
              return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
          }
          function setBodyInstance(value) {
              bodyInstance = value;
          }
          provide('NPopover', {
              getTriggerElement,
              handleKeydown,
              handleMouseEnter,
              handleMouseLeave,
              handleClickOutside,
              handleMouseMoveOutside,
              setBodyInstance,
              positionManuallyRef,
              isMountedRef,
              zIndexRef: toRef(props, 'zIndex'),
              extraClassRef: toRef(props, 'internalExtraClass'),
              internalRenderBodyRef: toRef(props, 'internalRenderBody')
          });
          watchEffect(() => {
              if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
                  doUpdateShow(false);
              }
          });
          const returned = {
              binderInstRef,
              positionManually: positionManuallyRef,
              mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
              // if to show popover body
              uncontrolledShow: uncontrolledShowRef,
              mergedShowArrow: mergedShowArrowRef,
              getMergedShow,
              setShow,
              handleClick,
              handleMouseEnter,
              handleMouseLeave,
              handleFocus,
              handleBlur,
              syncPosition
          };
          return returned;
      },
      render() {
          var _a;
          const { positionManually, $slots: slots } = this;
          let triggerVNode;
          let popoverInside = false;
          if (!positionManually) {
              if (slots.activator) {
                  triggerVNode = getFirstSlotVNode(slots, 'activator');
              }
              else {
                  triggerVNode = getFirstSlotVNode(slots, 'trigger');
              }
              if (triggerVNode) {
                  triggerVNode = cloneVNode(triggerVNode);
                  triggerVNode =
                      triggerVNode.type === Text ? h('span', [triggerVNode]) : triggerVNode;
                  const handlers = {
                      onClick: this.handleClick,
                      onMouseenter: this.handleMouseEnter,
                      onMouseleave: this.handleMouseLeave,
                      onFocus: this.handleFocus,
                      onBlur: this.handleBlur
                  };
                  if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
                      popoverInside = true;
                      // We assume that there's no DOM event handlers on popover element
                      if (!triggerVNode.props) {
                          triggerVNode.props = {
                              internalSyncTargetWithParent: true,
                              internalInheritedEventHandlers: []
                          };
                      }
                      triggerVNode.props.internalSyncTargetWithParent = true;
                      if (!triggerVNode.props.internalInheritedEventHandlers) {
                          triggerVNode.props.internalInheritedEventHandlers = [handlers];
                      }
                      else {
                          triggerVNode.props.internalInheritedEventHandlers = [
                              handlers,
                              ...triggerVNode.props.internalInheritedEventHandlers
                          ];
                      }
                  }
                  else {
                      const { internalInheritedEventHandlers } = this;
                      const ascendantAndCurrentHandlers = [
                          handlers,
                          ...internalInheritedEventHandlers
                      ];
                      const mergedHandlers = {
                          onBlur: (e) => {
                              ascendantAndCurrentHandlers.forEach((_handlers) => {
                                  _handlers.onBlur(e);
                              });
                          },
                          onFocus: (e) => {
                              ascendantAndCurrentHandlers.forEach((_handlers) => {
                                  _handlers.onFocus(e);
                              });
                          },
                          onClick: (e) => {
                              ascendantAndCurrentHandlers.forEach((_handlers) => {
                                  _handlers.onClick(e);
                              });
                          },
                          onMouseenter: (e) => {
                              ascendantAndCurrentHandlers.forEach((_handlers) => {
                                  _handlers.onMouseenter(e);
                              });
                          },
                          onMouseleave: (e) => {
                              ascendantAndCurrentHandlers.forEach((_handlers) => {
                                  _handlers.onMouseleave(e);
                              });
                          }
                      };
                      appendEvents(triggerVNode, internalInheritedEventHandlers
                          ? 'nested'
                          : positionManually
                              ? 'manual'
                              : this.trigger, mergedHandlers);
                  }
              }
          }
          return (h(VBinder, { ref: "binderInstRef", syncTarget: !popoverInside, syncTargetWithParent: this.internalSyncTargetWithParent }, {
              default: () => {
                  // We need to subscribe it. Sometimes rerender won't ge triggered.
                  // `mergedShowConsideringDisabledProp` is not the final disabled status.
                  // In ellpisis it's dynamic.
                  void this.mergedShowConsideringDisabledProp;
                  const mergedShow = this.getMergedShow();
                  return [
                      this.internalTrapFocus && mergedShow
                          ? withDirectives(h("div", { style: { position: 'fixed', inset: 0 } }), [
                              [
                                  zindexable$1,
                                  {
                                      enabled: mergedShow,
                                      zIndex: this.zIndex
                                  }
                              ]
                          ])
                          : null,
                      positionManually
                          ? null
                          : h(VTarget, null, {
                              default: () => triggerVNode
                          }),
                      h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), { showArrow: this.mergedShowArrow, show: mergedShow })), {
                          default: () => { var _a, _b; return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a); },
                          header: () => { var _a, _b; return (_b = (_a = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a); },
                          footer: () => { var _a, _b; return (_b = (_a = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a); }
                      })
                  ];
              }
          }));
      }
  });

  var commonVariables$j = {
      closeIconSizeTiny: '12px',
      closeIconSizeSmall: '12px',
      closeIconSizeMedium: '14px',
      closeIconSizeLarge: '14px',
      closeSizeTiny: '16px',
      closeSizeSmall: '16px',
      closeSizeMedium: '18px',
      closeSizeLarge: '18px',
      padding: '0 7px',
      closeMargin: '0 0 0 4px',
      closeMarginRtl: '0 4px 0 0'
  };

  const self$1a = (vars) => {
      const { textColor2, primaryColorHover, primaryColorPressed, primaryColor, infoColor, successColor, warningColor, errorColor, baseColor, borderColor, opacityDisabled, tagColor, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadiusSmall: borderRadius, fontSizeMini, fontSizeTiny, fontSizeSmall, fontSizeMedium, heightMini, heightTiny, heightSmall, heightMedium, closeColorHover, closeColorPressed, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$j), { closeBorderRadius: borderRadius, heightTiny: heightMini, heightSmall: heightTiny, heightMedium: heightSmall, heightLarge: heightMedium, borderRadius,
          opacityDisabled, fontSizeTiny: fontSizeMini, fontSizeSmall: fontSizeTiny, fontSizeMedium: fontSizeSmall, fontSizeLarge: fontSizeMedium, fontWeightStrong, 
          // checked
          textColorCheckable: textColor2, textColorHoverCheckable: textColor2, textColorPressedCheckable: textColor2, textColorChecked: baseColor, colorCheckable: '#0000', colorHoverCheckable: buttonColor2Hover, colorPressedCheckable: buttonColor2Pressed, colorChecked: primaryColor, colorCheckedHover: primaryColorHover, colorCheckedPressed: primaryColorPressed, 
          // default
          border: `1px solid ${borderColor}`, textColor: textColor2, color: tagColor, colorBordered: 'rgb(250, 250, 252)', closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed, borderPrimary: `1px solid ${changeColor(primaryColor, { alpha: 0.3 })}`, textColorPrimary: primaryColor, colorPrimary: changeColor(primaryColor, { alpha: 0.12 }), colorBorderedPrimary: changeColor(primaryColor, { alpha: 0.1 }), closeIconColorPrimary: primaryColor, closeIconColorHoverPrimary: primaryColor, closeIconColorPressedPrimary: primaryColor, closeColorHoverPrimary: changeColor(primaryColor, { alpha: 0.12 }), closeColorPressedPrimary: changeColor(primaryColor, { alpha: 0.18 }), borderInfo: `1px solid ${changeColor(infoColor, { alpha: 0.3 })}`, textColorInfo: infoColor, colorInfo: changeColor(infoColor, { alpha: 0.12 }), colorBorderedInfo: changeColor(infoColor, { alpha: 0.1 }), closeIconColorInfo: infoColor, closeIconColorHoverInfo: infoColor, closeIconColorPressedInfo: infoColor, closeColorHoverInfo: changeColor(infoColor, { alpha: 0.12 }), closeColorPressedInfo: changeColor(infoColor, { alpha: 0.18 }), borderSuccess: `1px solid ${changeColor(successColor, { alpha: 0.3 })}`, textColorSuccess: successColor, colorSuccess: changeColor(successColor, { alpha: 0.12 }), colorBorderedSuccess: changeColor(successColor, { alpha: 0.1 }), closeIconColorSuccess: successColor, closeIconColorHoverSuccess: successColor, closeIconColorPressedSuccess: successColor, closeColorHoverSuccess: changeColor(successColor, { alpha: 0.12 }), closeColorPressedSuccess: changeColor(successColor, { alpha: 0.18 }), borderWarning: `1px solid ${changeColor(warningColor, { alpha: 0.35 })}`, textColorWarning: warningColor, colorWarning: changeColor(warningColor, { alpha: 0.15 }), colorBorderedWarning: changeColor(warningColor, { alpha: 0.12 }), closeIconColorWarning: warningColor, closeIconColorHoverWarning: warningColor, closeIconColorPressedWarning: warningColor, closeColorHoverWarning: changeColor(warningColor, { alpha: 0.12 }), closeColorPressedWarning: changeColor(warningColor, { alpha: 0.18 }), borderError: `1px solid ${changeColor(errorColor, { alpha: 0.23 })}`, textColorError: errorColor, colorError: changeColor(errorColor, { alpha: 0.1 }), colorBorderedError: changeColor(errorColor, { alpha: 0.08 }), closeIconColorError: errorColor, closeIconColorHoverError: errorColor, closeIconColorPressedError: errorColor, closeColorHoverError: changeColor(errorColor, { alpha: 0.12 }), closeColorPressedError: changeColor(errorColor, { alpha: 0.18 }) });
  };
  const tagLight = {
      name: 'Tag',
      common: commonLight,
      self: self$1a
  };
  var tagLight$1 = tagLight;

  var commonProps = {
      color: Object,
      type: {
          type: String,
          default: 'default'
      },
      round: Boolean,
      size: {
          type: String,
          default: 'medium'
      },
      closable: Boolean,
      disabled: {
          type: Boolean,
          default: undefined
      }
  };

  // vars:
  // --n-bezier
  // --n-border-radius
  // --n-border
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-close-margin
  // --n-close-size
  // --n-color
  // --n-color-checkable
  // --n-color-checked
  // --n-color-checked-hover
  // --n-color-checked-pressed
  // --n-color-hover-checkable
  // --n-color-pressed-checkable
  // --n-font-size
  // --n-height
  // --n-opacity-disabled
  // --n-padding
  // --n-text-color
  // --n-text-color-checkable
  // --n-text-color-checked
  // --n-text-color-hover-checkable
  // --n-text-color-pressed-checkable
  // --n-font-weight-strong
  var style$1r = cB('tag', `
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM('strong', `
 font-weight: var(--n-font-weight-strong);
 `), cE('border', `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE('icon', `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE('avatar', `
 display: flex;
 margin: 0 6px 0 0;
 `), cE('close', `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM('round', `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE('icon', `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE('avatar', `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM('closable', `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM('icon, avatar', [cM('round', `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM('disabled', `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM('checkable', `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM('disabled', [c$1('&:hover', 'background-color: var(--n-color-hover-checkable);', [cNotM('checked', 'color: var(--n-text-color-hover-checkable);')]), c$1('&:active', 'background-color: var(--n-color-pressed-checkable);', [cNotM('checked', 'color: var(--n-text-color-pressed-checkable);')])]), cM('checked', `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM('disabled', [c$1('&:hover', 'background-color: var(--n-color-checked-hover);'), c$1('&:active', 'background-color: var(--n-color-checked-pressed);')])])])]);

  const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), { bordered: {
          type: Boolean,
          default: undefined
      }, checked: Boolean, checkable: Boolean, strong: Boolean, triggerClickOnClose: Boolean, onClose: [Array, Function], onMouseenter: Function, onMouseleave: Function, 'onUpdate:checked': Function, onUpdateChecked: Function, 
      // private
      internalCloseFocusable: {
          type: Boolean,
          default: true
      }, internalCloseIsButtonTag: {
          type: Boolean,
          default: true
      }, 
      // deprecated
      onCheckedChange: Function });
  const tagInjectionKey = createInjectionKey('n-tag');
  var NTag = defineComponent({
      name: 'Tag',
      props: tagProps,
      setup(props) {
          const contentRef = ref(null);
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Tag', '-tag', style$1r, tagLight$1, props, mergedClsPrefixRef);
          provide(tagInjectionKey, {
              roundRef: toRef(props, 'round')
          });
          function handleClick(e) {
              if (!props.disabled) {
                  if (props.checkable) {
                      const { checked, onCheckedChange, onUpdateChecked, 'onUpdate:checked': _onUpdateChecked } = props;
                      if (onUpdateChecked)
                          onUpdateChecked(!checked);
                      if (_onUpdateChecked)
                          _onUpdateChecked(!checked);
                      // deprecated
                      if (onCheckedChange)
                          onCheckedChange(!checked);
                  }
              }
          }
          function handleCloseClick(e) {
              if (!props.triggerClickOnClose) {
                  e.stopPropagation();
              }
              if (!props.disabled) {
                  const { onClose } = props;
                  if (onClose)
                      call(onClose, e);
              }
          }
          const tagPublicMethods = {
              setTextContent(textContent) {
                  const { value } = contentRef;
                  if (value)
                      value.textContent = textContent;
              }
          };
          const rtlEnabledRef = useRtl('Tag', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type, size, color: { color, textColor } = {} } = props;
              const { common: { cubicBezierEaseInOut }, self: { padding, closeMargin, closeMarginRtl, borderRadius, opacityDisabled, textColorCheckable, textColorHoverCheckable, textColorPressedCheckable, textColorChecked, colorCheckable, colorHoverCheckable, colorPressedCheckable, colorChecked, colorCheckedHover, colorCheckedPressed, closeBorderRadius, fontWeightStrong, [createKey('colorBordered', type)]: colorBordered, [createKey('closeSize', size)]: closeSize, [createKey('closeIconSize', size)]: closeIconSize, [createKey('fontSize', size)]: fontSize, [createKey('height', size)]: height, [createKey('color', type)]: typedColor, [createKey('textColor', type)]: typeTextColor, [createKey('border', type)]: border, [createKey('closeIconColor', type)]: closeIconColor, [createKey('closeIconColorHover', type)]: closeIconColorHover, [createKey('closeIconColorPressed', type)]: closeIconColorPressed, [createKey('closeColorHover', type)]: closeColorHover, [createKey('closeColorPressed', type)]: closeColorPressed } } = themeRef.value;
              return {
                  '--n-font-weight-strong': fontWeightStrong,
                  '--n-avatar-size-override': `calc(${height} - 8px)`,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-border': border,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-close-icon-color-disabled': closeIconColor,
                  '--n-close-margin': closeMargin,
                  '--n-close-margin-rtl': closeMarginRtl,
                  '--n-close-size': closeSize,
                  '--n-color': color || (mergedBorderedRef.value ? colorBordered : typedColor),
                  '--n-color-checkable': colorCheckable,
                  '--n-color-checked': colorChecked,
                  '--n-color-checked-hover': colorCheckedHover,
                  '--n-color-checked-pressed': colorCheckedPressed,
                  '--n-color-hover-checkable': colorHoverCheckable,
                  '--n-color-pressed-checkable': colorPressedCheckable,
                  '--n-font-size': fontSize,
                  '--n-height': height,
                  '--n-opacity-disabled': opacityDisabled,
                  '--n-padding': padding,
                  '--n-text-color': textColor || typeTextColor,
                  '--n-text-color-checkable': textColorCheckable,
                  '--n-text-color-checked': textColorChecked,
                  '--n-text-color-hover-checkable': textColorHoverCheckable,
                  '--n-text-color-pressed-checkable': textColorPressedCheckable
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('tag', computed(() => {
                  let hash = '';
                  const { type, size, color: { color, textColor } = {} } = props;
                  hash += type[0];
                  hash += size[0];
                  if (color) {
                      hash += `a${color2Class(color)}`;
                  }
                  if (textColor) {
                      hash += `b${color2Class(textColor)}`;
                  }
                  if (mergedBorderedRef.value) {
                      hash += 'c';
                  }
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, tagPublicMethods), { rtlEnabled: rtlEnabledRef, mergedClsPrefix: mergedClsPrefixRef, contentRef, mergedBordered: mergedBorderedRef, handleClick,
              handleCloseClick, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a, _b;
          const { mergedClsPrefix, rtlEnabled, closable, color: { borderColor } = {}, round, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const avatarNode = resolveWrappedSlot($slots.avatar, (children) => children && (h("div", { class: `${mergedClsPrefix}-tag__avatar` }, children)));
          const iconNode = resolveWrappedSlot($slots.icon, (children) => children && h("div", { class: `${mergedClsPrefix}-tag__icon` }, children));
          return (h("div", { class: [
                  `${mergedClsPrefix}-tag`,
                  this.themeClass,
                  {
                      [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
                      [`${mergedClsPrefix}-tag--strong`]: this.strong,
                      [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
                      [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
                      [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
                      [`${mergedClsPrefix}-tag--round`]: round,
                      [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
                      [`${mergedClsPrefix}-tag--icon`]: iconNode,
                      [`${mergedClsPrefix}-tag--closable`]: closable
                  }
              ], style: this.cssVars, onClick: this.handleClick, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave },
              iconNode || avatarNode,
              h("span", { class: `${mergedClsPrefix}-tag__content`, ref: "contentRef" }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)),
              !this.checkable && closable ? (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-tag__close`, disabled: this.disabled, onClick: this.handleCloseClick, focusable: this.internalCloseFocusable, round: round, isButtonTag: this.internalCloseIsButtonTag, absolute: true })) : null,
              !this.checkable && this.mergedBordered ? (h("div", { class: `${mergedClsPrefix}-tag__border`, style: { borderColor } })) : null));
      }
  });

  // vars:
  // --n-bezier
  // --n-clear-color
  // --n-clear-size
  // --n-clear-color-hover
  // --n-clear-color-pressed
  var style$1q = cB('base-clear', `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1('>', [cE('clear', `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1('&:hover', `
 color: var(--n-clear-color-hover)!important;
 `), c$1('&:active', `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE('placeholder', `
 display: flex;
 `), cE('clear, placeholder', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
    originalTransform: 'translateX(-50%) translateY(-50%)',
    left: '50%',
    top: '50%'
  })])])]);

  var NBaseClear = defineComponent({
      name: 'BaseClear',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          show: Boolean,
          onClear: Function
      },
      setup(props) {
          useStyle('-base-clear', style$1q, toRef(props, 'clsPrefix'));
          return {
              handleMouseDown(e) {
                  var _a;
                  e.preventDefault();
                  (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props, e);
              }
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-base-clear` },
              h(NIconSwitchTransition, null, {
                  default: () => {
                      var _a, _b;
                      return this.show ? (h("div", { key: "dismiss", class: `${clsPrefix}-base-clear__clear`, onClick: this.onClear, onMousedown: this.handleMouseDown, "data-clear": true }, resolveSlot(this.$slots.icon, () => [
                          h(NBaseIcon, { clsPrefix: clsPrefix }, {
                              default: () => h(ClearIcon, null)
                          })
                      ]))) : (h("div", { key: "icon", class: `${clsPrefix}-base-clear__placeholder` }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a)));
                  }
              })));
      }
  });

  var NBaseSuffix = defineComponent({
      name: 'InternalSelectionSuffix',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          showArrow: {
              type: Boolean,
              default: undefined
          },
          showClear: {
              type: Boolean,
              default: undefined
          },
          loading: {
              type: Boolean,
              default: false
          },
          onClear: Function
      },
      setup(props, { slots }) {
          return () => {
              const { clsPrefix } = props;
              return (h(NBaseLoading, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-suffix`, strokeWidth: 24, scale: 0.85, show: props.loading }, {
                  default: () => props.showArrow ? (h(NBaseClear, { clsPrefix: clsPrefix, show: props.showClear, onClear: props.onClear }, {
                      placeholder: () => (h(NBaseIcon, { clsPrefix: clsPrefix, class: `${clsPrefix}-base-suffix__arrow` }, {
                          default: () => resolveSlot(slots.default, () => [
                              h(ChevronDownIcon, null)
                          ])
                      }))
                  })) : null
              }));
          };
      }
  });

  var commonVars$b = {
      paddingSingle: '0 26px 0 12px',
      paddingMultiple: '3px 26px 0 12px',
      clearSize: '16px',
      arrowSize: '16px'
  };

  const self$19 = (vars) => {
      const { borderRadius, textColor2, textColorDisabled, inputColor, inputColorDisabled, primaryColor, primaryColorHover, warningColor, warningColorHover, errorColor, errorColorHover, borderColor, iconColor, iconColorDisabled, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge } = vars;
      return Object.assign(Object.assign({}, commonVars$b), { fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius, 
          // default
          textColor: textColor2, textColorDisabled,
          placeholderColor,
          placeholderColorDisabled, color: inputColor, colorDisabled: inputColorDisabled, colorActive: inputColor, border: `1px solid ${borderColor}`, borderHover: `1px solid ${primaryColorHover}`, borderActive: `1px solid ${primaryColor}`, borderFocus: `1px solid ${primaryColorHover}`, boxShadowHover: 'none', boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.2
        })}`, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
            alpha: 0.2
        })}`, caretColor: primaryColor, arrowColor: iconColor, arrowColorDisabled: iconColorDisabled, loadingColor: primaryColor, 
          // warning
          borderWarning: `1px solid ${warningColor}`, borderHoverWarning: `1px solid ${warningColorHover}`, borderActiveWarning: `1px solid ${warningColor}`, borderFocusWarning: `1px solid ${warningColorHover}`, boxShadowHoverWarning: 'none', boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
            alpha: 0.2
        })}`, boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
            alpha: 0.2
        })}`, colorActiveWarning: inputColor, caretColorWarning: warningColor, 
          // error
          borderError: `1px solid ${errorColor}`, borderHoverError: `1px solid ${errorColorHover}`, borderActiveError: `1px solid ${errorColor}`, borderFocusError: `1px solid ${errorColorHover}`, boxShadowHoverError: 'none', boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
            alpha: 0.2
        })}`, boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
            alpha: 0.2
        })}`, colorActiveError: inputColor, caretColorError: errorColor, clearColor,
          clearColorHover,
          clearColorPressed });
  };
  const internalSelectionLight = createTheme({
      name: 'InternalSelection',
      common: commonLight,
      peers: {
          Popover: popoverLight$1
      },
      self: self$19
  });
  var internalSelectionLight$1 = internalSelectionLight;

  // vars:
  // --n-bezier
  // --n-border
  // --n-border-active
  // --n-border-focus
  // --n-border-hover
  // --n-border-radius
  // --n-box-shadow-active
  // --n-box-shadow-focus
  // --n-box-shadow-hover
  // --n-caret-color
  // --n-color
  // --n-color-active
  // --n-color-disabled
  // --n-font-size
  // --n-height
  // --n-padding-single
  // --n-padding-multiple
  // --n-placeholder-color
  // --n-placeholder-color-disabled
  // --n-text-color
  // --n-text-color-disabled
  // --n-arrow-color
  // --n-arrow-size
  // --n-loading-color
  // ...clear vars
  // ...form item vars
  var style$1p = c$1([cB('base-selection', `
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cB('base-loading', `
 color: var(--n-loading-color);
 `), cB('base-selection-tags', 'min-height: var(--n-height);'), cE('border, state-border', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE('state-border', `
 z-index: 1;
 border-color: #0000;
 `), cB('base-suffix', `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [cE('arrow', `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), cB('base-selection-overlay', `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [cE('wrapper', `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cB('base-selection-placeholder', `
 color: var(--n-placeholder-color);
 `, [cE('inner', `
 max-width: 100%;
 overflow: hidden;
 `)]), cB('base-selection-tags', `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB('base-selection-label', `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [cB('base-selection-input', `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [cE('content', `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), cE('render-label', `
 color: var(--n-text-color);
 `)]), cNotM('disabled', [c$1('&:hover', [cE('state-border', `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), cM('focus', [cE('state-border', `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), cM('active', [cE('state-border', `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), cB('base-selection-label', 'background-color: var(--n-color-active);'), cB('base-selection-tags', 'background-color: var(--n-color-active);')])]), cM('disabled', 'cursor: not-allowed;', [cE('arrow', `
 color: var(--n-arrow-color-disabled);
 `), cB('base-selection-label', `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cB('base-selection-input', `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), cE('render-label', `
 color: var(--n-text-color-disabled);
 `)]), cB('base-selection-tags', `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), cB('base-selection-placeholder', `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), cB('base-selection-input-tag', `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [cE('input', `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), cE('mirror', `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ['warning', 'error'].map(status => cM(`${status}-status`, [cE('state-border', `border: var(--n-border-${status});`), cNotM('disabled', [c$1('&:hover', [cE('state-border', `
 box-shadow: var(--n-box-shadow-hover-${status});
 border: var(--n-border-hover-${status});
 `)]), cM('active', [cE('state-border', `
 box-shadow: var(--n-box-shadow-active-${status});
 border: var(--n-border-active-${status});
 `), cB('base-selection-label', `background-color: var(--n-color-active-${status});`), cB('base-selection-tags', `background-color: var(--n-color-active-${status});`)]), cM('focus', [cE('state-border', `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]), cB('base-selection-popover', `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), cB('base-selection-tag-wrapper', `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [c$1('&:last-child', 'padding-right: 0;'), cB('tag', `
 font-size: 14px;
 max-width: 100%;
 `, [cE('content', `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]);

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  var NInternalSelection = defineComponent({
      name: 'InternalSelection',
      props: Object.assign(Object.assign({}, useTheme.props), { clsPrefix: {
              type: String,
              required: true
          }, bordered: {
              type: Boolean,
              default: undefined
          }, active: Boolean, pattern: {
              type: String,
              default: ''
          }, placeholder: String, selectedOption: {
              type: Object,
              default: null
          }, selectedOptions: {
              type: Array,
              default: null
          }, labelField: { type: String, default: 'label' }, valueField: {
              type: String,
              default: 'value'
          }, multiple: Boolean, filterable: Boolean, clearable: Boolean, disabled: Boolean, size: {
              type: String,
              default: 'medium'
          }, loading: Boolean, autofocus: Boolean, showArrow: {
              type: Boolean,
              default: true
          }, inputProps: Object, focused: Boolean, renderTag: Function, onKeydown: Function, onClick: Function, onBlur: Function, onFocus: Function, onDeleteOption: Function, maxTagCount: [String, Number], onClear: Function, onPatternInput: Function, onPatternFocus: Function, onPatternBlur: Function, renderLabel: Function, status: String, inlineThemeDisabled: Boolean, ignoreComposition: { type: Boolean, default: true }, onResize: Function }),
      setup(props) {
          const patternInputMirrorRef = ref(null);
          const patternInputRef = ref(null);
          const selfRef = ref(null);
          const multipleElRef = ref(null);
          const singleElRef = ref(null);
          const patternInputWrapperRef = ref(null);
          const counterRef = ref(null);
          const counterWrapperRef = ref(null);
          const overflowRef = ref(null);
          const inputTagElRef = ref(null);
          const showTagsPopoverRef = ref(false);
          const patternInputFocusedRef = ref(false);
          const hoverRef = ref(false);
          const themeRef = useTheme('InternalSelection', '-internal-selection', style$1p, internalSelectionLight$1, props, toRef(props, 'clsPrefix'));
          const mergedClearableRef = computed(() => {
              return (props.clearable && !props.disabled && (hoverRef.value || props.active));
          });
          const filterablePlaceholderRef = computed(() => {
              return props.selectedOption
                  ? props.renderTag
                      ? props.renderTag({
                          option: props.selectedOption,
                          handleClose: () => { }
                      })
                      : props.renderLabel
                          ? props.renderLabel(props.selectedOption, true)
                          : render$1(props.selectedOption[props.labelField], props.selectedOption, true)
                  : props.placeholder;
          });
          const labelRef = computed(() => {
              const option = props.selectedOption;
              if (!option)
                  return undefined;
              return option[props.labelField];
          });
          const selectedRef = computed(() => {
              if (props.multiple) {
                  return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
              }
              else {
                  return props.selectedOption !== null;
              }
          });
          function syncMirrorWidth() {
              var _a;
              const { value: patternInputMirrorEl } = patternInputMirrorRef;
              if (patternInputMirrorEl) {
                  const { value: patternInputEl } = patternInputRef;
                  if (patternInputEl) {
                      patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
                      if (props.maxTagCount !== 'responsive') {
                          (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
                              showAllItemsBeforeCalculate: false
                          });
                      }
                  }
              }
          }
          function hideInputTag() {
              const { value: inputTagEl } = inputTagElRef;
              if (inputTagEl)
                  inputTagEl.style.display = 'none';
          }
          function showInputTag() {
              const { value: inputTagEl } = inputTagElRef;
              if (inputTagEl)
                  inputTagEl.style.display = 'inline-block';
          }
          watch(toRef(props, 'active'), (value) => {
              if (!value)
                  hideInputTag();
          });
          watch(toRef(props, 'pattern'), () => {
              if (props.multiple) {
                  void nextTick(syncMirrorWidth);
              }
          });
          function doFocus(e) {
              const { onFocus } = props;
              if (onFocus)
                  onFocus(e);
          }
          function doBlur(e) {
              const { onBlur } = props;
              if (onBlur)
                  onBlur(e);
          }
          function doDeleteOption(value) {
              const { onDeleteOption } = props;
              if (onDeleteOption)
                  onDeleteOption(value);
          }
          function doClear(e) {
              const { onClear } = props;
              if (onClear)
                  onClear(e);
          }
          function doPatternInput(value) {
              const { onPatternInput } = props;
              if (onPatternInput)
                  onPatternInput(value);
          }
          function handleFocusin(e) {
              var _a;
              if (!e.relatedTarget ||
                  !((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
                  doFocus(e);
              }
          }
          function handleFocusout(e) {
              var _a;
              if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
                  return;
              doBlur(e);
          }
          function handleClear(e) {
              doClear(e);
          }
          function handleMouseEnter() {
              hoverRef.value = true;
          }
          function handleMouseLeave() {
              hoverRef.value = false;
          }
          function handleMouseDown(e) {
              if (!props.active || !props.filterable)
                  return;
              if (e.target === patternInputRef.value)
                  return;
              e.preventDefault();
          }
          function handleDeleteOption(option) {
              doDeleteOption(option);
          }
          function handlePatternKeyDown(e) {
              if (e.key === 'Backspace' && !isComposingRef.value) {
                  if (!props.pattern.length) {
                      const { selectedOptions } = props;
                      if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
                          handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
                      }
                  }
              }
          }
          const isComposingRef = ref(false);
          // the composition end is later than its input so we can cached the event
          // and return the input event
          let cachedInputEvent = null;
          function handlePatternInputInput(e) {
              // we should sync mirror width here
              const { value: patternInputMirrorEl } = patternInputMirrorRef;
              if (patternInputMirrorEl) {
                  const inputText = e.target.value;
                  patternInputMirrorEl.textContent = inputText;
                  syncMirrorWidth();
              }
              if (props.ignoreComposition) {
                  if (!isComposingRef.value) {
                      doPatternInput(e);
                  }
                  else {
                      cachedInputEvent = e;
                  }
              }
              else {
                  doPatternInput(e);
              }
          }
          function handleCompositionStart() {
              isComposingRef.value = true;
          }
          function handleCompositionEnd() {
              isComposingRef.value = false;
              if (props.ignoreComposition) {
                  doPatternInput(cachedInputEvent);
              }
              cachedInputEvent = null;
          }
          function handlePatternInputFocus(e) {
              var _a;
              patternInputFocusedRef.value = true;
              (_a = props.onPatternFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handlePatternInputBlur(e) {
              var _a;
              patternInputFocusedRef.value = false;
              (_a = props.onPatternBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function blur() {
              var _a, _b;
              if (props.filterable) {
                  patternInputFocusedRef.value = false;
                  (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.blur();
                  (_b = patternInputRef.value) === null || _b === void 0 ? void 0 : _b.blur();
              }
              else if (props.multiple) {
                  const { value: multipleEl } = multipleElRef;
                  multipleEl === null || multipleEl === void 0 ? void 0 : multipleEl.blur();
              }
              else {
                  const { value: singleEl } = singleElRef;
                  singleEl === null || singleEl === void 0 ? void 0 : singleEl.blur();
              }
          }
          function focus() {
              var _a, _b, _c;
              if (props.filterable) {
                  patternInputFocusedRef.value = false;
                  (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              }
              else if (props.multiple) {
                  (_b = multipleElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
              }
              else {
                  (_c = singleElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
              }
          }
          function focusInput() {
              const { value: patternInputEl } = patternInputRef;
              if (patternInputEl) {
                  showInputTag();
                  patternInputEl.focus();
              }
          }
          function blurInput() {
              const { value: patternInputEl } = patternInputRef;
              if (patternInputEl) {
                  patternInputEl.blur();
              }
          }
          function updateCounter(count) {
              const { value } = counterRef;
              if (value) {
                  value.setTextContent(`+${count}`);
              }
          }
          function getCounter() {
              const { value } = counterWrapperRef;
              return value;
          }
          function getTail() {
              return patternInputRef.value;
          }
          let enterTimerId = null;
          function clearEnterTimer() {
              if (enterTimerId !== null)
                  window.clearTimeout(enterTimerId);
          }
          function handleMouseEnterCounter() {
              if (props.active)
                  return;
              clearEnterTimer();
              enterTimerId = window.setTimeout(() => {
                  if (selectedRef.value) {
                      showTagsPopoverRef.value = true;
                  }
              }, 100);
          }
          function handleMouseLeaveCounter() {
              clearEnterTimer();
          }
          function onPopoverUpdateShow(show) {
              if (!show) {
                  clearEnterTimer();
                  showTagsPopoverRef.value = false;
              }
          }
          watch(selectedRef, (value) => {
              if (!value) {
                  showTagsPopoverRef.value = false;
              }
          });
          onMounted(() => {
              watchEffect(() => {
                  const patternInputWrapperEl = patternInputWrapperRef.value;
                  if (!patternInputWrapperEl)
                      return;
                  if (props.disabled) {
                      patternInputWrapperEl.removeAttribute('tabindex');
                  }
                  else {
                      patternInputWrapperEl.tabIndex = patternInputFocusedRef.value ? -1 : 0;
                  }
              });
          });
          useOnResize(selfRef, props.onResize);
          const { inlineThemeDisabled } = props;
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { common: { cubicBezierEaseInOut }, self: { borderRadius, color, placeholderColor, textColor, paddingSingle, paddingMultiple, caretColor, colorDisabled, textColorDisabled, placeholderColorDisabled, colorActive, boxShadowFocus, boxShadowActive, boxShadowHover, border, borderFocus, borderHover, borderActive, arrowColor, arrowColorDisabled, loadingColor, 
              // form warning
              colorActiveWarning, boxShadowFocusWarning, boxShadowActiveWarning, boxShadowHoverWarning, borderWarning, borderFocusWarning, borderHoverWarning, borderActiveWarning, 
              // form error
              colorActiveError, boxShadowFocusError, boxShadowActiveError, boxShadowHoverError, borderError, borderFocusError, borderHoverError, borderActiveError, 
              // clear
              clearColor, clearColorHover, clearColorPressed, clearSize, 
              // arrow
              arrowSize, [createKey('height', size)]: height, [createKey('fontSize', size)]: fontSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border': border,
                  '--n-border-active': borderActive,
                  '--n-border-focus': borderFocus,
                  '--n-border-hover': borderHover,
                  '--n-border-radius': borderRadius,
                  '--n-box-shadow-active': boxShadowActive,
                  '--n-box-shadow-focus': boxShadowFocus,
                  '--n-box-shadow-hover': boxShadowHover,
                  '--n-caret-color': caretColor,
                  '--n-color': color,
                  '--n-color-active': colorActive,
                  '--n-color-disabled': colorDisabled,
                  '--n-font-size': fontSize,
                  '--n-height': height,
                  '--n-padding-single': paddingSingle,
                  '--n-padding-multiple': paddingMultiple,
                  '--n-placeholder-color': placeholderColor,
                  '--n-placeholder-color-disabled': placeholderColorDisabled,
                  '--n-text-color': textColor,
                  '--n-text-color-disabled': textColorDisabled,
                  '--n-arrow-color': arrowColor,
                  '--n-arrow-color-disabled': arrowColorDisabled,
                  '--n-loading-color': loadingColor,
                  // form warning
                  '--n-color-active-warning': colorActiveWarning,
                  '--n-box-shadow-focus-warning': boxShadowFocusWarning,
                  '--n-box-shadow-active-warning': boxShadowActiveWarning,
                  '--n-box-shadow-hover-warning': boxShadowHoverWarning,
                  '--n-border-warning': borderWarning,
                  '--n-border-focus-warning': borderFocusWarning,
                  '--n-border-hover-warning': borderHoverWarning,
                  '--n-border-active-warning': borderActiveWarning,
                  // form error
                  '--n-color-active-error': colorActiveError,
                  '--n-box-shadow-focus-error': boxShadowFocusError,
                  '--n-box-shadow-active-error': boxShadowActiveError,
                  '--n-box-shadow-hover-error': boxShadowHoverError,
                  '--n-border-error': borderError,
                  '--n-border-focus-error': borderFocusError,
                  '--n-border-hover-error': borderHoverError,
                  '--n-border-active-error': borderActiveError,
                  // clear
                  '--n-clear-size': clearSize,
                  '--n-clear-color': clearColor,
                  '--n-clear-color-hover': clearColorHover,
                  '--n-clear-color-pressed': clearColorPressed,
                  // arrow-size
                  '--n-arrow-size': arrowSize
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('internal-selection', computed(() => {
                  return props.size[0];
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedTheme: themeRef,
              mergedClearable: mergedClearableRef,
              patternInputFocused: patternInputFocusedRef,
              filterablePlaceholder: filterablePlaceholderRef,
              label: labelRef,
              selected: selectedRef,
              showTagsPanel: showTagsPopoverRef,
              isComposing: isComposingRef,
              // dom ref
              counterRef,
              counterWrapperRef,
              patternInputMirrorRef,
              patternInputRef,
              selfRef,
              multipleElRef,
              singleElRef,
              patternInputWrapperRef,
              overflowRef,
              inputTagElRef,
              handleMouseDown,
              handleFocusin,
              handleClear,
              handleMouseEnter,
              handleMouseLeave,
              handleDeleteOption,
              handlePatternKeyDown,
              handlePatternInputInput,
              handlePatternInputBlur,
              handlePatternInputFocus,
              handleMouseEnterCounter,
              handleMouseLeaveCounter,
              handleFocusout,
              handleCompositionEnd,
              handleCompositionStart,
              onPopoverUpdateShow,
              focus,
              focusInput,
              blur,
              blurInput,
              updateCounter,
              getCounter,
              getTail,
              renderLabel: props.renderLabel,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { status, multiple, size, disabled, filterable, maxTagCount, bordered, clsPrefix, onRender, renderTag, renderLabel } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const maxTagCountResponsive = maxTagCount === 'responsive';
          const maxTagCountNumeric = typeof maxTagCount === 'number';
          const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
          const suffix = (h(Wrapper, null, {
              default: () => (h(NBaseSuffix, { clsPrefix: clsPrefix, loading: this.loading, showArrow: this.showArrow, showClear: this.mergedClearable && this.selected, onClear: this.handleClear }, {
                  default: () => { var _a, _b; return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a); }
              }))
          }));
          let body;
          if (multiple) {
              const { labelField } = this;
              const createTag = (option) => (h("div", { class: `${clsPrefix}-base-selection-tag-wrapper`, key: option.value }, renderTag ? (renderTag({
                  option,
                  handleClose: () => {
                      this.handleDeleteOption(option);
                  }
              })) : (h(NTag, { size: size, closable: !option.disabled, disabled: disabled, onClose: () => {
                      this.handleDeleteOption(option);
                  }, internalCloseIsButtonTag: false, internalCloseFocusable: false }, {
                  default: () => renderLabel
                      ? renderLabel(option, true)
                      : render$1(option[labelField], option, true)
              }))));
              const createOriginalTagNodes = () => (maxTagCountNumeric
                  ? this.selectedOptions.slice(0, maxTagCount)
                  : this.selectedOptions).map(createTag);
              const input = filterable ? (h("div", { class: `${clsPrefix}-base-selection-input-tag`, ref: "inputTagElRef", key: "__input-tag__" },
                  h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", tabindex: -1, disabled: disabled, value: this.pattern, autofocus: this.autofocus, class: `${clsPrefix}-base-selection-input-tag__input`, onBlur: this.handlePatternInputBlur, onFocus: this.handlePatternInputFocus, onKeydown: this.handlePatternKeyDown, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
                  h("span", { ref: "patternInputMirrorRef", class: `${clsPrefix}-base-selection-input-tag__mirror` }, this.pattern))) : null;
              // May Overflow
              const renderCounter = maxTagCountResponsive
                  ? () => (h("div", { class: `${clsPrefix}-base-selection-tag-wrapper`, ref: "counterWrapperRef" },
                      h(NTag, { size: size, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, onMouseleave: this.handleMouseLeaveCounter, disabled: disabled })))
                  : undefined;
              let counter;
              if (maxTagCountNumeric) {
                  const rest = this.selectedOptions.length - maxTagCount;
                  if (rest > 0) {
                      counter = (h("div", { class: `${clsPrefix}-base-selection-tag-wrapper`, key: "__counter__" },
                          h(NTag, { size: size, ref: "counterRef", onMouseenter: this.handleMouseEnterCounter, disabled: disabled }, {
                              default: () => `+${rest}`
                          })));
                  }
              }
              const tags = maxTagCountResponsive ? (filterable ? (h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, getTail: this.getTail, style: {
                      width: '100%',
                      display: 'flex',
                      overflow: 'hidden'
                  } }, {
                  default: createOriginalTagNodes,
                  counter: renderCounter,
                  tail: () => input
              })) : (h(VOverflow, { ref: "overflowRef", updateCounter: this.updateCounter, getCounter: this.getCounter, style: {
                      width: '100%',
                      display: 'flex',
                      overflow: 'hidden'
                  } }, {
                  default: createOriginalTagNodes,
                  counter: renderCounter
              }))) : maxTagCountNumeric && counter ? (createOriginalTagNodes().concat(counter)) : (createOriginalTagNodes());
              const renderPopover = useMaxTagCount
                  ? () => (h("div", { class: `${clsPrefix}-base-selection-popover` }, maxTagCountResponsive
                      ? createOriginalTagNodes()
                      : this.selectedOptions.map(createTag)))
                  : undefined;
              const popoverProps = useMaxTagCount
                  ? {
                      show: this.showTagsPanel,
                      trigger: 'hover',
                      overlap: true,
                      placement: 'top',
                      width: 'trigger',
                      onUpdateShow: this.onPopoverUpdateShow,
                      theme: this.mergedTheme.peers.Popover,
                      themeOverrides: this.mergedTheme.peerOverrides.Popover
                  }
                  : null;
              const showPlaceholder = this.selected
                  ? false
                  : this.active
                      ? !this.pattern && !this.isComposing
                      : true;
              const placeholder = showPlaceholder ? (h("div", { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay` },
                  h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder))) : null;
              const popoverTrigger = filterable ? (h("div", { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-tags` },
                  tags,
                  maxTagCountResponsive ? null : input,
                  suffix)) : (h("div", { ref: "multipleElRef", class: `${clsPrefix}-base-selection-tags`, tabindex: disabled ? undefined : 0 },
                  tags,
                  suffix));
              body = (h(Fragment, null,
                  useMaxTagCount ? (h(NPopover, Object.assign({}, popoverProps, { scrollable: true, style: "max-height: calc(var(--v-target-height) * 6.6);" }), {
                      trigger: () => popoverTrigger,
                      default: renderPopover
                  })) : (popoverTrigger),
                  placeholder));
          }
          else {
              if (filterable) {
                  const hasInput = this.pattern || this.isComposing;
                  const showPlaceholder = this.active ? !hasInput : !this.selected;
                  const showSelectedLabel = this.active ? false : this.selected;
                  body = (h("div", { ref: "patternInputWrapperRef", class: `${clsPrefix}-base-selection-label` },
                      h("input", Object.assign({}, this.inputProps, { ref: "patternInputRef", class: `${clsPrefix}-base-selection-input`, value: this.active ? this.pattern : '', placeholder: "", readonly: disabled, disabled: disabled, tabindex: -1, autofocus: this.autofocus, onFocus: this.handlePatternInputFocus, onBlur: this.handlePatternInputBlur, onInput: this.handlePatternInputInput, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd })),
                      showSelectedLabel ? (h("div", { class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`, key: "input" },
                          h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, renderTag
                              ? renderTag({
                                  option: this.selectedOption,
                                  handleClose: () => { }
                              })
                              : renderLabel
                                  ? renderLabel(this.selectedOption, true)
                                  : render$1(this.label, this.selectedOption, true)))) : null,
                      showPlaceholder ? (h("div", { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                          h("div", { class: `${clsPrefix}-base-selection-overlay__wrapper` }, this.filterablePlaceholder))) : null,
                      suffix));
              }
              else {
                  body = (h("div", { ref: "singleElRef", class: `${clsPrefix}-base-selection-label`, tabindex: this.disabled ? undefined : 0 },
                      this.label !== undefined ? (h("div", { class: `${clsPrefix}-base-selection-input`, title: getTitleAttribute(this.label), key: "input" },
                          h("div", { class: `${clsPrefix}-base-selection-input__content` }, renderTag
                              ? renderTag({
                                  option: this.selectedOption,
                                  handleClose: () => { }
                              })
                              : renderLabel
                                  ? renderLabel(this.selectedOption, true)
                                  : render$1(this.label, this.selectedOption, true)))) : (h("div", { class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`, key: "placeholder" },
                          h("div", { class: `${clsPrefix}-base-selection-placeholder__inner` }, this.placeholder))),
                      suffix));
              }
          }
          return (h("div", { ref: "selfRef", class: [
                  `${clsPrefix}-base-selection`,
                  this.themeClass,
                  status && `${clsPrefix}-base-selection--${status}-status`,
                  {
                      [`${clsPrefix}-base-selection--active`]: this.active,
                      [`${clsPrefix}-base-selection--selected`]: this.selected || (this.active && this.pattern),
                      [`${clsPrefix}-base-selection--disabled`]: this.disabled,
                      [`${clsPrefix}-base-selection--multiple`]: this.multiple,
                      // focus is not controlled by selection itself since it always need
                      // to be managed together with menu. provide :focus style will cause
                      // many redundant codes.
                      [`${clsPrefix}-base-selection--focus`]: this.focused
                  }
              ], style: this.cssVars, onClick: this.onClick, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onKeydown: this.onKeydown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onMousedown: this.handleMouseDown },
              body,
              bordered ? (h("div", { class: `${clsPrefix}-base-selection__border` })) : null,
              bordered ? (h("div", { class: `${clsPrefix}-base-selection__state-border` })) : null));
      }
  });

  var SlotMachineNumber = defineComponent({
      name: 'SlotMachineNumber',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          value: {
              // could be '+', 1, 2, ...
              type: [Number, String],
              required: true
          },
          oldOriginalNumber: {
              type: Number,
              default: undefined
          },
          newOriginalNumber: {
              type: Number,
              default: undefined
          }
      },
      setup(props) {
          const numberRef = ref(null);
          const oldNumberRef = ref(props.value);
          const newNumberRef = ref(props.value);
          const scrollAnimationDirectionRef = ref('up');
          const activeRef = ref(false);
          const newNumberScrollAnimationClassRef = computed(() => {
              return activeRef.value
                  ? `${props.clsPrefix}-base-slot-machine-current-number--${scrollAnimationDirectionRef.value}-scroll`
                  : null;
          });
          const oldNumberScrollAnimationClassRef = computed(() => {
              return activeRef.value
                  ? `${props.clsPrefix}-base-slot-machine-old-number--${scrollAnimationDirectionRef.value}-scroll`
                  : null;
          });
          // BUG: may be typescript bug
          watch(toRef(props, 'value'), (value, oldValue) => {
              oldNumberRef.value = oldValue;
              newNumberRef.value = value;
              void nextTick(scroll);
          });
          function scroll() {
              const newOriginalNumber = props.newOriginalNumber;
              const oldOriginalNumber = props.oldOriginalNumber;
              if (oldOriginalNumber === undefined || newOriginalNumber === undefined) {
                  return;
              }
              if (newOriginalNumber > oldOriginalNumber) {
                  scrollByDir('up');
              }
              else if (oldOriginalNumber > newOriginalNumber) {
                  scrollByDir('down');
              }
          }
          function scrollByDir(dir) {
              scrollAnimationDirectionRef.value = dir;
              activeRef.value = false;
              void nextTick(() => {
                  var _a;
                  void ((_a = numberRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
                  activeRef.value = true;
              });
          }
          return () => {
              const { clsPrefix } = props;
              return (h("span", { ref: numberRef, class: `${clsPrefix}-base-slot-machine-number` },
                  oldNumberRef.value !== null ? (h("span", { class: [
                          `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--top`,
                          oldNumberScrollAnimationClassRef.value
                      ] }, oldNumberRef.value)) : null,
                  h("span", { class: [
                          `${clsPrefix}-base-slot-machine-current-number`,
                          newNumberScrollAnimationClassRef.value
                      ] },
                      h("span", { ref: "numberWrapper", class: [
                              `${clsPrefix}-base-slot-machine-current-number__inner`,
                              typeof props.value !== 'number' &&
                                  `${clsPrefix}-base-slot-machine-current-number__inner--not-number`
                          ] }, newNumberRef.value)),
                  oldNumberRef.value !== null ? (h("span", { class: [
                          `${clsPrefix}-base-slot-machine-old-number ${clsPrefix}-base-slot-machine-old-number--bottom`,
                          oldNumberScrollAnimationClassRef.value
                      ] }, oldNumberRef.value)) : null));
          };
      }
  });

  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$2
  } = commonVariables$m;
  function fadeInWidthExpandTransition({
    duration = '.2s',
    delay = '.1s'
  } = {}) {
    return [c$1('&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to', {
      opacity: 1
    }), c$1('&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from', `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1('&.fade-in-width-expand-transition-leave-active', `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$2},
 max-width ${duration} ${cubicBezierEaseInOut$2} ${delay},
 margin-left ${duration} ${cubicBezierEaseInOut$2} ${delay},
 margin-right ${duration} ${cubicBezierEaseInOut$2} ${delay};
 `), c$1('&.fade-in-width-expand-transition-enter-active', `
 overflow: hidden;
 transition:
 opacity ${duration} ${cubicBezierEaseInOut$2} ${delay},
 max-width ${duration} ${cubicBezierEaseInOut$2},
 margin-left ${duration} ${cubicBezierEaseInOut$2},
 margin-right ${duration} ${cubicBezierEaseInOut$2};
 `)];
  }

  const {
    cubicBezierEaseOut: cubicBezierEaseOut$5
  } = commonVariables$m;
  function fadeUpWidthExpandTransition({
    duration = '.2s'
  } = {}) {
    return [c$1('&.fade-up-width-expand-transition-leave-active', {
      transition: `
 opacity ${duration} ${cubicBezierEaseOut$5},
 max-width ${duration} ${cubicBezierEaseOut$5},
 transform ${duration} ${cubicBezierEaseOut$5}
 `
    }), c$1('&.fade-up-width-expand-transition-enter-active', {
      transition: `
 opacity ${duration} ${cubicBezierEaseOut$5},
 max-width ${duration} ${cubicBezierEaseOut$5},
 transform ${duration} ${cubicBezierEaseOut$5}
 `
    }), c$1('&.fade-up-width-expand-transition-enter-to', {
      opacity: 1,
      transform: 'translateX(0) translateY(0)'
    }), c$1('&.fade-up-width-expand-transition-enter-from', {
      maxWidth: '0 !important',
      opacity: 0,
      transform: 'translateY(60%)'
    }), c$1('&.fade-up-width-expand-transition-leave-from', {
      opacity: 1,
      transform: 'translateY(0)'
    }), c$1('&.fade-up-width-expand-transition-leave-to', {
      maxWidth: '0 !important',
      opacity: 0,
      transform: 'translateY(60%)'
    })];
  }

  // ease-out: cubic-bezier(0, 0, .2, 1)
  var style$1o = c$1([c$1('@keyframes n-base-slot-machine-fade-up-in', `
 from {
 transform: translateY(60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1('@keyframes n-base-slot-machine-fade-down-in', `
 from {
 transform: translateY(-60%);
 opacity: 0;
 }
 to {
 transform: translateY(0);
 opacity: 1;
 }
 `), c$1('@keyframes n-base-slot-machine-fade-up-out', `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(-60%);
 opacity: 0;
 }
 `), c$1('@keyframes n-base-slot-machine-fade-down-out', `
 from {
 transform: translateY(0%);
 opacity: 1;
 }
 to {
 transform: translateY(60%);
 opacity: 0;
 }
 `), cB('base-slot-machine', `
 overflow: hidden;
 white-space: nowrap;
 display: inline-block;
 height: 18px;
 line-height: 18px;
 `, [cB('base-slot-machine-number', `
 display: inline-block;
 position: relative;
 height: 18px;
 width: .6em;
 max-width: .6em;
 `, [fadeUpWidthExpandTransition({
    duration: '.2s'
  }),
  // use 0s, not 0
  fadeInWidthExpandTransition({
    duration: '.2s',
    delay: '0s'
  }), cB('base-slot-machine-old-number', `
 display: inline-block;
 opacity: 0;
 position: absolute;
 left: 0;
 right: 0;
 `, [cM('top', {
    transform: 'translateY(-100%)'
  }), cM('bottom', {
    transform: 'translateY(100%)'
  }), cM('down-scroll', {
    animation: 'n-base-slot-machine-fade-down-out .2s cubic-bezier(0, 0, .2, 1)',
    animationIterationCount: 1
  }), cM('up-scroll', {
    animation: 'n-base-slot-machine-fade-up-out .2s cubic-bezier(0, 0, .2, 1)',
    animationIterationCount: 1
  })]), cB('base-slot-machine-current-number', `
 display: inline-block;
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 1;
 transform: translateY(0);
 width: .6em;
 `, [cM('down-scroll', {
    animation: 'n-base-slot-machine-fade-down-in .2s cubic-bezier(0, 0, .2, 1)',
    animationIterationCount: 1
  }), cM('up-scroll', {
    animation: 'n-base-slot-machine-fade-up-in .2s cubic-bezier(0, 0, .2, 1)',
    animationIterationCount: 1
  }), cE('inner', `
 display: inline-block;
 position: absolute;
 right: 0;
 top: 0;
 width: .6em;
 `, [cM('not-number', `
 right: unset;
 left: 0;
 `)])])])])]);

  var NBaseSlotMachine = defineComponent({
      name: 'BaseSlotMachine',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          value: {
              type: [Number, String],
              default: 0
          },
          max: {
              type: Number,
              default: undefined
          },
          appeared: {
              type: Boolean,
              required: true
          }
      },
      setup(props) {
          useStyle('-base-slot-machine', style$1o, toRef(props, 'clsPrefix'));
          const oldValueRef = ref();
          const newValueRef = ref();
          const numbersRef = computed(() => {
              if (typeof props.value === 'string')
                  return [];
              if (props.value < 1)
                  return [0];
              const numbers = [];
              let value = props.value;
              if (props.max !== undefined) {
                  value = Math.min(props.max, value);
              }
              while (value >= 1) {
                  numbers.push(value % 10);
                  value /= 10;
                  value = Math.floor(value);
              }
              numbers.reverse();
              return numbers;
          });
          watch(toRef(props, 'value'), (value, oldValue) => {
              if (typeof value === 'string') {
                  newValueRef.value = undefined;
                  oldValueRef.value = undefined;
              }
              else {
                  if (typeof oldValue === 'string') {
                      newValueRef.value = value;
                      oldValueRef.value = undefined;
                  }
                  else {
                      newValueRef.value = value;
                      oldValueRef.value = oldValue;
                  }
              }
          });
          return () => {
              const { value, clsPrefix } = props;
              return typeof value === 'number' ? (h("span", { class: `${clsPrefix}-base-slot-machine` },
                  h(TransitionGroup, { name: "fade-up-width-expand-transition", tag: "span" }, {
                      default: () => numbersRef.value.map((number, i) => (h(SlotMachineNumber, { clsPrefix: clsPrefix, key: numbersRef.value.length - i - 1, oldOriginalNumber: oldValueRef.value, newOriginalNumber: newValueRef.value, value: number })))
                  }),
                  h(NFadeInExpandTransition, { key: "+", width: true }, {
                      default: () => props.max !== undefined && props.max < value ? (h(SlotMachineNumber, { clsPrefix: clsPrefix, value: "+" })) : null
                  }))) : (h("span", { class: `${clsPrefix}-base-slot-machine` }, value));
          };
      }
  });

  var commonVars$a = {
      iconMargin: '11px 8px 0 12px',
      iconMarginRtl: '11px 12px 0 8px',
      iconSize: '24px',
      closeIconSize: '16px',
      closeSize: '20px',
      closeMargin: '13px 14px 0 0',
      closeMarginRtl: '13px 0 0 14px',
      padding: '13px'
  };

  const self$18 = (vars) => {
      const { lineHeight, borderRadius, fontWeightStrong, baseColor, dividerColor, actionColor, textColor1, textColor2, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, warningColor, errorColor, fontSize } = vars;
      return Object.assign(Object.assign({}, commonVars$a), { fontSize,
          lineHeight, titleFontWeight: fontWeightStrong, borderRadius, border: `1px solid ${dividerColor}`, color: actionColor, titleTextColor: textColor1, iconColor: textColor2, contentTextColor: textColor2, closeBorderRadius: borderRadius, closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed, borderInfo: `1px solid ${composite(baseColor, changeColor(infoColor, { alpha: 0.25 }))}`, colorInfo: composite(baseColor, changeColor(infoColor, { alpha: 0.08 })), titleTextColorInfo: textColor1, iconColorInfo: infoColor, contentTextColorInfo: textColor2, closeColorHoverInfo: closeColorHover, closeColorPressedInfo: closeColorPressed, closeIconColorInfo: closeIconColor, closeIconColorHoverInfo: closeIconColorHover, closeIconColorPressedInfo: closeIconColorPressed, borderSuccess: `1px solid ${composite(baseColor, changeColor(successColor, { alpha: 0.25 }))}`, colorSuccess: composite(baseColor, changeColor(successColor, { alpha: 0.08 })), titleTextColorSuccess: textColor1, iconColorSuccess: successColor, contentTextColorSuccess: textColor2, closeColorHoverSuccess: closeColorHover, closeColorPressedSuccess: closeColorPressed, closeIconColorSuccess: closeIconColor, closeIconColorHoverSuccess: closeIconColorHover, closeIconColorPressedSuccess: closeIconColorPressed, borderWarning: `1px solid ${composite(baseColor, changeColor(warningColor, { alpha: 0.33 }))}`, colorWarning: composite(baseColor, changeColor(warningColor, { alpha: 0.08 })), titleTextColorWarning: textColor1, iconColorWarning: warningColor, contentTextColorWarning: textColor2, closeColorHoverWarning: closeColorHover, closeColorPressedWarning: closeColorPressed, closeIconColorWarning: closeIconColor, closeIconColorHoverWarning: closeIconColorHover, closeIconColorPressedWarning: closeIconColorPressed, borderError: `1px solid ${composite(baseColor, changeColor(errorColor, { alpha: 0.25 }))}`, colorError: composite(baseColor, changeColor(errorColor, { alpha: 0.08 })), titleTextColorError: textColor1, iconColorError: errorColor, contentTextColorError: textColor2, closeColorHoverError: closeColorHover, closeColorPressedError: closeColorPressed, closeIconColorError: closeIconColor, closeIconColorHoverError: closeIconColorHover, closeIconColorPressedError: closeIconColorPressed });
  };
  const alertLight = {
      name: 'Alert',
      common: commonLight,
      self: self$18
  };
  var alertLight$1 = alertLight;

  const {
    cubicBezierEaseInOut: cubicBezierEaseInOut$1,
    cubicBezierEaseOut: cubicBezierEaseOut$4,
    cubicBezierEaseIn: cubicBezierEaseIn$4
  } = commonVariables$m;
  function fadeInHeightExpandTransition({
    overflow = 'hidden',
    duration = '.3s',
    originalTransition = '',
    leavingDelay = '0s',
    foldPadding = false,
    enterToProps = undefined,
    leaveToProps = undefined,
    reverse = false
  } = {}) {
    const enterClass = reverse ? 'leave' : 'enter';
    const leaveClass = reverse ? 'enter' : 'leave';
    return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
      opacity: 1
    })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
      opacity: 0,
      marginTop: '0 !important',
      marginBottom: '0 !important',
      paddingTop: foldPadding ? '0 !important' : undefined,
      paddingBottom: foldPadding ? '0 !important' : undefined
    })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 opacity ${duration} ${cubicBezierEaseOut$4} ${leavingDelay},
 margin-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 margin-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-top ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-bottom ${duration} ${cubicBezierEaseInOut$1} ${leavingDelay}
 ${originalTransition ? ',' + originalTransition : ''}
 `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration} ${cubicBezierEaseInOut$1},
 opacity ${duration} ${cubicBezierEaseIn$4},
 margin-top ${duration} ${cubicBezierEaseInOut$1},
 margin-bottom ${duration} ${cubicBezierEaseInOut$1},
 padding-top ${duration} ${cubicBezierEaseInOut$1},
 padding-bottom ${duration} ${cubicBezierEaseInOut$1}
 ${originalTransition ? ',' + originalTransition : ''}
 `)];
  }

  // vars:
  // --n-bezier
  // --n-color
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-icon-color
  // --n-border
  // --n-title-text-color
  // --n-content-text-color
  // --n-line-height
  // --n-border-radius
  // --n-font-size
  // --n-title-font-weight
  // --n-icon-size
  // --n-icon-margin
  // --n-close-size
  // --n-close-icon-size
  // --n-close-margin
  // --n-padding
  // --n-icon-margin-left
  // --n-icon-margin-right
  var style$1n = cB('alert', `
 line-height: var(--n-line-height);
 border-radius: var(--n-border-radius);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 text-align: start;
 word-break: break-word;
`, [cE('border', `
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 transition: border-color .3s var(--n-bezier);
 border: var(--n-border);
 pointer-events: none;
 `), cM('closable', [cB('alert-body', [cE('title', `
 padding-right: 24px;
 `)])]), cE('icon', {
    color: 'var(--n-icon-color)'
  }), cB('alert-body', {
    padding: 'var(--n-padding)'
  }, [cE('title', {
    color: 'var(--n-title-text-color)'
  }), cE('content', {
    color: 'var(--n-content-text-color)'
  })]), fadeInHeightExpandTransition({
    originalTransition: 'transform .3s var(--n-bezier)',
    enterToProps: {
      transform: 'scale(1)'
    },
    leaveToProps: {
      transform: 'scale(0.9)'
    }
  }), cE('icon', `
 position: absolute;
 left: 0;
 top: 0;
 align-items: center;
 justify-content: center;
 display: flex;
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 margin: var(--n-icon-margin);
 `), cE('close', `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 `), cM('show-icon', [cB('alert-body', {
    paddingLeft: 'calc(var(--n-icon-margin-left) + var(--n-icon-size) + var(--n-icon-margin-right))'
  })]),
  // fix: https://github.com/tusen-ai/naive-ui/issues/4588
  cM('right-adjust', [cB('alert-body', {
    paddingRight: 'calc(var(--n-close-size) + var(--n-padding) + 2px)'
  })]), cB('alert-body', `
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 `, [cE('title', `
 transition: color .3s var(--n-bezier);
 font-size: 16px;
 line-height: 19px;
 font-weight: var(--n-title-font-weight);
 `, [c$1('& +', [cE('content', {
    marginTop: '9px'
  })])]), cE('content', {
    transition: 'color .3s var(--n-bezier)',
    fontSize: 'var(--n-font-size)'
  })]), cE('icon', {
    transition: 'color .3s var(--n-bezier)'
  })]);

  const alertProps = Object.assign(Object.assign({}, useTheme.props), { title: String, showIcon: {
          type: Boolean,
          default: true
      }, type: {
          type: String,
          default: 'default'
      }, bordered: {
          type: Boolean,
          default: true
      }, closable: Boolean, onClose: Function, onAfterLeave: Function, 
      /** @deprecated */
      onAfterHide: Function });
  var Alert = defineComponent({
      name: 'Alert',
      inheritAttrs: false,
      props: alertProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Alert', '-alert', style$1n, alertLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Alert', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { fontSize, borderRadius, titleFontWeight, lineHeight, iconSize, iconMargin, iconMarginRtl, closeIconSize, closeBorderRadius, closeSize, closeMargin, closeMarginRtl, padding } = self;
              const { type } = props;
              const { left, right } = getMargin(iconMargin);
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color': self[createKey('color', type)],
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-color-hover': self[createKey('closeColorHover', type)],
                  '--n-close-color-pressed': self[createKey('closeColorPressed', type)],
                  '--n-close-icon-color': self[createKey('closeIconColor', type)],
                  '--n-close-icon-color-hover': self[createKey('closeIconColorHover', type)],
                  '--n-close-icon-color-pressed': self[createKey('closeIconColorPressed', type)],
                  '--n-icon-color': self[createKey('iconColor', type)],
                  '--n-border': self[createKey('border', type)],
                  '--n-title-text-color': self[createKey('titleTextColor', type)],
                  '--n-content-text-color': self[createKey('contentTextColor', type)],
                  '--n-line-height': lineHeight,
                  '--n-border-radius': borderRadius,
                  '--n-font-size': fontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-icon-size': iconSize,
                  '--n-icon-margin': iconMargin,
                  '--n-icon-margin-rtl': iconMarginRtl,
                  '--n-close-size': closeSize,
                  '--n-close-margin': closeMargin,
                  '--n-close-margin-rtl': closeMarginRtl,
                  '--n-padding': padding,
                  '--n-icon-margin-left': left,
                  '--n-icon-margin-right': right
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('alert', computed(() => {
                  return props.type[0];
              }), cssVarsRef, props)
              : undefined;
          const visibleRef = ref(true);
          const doAfterLeave = () => {
              const { onAfterLeave, onAfterHide // deprecated
               } = props;
              if (onAfterLeave)
                  onAfterLeave();
              if (onAfterHide)
                  onAfterHide();
          };
          const handleCloseClick = () => {
              var _a;
              void Promise.resolve((_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props)).then((result) => {
                  if (result === false)
                      return;
                  visibleRef.value = false;
              });
          };
          const handleAfterLeave = () => {
              doAfterLeave();
          };
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedBordered: mergedBorderedRef,
              visible: visibleRef,
              handleCloseClick,
              handleAfterLeave,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h(NFadeInExpandTransition, { onAfterLeave: this.handleAfterLeave }, {
              default: () => {
                  const { mergedClsPrefix, $slots } = this;
                  const attrs = {
                      class: [
                          `${mergedClsPrefix}-alert`,
                          this.themeClass,
                          this.closable && `${mergedClsPrefix}-alert--closable`,
                          this.showIcon && `${mergedClsPrefix}-alert--show-icon`,
                          // fix: https://github.com/tusen-ai/naive-ui/issues/4588
                          !this.title &&
                              this.closable &&
                              `${mergedClsPrefix}-alert--right-adjust`,
                          this.rtlEnabled && `${mergedClsPrefix}-alert--rtl`
                      ],
                      style: this.cssVars,
                      role: 'alert'
                  };
                  return this.visible ? (
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  h("div", Object.assign({}, mergeProps(this.$attrs, attrs)),
                      this.closable && (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-alert__close`, onClick: this.handleCloseClick })),
                      this.bordered && (h("div", { class: `${mergedClsPrefix}-alert__border` })),
                      this.showIcon && (h("div", { class: `${mergedClsPrefix}-alert__icon`, "aria-hidden": "true" }, resolveSlot($slots.icon, () => [
                          h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                              default: () => {
                                  switch (this.type) {
                                      case 'success':
                                          return h(SuccessIcon, null);
                                      case 'info':
                                          return h(InfoIcon, null);
                                      case 'warning':
                                          return h(WarningIcon, null);
                                      case 'error':
                                          return h(ErrorIcon, null);
                                      default:
                                          return null;
                                  }
                              }
                          })
                      ]))),
                      h("div", { class: [
                              `${mergedClsPrefix}-alert-body`,
                              this.mergedBordered &&
                                  `${mergedClsPrefix}-alert-body--bordered`
                          ] },
                          resolveWrappedSlot($slots.header, (children) => {
                              const mergedChildren = children || this.title;
                              return mergedChildren ? (h("div", { class: `${mergedClsPrefix}-alert-body__title` }, mergedChildren)) : null;
                          }),
                          $slots.default && (h("div", { class: `${mergedClsPrefix}-alert-body__content` }, $slots))))) : null;
              }
          }));
      }
  });

  var commonVars$9 = {
      linkFontSize: '13px',
      linkPadding: '0 0 0 16px',
      railWidth: '4px'
  };

  const self$17 = (vars) => {
      const { borderRadius, railColor, primaryColor, primaryColorHover, primaryColorPressed, textColor2 } = vars;
      return Object.assign(Object.assign({}, commonVars$9), { borderRadius,
          railColor, railColorActive: primaryColor, linkColor: changeColor(primaryColor, { alpha: 0.15 }), linkTextColor: textColor2, linkTextColorHover: primaryColorHover, linkTextColorPressed: primaryColorPressed, linkTextColorActive: primaryColor });
  };
  const anchorLight = {
      name: 'Anchor',
      common: commonLight,
      self: self$17
  };
  var anchorLight$1 = anchorLight;

  // vars:
  // --n-link-color
  // --n-link-font-size
  // --n-link-text-color
  // --n-link-text-color-hover
  // --n-link-text-color-active
  // --n-link-text-color-pressed
  // --n-bezier
  // --n-rail-color
  // --n-rail-color-active
  // --n-rail-width
  // --n-link-padding
  // --n-link-border-radius
  var style$1m = cB('anchor', `
 position: relative;
`, [cNotM('block', `
 padding-left: var(--n-rail-width);
 `, [cB('anchor-link', [c$1('+, >', [cB('anchor-link', `
 margin-top: .5em;
 `)])]), cB('anchor-link-background', `
 max-width: 0;
 border-top-right-radius: 10.5px;
 border-bottom-right-radius: 10.5px;
 `), cNotM('show-rail', [c$1('>', [cB('anchor-link', 'padding-left: 0;')])])]), cM('block', [cB('anchor-link', `
 margin-bottom: 4px;
 padding: 2px 8px;
 transition: background-color .3s var(--n-bezier);
 background-color: transparent;
 border-radius: var(--n-link-border-radius);
 `, [cM('active', `
 background-color: var(--n-link-color);
 `)])]), cB('anchor-link-background', `
 position: absolute;
 left: calc(var(--n-rail-width) / 2);
 width: 100%;
 background-color: var(--n-link-color);
 transition:
 top .15s var(--n-bezier),
 max-width .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB('anchor-rail', `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 width: var(--n-rail-width);
 border-radius: calc(var(--n-rail-width) / 2);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE('bar', `
 position: absolute;
 left: 0;
 width: var(--n-rail-width);
 height: 21px;
 background-color: #0000;
 transition: 
 top .15s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cM('active', {
    backgroundColor: 'var(--n-rail-color-active)'
  })])]), cB('anchor-link', `
 padding: var(--n-link-padding);
 position: relative;
 line-height: 1.5;
 font-size: var(--n-link-font-size);
 min-height: 1.5em;
 display: flex;
 flex-direction: column;
 `, [cM('active', [c$1('>', [cE('title', `
 color: var(--n-link-text-color-active);
 `)])]), cE('title', `
 outline: none;
 max-width: 100%;
 text-decoration: none;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 cursor: pointer;
 display: inline-block;
 padding-right: 16px;
 transition: color .3s var(--n-bezier);
 color: var(--n-link-text-color);
 `, [c$1('&:hover, &:focus', `
 color: var(--n-link-text-color-hover);
 `), c$1('&:active', `
 color: var(--n-link-text-color-pressed);
 `)])])]);

  const anchorInjectionKey = createInjectionKey('n-anchor');
  const anchorLinkProps = {
      title: String,
      href: String
  };
  var Link = defineComponent({
      name: 'AnchorLink',
      props: anchorLinkProps,
      setup(props, { slots }) {
          const titleRef = ref(null);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NAnchor = inject(anchorInjectionKey);
          const hrefRef = toRef(props, 'href');
          const activeRef = useMemo(() => {
              return hrefRef.value && hrefRef.value === NAnchor.activeHref.value;
          });
          useInjectionCollection(anchorInjectionKey, 'collectedLinkHrefs', hrefRef);
          useInjectionElementCollection(anchorInjectionKey, 'titleEls', () => titleRef.value);
          watch(activeRef, (value) => {
              if (value && titleRef.value) {
                  NAnchor.updateBarPosition(titleRef.value);
              }
          });
          function handleClick() {
              if (props.href !== undefined) {
                  NAnchor.setActiveHref(props.href);
              }
          }
          return () => {
              var _a;
              const { value: mergedClsPrefix } = NAnchor.mergedClsPrefix;
              return (h("div", { class: [
                      `${mergedClsPrefix}-anchor-link`,
                      activeRef.value && `${mergedClsPrefix}-anchor-link--active`
                  ] },
                  h("a", { ref: titleRef, class: [`${mergedClsPrefix}-anchor-link__title`], href: props.href, title: getTitleAttribute(props.title), onClick: handleClick }, props.title), (_a = slots.default) === null || _a === void 0 ? void 0 :
                  _a.call(slots)));
          };
      }
  });

  function getOffset(el, scrollTarget) {
      const { top: elTop, height } = el.getBoundingClientRect();
      const scrollTargetTop = scrollTarget instanceof HTMLElement
          ? scrollTarget.getBoundingClientRect().top
          : 0;
      return {
          top: elTop - scrollTargetTop,
          height
      };
  }

  const baseAnchorProps = {
      type: {
          type: String,
          default: 'rail'
      },
      showRail: {
          type: Boolean,
          default: true
      },
      showBackground: {
          type: Boolean,
          default: true
      },
      bound: {
          type: Number,
          default: 12
      },
      internalScrollable: Boolean,
      ignoreGap: Boolean,
      offsetTarget: [String, Object, Function]
  };
  const baseAnchorPropKeys = keysOf(baseAnchorProps);
  var NBaseAnchor = defineComponent({
      name: 'BaseAnchor',
      props: Object.assign(Object.assign({}, baseAnchorProps), { mergedClsPrefix: {
              type: String,
              required: true
          } }),
      setup(props) {
          const collectedLinkHrefs = [];
          const titleEls = [];
          const activeHrefRef = ref(null);
          const slotRef = ref(null);
          const barRef = ref(null);
          const selfRef = ref(null);
          const isBlockTypeRef = computed(() => {
              return props.type === 'block';
          });
          const mergedShowRailRef = computed(() => {
              return !isBlockTypeRef.value && props.showRail;
          });
          function disableTransitionOneTick() {
              const { value: barEl } = barRef;
              const { value: slotEl } = slotRef;
              if (barEl) {
                  barEl.style.transition = 'none';
              }
              if (slotEl) {
                  slotEl.style.transition = 'none';
              }
              if (titleEls) {
                  titleEls.forEach((titleEl) => {
                      titleEl.style.transition = 'none';
                  });
              }
              void nextTick(() => {
                  const { value: nextBarEl } = barRef;
                  const { value: nextSlotEl } = slotRef;
                  if (nextBarEl) {
                      void nextBarEl.offsetWidth;
                      nextBarEl.style.transition = '';
                  }
                  if (nextSlotEl) {
                      void nextSlotEl.offsetWidth;
                      nextSlotEl.style.transition = '';
                  }
                  if (titleEls) {
                      titleEls.forEach((titleEl) => {
                          void titleEl.offsetWidth;
                          titleEl.style.transition = '';
                      });
                  }
              });
          }
          function updateBarPosition(linkTitleEl, transition = true) {
              const { value: barEl } = barRef;
              const { value: slotEl } = slotRef;
              const { value: selfEl } = selfRef;
              if (!selfEl || !barEl)
                  return;
              if (!transition) {
                  barEl.style.transition = 'none';
                  if (slotEl)
                      slotEl.style.transition = 'none';
              }
              const { offsetHeight, offsetWidth } = linkTitleEl;
              const { top: linkTitleClientTop, left: linkTitleClientLeft } = linkTitleEl.getBoundingClientRect();
              const { top: anchorClientTop, left: anchorClientLeft } = selfEl.getBoundingClientRect();
              const offsetTop = linkTitleClientTop - anchorClientTop;
              const offsetLeft = linkTitleClientLeft - anchorClientLeft;
              barEl.style.top = `${offsetTop}px`;
              barEl.style.height = `${offsetHeight}px`;
              if (slotEl) {
                  slotEl.style.top = `${offsetTop}px`;
                  slotEl.style.height = `${offsetHeight}px`;
                  slotEl.style.maxWidth = `${offsetWidth + offsetLeft}px`;
              }
              void barEl.offsetHeight;
              if (slotEl)
                  void slotEl.offsetHeight;
              if (!transition) {
                  barEl.style.transition = '';
                  if (slotEl)
                      slotEl.style.transition = '';
              }
          }
          function setActiveHref(href, transition = true) {
              const idMatchResult = /^#([^#]+)$/.exec(href);
              if (!idMatchResult)
                  return;
              const linkEl = document.getElementById(idMatchResult[1]);
              if (!linkEl)
                  return;
              activeHrefRef.value = href;
              linkEl.scrollIntoView();
              if (!transition) {
                  disableTransitionOneTick();
              }
              handleScroll();
          }
          const handleScroll = throttle(() => {
              _handleScroll(true);
          }, 128);
          function _handleScroll(transition = true) {
              var _a;
              const links = [];
              const offsetTarget = unwrapElement((_a = props.offsetTarget) !== null && _a !== void 0 ? _a : document);
              collectedLinkHrefs.forEach((href) => {
                  const idMatchResult = /#([^#]+)$/.exec(href);
                  if (!idMatchResult)
                      return;
                  const linkEl = document.getElementById(idMatchResult[1]);
                  if (linkEl && offsetTarget) {
                      const { top, height } = getOffset(linkEl, offsetTarget);
                      links.push({
                          top,
                          height,
                          href
                      });
                  }
              });
              links.sort((a, b) => {
                  // ascend top
                  if (a.top > b.top) {
                      return 1;
                      // descend height
                  }
                  else if (a.top === b.top && a.height < b.height) {
                      return -1;
                  }
                  return -1;
              });
              const currentActiveHref = activeHrefRef.value;
              const { bound, ignoreGap } = props;
              const activeLink = links.reduce((prevLink, link) => {
                  if (link.top + link.height < 0) {
                      if (ignoreGap) {
                          return link;
                      }
                      else {
                          return prevLink;
                      }
                  }
                  if (link.top <= bound) {
                      if (prevLink === null) {
                          return link;
                      }
                      else if (link.top === prevLink.top) {
                          if (link.href === currentActiveHref) {
                              return link;
                          }
                          else
                              return prevLink;
                      }
                      else if (link.top > prevLink.top) {
                          return link;
                      }
                      else {
                          return prevLink;
                      }
                  }
                  return prevLink;
              }, null);
              if (!transition)
                  disableTransitionOneTick();
              if (activeLink) {
                  activeHrefRef.value = activeLink.href;
              }
              else {
                  activeHrefRef.value = null;
              }
          }
          provide(anchorInjectionKey, {
              activeHref: activeHrefRef,
              mergedClsPrefix: toRef(props, 'mergedClsPrefix'),
              updateBarPosition,
              setActiveHref,
              collectedLinkHrefs,
              titleEls
          });
          onMounted(() => {
              document.addEventListener('scroll', handleScroll, true);
              setActiveHref(window.location.hash);
              _handleScroll(false);
          });
          onFontsReady(() => {
              setActiveHref(window.location.hash);
              _handleScroll(false);
          });
          onBeforeUnmount(() => {
              document.removeEventListener('scroll', handleScroll, true);
          });
          watch(activeHrefRef, (value) => {
              if (value === null) {
                  const { value: slotEl } = slotRef;
                  if (slotEl && !isBlockTypeRef.value) {
                      slotEl.style.maxWidth = '0';
                  }
              }
          });
          return {
              selfRef,
              barRef,
              slotRef,
              setActiveHref,
              activeHref: activeHrefRef,
              isBlockType: isBlockTypeRef,
              mergedShowRail: mergedShowRailRef
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix, mergedShowRail, isBlockType, $slots } = this;
          const Anchor = (h("div", { class: [
                  `${mergedClsPrefix}-anchor`,
                  isBlockType && `${mergedClsPrefix}-anchor--block`,
                  mergedShowRail && `${mergedClsPrefix}-anchor--show-rail`
              ], ref: "selfRef" },
              mergedShowRail && this.showBackground ? (h("div", { ref: "slotRef", class: `${mergedClsPrefix}-anchor-link-background` })) : null,
              mergedShowRail ? (h("div", { class: `${mergedClsPrefix}-anchor-rail` },
                  h("div", { ref: "barRef", class: [
                          `${mergedClsPrefix}-anchor-rail__bar`,
                          this.activeHref !== null &&
                              `${mergedClsPrefix}-anchor-rail__bar--active`
                      ] }))) : null, (_a = $slots.default) === null || _a === void 0 ? void 0 :
              _a.call($slots)));
          return this.internalScrollable ? (h(NScrollbar, null, {
              default: () => Anchor
          })) : (Anchor);
      }
  });

  const anchorProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { affix: Boolean }), affixProps), baseAnchorProps);
  var AnchorAdapter = defineComponent({
      name: 'Anchor',
      props: anchorProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Anchor', '-anchor', style$1m, anchorLight$1, props, mergedClsPrefixRef);
          const anchorRef = ref(null);
          const cssVarsRef = computed(() => {
              const { self: { railColor, linkColor, railColorActive, linkTextColor, linkTextColorHover, linkTextColorPressed, linkTextColorActive, linkFontSize, railWidth, linkPadding, borderRadius }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-link-border-radius': borderRadius,
                  '--n-link-color': linkColor,
                  '--n-link-font-size': linkFontSize,
                  '--n-link-text-color': linkTextColor,
                  '--n-link-text-color-hover': linkTextColorHover,
                  '--n-link-text-color-active': linkTextColorActive,
                  '--n-link-text-color-pressed': linkTextColorPressed,
                  '--n-link-padding': linkPadding,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-rail-color': railColor,
                  '--n-rail-color-active': railColorActive,
                  '--n-rail-width': railWidth
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('anchor', undefined, cssVarsRef, props)
              : undefined;
          return {
              scrollTo(href) {
                  var _a;
                  (_a = anchorRef.value) === null || _a === void 0 ? void 0 : _a.setActiveHref(href);
              },
              renderAnchor: () => {
                  themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
                  return (h(NBaseAnchor, Object.assign({ ref: anchorRef, style: inlineThemeDisabled
                          ? undefined
                          : cssVarsRef.value, class: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value }, keep(props, baseAnchorPropKeys), { mergedClsPrefix: mergedClsPrefixRef.value }), slots));
              }
          };
      },
      render() {
          return !this.affix ? (this.renderAnchor()) : (h(NAffix, Object.assign({}, keep(this, affixPropKeys)), { default: this.renderAnchor }));
      }
  });

  function getIsGroup(option) {
      return option.type === 'group';
  }
  function getIgnored(option) {
      return option.type === 'ignored';
  }
  function patternMatched(pattern, value) {
      try {
          return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));
      }
      catch (err) {
          return false;
      }
  }
  function createTmOptions(valueField, childrenField) {
      const options = {
          getIsGroup,
          getIgnored,
          getKey(option) {
              if (getIsGroup(option)) {
                  return (option.name ||
                      option.key ||
                      'key-required');
              }
              // Required for non-custom label & value field
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              return option[valueField];
          },
          getChildren(option) {
              return option[childrenField];
          }
      };
      return options;
  }
  function filterOptions(originalOpts, filter, pattern, childrenField) {
      if (!filter)
          return originalOpts;
      function traverse(options) {
          if (!Array.isArray(options))
              return [];
          const filteredOptions = [];
          for (const option of options) {
              if (getIsGroup(option)) {
                  const children = traverse(option[childrenField]);
                  if (children.length) {
                      filteredOptions.push(Object.assign({}, option, {
                          [childrenField]: children
                      }));
                  }
              }
              else if (getIgnored(option)) {
                  continue;
              }
              else if (filter(pattern, option)) {
                  filteredOptions.push(option);
              }
          }
          return filteredOptions;
      }
      return traverse(originalOpts);
  }
  function createValOptMap(options, valueField, childrenField) {
      const valOptMap = new Map();
      options.forEach((option) => {
          if (getIsGroup(option)) {
              option[childrenField].forEach((selectGroupOption) => {
                  valOptMap.set(selectGroupOption[valueField], selectGroupOption);
              });
          }
          else {
              valOptMap.set(option[valueField], option);
          }
      });
      return valOptMap;
  }

  const isChrome = isBrowser$2 && 'chrome' in window;
  isBrowser$2 && navigator.userAgent.includes('Firefox');
  const isSafari = isBrowser$2 && navigator.userAgent.includes('Safari') && !isChrome;

  var commonVariables$i = {
      paddingTiny: '0 8px',
      paddingSmall: '0 10px',
      paddingMedium: '0 12px',
      paddingLarge: '0 14px',
      clearSize: '16px'
  };

  const self$16 = (vars) => {
      const { textColor2, textColor3, textColorDisabled, primaryColor, primaryColorHover, inputColor, inputColorDisabled, borderColor, warningColor, warningColorHover, errorColor, errorColorHover, borderRadius, lineHeight, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightTiny, heightSmall, heightMedium, heightLarge, actionColor, clearColor, clearColorHover, clearColorPressed, placeholderColor, placeholderColorDisabled, iconColor, iconColorDisabled, iconColorHover, iconColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$i), { countTextColorDisabled: textColorDisabled, countTextColor: textColor3, heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight, lineHeightTextarea: lineHeight, borderRadius, iconSize: '16px', groupLabelColor: actionColor, groupLabelTextColor: textColor2, textColor: textColor2, textColorDisabled, textDecorationColor: textColor2, caretColor: primaryColor, placeholderColor,
          placeholderColorDisabled, color: inputColor, colorDisabled: inputColorDisabled, colorFocus: inputColor, groupLabelBorder: `1px solid ${borderColor}`, border: `1px solid ${borderColor}`, borderHover: `1px solid ${primaryColorHover}`, borderDisabled: `1px solid ${borderColor}`, borderFocus: `1px solid ${primaryColorHover}`, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`, loadingColor: primaryColor, 
          // warning
          loadingColorWarning: warningColor, borderWarning: `1px solid ${warningColor}`, borderHoverWarning: `1px solid ${warningColorHover}`, colorFocusWarning: inputColor, borderFocusWarning: `1px solid ${warningColorHover}`, boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
            alpha: 0.2
        })}`, caretColorWarning: warningColor, 
          // error
          loadingColorError: errorColor, borderError: `1px solid ${errorColor}`, borderHoverError: `1px solid ${errorColorHover}`, colorFocusError: inputColor, borderFocusError: `1px solid ${errorColorHover}`, boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
            alpha: 0.2
        })}`, caretColorError: errorColor, clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed, suffixTextColor: textColor2 });
  };
  const inputLight = {
      name: 'Input',
      common: commonLight,
      self: self$16
  };
  var inputLight$1 = inputLight;

  const inputInjectionKey = createInjectionKey('n-input');

  function len(s) {
      let count = 0;
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      for (const _ of s) {
          count++;
      }
      return count;
  }
  function isEmptyInputValue(value) {
      return value === '' || value == null;
  }
  function useCursor(inputElRef) {
      const selectionRef = ref(null);
      function recordCursor() {
          const { value: input } = inputElRef;
          if (!(input === null || input === void 0 ? void 0 : input.focus)) {
              reset();
              return;
          }
          const { selectionStart, selectionEnd, value } = input;
          if (selectionStart == null || selectionEnd == null) {
              reset();
              return;
          }
          selectionRef.value = {
              start: selectionStart,
              end: selectionEnd,
              beforeText: value.slice(0, selectionStart),
              afterText: value.slice(selectionEnd)
          };
      }
      function restoreCursor() {
          var _a;
          const { value: selection } = selectionRef;
          const { value: inputEl } = inputElRef;
          if (!selection || !inputEl) {
              return;
          }
          const { value } = inputEl;
          const { start, beforeText, afterText } = selection;
          let startPos = value.length;
          if (value.endsWith(afterText)) {
              startPos = value.length - afterText.length;
          }
          else if (value.startsWith(beforeText)) {
              startPos = beforeText.length;
          }
          else {
              const beforeLastChar = beforeText[start - 1];
              const newIndex = value.indexOf(beforeLastChar, start - 1);
              if (newIndex !== -1) {
                  startPos = newIndex + 1;
              }
          }
          (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
      }
      function reset() {
          selectionRef.value = null;
      }
      watch(inputElRef, reset);
      return {
          recordCursor,
          restoreCursor
      };
  }

  var WordCount = defineComponent({
      name: 'InputWordCount',
      setup(_, { slots }) {
          const { mergedValueRef, maxlengthRef, mergedClsPrefixRef, countGraphemesRef } = 
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(inputInjectionKey);
          const wordCountRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (mergedValue === null || Array.isArray(mergedValue))
                  return 0;
              return (countGraphemesRef.value || len)(mergedValue);
          });
          return () => {
              const { value: maxlength } = maxlengthRef;
              const { value: mergedValue } = mergedValueRef;
              return (h("span", { class: `${mergedClsPrefixRef.value}-input-word-count` }, resolveSlotWithProps(slots.default, {
                  value: mergedValue === null || Array.isArray(mergedValue)
                      ? ''
                      : mergedValue
              }, () => [
                  maxlength === undefined
                      ? wordCountRef.value
                      : `${wordCountRef.value} / ${maxlength}`
              ])));
          };
      }
  });

  // vars:
  // --n-bezier
  // --n-color
  // --n-font-size
  // --n-border-radius
  // --n-height
  // --n-padding-left
  // --n-padding-right
  // --n-text-color
  // --n-text-color-disabled
  // --n-caret-color
  // --n-text-decoration-color
  // --n-border
  // --n-border-disabled
  // --n-border-hover
  // --n-border-focus
  // --n-placeholder-color
  // --n-placeholder-color-disabled
  // --n-line-height-textarea
  // --n-color-disabled
  // --n-color-focus
  // --n-box-shadow-focus
  // --n-clear-color
  // --n-clear-size
  // --n-clear-color-hover
  // --n-clear-color-pressed
  // --n-suffix-text-color
  // --n-icon-color
  // --n-icon-color-hover
  // --n-icon-color-pressed
  // --n-icon-color-disabled
  // --n-count-text-color
  // --n-count-text-color-disabled
  // --n-loading-color
  // ...form item vars
  var style$1l = cB('input', `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
  // common
  cE('input, textarea', `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `), cE('input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder', `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `), cE('input-el, textarea-el', `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1('&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb', `
 width: 0;
 height: 0;
 display: none;
 `), c$1('&::placeholder', `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1('&:-webkit-autofill ~', [cE('placeholder', 'display: none;')])]), cM('round', [cNotM('textarea', 'border-radius: calc(var(--n-height) / 2);')]), cE('placeholder', `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1('span', `
 width: 100%;
 display: inline-block;
 `)]), cM('textarea', [cE('placeholder', 'overflow: visible;')]), cNotM('autosize', 'width: 100%;'), cM('autosize', [cE('textarea-el, input-el', `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
  // input
  cB('input-wrapper', `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `), cE('input-mirror', `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `), cE('input-el', `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1('&[type=password]::-ms-reveal', 'display: none;'), c$1('+', [cE('placeholder', `
 display: flex;
 align-items: center; 
 `)])]), cNotM('textarea', [cE('placeholder', 'white-space: nowrap;')]), cE('eye', `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `),
  // textarea
  cM('textarea', 'width: 100%;', [cB('input-word-count', `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM('resizable', [cB('input-wrapper', `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE('textarea-el, textarea-mirror, placeholder', `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), cE('textarea-mirror', `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
  // pair
  cM('pair', [cE('input-el, placeholder', 'text-align: center;'), cE('separator', `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB('icon', `
 color: var(--n-icon-color);
 `), cB('base-icon', `
 color: var(--n-icon-color);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE('border', 'border: var(--n-border-disabled);'), cE('input-el, textarea-el', `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE('placeholder', 'color: var(--n-placeholder-color-disabled);'), cE('separator', 'color: var(--n-text-color-disabled);', [cB('icon', `
 color: var(--n-icon-color-disabled);
 `), cB('base-icon', `
 color: var(--n-icon-color-disabled);
 `)]), cB('input-word-count', `
 color: var(--n-count-text-color-disabled);
 `), cE('suffix, prefix', 'color: var(--n-text-color-disabled);', [cB('icon', `
 color: var(--n-icon-color-disabled);
 `), cB('internal-icon', `
 color: var(--n-icon-color-disabled);
 `)])]), cNotM('disabled', [cE('eye', `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1('&:hover', `
 color: var(--n-icon-color-hover);
 `), c$1('&:active', `
 color: var(--n-icon-color-pressed);
 `)]), c$1('&:hover', [cE('state-border', 'border: var(--n-border-hover);')]), cM('focus', 'background-color: var(--n-color-focus);', [cE('state-border', `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cE('border, state-border', `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE('state-border', `
 border-color: #0000;
 z-index: 1;
 `), cE('prefix', 'margin-right: 4px;'), cE('suffix', `
 margin-left: 4px;
 `), cE('suffix, prefix', `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB('base-loading', `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB('base-clear', `
 font-size: var(--n-icon-size);
 `, [cE('placeholder', [cB('base-icon', `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1('>', [cB('icon', `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB('base-icon', `
 font-size: var(--n-icon-size);
 `)]), cB('input-word-count', `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `), ['warning', 'error'].map(status => cM(`${status}-status`, [cNotM('disabled', [cB('base-loading', `
 color: var(--n-loading-color-${status})
 `), cE('input-el, textarea-el', `
 caret-color: var(--n-caret-color-${status});
 `), cE('state-border', `
 border: var(--n-border-${status});
 `), c$1('&:hover', [cE('state-border', `
 border: var(--n-border-hover-${status});
 `)]), c$1('&:focus', `
 background-color: var(--n-color-focus-${status});
 `, [cE('state-border', `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM('focus', `
 background-color: var(--n-color-focus-${status});
 `, [cE('state-border', `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]);
  const safariStyle = cB('input', [cM('disabled', [cE('input-el, textarea-el', `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);

  const inputProps = Object.assign(Object.assign({}, useTheme.props), { bordered: {
          type: Boolean,
          default: undefined
      }, type: {
          type: String,
          default: 'text'
      }, placeholder: [Array, String], defaultValue: {
          type: [String, Array],
          default: null
      }, value: [String, Array], disabled: {
          type: Boolean,
          default: undefined
      }, size: String, rows: {
          type: [Number, String],
          default: 3
      }, round: Boolean, minlength: [String, Number], maxlength: [String, Number], clearable: Boolean, autosize: {
          type: [Boolean, Object],
          default: false
      }, pair: Boolean, separator: String, readonly: {
          type: [String, Boolean],
          default: false
      }, passivelyActivated: Boolean, showPasswordOn: String, stateful: {
          type: Boolean,
          default: true
      }, autofocus: Boolean, inputProps: Object, resizable: {
          type: Boolean,
          default: true
      }, showCount: Boolean, loading: {
          type: Boolean,
          default: undefined
      }, allowInput: Function, renderCount: Function, onMousedown: Function, onKeydown: Function, onKeyup: [Function, Array], onInput: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClick: [Function, Array], onChange: [Function, Array], onClear: [Function, Array], countGraphemes: Function, status: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 
      /** private */
      textDecoration: [String, Array], attrSize: {
          type: Number,
          default: 20
      }, onInputBlur: [Function, Array], onInputFocus: [Function, Array], onDeactivate: [Function, Array], onActivate: [Function, Array], onWrapperFocus: [Function, Array], onWrapperBlur: [Function, Array], internalDeactivateOnEnter: Boolean, internalForceFocus: Boolean, internalLoadingBeforeSuffix: {
          type: Boolean,
          default: true
      }, 
      /** deprecated */
      showPasswordToggle: Boolean });
  var NInput = defineComponent({
      name: 'Input',
      props: inputProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Input', '-input', style$1l, inputLight$1, props, mergedClsPrefixRef);
          if (isSafari) {
              useStyle('-input-safari', safariStyle, mergedClsPrefixRef);
          }
          // dom refs
          const wrapperElRef = ref(null);
          const textareaElRef = ref(null);
          const textareaMirrorElRef = ref(null);
          const inputMirrorElRef = ref(null);
          const inputElRef = ref(null);
          const inputEl2Ref = ref(null);
          const currentFocusedInputRef = ref(null);
          const focusedInputCursorControl = useCursor(currentFocusedInputRef);
          const textareaScrollbarInstRef = ref(null);
          // local
          const { localeRef } = useLocale('Input');
          // value
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          // form-item
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          // states
          const focusedRef = ref(false);
          const hoverRef = ref(false);
          const isComposingRef = ref(false);
          const activatedRef = ref(false);
          let syncSource = null;
          // placeholder
          const mergedPlaceholderRef = computed(() => {
              const { placeholder, pair } = props;
              if (pair) {
                  if (Array.isArray(placeholder)) {
                      return placeholder;
                  }
                  else if (placeholder === undefined) {
                      return ['', ''];
                  }
                  return [placeholder, placeholder];
              }
              else if (placeholder === undefined) {
                  return [localeRef.value.placeholder];
              }
              else {
                  return [placeholder];
              }
          });
          const showPlaceholder1Ref = computed(() => {
              const { value: isComposing } = isComposingRef;
              const { value: mergedValue } = mergedValueRef;
              const { value: mergedPlaceholder } = mergedPlaceholderRef;
              return (!isComposing &&
                  (isEmptyInputValue(mergedValue) ||
                      (Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0]))) &&
                  mergedPlaceholder[0]);
          });
          const showPlaceholder2Ref = computed(() => {
              const { value: isComposing } = isComposingRef;
              const { value: mergedValue } = mergedValueRef;
              const { value: mergedPlaceholder } = mergedPlaceholderRef;
              return (!isComposing &&
                  mergedPlaceholder[1] &&
                  (isEmptyInputValue(mergedValue) ||
                      (Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]))));
          });
          // focus
          const mergedFocusRef = useMemo(() => {
              return props.internalForceFocus || focusedRef.value;
          });
          // clear
          const showClearButton = useMemo(() => {
              if (mergedDisabledRef.value ||
                  props.readonly ||
                  !props.clearable ||
                  (!mergedFocusRef.value && !hoverRef.value)) {
                  return false;
              }
              const { value: mergedValue } = mergedValueRef;
              const { value: mergedFocus } = mergedFocusRef;
              if (props.pair) {
                  return (!!(Array.isArray(mergedValue) &&
                      (mergedValue[0] || mergedValue[1])) &&
                      (hoverRef.value || mergedFocus));
              }
              else {
                  return !!mergedValue && (hoverRef.value || mergedFocus);
              }
          });
          // passwordVisible
          const mergedShowPasswordOnRef = computed(() => {
              const { showPasswordOn } = props;
              if (showPasswordOn) {
                  return showPasswordOn;
              }
              if (props.showPasswordToggle)
                  return 'click';
              return undefined;
          });
          const passwordVisibleRef = ref(false);
          // text-decoration
          const textDecorationStyleRef = computed(() => {
              const { textDecoration } = props;
              if (!textDecoration)
                  return ['', ''];
              if (Array.isArray(textDecoration)) {
                  return textDecoration.map((v) => ({
                      textDecoration: v
                  }));
              }
              return [
                  {
                      textDecoration
                  }
              ];
          });
          const textAreaScrollContainerWidthRef = ref(undefined);
          // textarea autosize
          const updateTextAreaStyle = () => {
              var _a, _b;
              if (props.type === 'textarea') {
                  const { autosize } = props;
                  if (autosize) {
                      textAreaScrollContainerWidthRef.value =
                          (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
                  }
                  if (!textareaElRef.value)
                      return;
                  if (typeof autosize === 'boolean')
                      return;
                  const { paddingTop: stylePaddingTop, paddingBottom: stylePaddingBottom, lineHeight: styleLineHeight } = window.getComputedStyle(textareaElRef.value);
                  const paddingTop = Number(stylePaddingTop.slice(0, -2));
                  const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
                  const lineHeight = Number(styleLineHeight.slice(0, -2));
                  const { value: textareaMirrorEl } = textareaMirrorElRef;
                  if (!textareaMirrorEl)
                      return;
                  if (autosize.minRows) {
                      const minRows = Math.max(autosize.minRows, 1);
                      const styleMinHeight = `${paddingTop + paddingBottom + lineHeight * minRows}px`;
                      textareaMirrorEl.style.minHeight = styleMinHeight;
                  }
                  if (autosize.maxRows) {
                      const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight * autosize.maxRows}px`;
                      textareaMirrorEl.style.maxHeight = styleMaxHeight;
                  }
              }
          };
          // word count
          const maxlengthRef = computed(() => {
              const { maxlength } = props;
              return maxlength === undefined ? undefined : Number(maxlength);
          });
          onMounted(() => {
              // sync mirror if is not pair
              const { value } = mergedValueRef;
              if (!Array.isArray(value)) {
                  syncMirror(value);
              }
          });
          // other methods
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const vm = getCurrentInstance().proxy;
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onInput } = props;
              const { nTriggerFormInput } = formItem;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onInput)
                  call(onInput, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
          }
          function doChange(value) {
              const { onChange } = props;
              const { nTriggerFormChange } = formItem;
              if (onChange)
                  call(onChange, value);
              uncontrolledValueRef.value = value;
              nTriggerFormChange();
          }
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function doClear(e) {
              const { onClear } = props;
              if (onClear)
                  call(onClear, e);
          }
          function doUpdateValueBlur(e) {
              const { onInputBlur } = props;
              if (onInputBlur)
                  call(onInputBlur, e);
          }
          function doUpdateValueFocus(e) {
              const { onInputFocus } = props;
              if (onInputFocus)
                  call(onInputFocus, e);
          }
          function doDeactivate() {
              const { onDeactivate } = props;
              if (onDeactivate)
                  call(onDeactivate);
          }
          function doActivate() {
              const { onActivate } = props;
              if (onActivate)
                  call(onActivate);
          }
          function doClick(e) {
              const { onClick } = props;
              if (onClick)
                  call(onClick, e);
          }
          function doWrapperFocus(e) {
              const { onWrapperFocus } = props;
              if (onWrapperFocus)
                  call(onWrapperFocus, e);
          }
          function doWrapperBlur(e) {
              const { onWrapperBlur } = props;
              if (onWrapperBlur)
                  call(onWrapperBlur, e);
          }
          // methods
          function handleCompositionStart() {
              isComposingRef.value = true;
          }
          function handleCompositionEnd(e) {
              isComposingRef.value = false;
              if (e.target === inputEl2Ref.value) {
                  handleInput(e, 1);
              }
              else {
                  handleInput(e, 0);
              }
          }
          function handleInput(e, index = 0, event = 'input') {
              const targetValue = e.target.value;
              syncMirror(targetValue);
              if (e instanceof InputEvent && !e.isComposing) {
                  isComposingRef.value = false;
              }
              if (props.type === 'textarea') {
                  const { value: textareaScrollbarInst } = textareaScrollbarInstRef;
                  if (textareaScrollbarInst) {
                      textareaScrollbarInst.syncUnifiedContainer();
                  }
              }
              syncSource = targetValue;
              if (isComposingRef.value)
                  return;
              focusedInputCursorControl.recordCursor();
              const isIncomingValueValid = allowInput(targetValue);
              if (isIncomingValueValid) {
                  if (!props.pair) {
                      event === 'input' ? doUpdateValue(targetValue) : doChange(targetValue);
                  }
                  else {
                      let { value } = mergedValueRef;
                      if (!Array.isArray(value)) {
                          value = ['', ''];
                      }
                      else {
                          value = [value[0], value[1]];
                      }
                      value[index] = targetValue;
                      event === 'input' ? doUpdateValue(value) : doChange(value);
                  }
              }
              // force update to sync input's view with value
              // if not set, after input, input value won't sync with dom input value
              vm.$forceUpdate();
              if (!isIncomingValueValid) {
                  void nextTick(focusedInputCursorControl.restoreCursor);
              }
          }
          function allowInput(value) {
              const { countGraphemes, maxlength, minlength } = props;
              if (countGraphemes) {
                  let graphemesCount;
                  if (maxlength !== undefined) {
                      if (graphemesCount === undefined) {
                          graphemesCount = countGraphemes(value);
                      }
                      if (graphemesCount > Number(maxlength))
                          return false;
                  }
                  if (minlength !== undefined) {
                      if (graphemesCount === undefined) {
                          graphemesCount = countGraphemes(value);
                      }
                      if (graphemesCount < Number(maxlength))
                          return false;
                  }
              }
              const { allowInput } = props;
              if (typeof allowInput === 'function') {
                  return allowInput(value);
              }
              return true;
          }
          function handleInputBlur(e) {
              doUpdateValueBlur(e);
              if (e.relatedTarget === wrapperElRef.value) {
                  doDeactivate();
              }
              if (!(e.relatedTarget !== null &&
                  (e.relatedTarget === inputElRef.value ||
                      e.relatedTarget === inputEl2Ref.value ||
                      e.relatedTarget === textareaElRef.value))) {
                  activatedRef.value = false;
              }
              dealWithEvent(e, 'blur');
              currentFocusedInputRef.value = null;
          }
          function handleInputFocus(e, index) {
              doUpdateValueFocus(e);
              focusedRef.value = true;
              activatedRef.value = true;
              doActivate();
              dealWithEvent(e, 'focus');
              if (index === 0) {
                  currentFocusedInputRef.value = inputElRef.value;
              }
              else if (index === 1) {
                  currentFocusedInputRef.value = inputEl2Ref.value;
              }
              else if (index === 2) {
                  currentFocusedInputRef.value = textareaElRef.value;
              }
          }
          function handleWrapperBlur(e) {
              if (props.passivelyActivated) {
                  doWrapperBlur(e);
                  dealWithEvent(e, 'blur');
              }
          }
          function handleWrapperFocus(e) {
              if (props.passivelyActivated) {
                  focusedRef.value = true;
                  doWrapperFocus(e);
                  dealWithEvent(e, 'focus');
              }
          }
          function dealWithEvent(e, type) {
              if (e.relatedTarget !== null &&
                  (e.relatedTarget === inputElRef.value ||
                      e.relatedTarget === inputEl2Ref.value ||
                      e.relatedTarget === textareaElRef.value ||
                      e.relatedTarget === wrapperElRef.value)) ;
              else {
                  if (type === 'focus') {
                      doFocus(e);
                      focusedRef.value = true;
                  }
                  else if (type === 'blur') {
                      doBlur(e);
                      focusedRef.value = false;
                  }
              }
          }
          function handleChange(e, index) {
              handleInput(e, index, 'change');
          }
          function handleClick(e) {
              doClick(e);
          }
          function handleClear(e) {
              doClear(e);
              if (props.pair) {
                  doUpdateValue(['', '']);
                  doChange(['', '']);
              }
              else {
                  doUpdateValue('');
                  doChange('');
              }
          }
          function handleMouseDown(e) {
              const { onMousedown } = props;
              if (onMousedown)
                  onMousedown(e);
              const { tagName } = e.target;
              if (tagName !== 'INPUT' && tagName !== 'TEXTAREA') {
                  if (props.resizable) {
                      const { value: wrapperEl } = wrapperElRef;
                      if (wrapperEl) {
                          const { left, top, width, height } = wrapperEl.getBoundingClientRect();
                          const resizeHandleSize = 14;
                          if (left + width - resizeHandleSize < e.clientX &&
                              e.clientX < left + width &&
                              top + height - resizeHandleSize < e.clientY &&
                              e.clientY < top + height) {
                              // touching resize handle, just let it go.
                              // resize won't take focus, maybe there is a better way to do this.
                              // hope someone can figure out a better solution
                              return;
                          }
                      }
                  }
                  e.preventDefault();
                  if (!focusedRef.value) {
                      focus();
                  }
              }
          }
          function handleMouseEnter() {
              var _a;
              hoverRef.value = true;
              if (props.type === 'textarea') {
                  (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
              }
          }
          function handleMouseLeave() {
              var _a;
              hoverRef.value = false;
              if (props.type === 'textarea') {
                  (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
              }
          }
          function handlePasswordToggleClick() {
              if (mergedDisabledRef.value)
                  return;
              if (mergedShowPasswordOnRef.value !== 'click')
                  return;
              passwordVisibleRef.value = !passwordVisibleRef.value;
          }
          function handlePasswordToggleMousedown(e) {
              if (mergedDisabledRef.value)
                  return;
              e.preventDefault();
              const preventDefaultOnce = (e) => {
                  e.preventDefault();
                  off('mouseup', document, preventDefaultOnce);
              };
              on('mouseup', document, preventDefaultOnce);
              if (mergedShowPasswordOnRef.value !== 'mousedown')
                  return;
              passwordVisibleRef.value = true;
              const hidePassword = () => {
                  passwordVisibleRef.value = false;
                  off('mouseup', document, hidePassword);
              };
              on('mouseup', document, hidePassword);
          }
          function handleWrapperKeyup(e) {
              if (props.onKeyup)
                  call(props.onKeyup, e);
          }
          function handleWrapperKeydown(e) {
              if (props.onKeydown)
                  call(props.onKeydown, e);
              switch (e.key) {
                  case 'Escape':
                      handleWrapperKeydownEsc();
                      break;
                  case 'Enter':
                      handleWrapperKeydownEnter(e);
                      break;
              }
          }
          function handleWrapperKeydownEnter(e) {
              var _a, _b;
              if (props.passivelyActivated) {
                  const { value: focused } = activatedRef;
                  if (focused) {
                      if (props.internalDeactivateOnEnter) {
                          handleWrapperKeydownEsc();
                      }
                      return;
                  }
                  e.preventDefault();
                  if (props.type === 'textarea') {
                      (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                  }
                  else {
                      (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
                  }
              }
          }
          function handleWrapperKeydownEsc() {
              if (props.passivelyActivated) {
                  activatedRef.value = false;
                  void nextTick(() => {
                      var _a;
                      (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                  });
              }
          }
          function focus() {
              var _a, _b, _c;
              if (mergedDisabledRef.value)
                  return;
              if (props.passivelyActivated) {
                  (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              }
              else {
                  (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
                  (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
              }
          }
          function blur() {
              var _a;
              if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
                  document.activeElement.blur();
              }
          }
          function select() {
              var _a, _b;
              (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
              (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
          }
          function activate() {
              if (mergedDisabledRef.value)
                  return;
              if (textareaElRef.value)
                  textareaElRef.value.focus();
              else if (inputElRef.value)
                  inputElRef.value.focus();
          }
          function deactivate() {
              const { value: wrapperEl } = wrapperElRef;
              if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) &&
                  wrapperEl !== document.activeElement) {
                  handleWrapperKeydownEsc();
              }
          }
          function scrollTo(options) {
              if (props.type === 'textarea') {
                  const { value: textareaEl } = textareaElRef;
                  textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
              }
              else {
                  const { value: inputEl } = inputElRef;
                  inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
              }
          }
          function syncMirror(value) {
              const { type, pair, autosize } = props;
              if (!pair && autosize) {
                  if (type === 'textarea') {
                      const { value: textareaMirrorEl } = textareaMirrorElRef;
                      if (textareaMirrorEl) {
                          textareaMirrorEl.textContent = (value !== null && value !== void 0 ? value : '') + '\r\n';
                      }
                  }
                  else {
                      const { value: inputMirrorEl } = inputMirrorElRef;
                      if (inputMirrorEl) {
                          if (value) {
                              inputMirrorEl.textContent = value;
                          }
                          else {
                              inputMirrorEl.innerHTML = '&nbsp;';
                          }
                      }
                  }
              }
          }
          function handleTextAreaMirrorResize() {
              updateTextAreaStyle();
          }
          const placeholderStyleRef = ref({
              top: '0'
          });
          function handleTextAreaScroll(e) {
              var _a;
              const { scrollTop } = e.target;
              placeholderStyleRef.value.top = `${-scrollTop}px`;
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
          }
          let stopWatchMergedValue1 = null;
          watchEffect(() => {
              const { autosize, type } = props;
              if (autosize && type === 'textarea') {
                  stopWatchMergedValue1 = watch(mergedValueRef, (value) => {
                      if (!Array.isArray(value) && value !== syncSource) {
                          syncMirror(value);
                      }
                  });
              }
              else {
                  stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
              }
          });
          let stopWatchMergedValue2 = null;
          watchEffect(() => {
              if (props.type === 'textarea') {
                  stopWatchMergedValue2 = watch(mergedValueRef, (value) => {
                      var _a;
                      if (!Array.isArray(value) && value !== syncSource) {
                          (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
                      }
                  });
              }
              else {
                  stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
              }
          });
          provide(inputInjectionKey, {
              mergedValueRef,
              maxlengthRef,
              mergedClsPrefixRef,
              countGraphemesRef: toRef(props, 'countGraphemes')
          });
          const exposedProps = {
              wrapperElRef,
              inputElRef,
              textareaElRef,
              isCompositing: isComposingRef,
              focus,
              blur,
              select,
              deactivate,
              activate,
              scrollTo
          };
          const rtlEnabledRef = useRtl('Input', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { value: size } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut }, self: { color, borderRadius, textColor, caretColor, caretColorError, caretColorWarning, textDecorationColor, border, borderDisabled, borderHover, borderFocus, placeholderColor, placeholderColorDisabled, lineHeightTextarea, colorDisabled, colorFocus, textColorDisabled, boxShadowFocus, iconSize, colorFocusWarning, boxShadowFocusWarning, borderWarning, borderFocusWarning, borderHoverWarning, colorFocusError, boxShadowFocusError, borderError, borderFocusError, borderHoverError, clearSize, clearColor, clearColorHover, clearColorPressed, iconColor, iconColorDisabled, suffixTextColor, countTextColor, countTextColorDisabled, iconColorHover, iconColorPressed, loadingColor, loadingColorError, loadingColorWarning, [createKey('padding', size)]: padding, [createKey('fontSize', size)]: fontSize, [createKey('height', size)]: height } } = themeRef.value;
              const { left: paddingLeft, right: paddingRight } = getMargin(padding);
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-count-text-color': countTextColor,
                  '--n-count-text-color-disabled': countTextColorDisabled,
                  '--n-color': color,
                  '--n-font-size': fontSize,
                  '--n-border-radius': borderRadius,
                  '--n-height': height,
                  '--n-padding-left': paddingLeft,
                  '--n-padding-right': paddingRight,
                  '--n-text-color': textColor,
                  '--n-caret-color': caretColor,
                  '--n-text-decoration-color': textDecorationColor,
                  '--n-border': border,
                  '--n-border-disabled': borderDisabled,
                  '--n-border-hover': borderHover,
                  '--n-border-focus': borderFocus,
                  '--n-placeholder-color': placeholderColor,
                  '--n-placeholder-color-disabled': placeholderColorDisabled,
                  '--n-icon-size': iconSize,
                  '--n-line-height-textarea': lineHeightTextarea,
                  '--n-color-disabled': colorDisabled,
                  '--n-color-focus': colorFocus,
                  '--n-text-color-disabled': textColorDisabled,
                  '--n-box-shadow-focus': boxShadowFocus,
                  '--n-loading-color': loadingColor,
                  // form warning
                  '--n-caret-color-warning': caretColorWarning,
                  '--n-color-focus-warning': colorFocusWarning,
                  '--n-box-shadow-focus-warning': boxShadowFocusWarning,
                  '--n-border-warning': borderWarning,
                  '--n-border-focus-warning': borderFocusWarning,
                  '--n-border-hover-warning': borderHoverWarning,
                  '--n-loading-color-warning': loadingColorWarning,
                  // form error
                  '--n-caret-color-error': caretColorError,
                  '--n-color-focus-error': colorFocusError,
                  '--n-box-shadow-focus-error': boxShadowFocusError,
                  '--n-border-error': borderError,
                  '--n-border-focus-error': borderFocusError,
                  '--n-border-hover-error': borderHoverError,
                  '--n-loading-color-error': loadingColorError,
                  // clear-button
                  '--n-clear-color': clearColor,
                  '--n-clear-size': clearSize,
                  '--n-clear-color-hover': clearColorHover,
                  '--n-clear-color-pressed': clearColorPressed,
                  '--n-icon-color': iconColor,
                  '--n-icon-color-hover': iconColorHover,
                  '--n-icon-color-pressed': iconColorPressed,
                  '--n-icon-color-disabled': iconColorDisabled,
                  '--n-suffix-text-color': suffixTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('input', computed(() => {
                  const { value: size } = mergedSizeRef;
                  return size[0];
              }), cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedProps), { 
              // DOM ref
              wrapperElRef,
              inputElRef,
              inputMirrorElRef,
              inputEl2Ref,
              textareaElRef,
              textareaMirrorElRef,
              textareaScrollbarInstRef, 
              // value
              rtlEnabled: rtlEnabledRef, uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, passwordVisible: passwordVisibleRef, mergedPlaceholder: mergedPlaceholderRef, showPlaceholder1: showPlaceholder1Ref, showPlaceholder2: showPlaceholder2Ref, mergedFocus: mergedFocusRef, isComposing: isComposingRef, activated: activatedRef, showClearButton, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, textDecorationStyle: textDecorationStyleRef, mergedClsPrefix: mergedClsPrefixRef, mergedBordered: mergedBorderedRef, mergedShowPasswordOn: mergedShowPasswordOnRef, placeholderStyle: placeholderStyleRef, mergedStatus: mergedStatusRef, textAreaScrollContainerWidth: textAreaScrollContainerWidthRef, 
              // methods
              handleTextAreaScroll,
              handleCompositionStart,
              handleCompositionEnd,
              handleInput,
              handleInputBlur,
              handleInputFocus,
              handleWrapperBlur,
              handleWrapperFocus,
              handleMouseEnter,
              handleMouseLeave,
              handleMouseDown,
              handleChange,
              handleClick,
              handleClear,
              handlePasswordToggleClick,
              handlePasswordToggleMousedown,
              handleWrapperKeydown,
              handleWrapperKeyup,
              handleTextAreaMirrorResize, getTextareaScrollContainer: () => {
                  return textareaElRef.value;
              }, mergedTheme: themeRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a, _b;
          const { mergedClsPrefix, mergedStatus, themeClass, type, countGraphemes, onRender } = this;
          const $slots = this.$slots;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "wrapperElRef", class: [
                  `${mergedClsPrefix}-input`,
                  themeClass,
                  mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`,
                  {
                      [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
                      [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
                      [`${mergedClsPrefix}-input--textarea`]: type === 'textarea',
                      [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
                      [`${mergedClsPrefix}-input--autosize`]: this.autosize,
                      [`${mergedClsPrefix}-input--round`]: this.round && !(type === 'textarea'),
                      [`${mergedClsPrefix}-input--pair`]: this.pair,
                      [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
                      [`${mergedClsPrefix}-input--stateful`]: this.stateful
                  }
              ], style: this.cssVars, tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated
                  ? 0
                  : undefined, onFocus: this.handleWrapperFocus, onBlur: this.handleWrapperBlur, onClick: this.handleClick, onMousedown: this.handleMouseDown, onMouseenter: this.handleMouseEnter, onMouseleave: this.handleMouseLeave, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd, onKeyup: this.handleWrapperKeyup, onKeydown: this.handleWrapperKeydown },
              h("div", { class: `${mergedClsPrefix}-input-wrapper` },
                  resolveWrappedSlot($slots.prefix, (children) => children && (h("div", { class: `${mergedClsPrefix}-input__prefix` }, children))),
                  type === 'textarea' ? (h(NScrollbar, { ref: "textareaScrollbarInstRef", class: `${mergedClsPrefix}-input__textarea`, container: this.getTextareaScrollContainer, triggerDisplayManually: true, useUnifiedContainer: true, internalHoistYRail: true }, {
                      default: () => {
                          var _a, _b;
                          const { textAreaScrollContainerWidth } = this;
                          const scrollContainerWidthStyle = {
                              width: this.autosize &&
                                  textAreaScrollContainerWidth &&
                                  `${textAreaScrollContainerWidth}px`
                          };
                          return (h(Fragment, null,
                              h("textarea", Object.assign({}, this.inputProps, { ref: "textareaElRef", class: [
                                      `${mergedClsPrefix}-input__textarea-el`,
                                      (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class
                                  ], autofocus: this.autofocus, rows: Number(this.rows), placeholder: this.placeholder, value: this.mergedValue, disabled: this.mergedDisabled, maxlength: countGraphemes ? undefined : this.maxlength, minlength: countGraphemes ? undefined : this.minlength, readonly: this.readonly, tabindex: this.passivelyActivated && !this.activated
                                      ? -1
                                      : undefined, style: [
                                      this.textDecorationStyle[0],
                                      (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style,
                                      scrollContainerWidthStyle
                                  ], onBlur: this.handleInputBlur, onFocus: (e) => {
                                      this.handleInputFocus(e, 2);
                                  }, onInput: this.handleInput, onChange: this.handleChange, onScroll: this.handleTextAreaScroll })),
                              this.showPlaceholder1 ? (h("div", { class: `${mergedClsPrefix}-input__placeholder`, style: [
                                      this.placeholderStyle,
                                      scrollContainerWidthStyle
                                  ], key: "placeholder" }, this.mergedPlaceholder[0])) : null,
                              this.autosize ? (h(VResizeObserver, { onResize: this.handleTextAreaMirrorResize }, {
                                  default: () => (h("div", { ref: "textareaMirrorElRef", class: `${mergedClsPrefix}-input__textarea-mirror`, key: "mirror" }))
                              })) : null));
                      }
                  })) : (h("div", { class: `${mergedClsPrefix}-input__input` },
                      h("input", Object.assign({ type: type === 'password' &&
                              this.mergedShowPasswordOn &&
                              this.passwordVisible
                              ? 'text'
                              : type }, this.inputProps, { ref: "inputElRef", class: [
                              `${mergedClsPrefix}-input__input-el`,
                              (_a = this.inputProps) === null || _a === void 0 ? void 0 : _a.class
                          ], style: [
                              this.textDecorationStyle[0],
                              (_b = this.inputProps) === null || _b === void 0 ? void 0 : _b.style
                          ], tabindex: this.passivelyActivated && !this.activated ? -1 : undefined, placeholder: this.mergedPlaceholder[0], disabled: this.mergedDisabled, maxlength: countGraphemes ? undefined : this.maxlength, minlength: countGraphemes ? undefined : this.minlength, value: Array.isArray(this.mergedValue)
                              ? this.mergedValue[0]
                              : this.mergedValue, readonly: this.readonly, autofocus: this.autofocus, size: this.attrSize, onBlur: this.handleInputBlur, onFocus: (e) => {
                              this.handleInputFocus(e, 0);
                          }, onInput: (e) => {
                              this.handleInput(e, 0);
                          }, onChange: (e) => {
                              this.handleChange(e, 0);
                          } })),
                      this.showPlaceholder1 ? (h("div", { class: `${mergedClsPrefix}-input__placeholder` },
                          h("span", null, this.mergedPlaceholder[0]))) : null,
                      this.autosize ? (h("div", { class: `${mergedClsPrefix}-input__input-mirror`, key: "mirror", ref: "inputMirrorElRef" }, "\u00A0")) : null)),
                  !this.pair &&
                      resolveWrappedSlot($slots.suffix, (children) => {
                          return children ||
                              this.clearable ||
                              this.showCount ||
                              this.mergedShowPasswordOn ||
                              this.loading !== undefined ? (h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                              resolveWrappedSlot($slots['clear-icon-placeholder'], (children) => {
                                  return ((this.clearable || children) && (h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                                      placeholder: () => children,
                                      icon: () => { var _a, _b; return (_b = (_a = this.$slots)['clear-icon']) === null || _b === void 0 ? void 0 : _b.call(_a); }
                                  })));
                              }),
                              !this.internalLoadingBeforeSuffix ? children : null,
                              this.loading !== undefined ? (h(NBaseSuffix, { clsPrefix: mergedClsPrefix, loading: this.loading, showArrow: false, showClear: false, style: this.cssVars })) : null,
                              this.internalLoadingBeforeSuffix ? children : null,
                              this.showCount && this.type !== 'textarea' ? (h(WordCount, null, {
                                  default: (props) => { var _a; return (_a = $slots.count) === null || _a === void 0 ? void 0 : _a.call($slots, props); }
                              })) : null,
                              this.mergedShowPasswordOn && this.type === 'password' ? (h("div", { class: `${mergedClsPrefix}-input__eye`, onMousedown: this.handlePasswordToggleMousedown, onClick: this.handlePasswordToggleClick }, this.passwordVisible
                                  ? resolveSlot($slots['password-visible-icon'], () => [
                                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(EyeIcon, null) })
                                  ])
                                  : resolveSlot($slots['password-invisible-icon'], () => [
                                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(EyeOffIcon, null) })
                                  ]))) : null
                          ])) : null;
                      })),
              this.pair ? (h("span", { class: `${mergedClsPrefix}-input__separator` }, resolveSlot($slots.separator, () => [this.separator]))) : null,
              this.pair ? (h("div", { class: `${mergedClsPrefix}-input-wrapper` },
                  h("div", { class: `${mergedClsPrefix}-input__input` },
                      h("input", { ref: "inputEl2Ref", type: this.type, class: `${mergedClsPrefix}-input__input-el`, tabindex: this.passivelyActivated && !this.activated ? -1 : undefined, placeholder: this.mergedPlaceholder[1], disabled: this.mergedDisabled, maxlength: countGraphemes ? undefined : this.maxlength, minlength: countGraphemes ? undefined : this.minlength, value: Array.isArray(this.mergedValue)
                              ? this.mergedValue[1]
                              : undefined, readonly: this.readonly, style: this.textDecorationStyle[1], onBlur: this.handleInputBlur, onFocus: (e) => {
                              this.handleInputFocus(e, 1);
                          }, onInput: (e) => {
                              this.handleInput(e, 1);
                          }, onChange: (e) => {
                              this.handleChange(e, 1);
                          } }),
                      this.showPlaceholder2 ? (h("div", { class: `${mergedClsPrefix}-input__placeholder` },
                          h("span", null, this.mergedPlaceholder[1]))) : null),
                  resolveWrappedSlot($slots.suffix, (children) => {
                      return ((this.clearable || children) && (h("div", { class: `${mergedClsPrefix}-input__suffix` }, [
                          this.clearable && (h(NBaseClear, { clsPrefix: mergedClsPrefix, show: this.showClearButton, onClear: this.handleClear }, {
                              icon: () => { var _a; return (_a = $slots['clear-icon']) === null || _a === void 0 ? void 0 : _a.call($slots); },
                              placeholder: () => { var _a; return (_a = $slots['clear-icon-placeholder']) === null || _a === void 0 ? void 0 : _a.call($slots); }
                          })),
                          children
                      ])));
                  }))) : null,
              this.mergedBordered ? (h("div", { class: `${mergedClsPrefix}-input__border` })) : null,
              this.mergedBordered ? (h("div", { class: `${mergedClsPrefix}-input__state-border` })) : null,
              this.showCount && type === 'textarea' ? (h(WordCount, null, {
                  default: (props) => {
                      var _a;
                      const { renderCount } = this;
                      if (renderCount) {
                          return renderCount(props);
                      }
                      return (_a = $slots.count) === null || _a === void 0 ? void 0 : _a.call($slots, props);
                  }
              })) : null));
      }
  });

  var style$1k = cB('input-group', `
 display: inline-flex;
 width: 100%;
 flex-wrap: nowrap;
 vertical-align: bottom;
`, [c$1('>', [cB('input', [c$1('&:not(:last-child)', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), c$1('&:not(:first-child)', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 margin-left: -1px!important;
 `)]), cB('button', [c$1('&:not(:last-child)', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [cE('state-border, border', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)]), c$1('&:not(:first-child)', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [cE('state-border, border', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])]), c$1('*', [c$1('&:not(:last-child)', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `, [c$1('>', [cB('input', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB('base-selection', [cB('base-selection-label', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cB('base-selection-tags', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `), cE('box-shadow, border, state-border', `
 border-top-right-radius: 0!important;
 border-bottom-right-radius: 0!important;
 `)])])]), c$1('&:not(:first-child)', `
 margin-left: -1px!important;
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `, [c$1('>', [cB('input', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB('base-selection', [cB('base-selection-label', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cB('base-selection-tags', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `), cE('box-shadow, border, state-border', `
 border-top-left-radius: 0!important;
 border-bottom-left-radius: 0!important;
 `)])])])])])]);

  const inputGroupProps = {};
  var NInputGroup = defineComponent({
      name: 'InputGroup',
      props: inputGroupProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useStyle('-input-group', style$1k, mergedClsPrefixRef);
          return {
              mergedClsPrefix: mergedClsPrefixRef
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return h("div", { class: `${mergedClsPrefix}-input-group` }, this.$slots);
      }
  });

  // vars:
  // --n-bezier
  // --n-group-label-color
  // --n-border-radius
  // --n-group-label-text-color
  // --n-font-size
  // --n-height
  // --n-group-label-border
  var style$1j = cB('input-group-label', `
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 box-sizing: border-box;
 padding: 0 12px;
 display: inline-block;
 border-radius: var(--n-border-radius);
 background-color: var(--n-group-label-color);
 color: var(--n-group-label-text-color);
 font-size: var(--n-font-size);
 line-height: var(--n-height);
 height: var(--n-height);
 flex-shrink: 0;
 white-space: nowrap;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [cE('border', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-group-label-border);
 transition: border-color .3s var(--n-bezier);
 `)]);

  const inputGroupLabelProps = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: String,
          default: 'medium'
      }, bordered: {
          type: Boolean,
          default: undefined
      } });
  var InputGroupLabel = defineComponent({
      name: 'InputGroupLabel',
      props: inputGroupLabelProps,
      setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Input', '-input-group-label', style$1j, inputLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { common: { cubicBezierEaseInOut }, self: { groupLabelColor, borderRadius, groupLabelTextColor, lineHeight, groupLabelBorder, [createKey('fontSize', size)]: fontSize, [createKey('height', size)]: height } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-group-label-color': groupLabelColor,
                  '--n-group-label-border': groupLabelBorder,
                  '--n-border-radius': borderRadius,
                  '--n-group-label-text-color': groupLabelTextColor,
                  '--n-font-size': fontSize,
                  '--n-line-height': lineHeight,
                  '--n-height': height
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('input-group-label', computed(() => props.size[0]), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedBordered: mergedBorderedRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [`${mergedClsPrefix}-input-group-label`, this.themeClass], style: this.cssVars }, (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 :
              _c.call(_b),
              this.mergedBordered ? (h("div", { class: `${mergedClsPrefix}-input-group-label__border` })) : null));
      }
  });

  function self$15(vars) {
      const { boxShadow2 } = vars;
      return {
          menuBoxShadow: boxShadow2
      };
  }
  const autoCompleteLight = createTheme({
      name: 'AutoComplete',
      common: commonLight,
      peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          Input: inputLight$1
      },
      self: self$15
  });
  var autoCompleteLight$1 = autoCompleteLight;

  function mapAutoCompleteOptionsToSelectOptions(options) {
      return options.map(convertAutoCompleteOptionToSelectOption);
  }
  function convertAutoCompleteOptionToSelectOption(option) {
      var _a, _b;
      if (typeof option === 'string') {
          return {
              label: option,
              value: option
          };
      }
      else if (option.type === 'group') {
          const groupOption = {
              type: 'group',
              label: (_a = option.label) !== null && _a !== void 0 ? _a : option.name,
              value: (_b = option.value) !== null && _b !== void 0 ? _b : option.name,
              key: (option.key || option.name),
              children: option.children.map((groupOption) => convertAutoCompleteOptionToSelectOption(groupOption))
          };
          return groupOption;
      }
      else {
          return option;
      }
  }

  // vars:
  // --n-bezier
  // --n-menu-box-shadow
  var style$1i = c$1([cB('auto-complete', `
 z-index: auto;
 position: relative;
 display: inline-flex;
 width: 100%;
 `), cB('auto-complete-menu', `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: 'background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)'
  })])]);

  const autoCompleteProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, menuProps: Object, bordered: {
          type: Boolean,
          default: undefined
      }, clearable: {
          type: Boolean,
          default: undefined
      }, defaultValue: {
          type: String,
          default: null
      }, loading: {
          type: Boolean,
          default: undefined
      }, disabled: {
          type: Boolean,
          default: undefined
      }, placeholder: String, placement: {
          type: String,
          default: 'bottom-start'
      }, value: String, blurAfterSelect: Boolean, clearAfterSelect: Boolean, getShow: Function, inputProps: Object, renderOption: Function, renderLabel: Function, size: String, options: {
          type: Array,
          default: () => []
      }, zIndex: Number, status: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onSelect: [Function, Array], onBlur: [Function, Array], onFocus: [Function, Array], 
      // deprecated
      onInput: [Function, Array] });
  var AutoComplete = defineComponent({
      name: 'AutoComplete',
      props: autoCompleteProps,
      setup(props) {
          const { mergedBorderedRef, namespaceRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const triggerElRef = ref(null);
          const menuInstRef = ref(null);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const canBeActivatedRef = ref(false);
          const isComposingRef = ref(false);
          const themeRef = useTheme('AutoComplete', '-auto-complete', style$1i, autoCompleteLight$1, props, mergedClsPrefixRef);
          const selectOptionsRef = computed(() => {
              return mapAutoCompleteOptionsToSelectOptions(props.options);
          });
          const mergedShowOptionsRef = computed(() => {
              const { getShow } = props;
              if (getShow) {
                  return getShow(mergedValueRef.value || '');
              }
              return !!mergedValueRef.value;
          });
          const activeRef = computed(() => {
              return (mergedShowOptionsRef.value &&
                  canBeActivatedRef.value &&
                  !!selectOptionsRef.value.length);
          });
          const treeMateRef = computed(() => createTreeMate(selectOptionsRef.value, createTmOptions('value', 'children')));
          function doUpdateValue(value) {
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue, onInput } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onInput)
                  call(onInput, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function doSelect(value) {
              const { onSelect } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onSelect)
                  call(onSelect, value);
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function handleCompositionStart() {
              isComposingRef.value = true;
          }
          function handleCompositionEnd() {
              window.setTimeout(() => {
                  isComposingRef.value = false;
              }, 0);
          }
          function handleKeyDown(e) {
              var _a, _b, _c;
              switch (e.key) {
                  case 'Enter':
                      if (!isComposingRef.value) {
                          const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
                          if (pendingOptionTmNode) {
                              select(pendingOptionTmNode.rawNode);
                              e.preventDefault();
                          }
                      }
                      break;
                  case 'ArrowDown':
                      (_b = menuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
                      break;
                  case 'ArrowUp':
                      (_c = menuInstRef.value) === null || _c === void 0 ? void 0 : _c.prev();
                      break;
              }
          }
          function select(option) {
              if ((option === null || option === void 0 ? void 0 : option.value) !== undefined) {
                  doSelect(option.value);
                  if (props.clearAfterSelect) {
                      doUpdateValue(null);
                  }
                  else if (option.label !== undefined) {
                      doUpdateValue(option.label);
                  }
                  canBeActivatedRef.value = false;
                  if (props.blurAfterSelect) {
                      blur();
                  }
              }
          }
          function handleClear() {
              doUpdateValue(null);
          }
          function handleFocus(e) {
              canBeActivatedRef.value = true;
              doFocus(e);
          }
          function handleBlur(e) {
              canBeActivatedRef.value = false;
              doBlur(e);
          }
          function handleInput(value) {
              canBeActivatedRef.value = true;
              doUpdateValue(value);
          }
          function handleToggle(option) {
              select(option.rawNode);
          }
          function handleClickOutsideMenu(e) {
              var _a;
              if (!((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
                  canBeActivatedRef.value = false;
              }
          }
          function blur() {
              var _a, _b;
              if ((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
                  (_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.blur();
              }
          }
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { menuBoxShadow } } = themeRef.value;
              return {
                  '--n-menu-box-shadow': menuBoxShadow,
                  '--n-bezier': cubicBezierEaseInOut
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('auto-complete', undefined, cssVarsRef, props)
              : undefined;
          const inputInstRef = ref(null);
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              }
          };
          return {
              focus: exposedMethods.focus,
              blur: exposedMethods.blur,
              inputInstRef,
              uncontrolledValue: uncontrolledValueRef,
              mergedValue: mergedValueRef,
              isMounted: isMounted(),
              adjustedTo: useAdjustedTo(props),
              menuInstRef,
              triggerElRef,
              treeMate: treeMateRef,
              mergedSize: mergedSizeRef,
              mergedDisabled: mergedDisabledRef,
              active: activeRef,
              mergedStatus: mergedStatusRef,
              handleClear,
              handleFocus,
              handleBlur,
              handleInput,
              handleToggle,
              handleClickOutsideMenu,
              handleCompositionStart,
              handleCompositionEnd,
              handleKeyDown,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              mergedBordered: mergedBorderedRef,
              namespace: namespaceRef,
              mergedClsPrefix: mergedClsPrefixRef
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-auto-complete`, ref: "triggerElRef", onKeydown: this.handleKeyDown, onCompositionstart: this.handleCompositionStart, onCompositionend: this.handleCompositionEnd },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => {
                              const defaultSlot = this.$slots.default;
                              if (defaultSlot) {
                                  return getFirstSlotVNode(this.$slots, 'default', {
                                      handleInput: this.handleInput,
                                      handleFocus: this.handleFocus,
                                      handleBlur: this.handleBlur,
                                      value: this.mergedValue
                                  });
                              }
                              const { mergedTheme } = this;
                              return (h(NInput, { ref: "inputInstRef", status: this.mergedStatus, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, bordered: this.mergedBordered, value: this.mergedValue, placeholder: this.placeholder, size: this.mergedSize, disabled: this.mergedDisabled, clearable: this.clearable, loading: this.loading, inputProps: this.inputProps, onClear: this.handleClear, onFocus: this.handleFocus, onUpdateValue: this.handleInput, onBlur: this.handleBlur }, {
                                  suffix: () => { var _a, _b; return (_b = (_a = this.$slots).suffix) === null || _b === void 0 ? void 0 : _b.call(_a); },
                                  prefix: () => { var _a, _b; return (_b = (_a = this.$slots).prefix) === null || _b === void 0 ? void 0 : _b.call(_a); }
                              }));
                          }
                      }),
                      h(VFollower, { show: this.active, to: this.adjustedTo, containerClass: this.namespace, zIndex: this.zIndex, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.placement, width: "target" }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                              default: () => {
                                  var _a;
                                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                                  if (!this.active)
                                      return null;
                                  const { menuProps } = this;
                                  return withDirectives(h(NInternalSelectMenu, Object.assign({}, menuProps, { clsPrefix: mergedClsPrefix, ref: "menuInstRef", theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides
                                          .InternalSelectMenu, "auto-pending": true, class: [
                                          `${mergedClsPrefix}-auto-complete-menu`,
                                          this.themeClass,
                                          menuProps === null || menuProps === void 0 ? void 0 : menuProps.class
                                      ], style: [
                                          menuProps === null || menuProps === void 0 ? void 0 : menuProps.style,
                                          this.cssVars
                                      ], treeMate: this.treeMate, multiple: false, renderLabel: this.renderLabel, renderOption: this.renderOption, size: "medium", onToggle: this.handleToggle })), [
                                      [
                                          clickoutside$1,
                                          this.handleClickOutsideMenu,
                                          undefined,
                                          { capture: true }
                                      ]
                                  ]);
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  const isImageSupportNativeLazy = isBrowser$2 && 'loading' in document.createElement('img');

  const resolveOptionsAndHash = (options = {}) => {
      var _a;
      const { root = null } = options;
      return {
          hash: `${options.rootMargin || '0px 0px 0px 0px'}-${Array.isArray(options.threshold)
            ? options.threshold.join(',')
            : (_a = options.threshold) !== null && _a !== void 0 ? _a : '0'}`,
          options: Object.assign(Object.assign({}, options), { root: (typeof root === 'string' ? document.querySelector(root) : root) ||
                  document.documentElement })
      };
  };
  // root -> options -> [observer, elements]
  const observers = new WeakMap();
  const unobserveHandleMap = new WeakMap();
  const shouldStartLoadingRefMap = new WeakMap();
  const observeIntersection = (el, options, shouldStartLoadingRef) => {
      if (!el)
          return () => { };
      const resolvedOptionsAndHash = resolveOptionsAndHash(options);
      const { root } = resolvedOptionsAndHash.options;
      let rootObservers;
      const _rootObservers = observers.get(root);
      if (_rootObservers) {
          rootObservers = _rootObservers;
      }
      else {
          rootObservers = new Map();
          observers.set(root, rootObservers);
      }
      let observer;
      let observerAndObservedElements;
      if (rootObservers.has(resolvedOptionsAndHash.hash)) {
          observerAndObservedElements =
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              rootObservers.get(resolvedOptionsAndHash.hash);
          if (!observerAndObservedElements[1].has(el)) {
              observer = observerAndObservedElements[0];
              observerAndObservedElements[1].add(el);
              observer.observe(el);
          }
      }
      else {
          observer = new IntersectionObserver((entries) => {
              entries.forEach((entry) => {
                  if (entry.isIntersecting) {
                      const _unobserve = unobserveHandleMap.get(entry.target);
                      const _shouldStartLoadingRef = shouldStartLoadingRefMap.get(entry.target);
                      if (_unobserve)
                          _unobserve();
                      if (_shouldStartLoadingRef) {
                          _shouldStartLoadingRef.value = true;
                      }
                  }
              });
          }, resolvedOptionsAndHash.options);
          observer.observe(el);
          observerAndObservedElements = [observer, new Set([el])];
          rootObservers.set(resolvedOptionsAndHash.hash, observerAndObservedElements);
      }
      let unobservered = false;
      const unobserve = () => {
          if (unobservered)
              return;
          unobserveHandleMap.delete(el);
          shouldStartLoadingRefMap.delete(el);
          unobservered = true;
          if (observerAndObservedElements[1].has(el)) {
              observerAndObservedElements[0].unobserve(el);
              observerAndObservedElements[1].delete(el);
          }
          if (observerAndObservedElements[1].size <= 0) {
              rootObservers.delete(resolvedOptionsAndHash.hash);
          }
          if (!rootObservers.size) {
              observers.delete(root);
          }
      };
      unobserveHandleMap.set(el, unobserve);
      shouldStartLoadingRefMap.set(el, shouldStartLoadingRef);
      return unobserve;
  };

  const self$14 = (vars) => {
      const { borderRadius, avatarColor, cardColor, fontSize, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, modalColor, popoverColor } = vars;
      return {
          borderRadius,
          fontSize,
          border: `2px solid ${cardColor}`,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          heightHuge,
          color: composite(cardColor, avatarColor),
          colorModal: composite(modalColor, avatarColor),
          colorPopover: composite(popoverColor, avatarColor)
      };
  };
  const avatarLight = {
      name: 'Avatar',
      common: commonLight,
      self: self$14
  };
  var avatarLight$1 = avatarLight;

  const avatarGroupInjectionKey = createInjectionKey('n-avatar-group');

  // vars:
  // --n-font-size
  // --n-border-radius
  // --n-color
  // --n-color-modal
  // --n-color-popover
  // --n-bezier
  // --n-merged-size
  var style$1h = cB('avatar', `
 width: var(--n-merged-size);
 height: var(--n-merged-size);
 color: #FFF;
 font-size: var(--n-font-size);
 display: inline-flex;
 position: relative;
 overflow: hidden;
 text-align: center;
 border: var(--n-border);
 border-radius: var(--n-border-radius);
 --n-merged-color: var(--n-color);
 background-color: var(--n-merged-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [insideModal(c$1('&', '--n-merged-color: var(--n-color-modal);')), insidePopover(c$1('&', '--n-merged-color: var(--n-color-popover);')), c$1('img', `
 width: 100%;
 height: 100%;
 `), cE('text', `
 white-space: nowrap;
 display: inline-block;
 position: absolute;
 left: 50%;
 top: 50%;
 `), cB('icon', `
 vertical-align: bottom;
 font-size: calc(var(--n-merged-size) - 6px);
 `), cE('text', 'line-height: 1.25')]);

  const avatarProps = Object.assign(Object.assign({}, useTheme.props), { size: [String, Number], src: String, circle: {
          type: Boolean,
          default: undefined
      }, objectFit: String, round: {
          type: Boolean,
          default: undefined
      }, bordered: {
          type: Boolean,
          default: undefined
      }, onError: Function, fallbackSrc: String, intersectionObserverOptions: Object, lazy: Boolean, onLoad: Function, renderPlaceholder: Function, renderFallback: Function, imgProps: Object, 
      /** @deprecated */
      color: String });
  var NAvatar = defineComponent({
      name: 'Avatar',
      props: avatarProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const hasLoadErrorRef = ref(false);
          let memoedTextHtml = null;
          const textRef = ref(null);
          const selfRef = ref(null);
          const fitTextTransform = () => {
              const { value: textEl } = textRef;
              if (textEl) {
                  if (memoedTextHtml === null || memoedTextHtml !== textEl.innerHTML) {
                      memoedTextHtml = textEl.innerHTML;
                      const { value: selfEl } = selfRef;
                      if (selfEl) {
                          const { offsetWidth: elWidth, offsetHeight: elHeight } = selfEl;
                          const { offsetWidth: textWidth, offsetHeight: textHeight } = textEl;
                          const radix = 0.9;
                          const ratio = Math.min((elWidth / textWidth) * radix, (elHeight / textHeight) * radix, 1);
                          textEl.style.transform = `translateX(-50%) translateY(-50%) scale(${ratio})`;
                      }
                  }
              }
          };
          const NAvatarGroup = inject(avatarGroupInjectionKey, null);
          const mergedSizeRef = computed(() => {
              const { size } = props;
              if (size)
                  return size;
              const { size: avatarGroupSize } = NAvatarGroup || {};
              if (avatarGroupSize)
                  return avatarGroupSize;
              return 'medium';
          });
          const themeRef = useTheme('Avatar', '-avatar', style$1h, avatarLight$1, props, mergedClsPrefixRef);
          const TagInjection = inject(tagInjectionKey, null);
          const mergedRoundRef = computed(() => {
              if (NAvatarGroup)
                  return true;
              const { round, circle } = props;
              if (round !== undefined || circle !== undefined)
                  return round || circle;
              if (TagInjection) {
                  return TagInjection.roundRef.value;
              }
              return false;
          });
          const mergedBorderedRef = computed(() => {
              if (NAvatarGroup)
                  return true;
              return props.bordered || false;
          });
          const handleError = (e) => {
              var _a;
              if (!shouldStartLoadingRef.value)
                  return;
              hasLoadErrorRef.value = true;
              const { onError, imgProps } = props;
              (_a = imgProps === null || imgProps === void 0 ? void 0 : imgProps.onError) === null || _a === void 0 ? void 0 : _a.call(imgProps, e);
              if (onError) {
                  onError(e);
              }
          };
          watch(() => props.src, () => (hasLoadErrorRef.value = false));
          const cssVarsRef = computed(() => {
              const size = mergedSizeRef.value;
              const round = mergedRoundRef.value;
              const bordered = mergedBorderedRef.value;
              const { color: propColor } = props;
              const { self: { borderRadius, fontSize, color, border, colorModal, colorPopover }, common: { cubicBezierEaseInOut } } = themeRef.value;
              let height;
              if (typeof size === 'number') {
                  height = `${size}px`;
              }
              else {
                  height = themeRef.value.self[createKey('height', size)];
              }
              return {
                  '--n-font-size': fontSize,
                  '--n-border': bordered ? border : 'none',
                  '--n-border-radius': round ? '50%' : borderRadius,
                  '--n-color': propColor || color,
                  '--n-color-modal': propColor || colorModal,
                  '--n-color-popover': propColor || colorPopover,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-merged-size': `var(--n-avatar-size-override, ${height})`
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('avatar', computed(() => {
                  const size = mergedSizeRef.value;
                  const round = mergedRoundRef.value;
                  const bordered = mergedBorderedRef.value;
                  const { color } = props;
                  let hash = '';
                  if (size) {
                      if (typeof size === 'number') {
                          hash += `a${size}`;
                      }
                      else {
                          hash += size[0];
                      }
                  }
                  if (round) {
                      hash += 'b';
                  }
                  if (bordered) {
                      hash += 'c';
                  }
                  if (color) {
                      hash += color2Class(color);
                  }
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          const shouldStartLoadingRef = ref(!props.lazy);
          onMounted(() => {
              if (isImageSupportNativeLazy) {
                  return;
              }
              let unobserve;
              const stopWatchHandle = watchEffect(() => {
                  unobserve === null || unobserve === void 0 ? void 0 : unobserve();
                  unobserve = undefined;
                  if (props.lazy) {
                      unobserve = observeIntersection(selfRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
                  }
              });
              onBeforeUnmount(() => {
                  stopWatchHandle();
                  unobserve === null || unobserve === void 0 ? void 0 : unobserve();
              });
          });
          const loadedRef = ref(!props.lazy);
          return {
              textRef,
              selfRef,
              mergedRoundRef,
              mergedClsPrefix: mergedClsPrefixRef,
              fitTextTransform,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              hasLoadError: hasLoadErrorRef,
              handleError,
              shouldStartLoading: shouldStartLoadingRef,
              loaded: loadedRef,
              mergedOnLoad: (e) => {
                  var _a;
                  const { onLoad, imgProps } = props;
                  onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
                  (_a = imgProps === null || imgProps === void 0 ? void 0 : imgProps.onLoad) === null || _a === void 0 ? void 0 : _a.call(imgProps, e);
                  loadedRef.value = true;
              }
          };
      },
      render() {
          var _a, _b;
          const { $slots, src, mergedClsPrefix, lazy, onRender, mergedOnLoad, shouldStartLoading, loaded, hasLoadError } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          let img;
          const placeholderNode = !loaded &&
              !hasLoadError &&
              (this.renderPlaceholder
                  ? this.renderPlaceholder()
                  : (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
          if (this.hasLoadError) {
              img = this.renderFallback
                  ? this.renderFallback()
                  : resolveSlot($slots.fallback, () => [
                      h("img", { src: this.fallbackSrc, style: { objectFit: this.objectFit } })
                  ]);
          }
          else {
              img = resolveWrappedSlot($slots.default, (children) => {
                  if (children) {
                      return (h(VResizeObserver, { onResize: this.fitTextTransform }, {
                          default: () => (h("span", { ref: "textRef", class: `${mergedClsPrefix}-avatar__text` }, children))
                      }));
                  }
                  else if (src) {
                      const { imgProps } = this;
                      return h('img', Object.assign(Object.assign({}, imgProps), { loading: 
                          // If interseciton observer options is set, do not use native lazy
                          isImageSupportNativeLazy &&
                              !this.intersectionObserverOptions &&
                              lazy
                              ? 'lazy'
                              : 'eager', src: isImageSupportNativeLazy
                              ? src
                              : shouldStartLoading || loaded
                                  ? src
                                  : undefined, onLoad: mergedOnLoad, 'data-image-src': src, onError: this.handleError, style: [
                              imgProps === null || imgProps === void 0 ? void 0 : imgProps.style,
                              { objectFit: this.objectFit },
                              placeholderNode
                                  ? {
                                      height: '0',
                                      width: '0',
                                      visibility: 'hidden',
                                      position: 'absolute'
                                  }
                                  : ''
                          ] }));
                  }
              });
          }
          return (h("span", { ref: "selfRef", class: [`${mergedClsPrefix}-avatar`, this.themeClass], style: this.cssVars },
              img,
              lazy && placeholderNode));
      }
  });

  // --n-gap
  var style$1g = cB('avatar-group', `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM('vertical', {
    flexDirection: 'row'
  }, [cB('avatar', [c$1('&:not(:first-child)', `
 margin-left: var(--n-gap);
 `)])]), cM('vertical', {
    flexDirection: 'column'
  }, [cB('avatar', [c$1('&:not(:first-child)', `
 margin-top: var(--n-gap);
 `)])])]);

  const self$13 = () => {
      return {
          gap: '-12px'
      };
  };
  const avatarGroupLight = createTheme({
      name: 'AvatarGroup',
      common: commonLight,
      peers: {
          Avatar: avatarLight$1
      },
      self: self$13
  });
  var avatarGroupLight$1 = avatarGroupLight;

  const avatarGroupProps = Object.assign(Object.assign({}, useTheme.props), { max: Number, maxStyle: [Object, String], options: {
          type: Array,
          default: () => []
      }, vertical: Boolean, size: [String, Number] });
  var AvatarGroup = defineComponent({
      name: 'AvatarGroup',
      props: avatarGroupProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const mergedThemeRef = useTheme('AvatarGroup', '-avatar-group', style$1g, avatarGroupLight$1, props, mergedClsPrefixRef);
          provide(avatarGroupInjectionKey, props);
          const rtlEnabledRef = useRtl('AvatarGroup', mergedRtlRef, mergedClsPrefixRef);
          const restOptionsRef = computed(() => {
              const { max } = props;
              if (max === undefined)
                  return undefined;
              const { options } = props;
              if (options.length > max)
                  return options.slice(max - 1, options.length);
              return [];
          });
          const displayedOptionsRef = computed(() => {
              const { options, max } = props;
              if (max === undefined)
                  return options;
              if (options.length > max)
                  return options.slice(0, max - 1);
              if (options.length === max)
                  return options.slice(0, max);
              return options;
          });
          return {
              mergedTheme: mergedThemeRef,
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              restOptions: restOptionsRef,
              displayedOptions: displayedOptionsRef,
              cssVars: computed(() => {
                  return {
                      '--n-gap': mergedThemeRef.value.self.gap
                  };
              })
          };
      },
      render() {
          const { mergedClsPrefix, displayedOptions, restOptions, mergedTheme, $slots } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-avatar-group`,
                  this.rtlEnabled && `${mergedClsPrefix}-avatar-group--rtl`,
                  this.vertical && `${mergedClsPrefix}-avatar-group--vertical`
              ], style: this.cssVars, role: "group" },
              displayedOptions.map((option) => {
                  return $slots.avatar ? ($slots.avatar({ option })) : (h(NAvatar, { src: option.src, theme: mergedTheme.peers.Avatar, themeOverrides: mergedTheme.peerOverrides.Avatar }));
              }),
              restOptions !== undefined &&
                  restOptions.length > 0 &&
                  ($slots.rest ? ($slots.rest({ options: restOptions, rest: restOptions.length })) : (h(NAvatar, { style: this.maxStyle, theme: mergedTheme.peers.Avatar, themeOverrides: mergedTheme.peerOverrides.Avatar }, {
                      default: () => `+${restOptions.length}`
                  })))));
      }
  });

  var commonVariables$h = {
      width: '44px',
      height: '44px',
      borderRadius: '22px',
      iconSize: '26px'
  };

  const self$12 = (vars) => {
      const { popoverColor, textColor2, primaryColorHover, primaryColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$h), { color: popoverColor, textColor: textColor2, iconColor: textColor2, iconColorHover: primaryColorHover, iconColorPressed: primaryColorPressed, boxShadow: '0 2px 8px 0px rgba(0, 0, 0, .12)', boxShadowHover: '0 2px 12px 0px rgba(0, 0, 0, .18)', boxShadowPressed: '0 2px 12px 0px rgba(0, 0, 0, .18)' });
  };
  const backTopLight = {
      name: 'BackTop',
      common: commonLight,
      self: self$12
  };
  var backTopLight$1 = backTopLight;

  var BackTopIcon = (h("svg", { viewBox: "0 0 24 24", version: "1.1", xmlns: "http://www.w3.org/2000/svg", xlinkHref: "http://www.w3.org/1999/xlink" },
      h("g", { stroke: "none", "stroke-width": "1", "fill-rule": "evenodd" },
          h("g", { transform: "translate(-139.000000, -4423.000000)", "fill-rule": "nonzero" },
              h("g", { transform: "translate(120.000000, 4285.000000)" },
                  h("g", { transform: "translate(7.000000, 126.000000)" },
                      h("g", { transform: "translate(24.000000, 24.000000) scale(1, -1) translate(-24.000000, -24.000000) translate(12.000000, 12.000000)" },
                          h("g", { transform: "translate(4.000000, 2.000000)" },
                              h("path", { d: "M8,0 C8.51283584,0 8.93550716,0.38604019 8.99327227,0.883378875 L9,1 L9,10.584 L12.2928932,7.29289322 C12.6834175,6.90236893 13.3165825,6.90236893 13.7071068,7.29289322 C14.0675907,7.65337718 14.0953203,8.22060824 13.7902954,8.61289944 L13.7071068,8.70710678 L8.70710678,13.7071068 L8.62544899,13.7803112 L8.618,13.784 L8.59530661,13.8036654 L8.4840621,13.8753288 L8.37133602,13.9287745 L8.22929083,13.9735893 L8.14346259,13.9897165 L8.03324678,13.9994506 L7.9137692,13.9962979 L7.77070917,13.9735893 L7.6583843,13.9401293 L7.57677845,13.9063266 L7.47929125,13.8540045 L7.4048407,13.8036865 L7.38131006,13.7856883 C7.35030318,13.7612383 7.32077858,13.7349921 7.29289322,13.7071068 L2.29289322,8.70710678 L2.20970461,8.61289944 C1.90467972,8.22060824 1.93240926,7.65337718 2.29289322,7.29289322 C2.65337718,6.93240926 3.22060824,6.90467972 3.61289944,7.20970461 L3.70710678,7.29289322 L7,10.585 L7,1 L7.00672773,0.883378875 C7.06449284,0.38604019 7.48716416,0 8,0 Z" }),
                              h("path", { d: "M14.9333333,15.9994506 C15.5224371,15.9994506 16,16.4471659 16,16.9994506 C16,17.5122865 15.5882238,17.9349578 15.0577292,17.9927229 L14.9333333,17.9994506 L1.06666667,17.9994506 C0.477562934,17.9994506 0,17.5517354 0,16.9994506 C0,16.4866148 0.411776203,16.0639435 0.9422708,16.0061783 L1.06666667,15.9994506 L14.9333333,15.9994506 Z" })))))))));

  // vars:
  // --n-bezier
  // --n-border-radius
  // --n-height
  // --n-width
  // --n-box-shadow
  // --n-box-shadow-hover
  // --n-box-shadow-pressed
  // --n-color
  // --n-icon-size
  // --n-icon-color
  // --n-icon-color-hover
  // --n-icon-color-pressed
  // --n-text-color
  var style$1f = cB('back-top', `
 position: fixed;
 right: 40px;
 bottom: 40px;
 cursor: pointer;
 display: flex;
 align-items: center;
 justify-content: center;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 height: var(--n-height);
 min-width: var(--n-width);
 box-shadow: var(--n-box-shadow);
 background-color: var(--n-color);
`, [fadeInScaleUpTransition(), cM('transition-disabled', {
    transition: 'none !important'
  }), cB('base-icon', `
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), c$1('svg', {
    pointerEvents: 'none'
  }), c$1('&:hover', {
    boxShadow: 'var(--n-box-shadow-hover)'
  }, [cB('base-icon', {
    color: 'var(--n-icon-color-hover)'
  })]), c$1('&:active', {
    boxShadow: 'var(--n-box-shadow-pressed)'
  }, [cB('base-icon', {
    color: 'var(--n-icon-color-pressed)'
  })])]);

  const backTopProps = Object.assign(Object.assign({}, useTheme.props), { show: {
          type: Boolean,
          default: undefined
      }, right: {
          type: [Number, String],
          default: 40
      }, bottom: {
          type: [Number, String],
          default: 40
      }, to: {
          type: [String, Object],
          default: 'body'
      }, visibilityHeight: {
          type: Number,
          default: 180
      }, listenTo: [String, Object, Function], 'onUpdate:show': {
          type: Function,
          default: () => { }
      }, 
      // deprecated
      target: Function, onShow: Function, onHide: Function });
  var BackTop = defineComponent({
      name: 'BackTop',
      // make style applied to back-top button
      inheritAttrs: false,
      props: backTopProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const scrollTopRef = ref(null);
          const uncontrolledShowRef = ref(false);
          watchEffect(() => {
              const { value: scrollTop } = scrollTopRef;
              if (scrollTop === null) {
                  uncontrolledShowRef.value = false;
                  return;
              }
              uncontrolledShowRef.value = scrollTop >= props.visibilityHeight;
          });
          const DomInfoReadyRef = ref(false);
          watch(uncontrolledShowRef, (value) => {
              var _a;
              if (DomInfoReadyRef.value) {
                  (_a = props['onUpdate:show']) === null || _a === void 0 ? void 0 : _a.call(props, value);
              }
          });
          const controlledShowRef = toRef(props, 'show');
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const transitionDisabledRef = ref(true);
          const placeholderRef = ref(null);
          const styleRef = computed(() => {
              return {
                  right: `calc(${formatLength(props.right)} + ${lockHtmlScrollRightCompensationRef.value})`,
                  bottom: formatLength(props.bottom)
              };
          });
          let scrollElement;
          let scrollListenerRegistered;
          // deprecated
          watch(mergedShowRef, (value) => {
              var _a, _b;
              if (DomInfoReadyRef.value) {
                  if (value) {
                      (_a = props.onShow) === null || _a === void 0 ? void 0 : _a.call(props);
                  }
                  (_b = props.onHide) === null || _b === void 0 ? void 0 : _b.call(props);
              }
          });
          const themeRef = useTheme('BackTop', '-back-top', style$1f, backTopLight$1, props, mergedClsPrefixRef);
          function init() {
              var _a;
              if (scrollListenerRegistered)
                  return;
              scrollListenerRegistered = true;
              const scrollEl = ((_a = props.target) === null || _a === void 0 ? void 0 : _a.call(props)) ||
                  unwrapElement(props.listenTo) ||
                  getScrollParent$1(placeholderRef.value);
              if (!scrollEl) {
                  return;
              }
              scrollElement =
                  scrollEl === document.documentElement ? document : scrollEl;
              const { to } = props;
              typeof to === 'string' ? document.querySelector(to) : to;
              scrollElement.addEventListener('scroll', handleScroll);
              handleScroll();
          }
          function handleClick() {
              (isDocument(scrollElement)
                  ? document.documentElement
                  : scrollElement).scrollTo({
                  top: 0,
                  behavior: 'smooth'
              });
          }
          function handleScroll() {
              scrollTopRef.value = (isDocument(scrollElement) ? document.documentElement : scrollElement).scrollTop;
              if (!DomInfoReadyRef.value) {
                  void nextTick(() => {
                      DomInfoReadyRef.value = true;
                  });
              }
          }
          function handleAfterEnter() {
              transitionDisabledRef.value = false;
          }
          onMounted(() => {
              init();
              transitionDisabledRef.value = mergedShowRef.value;
          });
          onBeforeUnmount(() => {
              if (scrollElement) {
                  scrollElement.removeEventListener('scroll', handleScroll);
              }
          });
          const cssVarsRef = computed(() => {
              const { self: { color, boxShadow, boxShadowHover, boxShadowPressed, iconColor, iconColorHover, iconColorPressed, width, height, iconSize, borderRadius, textColor }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-height': height,
                  '--n-width': width,
                  '--n-box-shadow': boxShadow,
                  '--n-box-shadow-hover': boxShadowHover,
                  '--n-box-shadow-pressed': boxShadowPressed,
                  '--n-color': color,
                  '--n-icon-size': iconSize,
                  '--n-icon-color': iconColor,
                  '--n-icon-color-hover': iconColorHover,
                  '--n-icon-color-pressed': iconColorPressed,
                  '--n-text-color': textColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('back-top', undefined, cssVarsRef, props)
              : undefined;
          return {
              placeholderRef,
              style: styleRef,
              mergedShow: mergedShowRef,
              isMounted: isMounted(),
              scrollElement: ref(null),
              scrollTop: scrollTopRef,
              DomInfoReady: DomInfoReadyRef,
              transitionDisabled: transitionDisabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              handleAfterEnter,
              handleScroll,
              handleClick,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { ref: "placeholderRef", class: `${mergedClsPrefix}-back-top-placeholder`, style: "display: none", "aria-hidden": true },
              h(LazyTeleport, { to: this.to, show: this.mergedShow }, {
                  default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterEnter: this.handleAfterEnter }, {
                      default: () => {
                          var _a;
                          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                          return this.mergedShow
                              ? h('div', mergeProps(this.$attrs, {
                                  class: [
                                      `${mergedClsPrefix}-back-top`,
                                      this.themeClass,
                                      this.transitionDisabled &&
                                          `${mergedClsPrefix}-back-top--transition-disabled`
                                  ],
                                  style: [this.style, this.cssVars],
                                  onClick: this.handleClick
                              }), resolveSlot(this.$slots.default, () => [
                                  h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => BackTopIcon })
                              ]))
                              : null;
                      }
                  }))
              })));
      }
  });

  const self$11 = (vars) => {
      const { errorColor, infoColor, successColor, warningColor, fontFamily } = vars;
      return {
          color: errorColor,
          colorInfo: infoColor,
          colorSuccess: successColor,
          colorError: errorColor,
          colorWarning: warningColor,
          fontSize: '12px',
          fontFamily
      };
  };
  const badgeLight = {
      name: 'Badge',
      common: commonLight,
      self: self$11
  };
  var badgeLight$1 = badgeLight;

  // vars:
  // --n-color
  // --n-ripple-color
  // --n-bezier
  // --n-ripple-bezier
  // --n-font-size
  // --n-font-family
  var style$1e = c$1([c$1('@keyframes badge-wave-spread', {
    from: {
      boxShadow: '0 0 0.5px 0px var(--n-ripple-color)',
      opacity: 0.6
    },
    to: {
      // don't use exact 5px since chrome will display the animation with glitches
      boxShadow: '0 0 0.5px 4.5px var(--n-ripple-color)',
      opacity: 0
    }
  }), cB('badge', `
 display: inline-flex;
 position: relative;
 vertical-align: middle;
 color: var(--n-color);
 font-family: var(--n-font-family);
 `, [cM('as-is', [cB('badge-sup', {
    position: 'static',
    transform: 'translateX(0)'
  }, [fadeInScaleUpTransition({
    transformOrigin: 'left bottom',
    originalTransform: 'translateX(0)'
  })])]), cM('dot', [cB('badge-sup', `
 height: 8px;
 width: 8px;
 padding: 0;
 min-width: 8px;
 left: 100%;
 bottom: calc(100% - 4px);
 `, [c$1('::before', 'border-radius: 4px;')])]), cB('badge-sup', `
 background: var(--n-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: #FFF;
 position: absolute;
 height: 18px;
 line-height: 18px;
 border-radius: 9px;
 padding: 0 6px;
 text-align: center;
 font-size: var(--n-font-size);
 transform: translateX(-50%);
 left: 100%;
 bottom: calc(100% - 9px);
 font-variant-numeric: tabular-nums;
 z-index: 1;
 display: flex;
 align-items: center;
 `, [fadeInScaleUpTransition({
    transformOrigin: 'left bottom',
    originalTransform: 'translateX(-50%)'
  }), cB('base-wave', {
    zIndex: 1,
    animationDuration: '2s',
    animationIterationCount: 'infinite',
    animationDelay: '1s',
    animationTimingFunction: 'var(--n-ripple-bezier)',
    animationName: 'badge-wave-spread'
  }), c$1('&::before', `
 opacity: 0;
 transform: scale(1);
 border-radius: 9px;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)])])]);

  const badgeProps = Object.assign(Object.assign({}, useTheme.props), { value: [String, Number], max: Number, dot: Boolean, type: {
          type: String,
          default: 'default'
      }, show: {
          type: Boolean,
          default: true
      }, showZero: Boolean, processing: Boolean, color: String, offset: Array });
  var Badge = defineComponent({
      name: 'Badge',
      props: badgeProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Badge', '-badge', style$1e, badgeLight$1, props, mergedClsPrefixRef);
          const appearedRef = ref(false);
          const handleAfterEnter = () => {
              appearedRef.value = true;
          };
          const handleAfterLeave = () => {
              appearedRef.value = false;
          };
          const showBadgeRef = computed(() => {
              return (props.show &&
                  (props.dot ||
                      (props.value !== undefined &&
                          !(!props.showZero && Number(props.value) <= 0)) ||
                      !isSlotEmpty(slots.value)));
          });
          onMounted(() => {
              if (showBadgeRef.value)
                  appearedRef.value = true;
          });
          const rtlEnabledRef = useRtl('Badge', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type, color: propColor } = props;
              const { common: { cubicBezierEaseInOut, cubicBezierEaseOut }, self: { [createKey('color', type)]: color, fontFamily, fontSize } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-font-family': fontFamily,
                  '--n-color': propColor || color,
                  '--n-ripple-color': propColor || color,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-ripple-bezier': cubicBezierEaseOut
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('badge', computed(() => {
                  let hash = '';
                  const { type, color } = props;
                  if (type) {
                      hash += type[0];
                  }
                  if (color) {
                      hash += color2Class(color);
                  }
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          const offsetStyleRef = computed(() => {
              const { offset } = props;
              if (!offset)
                  return undefined;
              const [x, y] = offset;
              const reslovedOffsetX = typeof x === 'number' ? `${x}px` : x;
              const reslovedOffsetY = typeof y === 'number' ? `${y}px` : y;
              return {
                  transform: `translate(calc(${(rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? '50%' : '-50%'} + ${reslovedOffsetX}), ${reslovedOffsetY})`
              };
          });
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              appeared: appearedRef,
              showBadge: showBadgeRef,
              handleAfterEnter,
              handleAfterLeave,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              offsetStyle: offsetStyleRef
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix, onRender, themeClass, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const children = (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
          return (h("div", { class: [
                  `${mergedClsPrefix}-badge`,
                  this.rtlEnabled && `${mergedClsPrefix}-badge--rtl`,
                  themeClass,
                  {
                      [`${mergedClsPrefix}-badge--dot`]: this.dot,
                      [`${mergedClsPrefix}-badge--as-is`]: !children
                  }
              ], style: this.cssVars },
              children,
              h(Transition, { name: "fade-in-scale-up-transition", onAfterEnter: this.handleAfterEnter, onAfterLeave: this.handleAfterLeave }, {
                  default: () => this.showBadge ? (h("sup", { class: `${mergedClsPrefix}-badge-sup`, title: getTitleAttribute(this.value), style: this.offsetStyle },
                      resolveSlot($slots.value, () => [
                          !this.dot ? (h(NBaseSlotMachine, { clsPrefix: mergedClsPrefix, appeared: this.appeared, max: this.max, value: this.value })) : null
                      ]),
                      this.processing ? (h(NBaseWave, { clsPrefix: mergedClsPrefix })) : null)) : null
              })));
      }
  });

  var commonVariables$g = {
      fontWeightActive: '400'
  };

  const self$10 = (vars) => {
      const { fontSize, textColor3, textColor2, borderRadius, buttonColor2Hover, buttonColor2Pressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$g), { fontSize, itemLineHeight: '1.25', itemTextColor: textColor3, itemTextColorHover: textColor2, itemTextColorPressed: textColor2, itemTextColorActive: textColor2, itemBorderRadius: borderRadius, itemColorHover: buttonColor2Hover, itemColorPressed: buttonColor2Pressed, separatorColor: textColor3 });
  };
  const breadcrumbLight = {
      name: 'Breadcrumb',
      common: commonLight,
      self: self$10
  };
  var breadcrumbLight$1 = breadcrumbLight;

  // vars:
  // --n-font-size
  // --n-bezier
  // --n-item-text-color
  // --n-item-text-color-hover
  // --n-item-text-color-pressed
  // --n-item-text-color-active
  // --n-separator-color
  // --n-font-weight-active
  // --n-item-border-radius
  // --n-item-color-hover
  // --n-item-color-active
  // --n-item-line-height
  var style$1d = cB('breadcrumb', `
 white-space: nowrap;
 cursor: default;
 line-height: var(--n-item-line-height);
`, [c$1('ul', `
 list-style: none;
 padding: 0;
 margin: 0;
 `), c$1('a', `
 color: inherit;
 text-decoration: inherit;
 `), cB('breadcrumb-item', `
 font-size: var(--n-font-size);
 transition: color .3s var(--n-bezier);
 display: inline-flex;
 align-items: center;
 `, [cB('icon', `
 font-size: 18px;
 vertical-align: -.2em;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `), c$1('&:not(:last-child)', [cM('clickable', [cE('link', `
 cursor: pointer;
 `, [c$1('&:hover', `
 background-color: var(--n-item-color-hover);
 `), c$1('&:active', `
 background-color: var(--n-item-color-pressed); 
 `)])])]), cE('link', `
 padding: 4px;
 border-radius: var(--n-item-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 position: relative;
 `, [c$1('&:hover', `
 color: var(--n-item-text-color-hover);
 `, [cB('icon', `
 color: var(--n-item-text-color-hover);
 `)]), c$1('&:active', `
 color: var(--n-item-text-color-pressed);
 `, [cB('icon', `
 color: var(--n-item-text-color-pressed);
 `)])]), cE('separator', `
 margin: 0 8px;
 color: var(--n-separator-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 `), c$1('&:last-child', [cE('link', `
 font-weight: var(--n-font-weight-active);
 cursor: unset;
 color: var(--n-item-text-color-active);
 `, [cB('icon', `
 color: var(--n-item-text-color-active);
 `)]), cE('separator', `
 display: none;
 `)])])]);

  const breadcrumbInjectionKey = createInjectionKey('n-breadcrumb');
  const breadcrumbProps = Object.assign(Object.assign({}, useTheme.props), { separator: {
          type: String,
          default: '/'
      } });
  var Breadcrumb = defineComponent({
      name: 'Breadcrumb',
      props: breadcrumbProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Breadcrumb', '-breadcrumb', style$1d, breadcrumbLight$1, props, mergedClsPrefixRef);
          provide(breadcrumbInjectionKey, {
              separatorRef: toRef(props, 'separator'),
              mergedClsPrefixRef
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { separatorColor, itemTextColor, itemTextColorHover, itemTextColorPressed, itemTextColorActive, fontSize, fontWeightActive, itemBorderRadius, itemColorHover, itemColorPressed, itemLineHeight } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-item-text-color': itemTextColor,
                  '--n-item-text-color-hover': itemTextColorHover,
                  '--n-item-text-color-pressed': itemTextColorPressed,
                  '--n-item-text-color-active': itemTextColorActive,
                  '--n-separator-color': separatorColor,
                  '--n-item-color-hover': itemColorHover,
                  '--n-item-color-pressed': itemColorPressed,
                  '--n-item-border-radius': itemBorderRadius,
                  '--n-font-weight-active': fontWeightActive,
                  '--n-item-line-height': itemLineHeight
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('breadcrumb', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("nav", { class: [`${this.mergedClsPrefix}-breadcrumb`, this.themeClass], style: this.cssVars, "aria-label": "Breadcrumb" },
              h("ul", null, this.$slots)));
      }
  });

  const useBrowserLocation = (customWindow = isBrowser$2 ? window : null) => {
      const getWindowLocation = () => {
          const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (customWindow === null || customWindow === void 0 ? void 0 : customWindow.location) || {};
          return {
              hash,
              host,
              hostname,
              href,
              origin,
              pathname,
              port,
              protocol,
              search
          };
      };
      const updateLocation = () => {
          locationState.value = getWindowLocation();
      };
      const locationState = ref(getWindowLocation());
      onMounted(() => {
          if (customWindow) {
              customWindow.addEventListener('popstate', updateLocation);
              customWindow.addEventListener('hashchange', updateLocation);
          }
      });
      onUnmounted(() => {
          if (customWindow) {
              customWindow.removeEventListener('popstate', updateLocation);
              customWindow.removeEventListener('hashchange', updateLocation);
          }
      });
      return locationState;
  };

  const breadcrumbItemProps = {
      separator: String,
      href: String,
      clickable: {
          type: Boolean,
          default: true
      },
      onClick: Function
  };
  var BreadcrumbItem = defineComponent({
      name: 'BreadcrumbItem',
      props: breadcrumbItemProps,
      setup(props, { slots }) {
          const NBreadcrumb = inject(breadcrumbInjectionKey, null);
          if (!NBreadcrumb) {
              return () => null;
          }
          const { separatorRef, mergedClsPrefixRef } = NBreadcrumb;
          const browserLocationRef = useBrowserLocation();
          const htmlTagRef = computed(() => (props.href ? 'a' : 'span'));
          const ariaCurrentRef = computed(() => browserLocationRef.value.href === props.href ? 'location' : null);
          return () => {
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              return (h("li", { class: [
                      `${mergedClsPrefix}-breadcrumb-item`,
                      props.clickable && `${mergedClsPrefix}-breadcrumb-item--clickable`
                  ] },
                  h(htmlTagRef.value, {
                      class: `${mergedClsPrefix}-breadcrumb-item__link`,
                      'aria-current': ariaCurrentRef.value,
                      href: props.href,
                      onClick: props.onClick
                  }, slots),
                  h("span", { class: `${mergedClsPrefix}-breadcrumb-item__separator`, "aria-hidden": "true" }, resolveSlot(slots.separator, () => {
                      var _a;
                      return [
                          (_a = props.separator) !== null && _a !== void 0 ? _a : separatorRef.value
                      ];
                  }))));
          };
      }
  });

  function createHoverColor(rgb) {
      return composite(rgb, [255, 255, 255, 0.16]);
  }
  function createPressedColor(rgb) {
      return composite(rgb, [0, 0, 0, 0.12]);
  }

  const buttonGroupInjectionKey = createInjectionKey('n-button-group');

  var commonVariables$f = {
      paddingTiny: '0 6px',
      paddingSmall: '0 10px',
      paddingMedium: '0 14px',
      paddingLarge: '0 18px',
      paddingRoundTiny: '0 10px',
      paddingRoundSmall: '0 14px',
      paddingRoundMedium: '0 18px',
      paddingRoundLarge: '0 22px',
      iconMarginTiny: '6px',
      iconMarginSmall: '6px',
      iconMarginMedium: '6px',
      iconMarginLarge: '6px',
      iconSizeTiny: '14px',
      iconSizeSmall: '18px',
      iconSizeMedium: '18px',
      iconSizeLarge: '20px',
      rippleDuration: '.6s'
  };

  const self$$ = (vars) => {
      const { heightTiny, heightSmall, heightMedium, heightLarge, borderRadius, fontSizeTiny, fontSizeSmall, fontSizeMedium, fontSizeLarge, opacityDisabled, textColor2, textColor3, primaryColorHover, primaryColorPressed, borderColor, primaryColor, baseColor, infoColor, infoColorHover, infoColorPressed, successColor, successColorHover, successColorPressed, warningColor, warningColorHover, warningColorPressed, errorColor, errorColorHover, errorColorPressed, fontWeight, buttonColor2, buttonColor2Hover, buttonColor2Pressed, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$f), { heightTiny,
          heightSmall,
          heightMedium,
          heightLarge, borderRadiusTiny: borderRadius, borderRadiusSmall: borderRadius, borderRadiusMedium: borderRadius, borderRadiusLarge: borderRadius, fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          opacityDisabled, 
          // secondary
          colorOpacitySecondary: '0.16', colorOpacitySecondaryHover: '0.22', colorOpacitySecondaryPressed: '0.28', colorSecondary: buttonColor2, colorSecondaryHover: buttonColor2Hover, colorSecondaryPressed: buttonColor2Pressed, 
          // tertiary
          colorTertiary: buttonColor2, colorTertiaryHover: buttonColor2Hover, colorTertiaryPressed: buttonColor2Pressed, 
          // quaternary
          colorQuaternary: '#0000', colorQuaternaryHover: buttonColor2Hover, colorQuaternaryPressed: buttonColor2Pressed, 
          // default type
          color: '#0000', colorHover: '#0000', colorPressed: '#0000', colorFocus: '#0000', colorDisabled: '#0000', textColor: textColor2, textColorTertiary: textColor3, textColorHover: primaryColorHover, textColorPressed: primaryColorPressed, textColorFocus: primaryColorHover, textColorDisabled: textColor2, textColorText: textColor2, textColorTextHover: primaryColorHover, textColorTextPressed: primaryColorPressed, textColorTextFocus: primaryColorHover, textColorTextDisabled: textColor2, textColorGhost: textColor2, textColorGhostHover: primaryColorHover, textColorGhostPressed: primaryColorPressed, textColorGhostFocus: primaryColorHover, textColorGhostDisabled: textColor2, border: `1px solid ${borderColor}`, borderHover: `1px solid ${primaryColorHover}`, borderPressed: `1px solid ${primaryColorPressed}`, borderFocus: `1px solid ${primaryColorHover}`, borderDisabled: `1px solid ${borderColor}`, rippleColor: primaryColor, 
          // primary
          colorPrimary: primaryColor, colorHoverPrimary: primaryColorHover, colorPressedPrimary: primaryColorPressed, colorFocusPrimary: primaryColorHover, colorDisabledPrimary: primaryColor, textColorPrimary: baseColor, textColorHoverPrimary: baseColor, textColorPressedPrimary: baseColor, textColorFocusPrimary: baseColor, textColorDisabledPrimary: baseColor, textColorTextPrimary: primaryColor, textColorTextHoverPrimary: primaryColorHover, textColorTextPressedPrimary: primaryColorPressed, textColorTextFocusPrimary: primaryColorHover, textColorTextDisabledPrimary: textColor2, textColorGhostPrimary: primaryColor, textColorGhostHoverPrimary: primaryColorHover, textColorGhostPressedPrimary: primaryColorPressed, textColorGhostFocusPrimary: primaryColorHover, textColorGhostDisabledPrimary: primaryColor, borderPrimary: `1px solid ${primaryColor}`, borderHoverPrimary: `1px solid ${primaryColorHover}`, borderPressedPrimary: `1px solid ${primaryColorPressed}`, borderFocusPrimary: `1px solid ${primaryColorHover}`, borderDisabledPrimary: `1px solid ${primaryColor}`, rippleColorPrimary: primaryColor, 
          // info
          colorInfo: infoColor, colorHoverInfo: infoColorHover, colorPressedInfo: infoColorPressed, colorFocusInfo: infoColorHover, colorDisabledInfo: infoColor, textColorInfo: baseColor, textColorHoverInfo: baseColor, textColorPressedInfo: baseColor, textColorFocusInfo: baseColor, textColorDisabledInfo: baseColor, textColorTextInfo: infoColor, textColorTextHoverInfo: infoColorHover, textColorTextPressedInfo: infoColorPressed, textColorTextFocusInfo: infoColorHover, textColorTextDisabledInfo: textColor2, textColorGhostInfo: infoColor, textColorGhostHoverInfo: infoColorHover, textColorGhostPressedInfo: infoColorPressed, textColorGhostFocusInfo: infoColorHover, textColorGhostDisabledInfo: infoColor, borderInfo: `1px solid ${infoColor}`, borderHoverInfo: `1px solid ${infoColorHover}`, borderPressedInfo: `1px solid ${infoColorPressed}`, borderFocusInfo: `1px solid ${infoColorHover}`, borderDisabledInfo: `1px solid ${infoColor}`, rippleColorInfo: infoColor, 
          // success
          colorSuccess: successColor, colorHoverSuccess: successColorHover, colorPressedSuccess: successColorPressed, colorFocusSuccess: successColorHover, colorDisabledSuccess: successColor, textColorSuccess: baseColor, textColorHoverSuccess: baseColor, textColorPressedSuccess: baseColor, textColorFocusSuccess: baseColor, textColorDisabledSuccess: baseColor, textColorTextSuccess: successColor, textColorTextHoverSuccess: successColorHover, textColorTextPressedSuccess: successColorPressed, textColorTextFocusSuccess: successColorHover, textColorTextDisabledSuccess: textColor2, textColorGhostSuccess: successColor, textColorGhostHoverSuccess: successColorHover, textColorGhostPressedSuccess: successColorPressed, textColorGhostFocusSuccess: successColorHover, textColorGhostDisabledSuccess: successColor, borderSuccess: `1px solid ${successColor}`, borderHoverSuccess: `1px solid ${successColorHover}`, borderPressedSuccess: `1px solid ${successColorPressed}`, borderFocusSuccess: `1px solid ${successColorHover}`, borderDisabledSuccess: `1px solid ${successColor}`, rippleColorSuccess: successColor, 
          // warning
          colorWarning: warningColor, colorHoverWarning: warningColorHover, colorPressedWarning: warningColorPressed, colorFocusWarning: warningColorHover, colorDisabledWarning: warningColor, textColorWarning: baseColor, textColorHoverWarning: baseColor, textColorPressedWarning: baseColor, textColorFocusWarning: baseColor, textColorDisabledWarning: baseColor, textColorTextWarning: warningColor, textColorTextHoverWarning: warningColorHover, textColorTextPressedWarning: warningColorPressed, textColorTextFocusWarning: warningColorHover, textColorTextDisabledWarning: textColor2, textColorGhostWarning: warningColor, textColorGhostHoverWarning: warningColorHover, textColorGhostPressedWarning: warningColorPressed, textColorGhostFocusWarning: warningColorHover, textColorGhostDisabledWarning: warningColor, borderWarning: `1px solid ${warningColor}`, borderHoverWarning: `1px solid ${warningColorHover}`, borderPressedWarning: `1px solid ${warningColorPressed}`, borderFocusWarning: `1px solid ${warningColorHover}`, borderDisabledWarning: `1px solid ${warningColor}`, rippleColorWarning: warningColor, 
          // error
          colorError: errorColor, colorHoverError: errorColorHover, colorPressedError: errorColorPressed, colorFocusError: errorColorHover, colorDisabledError: errorColor, textColorError: baseColor, textColorHoverError: baseColor, textColorPressedError: baseColor, textColorFocusError: baseColor, textColorDisabledError: baseColor, textColorTextError: errorColor, textColorTextHoverError: errorColorHover, textColorTextPressedError: errorColorPressed, textColorTextFocusError: errorColorHover, textColorTextDisabledError: textColor2, textColorGhostError: errorColor, textColorGhostHoverError: errorColorHover, textColorGhostPressedError: errorColorPressed, textColorGhostFocusError: errorColorHover, textColorGhostDisabledError: errorColor, borderError: `1px solid ${errorColor}`, borderHoverError: `1px solid ${errorColorHover}`, borderPressedError: `1px solid ${errorColorPressed}`, borderFocusError: `1px solid ${errorColorHover}`, borderDisabledError: `1px solid ${errorColor}`, rippleColorError: errorColor, waveOpacity: '0.6', fontWeight,
          fontWeightStrong });
  };
  const buttonLight = {
      name: 'Button',
      common: commonLight,
      self: self$$
  };
  var buttonLight$1 = buttonLight;

  // vars:
  // --n-bezier
  // --n-bezier-ease-out
  // --n-ripple-duration
  // --n-opacity-disabled
  // --n-text-color
  // --n-text-color-hover
  // --n-text-color-pressed
  // --n-text-color-focus
  // --n-text-color-disabled
  // --n-color
  // --n-color-hover
  // --n-color-pressed
  // --n-color-focus
  // --n-color-disabled
  // --n-border
  // --n-border-hover
  // --n-border-pressed
  // --n-border-focus
  // --n-border-disabled
  // --n-ripple-color
  // --n-border-radius
  // --n-height
  // --n-width
  // --n-font-size
  // --n-padding
  // --n-icon-size
  // --n-icon-margin
  // --n-wave-opacity
  // --n-font-weight
  //
  // private-vars:
  // --n-border-color-xxx, used for custom color
  var style$1c = c$1([cB('button', `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM('color', [cE('border', {
    borderColor: 'var(--n-border-color)'
  }), cM('disabled', [cE('border', {
    borderColor: 'var(--n-border-color-disabled)'
  })]), cNotM('disabled', [c$1('&:focus', [cE('state-border', {
    borderColor: 'var(--n-border-color-focus)'
  })]), c$1('&:hover', [cE('state-border', {
    borderColor: 'var(--n-border-color-hover)'
  })]), c$1('&:active', [cE('state-border', {
    borderColor: 'var(--n-border-color-pressed)'
  })]), cM('pressed', [cE('state-border', {
    borderColor: 'var(--n-border-color-pressed)'
  })])])]), cM('disabled', {
    backgroundColor: 'var(--n-color-disabled)',
    color: 'var(--n-text-color-disabled)'
  }, [cE('border', {
    border: 'var(--n-border-disabled)'
  })]), cNotM('disabled', [c$1('&:focus', {
    backgroundColor: 'var(--n-color-focus)',
    color: 'var(--n-text-color-focus)'
  }, [cE('state-border', {
    border: 'var(--n-border-focus)'
  })]), c$1('&:hover', {
    backgroundColor: 'var(--n-color-hover)',
    color: 'var(--n-text-color-hover)'
  }, [cE('state-border', {
    border: 'var(--n-border-hover)'
  })]), c$1('&:active', {
    backgroundColor: 'var(--n-color-pressed)',
    color: 'var(--n-text-color-pressed)'
  }, [cE('state-border', {
    border: 'var(--n-border-pressed)'
  })]), cM('pressed', {
    backgroundColor: 'var(--n-color-pressed)',
    color: 'var(--n-text-color-pressed)'
  }, [cE('state-border', {
    border: 'var(--n-border-pressed)'
  })])]), cM('loading', 'cursor: wait;'), cB('base-wave', `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM('active', {
    zIndex: 1,
    animationName: 'button-wave-spread, button-wave-opacity'
  })]), isBrowser$2 && 'MozBoxSizing' in document.createElement('div').style ? c$1('&::moz-focus-inner', {
    border: 0
  }) : null, cE('border, state-border', `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE('border', {
    border: 'var(--n-border)'
  }), cE('state-border', {
    border: 'var(--n-border)',
    borderColor: '#0000',
    zIndex: 1
  }), cE('icon', `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB('icon-slot', `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
    top: '50%',
    originalTransform: 'translateY(-50%)'
  })]), fadeInWidthExpandTransition()]), cE('content', `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1('~', [cE('icon', {
    margin: 'var(--n-icon-margin)',
    marginRight: 0
  })])]), cM('block', `
 display: flex;
 width: 100%;
 `), cM('dashed', [cE('border, state-border', {
    borderStyle: 'dashed !important'
  })]), cM('disabled', {
    cursor: 'not-allowed',
    opacity: 'var(--n-opacity-disabled)'
  })]), c$1('@keyframes button-wave-spread', {
    from: {
      boxShadow: '0 0 0.5px 0 var(--n-ripple-color)'
    },
    to: {
      // don't use exact 5px since chrome will display the animation with glitches
      boxShadow: '0 0 0.5px 4.5px var(--n-ripple-color)'
    }
  }), c$1('@keyframes button-wave-opacity', {
    from: {
      opacity: 'var(--n-wave-opacity)'
    },
    to: {
      opacity: 0
    }
  })]);

  const buttonProps = Object.assign(Object.assign({}, useTheme.props), { color: String, textColor: String, text: Boolean, block: Boolean, loading: Boolean, disabled: Boolean, circle: Boolean, size: String, ghost: Boolean, round: Boolean, secondary: Boolean, tertiary: Boolean, quaternary: Boolean, strong: Boolean, focusable: {
          type: Boolean,
          default: true
      }, keyboard: {
          type: Boolean,
          default: true
      }, tag: {
          type: String,
          default: 'button'
      }, type: {
          type: String,
          default: 'default'
      }, dashed: Boolean, renderIcon: Function, iconPlacement: {
          type: String,
          default: 'left'
      }, attrType: {
          type: String,
          default: 'button'
      }, bordered: {
          type: Boolean,
          default: true
      }, onClick: [Function, Array], nativeFocusBehavior: {
          type: Boolean,
          default: !isSafari
      } });
  const Button = defineComponent({
      name: 'Button',
      props: buttonProps,
      setup(props) {
          const selfElRef = ref(null);
          const waveElRef = ref(null);
          const enterPressedRef = ref(false);
          const showBorderRef = useMemo(() => {
              return (!props.quaternary &&
                  !props.tertiary &&
                  !props.secondary &&
                  !props.text &&
                  (!props.color || props.ghost || props.dashed) &&
                  props.bordered);
          });
          const NButtonGroup = inject(buttonGroupInjectionKey, {});
          const { mergedSizeRef } = useFormItem({}, {
              defaultSize: 'medium',
              mergedSize: (NFormItem) => {
                  const { size } = props;
                  if (size)
                      return size;
                  const { size: buttonGroupSize } = NButtonGroup;
                  if (buttonGroupSize)
                      return buttonGroupSize;
                  const { mergedSize: formItemSize } = NFormItem || {};
                  if (formItemSize) {
                      return formItemSize.value;
                  }
                  return 'medium';
              }
          });
          const mergedFocusableRef = computed(() => {
              return props.focusable && !props.disabled;
          });
          const handleMousedown = (e) => {
              var _a;
              if (!mergedFocusableRef.value) {
                  e.preventDefault();
              }
              if (props.nativeFocusBehavior) {
                  return;
              }
              e.preventDefault();
              // normally this won't be called if disabled (when tag is button)
              // if not, we try to make it behave like a button
              if (props.disabled) {
                  return;
              }
              if (mergedFocusableRef.value) {
                  (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
              }
          };
          const handleClick = (e) => {
              var _a;
              if (!props.disabled && !props.loading) {
                  const { onClick } = props;
                  if (onClick)
                      call(onClick, e);
                  if (!props.text) {
                      (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
                  }
              }
          };
          const handleKeyup = (e) => {
              switch (e.key) {
                  case 'Enter':
                      if (!props.keyboard) {
                          return;
                      }
                      enterPressedRef.value = false;
              }
          };
          const handleKeydown = (e) => {
              switch (e.key) {
                  case 'Enter':
                      if (!props.keyboard || props.loading) {
                          e.preventDefault();
                          return;
                      }
                      enterPressedRef.value = true;
              }
          };
          const handleBlur = () => {
              enterPressedRef.value = false;
          };
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Button', '-button', style$1c, buttonLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Button', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const theme = themeRef.value;
              const { common: { cubicBezierEaseInOut, cubicBezierEaseOut }, self } = theme;
              const { rippleDuration, opacityDisabled, fontWeight, fontWeightStrong } = self;
              const size = mergedSizeRef.value;
              const { dashed, type, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
              // font
              const fontProps = {
                  'font-weight': strong ? fontWeightStrong : fontWeight
              };
              // color
              let colorProps = {
                  '--n-color': 'initial',
                  '--n-color-hover': 'initial',
                  '--n-color-pressed': 'initial',
                  '--n-color-focus': 'initial',
                  '--n-color-disabled': 'initial',
                  '--n-ripple-color': 'initial',
                  '--n-text-color': 'initial',
                  '--n-text-color-hover': 'initial',
                  '--n-text-color-pressed': 'initial',
                  '--n-text-color-focus': 'initial',
                  '--n-text-color-disabled': 'initial'
              };
              const typeIsTertiary = type === 'tertiary';
              const typeIsDefault = type === 'default';
              const mergedType = typeIsTertiary ? 'default' : type;
              if (text) {
                  const propTextColor = textColor || color;
                  const mergedTextColor = propTextColor || self[createKey('textColorText', mergedType)];
                  colorProps = {
                      '--n-color': '#0000',
                      '--n-color-hover': '#0000',
                      '--n-color-pressed': '#0000',
                      '--n-color-focus': '#0000',
                      '--n-color-disabled': '#0000',
                      '--n-ripple-color': '#0000',
                      '--n-text-color': mergedTextColor,
                      '--n-text-color-hover': propTextColor
                          ? createHoverColor(propTextColor)
                          : self[createKey('textColorTextHover', mergedType)],
                      '--n-text-color-pressed': propTextColor
                          ? createPressedColor(propTextColor)
                          : self[createKey('textColorTextPressed', mergedType)],
                      '--n-text-color-focus': propTextColor
                          ? createHoverColor(propTextColor)
                          : self[createKey('textColorTextHover', mergedType)],
                      '--n-text-color-disabled': propTextColor ||
                          self[createKey('textColorTextDisabled', mergedType)]
                  };
              }
              else if (ghost || dashed) {
                  const mergedTextColor = textColor || color;
                  colorProps = {
                      '--n-color': '#0000',
                      '--n-color-hover': '#0000',
                      '--n-color-pressed': '#0000',
                      '--n-color-focus': '#0000',
                      '--n-color-disabled': '#0000',
                      '--n-ripple-color': color || self[createKey('rippleColor', mergedType)],
                      '--n-text-color': mergedTextColor || self[createKey('textColorGhost', mergedType)],
                      '--n-text-color-hover': mergedTextColor
                          ? createHoverColor(mergedTextColor)
                          : self[createKey('textColorGhostHover', mergedType)],
                      '--n-text-color-pressed': mergedTextColor
                          ? createPressedColor(mergedTextColor)
                          : self[createKey('textColorGhostPressed', mergedType)],
                      '--n-text-color-focus': mergedTextColor
                          ? createHoverColor(mergedTextColor)
                          : self[createKey('textColorGhostHover', mergedType)],
                      '--n-text-color-disabled': mergedTextColor ||
                          self[createKey('textColorGhostDisabled', mergedType)]
                  };
              }
              else if (secondary) {
                  const typeTextColor = typeIsDefault
                      ? self.textColor
                      : typeIsTertiary
                          ? self.textColorTertiary
                          : self[createKey('color', mergedType)];
                  const mergedTextColor = color || typeTextColor;
                  const isColoredType = type !== 'default' && type !== 'tertiary';
                  colorProps = {
                      '--n-color': isColoredType
                          ? changeColor(mergedTextColor, {
                              alpha: Number(self.colorOpacitySecondary)
                          })
                          : self.colorSecondary,
                      '--n-color-hover': isColoredType
                          ? changeColor(mergedTextColor, {
                              alpha: Number(self.colorOpacitySecondaryHover)
                          })
                          : self.colorSecondaryHover,
                      '--n-color-pressed': isColoredType
                          ? changeColor(mergedTextColor, {
                              alpha: Number(self.colorOpacitySecondaryPressed)
                          })
                          : self.colorSecondaryPressed,
                      '--n-color-focus': isColoredType
                          ? changeColor(mergedTextColor, {
                              alpha: Number(self.colorOpacitySecondaryHover)
                          })
                          : self.colorSecondaryHover,
                      '--n-color-disabled': self.colorSecondary,
                      '--n-ripple-color': '#0000',
                      '--n-text-color': mergedTextColor,
                      '--n-text-color-hover': mergedTextColor,
                      '--n-text-color-pressed': mergedTextColor,
                      '--n-text-color-focus': mergedTextColor,
                      '--n-text-color-disabled': mergedTextColor
                  };
              }
              else if (tertiary || quaternary) {
                  const typeColor = typeIsDefault
                      ? self.textColor
                      : typeIsTertiary
                          ? self.textColorTertiary
                          : self[createKey('color', mergedType)];
                  const mergedColor = color || typeColor;
                  if (tertiary) {
                      colorProps['--n-color'] = self.colorTertiary;
                      colorProps['--n-color-hover'] = self.colorTertiaryHover;
                      colorProps['--n-color-pressed'] = self.colorTertiaryPressed;
                      colorProps['--n-color-focus'] = self.colorSecondaryHover;
                      colorProps['--n-color-disabled'] = self.colorTertiary;
                  }
                  else {
                      colorProps['--n-color'] = self.colorQuaternary;
                      colorProps['--n-color-hover'] = self.colorQuaternaryHover;
                      colorProps['--n-color-pressed'] = self.colorQuaternaryPressed;
                      colorProps['--n-color-focus'] = self.colorQuaternaryHover;
                      colorProps['--n-color-disabled'] = self.colorQuaternary;
                  }
                  colorProps['--n-ripple-color'] = '#0000';
                  colorProps['--n-text-color'] = mergedColor;
                  colorProps['--n-text-color-hover'] = mergedColor;
                  colorProps['--n-text-color-pressed'] = mergedColor;
                  colorProps['--n-text-color-focus'] = mergedColor;
                  colorProps['--n-text-color-disabled'] = mergedColor;
              }
              else {
                  colorProps = {
                      '--n-color': color || self[createKey('color', mergedType)],
                      '--n-color-hover': color
                          ? createHoverColor(color)
                          : self[createKey('colorHover', mergedType)],
                      '--n-color-pressed': color
                          ? createPressedColor(color)
                          : self[createKey('colorPressed', mergedType)],
                      '--n-color-focus': color
                          ? createHoverColor(color)
                          : self[createKey('colorFocus', mergedType)],
                      '--n-color-disabled': color || self[createKey('colorDisabled', mergedType)],
                      '--n-ripple-color': color || self[createKey('rippleColor', mergedType)],
                      '--n-text-color': textColor ||
                          (color
                              ? self.textColorPrimary
                              : typeIsTertiary
                                  ? self.textColorTertiary
                                  : self[createKey('textColor', mergedType)]),
                      '--n-text-color-hover': textColor ||
                          (color
                              ? self.textColorHoverPrimary
                              : self[createKey('textColorHover', mergedType)]),
                      '--n-text-color-pressed': textColor ||
                          (color
                              ? self.textColorPressedPrimary
                              : self[createKey('textColorPressed', mergedType)]),
                      '--n-text-color-focus': textColor ||
                          (color
                              ? self.textColorFocusPrimary
                              : self[createKey('textColorFocus', mergedType)]),
                      '--n-text-color-disabled': textColor ||
                          (color
                              ? self.textColorDisabledPrimary
                              : self[createKey('textColorDisabled', mergedType)])
                  };
              }
              // border
              let borderProps = {
                  '--n-border': 'initial',
                  '--n-border-hover': 'initial',
                  '--n-border-pressed': 'initial',
                  '--n-border-focus': 'initial',
                  '--n-border-disabled': 'initial'
              };
              if (text) {
                  borderProps = {
                      '--n-border': 'none',
                      '--n-border-hover': 'none',
                      '--n-border-pressed': 'none',
                      '--n-border-focus': 'none',
                      '--n-border-disabled': 'none'
                  };
              }
              else {
                  borderProps = {
                      '--n-border': self[createKey('border', mergedType)],
                      '--n-border-hover': self[createKey('borderHover', mergedType)],
                      '--n-border-pressed': self[createKey('borderPressed', mergedType)],
                      '--n-border-focus': self[createKey('borderFocus', mergedType)],
                      '--n-border-disabled': self[createKey('borderDisabled', mergedType)]
                  };
              }
              // size
              const { [createKey('height', size)]: height, [createKey('fontSize', size)]: fontSize, [createKey('padding', size)]: padding, [createKey('paddingRound', size)]: paddingRound, [createKey('iconSize', size)]: iconSize, [createKey('borderRadius', size)]: borderRadius, [createKey('iconMargin', size)]: iconMargin, waveOpacity } = self;
              const sizeProps = {
                  '--n-width': circle && !text ? height : 'initial',
                  '--n-height': text ? 'initial' : height,
                  '--n-font-size': fontSize,
                  '--n-padding': circle
                      ? 'initial'
                      : text
                          ? 'initial'
                          : round
                              ? paddingRound
                              : padding,
                  '--n-icon-size': iconSize,
                  '--n-icon-margin': iconMargin,
                  '--n-border-radius': text
                      ? 'initial'
                      : circle || round
                          ? height
                          : borderRadius
              };
              return Object.assign(Object.assign(Object.assign(Object.assign({ '--n-bezier': cubicBezierEaseInOut, '--n-bezier-ease-out': cubicBezierEaseOut, '--n-ripple-duration': rippleDuration, '--n-opacity-disabled': opacityDisabled, '--n-wave-opacity': waveOpacity }, fontProps), colorProps), borderProps), sizeProps);
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('button', computed(() => {
                  let hash = '';
                  const { dashed, type, ghost, text, color, round, circle, textColor, secondary, tertiary, quaternary, strong } = props;
                  if (dashed)
                      hash += 'a';
                  if (ghost)
                      hash += 'b';
                  if (text)
                      hash += 'c';
                  if (round)
                      hash += 'd';
                  if (circle)
                      hash += 'e';
                  if (secondary)
                      hash += 'f';
                  if (tertiary)
                      hash += 'g';
                  if (quaternary)
                      hash += 'h';
                  if (strong)
                      hash += 'i';
                  if (color)
                      hash += 'j' + color2Class(color);
                  if (textColor)
                      hash += 'k' + color2Class(textColor);
                  const { value: size } = mergedSizeRef;
                  hash += 'l' + size[0];
                  hash += 'm' + type[0];
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              selfElRef,
              waveElRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedFocusable: mergedFocusableRef,
              mergedSize: mergedSizeRef,
              showBorder: showBorderRef,
              enterPressed: enterPressedRef,
              rtlEnabled: rtlEnabledRef,
              handleMousedown,
              handleKeydown,
              handleBlur,
              handleKeyup,
              handleClick,
              customColorCssVars: computed(() => {
                  const { color } = props;
                  if (!color)
                      return null;
                  const hoverColor = createHoverColor(color);
                  return {
                      '--n-border-color': color,
                      '--n-border-color-hover': hoverColor,
                      '--n-border-color-pressed': createPressedColor(color),
                      '--n-border-color-focus': hoverColor,
                      '--n-border-color-disabled': color
                  };
              }),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, tag: Component, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const children = resolveWrappedSlot(this.$slots.default, (children) => children && (h("span", { class: `${mergedClsPrefix}-button__content` }, children)));
          return (h(Component, { ref: "selfElRef", class: [
                  this.themeClass,
                  `${mergedClsPrefix}-button`,
                  `${mergedClsPrefix}-button--${this.type}-type`,
                  `${mergedClsPrefix}-button--${this.mergedSize}-type`,
                  this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
                  this.disabled && `${mergedClsPrefix}-button--disabled`,
                  this.block && `${mergedClsPrefix}-button--block`,
                  this.enterPressed && `${mergedClsPrefix}-button--pressed`,
                  !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
                  this.color && `${mergedClsPrefix}-button--color`,
                  this.secondary && `${mergedClsPrefix}-button--secondary`,
                  this.loading && `${mergedClsPrefix}-button--loading`,
                  this.ghost && `${mergedClsPrefix}-button--ghost` // required for button group border collapse
              ], tabindex: this.mergedFocusable ? 0 : -1, type: this.attrType, style: this.cssVars, disabled: this.disabled, onClick: this.handleClick, onBlur: this.handleBlur, onMousedown: this.handleMousedown, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
              this.iconPlacement === 'right' && children,
              h(NFadeInExpandTransition, { width: true }, {
                  default: () => resolveWrappedSlot(this.$slots.icon, (children) => (this.loading || this.renderIcon || children) && (h("span", { class: `${mergedClsPrefix}-button__icon`, style: {
                          margin: isSlotEmpty(this.$slots.default) ? '0' : ''
                      } },
                      h(NIconSwitchTransition, null, {
                          default: () => this.loading ? (h(NBaseLoading, { clsPrefix: mergedClsPrefix, key: "loading", class: `${mergedClsPrefix}-icon-slot`, strokeWidth: 20 })) : (h("div", { key: "icon", class: `${mergedClsPrefix}-icon-slot`, role: "none" }, this.renderIcon ? this.renderIcon() : children))
                      }))))
              }),
              this.iconPlacement === 'left' && children,
              !this.text ? (h(NBaseWave, { ref: "waveElRef", clsPrefix: mergedClsPrefix })) : null,
              this.showBorder ? (h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__border`, style: this.customColorCssVars })) : null,
              this.showBorder ? (h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-button__state-border`, style: this.customColorCssVars })) : null));
      }
  });
  var NButton = Button;
  // XButton is for tsx type checking
  // It's not compatible with render function `h`
  // Currently we don't expose it as public
  // If there's any issue about this, we may expose it
  // Since most people use template, the type checking phase doesn't work as tsx
  const XButton = Button;
  // Also, we may make XButton a generic type which support `tag` prop
  // but currently vue doesn't export IntrinsicElementAttributes from runtime-dom
  // so we can't easily make an attr map by hand
  // just leave it for later

  const zero = '0!important';
  const n1 = '-1px!important';
  function createLeftBorderStyle(type) {
    return cM(type + '-type', [c$1('& +', [cB('button', {}, [cM(type + '-type', [cE('border', {
      borderLeftWidth: zero
    }), cE('state-border', {
      left: n1
    })])])])]);
  }
  function createTopBorderStyle(type) {
    return cM(type + '-type', [c$1('& +', [cB('button', [cM(type + '-type', [cE('border', {
      borderTopWidth: zero
    }), cE('state-border', {
      top: n1
    })])])])]);
  }
  var style$1b = cB('button-group', `
 flex-wrap: nowrap;
 display: inline-flex;
 position: relative;
`, [cNotM('vertical', {
    flexDirection: 'row'
  }, [cNotM('rtl', [cB('button', [c$1('&:first-child:not(:last-child)', `
 margin-right: ${zero};
 border-top-right-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1('&:last-child:not(:first-child)', `
 margin-left: ${zero};
 border-top-left-radius: ${zero};
 border-bottom-left-radius: ${zero};
 `), c$1('&:not(:first-child):not(:last-child)', `
 margin-left: ${zero};
 margin-right: ${zero};
 border-radius: ${zero};
 `), createLeftBorderStyle('default'), cM('ghost', [createLeftBorderStyle('primary'), createLeftBorderStyle('info'), createLeftBorderStyle('success'), createLeftBorderStyle('warning'), createLeftBorderStyle('error')])])])]), cM('vertical', {
    flexDirection: 'column'
  }, [cB('button', [c$1('&:first-child:not(:last-child)', `
 margin-bottom: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-bottom-left-radius: ${zero};
 border-bottom-right-radius: ${zero};
 `), c$1('&:last-child:not(:first-child)', `
 margin-top: ${zero};
 margin-left: ${zero};
 margin-right: ${zero};
 border-top-left-radius: ${zero};
 border-top-right-radius: ${zero};
 `), c$1('&:not(:first-child):not(:last-child)', `
 margin: ${zero};
 border-radius: ${zero};
 `), createTopBorderStyle('default'), cM('ghost', [createTopBorderStyle('primary'), createTopBorderStyle('info'), createTopBorderStyle('success'), createTopBorderStyle('warning'), createTopBorderStyle('error')])])])]);

  const buttonGroupProps = {
      size: {
          type: String,
          default: undefined
      },
      vertical: Boolean
  };
  var NButtonGroup = defineComponent({
      name: 'ButtonGroup',
      props: buttonGroupProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          useStyle('-button-group', style$1b, mergedClsPrefixRef);
          provide(buttonGroupInjectionKey, props);
          const rtlEnabledRef = useRtl('ButtonGroup', mergedRtlRef, mergedClsPrefixRef);
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-button-group`,
                  this.rtlEnabled && `${mergedClsPrefix}-button-group--rtl`,
                  this.vertical && `${mergedClsPrefix}-button-group--vertical`
              ], role: "group" }, this.$slots));
      }
  });

  const START_YEAR = 1901;
  // TODO: we need to remove it to make height customizable
  const MONTH_ITEM_HEIGHT = 40;

  const matcherMap = {
      date: isSameDay,
      month: isSameMonth,
      year: isSameYear,
      quarter: isSameQuarter
  };
  function matchDate(sourceTime, patternTime, type) {
      const matcher = matcherMap[type];
      return matcher(sourceTime, patternTime);
  }
  // date item's valueTs can be a tuple since two date may show in one panel, so
  // any matched value would make it shown as selected
  function dateItem(time, monthTs, valueTs, currentTs) {
      let inSpan = false;
      let startOfSpan = false;
      let endOfSpan = false;
      if (Array.isArray(valueTs)) {
          if (valueTs[0] < time && time < valueTs[1]) {
              inSpan = true;
          }
          if (matchDate(valueTs[0], time, 'date'))
              startOfSpan = true;
          if (matchDate(valueTs[1], time, 'date'))
              endOfSpan = true;
      }
      const selected = valueTs !== null &&
          (Array.isArray(valueTs)
              ? matchDate(valueTs[0], time, 'date') ||
                  matchDate(valueTs[1], time, 'date')
              : matchDate(valueTs, time, 'date'));
      return {
          type: 'date',
          dateObject: {
              date: getDate(time),
              month: getMonth(time),
              year: getYear(time)
          },
          inCurrentMonth: isSameMonth(time, monthTs),
          isCurrentDate: matchDate(currentTs, time, 'date'),
          inSpan,
          startOfSpan,
          endOfSpan,
          selected,
          ts: getTime(time)
      };
  }
  function monthItem(monthTs, valueTs, currentTs) {
      return {
          type: 'month',
          dateObject: {
              month: getMonth(monthTs),
              year: getYear(monthTs)
          },
          isCurrent: isSameMonth(currentTs, monthTs),
          selected: valueTs !== null && matchDate(valueTs, monthTs, 'month'),
          ts: getTime(monthTs)
      };
  }
  function yearItem(yearTs, valueTs, currentTs) {
      return {
          type: 'year',
          dateObject: {
              year: getYear(yearTs)
          },
          isCurrent: isSameYear(currentTs, yearTs),
          selected: valueTs !== null && matchDate(valueTs, yearTs, 'year'),
          ts: getTime(yearTs)
      };
  }
  function quarterItem(quarterTs, valueTs, currentTs) {
      return {
          type: 'quarter',
          dateObject: {
              quarter: getQuarter(quarterTs),
              year: getYear(quarterTs)
          },
          isCurrent: isSameQuarter(currentTs, quarterTs),
          selected: valueTs !== null && matchDate(valueTs, quarterTs, 'quarter'),
          ts: getTime(quarterTs)
      };
  }
  /**
   * Given time to display calendar, given the selected time, given current time,
   * return the date array of display time's month.
   */
  function dateArray(monthTs, valueTs, currentTs, startDay, strip = false) {
      const displayMonth = getMonth(monthTs);
      // First day of current month
      let displayMonthIterator = getTime(startOfMonth(monthTs));
      // Last day of last month
      let lastMonthIterator = getTime(addDays(displayMonthIterator, -1));
      const calendarDays = [];
      let protectLastMonthDateIsShownFlag = !strip;
      while (getDay(lastMonthIterator) !== startDay ||
          protectLastMonthDateIsShownFlag) {
          calendarDays.unshift(dateItem(lastMonthIterator, monthTs, valueTs, currentTs));
          lastMonthIterator = getTime(addDays(lastMonthIterator, -1));
          protectLastMonthDateIsShownFlag = false;
      }
      while (getMonth(displayMonthIterator) === displayMonth) {
          calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
          displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
      }
      const endIndex = strip
          ? calendarDays.length <= 28
              ? 28
              : calendarDays.length <= 35
                  ? 35
                  : 42
          : 42;
      while (calendarDays.length < endIndex) {
          calendarDays.push(dateItem(displayMonthIterator, monthTs, valueTs, currentTs));
          displayMonthIterator = getTime(addDays(displayMonthIterator, 1));
      }
      return calendarDays;
  }
  function monthArray(yearAnchorTs, valueTs, currentTs) {
      const calendarMonths = [];
      const yearStart = startOfYear(yearAnchorTs);
      for (let i = 0; i < 12; i++) {
          calendarMonths.push(monthItem(getTime(addMonths(yearStart, i)), valueTs, currentTs));
      }
      return calendarMonths;
  }
  function quarterArray(yearAnchorTs, valueTs, currentTs) {
      const calendarQuarters = [];
      const yearStart = startOfYear(yearAnchorTs);
      for (let i = 0; i < 4; i++) {
          calendarQuarters.push(quarterItem(getTime(addQuarters(yearStart, i)), valueTs, currentTs));
      }
      return calendarQuarters;
  }
  function yearArray(valueTs, currentTs) {
      const calendarYears = [];
      const time1900 = new Date(START_YEAR, 0, 1);
      // 1900 is not a round time, so we use 1911 as start...
      // new Date(1900, 0, 1)
      // 1899-12-31T15:54:17.000Z
      for (let i = 0; i < 200; i++) {
          calendarYears.push(yearItem(getTime(addYears(time1900, i)), valueTs, currentTs));
      }
      return calendarYears;
  }
  function strictParse(string, pattern, backup, option) {
      const result = parse$1(string, pattern, backup, option);
      if (!isValid$1(result))
          return result;
      else if (format$4(result, pattern, option) === string)
          return result;
      else
          return new Date(NaN);
  }
  function getDefaultTime(timeValue) {
      if (timeValue === undefined) {
          return undefined;
      }
      if (typeof timeValue === 'number') {
          return timeValue;
      }
      const [hour, minute, second] = timeValue.split(':');
      return {
          hours: Number(hour),
          minutes: Number(minute),
          seconds: Number(second)
      };
  }
  function pluckValueFromRange(value, type) {
      return Array.isArray(value) ? value[type === 'start' ? 0 : 1] : null;
  }

  var commonVariables$e = {
      titleFontSize: '22px'
  };

  const self$_ = (vars) => {
      const { borderRadius, fontSize, lineHeight, textColor2, textColor1, textColorDisabled, dividerColor, fontWeightStrong, primaryColor, baseColor, hoverColor, cardColor, modalColor, popoverColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$e), { borderRadius, borderColor: composite(cardColor, dividerColor), borderColorModal: composite(modalColor, dividerColor), borderColorPopover: composite(popoverColor, dividerColor), textColor: textColor2, titleFontWeight: fontWeightStrong, titleTextColor: textColor1, dayTextColor: textColorDisabled, fontSize,
          lineHeight, dateColorCurrent: primaryColor, dateTextColorCurrent: baseColor, cellColorHover: composite(cardColor, hoverColor), cellColorHoverModal: composite(modalColor, hoverColor), cellColorHoverPopover: composite(popoverColor, hoverColor), cellColor: cardColor, cellColorModal: modalColor, cellColorPopover: popoverColor, barColor: primaryColor });
  };
  const calendarLight = createTheme({
      name: 'Calendar',
      common: commonLight,
      peers: {
          Button: buttonLight$1
      },
      self: self$_
  });
  var calendarLight$1 = calendarLight;

  // vars:
  // --n-bezier
  // --n-border-color
  // --n-border-color-modal
  // --n-border-color-popover
  // --n-border-radius
  // --n-text-color
  // --n-title-font-weight
  // --n-title-font-size
  // --n-title-text-color
  // --n-day-text-color
  // --n-font-size
  // --n-line-height
  // --n-date-color-current
  // --n-cell-color
  // --n-cell-color-hover
  // --n-cell-color-hover-modal
  // --n-cell-color-hover-popover
  // --n-bar-color
  var style$1a = c$1([cB('calendar', `
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 height: 720px;
 display: flex;
 flex-direction: column;
 `, [cB('calendar-prev-btn', `
 cursor: pointer;
 `), cB('calendar-next-btn', `
 cursor: pointer;
 `), cB('calendar-header', `
 display: flex;
 align-items: center;
 line-height: 1;
 font-size: var(--n-title-font-size);
 padding: 0 0 18px 0;
 justify-content: space-between;
 `, [cE('title', `
 color: var(--n-title-text-color);
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 `), cE('extra', `
 display: flex;
 align-items: center;
 `)]), cB('calendar-dates', `
 display: grid;
 grid-template-columns: repeat(7, minmax(0, 1fr));
 grid-auto-rows: 1fr;
 border-radius: var(--n-border-radius);
 flex: 1;
 border-top: 1px solid;
 border-left: 1px solid;
 border-color: var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 `), cB('calendar-cell', `
 box-sizing: border-box;
 padding: 10px;
 border-right: 1px solid;
 border-bottom: 1px solid;
 border-color: var(--n-border-color);
 cursor: pointer;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1('&:nth-child(7)', `
 border-top-right-radius: var(--n-border-radius);
 `), c$1('&:nth-last-child(7)', `
 border-bottom-left-radius: var(--n-border-radius);
 `), c$1('&:last-child', `
 border-bottom-right-radius: var(--n-border-radius);
 `), c$1('&:hover', `
 background-color: var(--n-cell-color-hover);
 `), cE('bar', `
 position: absolute;
 left: 0;
 right: 0;
 bottom: -1px;
 height: 3px;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `), cM('selected', [cE('bar', `
 background-color: var(--n-bar-color);
 `)]), cB('calendar-date', `
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 color: var(--n-text-color);
 `, [cE('date', `
 color: var(--n-text-color);
 `)]), cM('disabled, other-month', `
 color: var(--n-day-text-color);
 `, [cB('calendar-date', [cE('date', `
 color: var(--n-day-text-color);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 `), cM('current', [cB('calendar-date', [cE('date', `
 color: var(--n-date-text-color-current);
 background-color: var(--n-date-color-current);
 `)])]), cB('calendar-date', `
 position: relative;
 line-height: 1;
 display: flex;
 align-items: center;
 height: 1em;
 justify-content: space-between;
 padding-bottom: .75em;
 `, [cE('date', `
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 margin-left: -0.4em;
 width: 1.8em;
 height: 1.8em;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cE('day', `
 color: var(--n-day-text-color);
 transition: color .3s var(--n-bezier);
 `)])])]), insideModal(cB('calendar', [cB('calendar-dates', `
 border-color: var(--n-border-color-modal);
 `), cB('calendar-cell', `
 border-color: var(--n-border-color-modal);
 `, [c$1('&:hover', `
 background-color: var(--n-cell-color-hover-modal);
 `)])])), insidePopover(cB('calendar', [cB('calendar-dates', `
 border-color: var(--n-border-color-popover);
 `), cB('calendar-cell', `
 border-color: var(--n-border-color-popover);
 `, [c$1('&:hover', `
 background-color: var(--n-cell-color-hover-popover);
 `)])]))]);

  const calendarProps = Object.assign(Object.assign({}, useTheme.props), { isDateDisabled: Function, value: Number, defaultValue: {
          type: Number,
          default: null
      }, onPanelChange: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array] });
  var Calendar = defineComponent({
      name: 'Calendar',
      props: calendarProps,
      setup(props) {
          var _a;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Calendar', '-calendar', style$1a, calendarLight$1, props, mergedClsPrefixRef);
          const { localeRef, dateLocaleRef } = useLocale('DatePicker');
          const now = Date.now();
          // ts => timestamp
          const monthTsRef = ref(startOfMonth((_a = props.defaultValue) !== null && _a !== void 0 ? _a : now).valueOf());
          const uncontrolledValueRef = ref(props.defaultValue || null);
          const mergedValueRef = useMergedState(toRef(props, 'value'), uncontrolledValueRef);
          function doUpdateValue(value, time) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              if (onUpdateValue) {
                  call(onUpdateValue, value, time);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, time);
              }
              uncontrolledValueRef.value = value;
          }
          function handlePrevClick() {
              var _a;
              const monthTs = addMonths(monthTsRef.value, -1).valueOf();
              monthTsRef.value = monthTs;
              (_a = props.onPanelChange) === null || _a === void 0 ? void 0 : _a.call(props, {
                  year: getYear(monthTs),
                  month: getMonth(monthTs) + 1
              });
          }
          function handleNextClick() {
              var _a;
              const monthTs = addMonths(monthTsRef.value, 1).valueOf();
              monthTsRef.value = monthTs;
              (_a = props.onPanelChange) === null || _a === void 0 ? void 0 : _a.call(props, {
                  year: getYear(monthTs),
                  month: getMonth(monthTs) + 1
              });
          }
          function handleTodayClick() {
              var _a;
              const { value: monthTs } = monthTsRef;
              const oldYear = getYear(monthTs);
              const oldMonth = getMonth(monthTs);
              const newMonthTs = startOfMonth(now).valueOf();
              monthTsRef.value = newMonthTs;
              const newYear = getYear(newMonthTs);
              const newMonth = getMonth(newMonthTs);
              if (oldYear !== newYear || oldMonth !== newMonth) {
                  (_a = props.onPanelChange) === null || _a === void 0 ? void 0 : _a.call(props, {
                      year: newYear,
                      month: newMonth + 1
                  });
              }
          }
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { borderColor, borderColorModal, borderColorPopover, borderRadius, titleFontSize, textColor, titleFontWeight, titleTextColor, dayTextColor, fontSize, lineHeight, dateColorCurrent, dateTextColorCurrent, cellColorHover, cellColor, cellColorModal, barColor, cellColorPopover, cellColorHoverModal, cellColorHoverPopover } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-color': borderColor,
                  '--n-border-color-modal': borderColorModal,
                  '--n-border-color-popover': borderColorPopover,
                  '--n-border-radius': borderRadius,
                  '--n-text-color': textColor,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-text-color': titleTextColor,
                  '--n-day-text-color': dayTextColor,
                  '--n-font-size': fontSize,
                  '--n-line-height': lineHeight,
                  '--n-date-color-current': dateColorCurrent,
                  '--n-date-text-color-current': dateTextColorCurrent,
                  '--n-cell-color': cellColor,
                  '--n-cell-color-modal': cellColorModal,
                  '--n-cell-color-popover': cellColorPopover,
                  '--n-cell-color-hover': cellColorHover,
                  '--n-cell-color-hover-modal': cellColorHoverModal,
                  '--n-cell-color-hover-popover': cellColorHoverPopover,
                  '--n-bar-color': barColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('calendar', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              locale: localeRef,
              dateLocale: dateLocaleRef,
              now,
              mergedValue: mergedValueRef,
              monthTs: monthTsRef,
              dateItems: computed(() => {
                  return dateArray(monthTsRef.value, mergedValueRef.value, now, localeRef.value.firstDayOfWeek, true);
              }),
              doUpdateValue,
              handleTodayClick,
              handlePrevClick,
              handleNextClick,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { isDateDisabled, mergedClsPrefix, monthTs, cssVars, mergedValue, mergedTheme, $slots, locale: { monthBeforeYear, today }, dateLocale: { locale }, handleTodayClick, handlePrevClick, handleNextClick, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const normalizedValue = mergedValue && startOfDay(mergedValue).valueOf();
          const year = getYear(monthTs);
          const calendarMonth = getMonth(monthTs) + 1;
          return (h("div", { class: [`${mergedClsPrefix}-calendar`, this.themeClass], style: cssVars },
              h("div", { class: `${mergedClsPrefix}-calendar-header` },
                  h("div", { class: `${mergedClsPrefix}-calendar-header__title` }, resolveSlotWithProps($slots.header, { year, month: calendarMonth }, () => {
                      const localeMonth = format$4(monthTs, 'MMMM', { locale });
                      return [
                          monthBeforeYear
                              ? `${localeMonth} ${year}`
                              : `${year} ${localeMonth}`
                      ];
                  })),
                  h("div", { class: `${mergedClsPrefix}-calendar-header__extra` },
                      h(NButtonGroup, null, {
                          default: () => (h(Fragment, null,
                              h(NButton, { size: "small", onClick: handlePrevClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-prev-btn` }, { default: () => h(ChevronLeftIcon, null) }))
                              }),
                              h(NButton, { size: "small", onClick: handleTodayClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => today }),
                              h(NButton, { size: "small", onClick: handleNextClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-calendar-next-btn` }, { default: () => h(ChevronRightIcon, null) }))
                              })))
                      }))),
              h("div", { class: `${mergedClsPrefix}-calendar-dates` }, this.dateItems.map(({ dateObject, ts, inCurrentMonth, isCurrentDate }, index) => {
                  var _a;
                  const { year, month, date } = dateObject;
                  const fullDate = format$4(ts, 'yyyy-MM-dd');
                  // 'notInCurrentMonth' and 'disabled' are both disabled styles, but 'disabled''s cursor are not-allowed
                  const notInCurrentMonth = !inCurrentMonth;
                  const disabled = (isDateDisabled === null || isDateDisabled === void 0 ? void 0 : isDateDisabled(ts)) === true;
                  const selected = normalizedValue === startOfDay(ts).valueOf();
                  return (h("div", { key: `${calendarMonth}-${index}`, class: [
                          `${mergedClsPrefix}-calendar-cell`,
                          disabled && `${mergedClsPrefix}-calendar-cell--disabled`,
                          notInCurrentMonth &&
                              `${mergedClsPrefix}-calendar-cell--other-month`,
                          disabled && `${mergedClsPrefix}-calendar-cell--not-allowed`,
                          isCurrentDate &&
                              `${mergedClsPrefix}-calendar-cell--current`,
                          selected && `${mergedClsPrefix}-calendar-cell--selected`
                      ], onClick: () => {
                          var _a;
                          if (disabled)
                              return;
                          const monthTs = startOfMonth(ts).valueOf();
                          this.monthTs = monthTs;
                          if (notInCurrentMonth) {
                              (_a = this.onPanelChange) === null || _a === void 0 ? void 0 : _a.call(this, {
                                  year: getYear(monthTs),
                                  month: getMonth(monthTs) + 1
                              });
                          }
                          this.doUpdateValue(ts, {
                              year,
                              month: month + 1,
                              date
                          });
                      } },
                      h("div", { class: `${mergedClsPrefix}-calendar-date` },
                          h("div", { class: `${mergedClsPrefix}-calendar-date__date`, title: fullDate }, date),
                          index < 7 && (h("div", { class: `${mergedClsPrefix}-calendar-date__day`, title: fullDate }, format$4(ts, 'EEE', {
                              locale
                          })))), (_a = $slots.default) === null || _a === void 0 ? void 0 :
                      _a.call($slots, {
                          year,
                          month: month + 1,
                          date
                      }),
                      h("div", { class: `${mergedClsPrefix}-calendar-cell__bar` })));
              }))));
      }
  });

  const self$Z = (vars) => {
      const { fontSize, boxShadow2, popoverColor, textColor2, borderRadius, borderColor, heightSmall, heightMedium, heightLarge, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor } = vars;
      return {
          panelFontSize: fontSize,
          boxShadow: boxShadow2,
          color: popoverColor,
          textColor: textColor2,
          borderRadius,
          border: `1px solid ${borderColor}`,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          dividerColor
      };
  };
  const colorPickerLight = createTheme({
      name: 'ColorPicker',
      common: commonLight,
      peers: {
          Input: inputLight$1,
          Button: buttonLight$1
      },
      self: self$Z
  });
  var colorPickerLight$1 = colorPickerLight;

  function deriveDefaultValue(modes, showAlpha) {
      const mode = modes[0];
      switch (mode) {
          case 'hex':
              return showAlpha ? '#000000FF' : '#000000';
          case 'rgb':
              return showAlpha ? 'rgba(0, 0, 0, 1)' : 'rgb(0, 0, 0)';
          case 'hsl':
              return showAlpha ? 'hsla(0, 0%, 0%, 1)' : 'hsl(0, 0%, 0%)';
          case 'hsv':
              return showAlpha ? 'hsva(0, 0%, 0%, 1)' : 'hsv(0, 0%, 0%)';
      }
      // in case of invalid modes
      return '#000000';
  }
  function getModeFromValue(color) {
      if (color === null)
          return null;
      if (/^ *#/.test(color))
          return 'hex';
      if (color.includes('rgb'))
          return 'rgb';
      if (color.includes('hsl'))
          return 'hsl';
      if (color.includes('hsv'))
          return 'hsv';
      return null;
  }
  function normalizeHue(hue) {
      hue = Math.round(hue);
      return hue >= 360 ? 359 : hue < 0 ? 0 : hue;
  }
  function normalizeAlpha(alpha) {
      alpha = Math.round(alpha * 100) / 100;
      return alpha > 1 ? 1 : alpha < 0 ? 0 : alpha;
  }
  const convert = {
      rgb: {
          hex(value) {
              return toHexaString(rgba(value));
          },
          hsl(value) {
              const [r, g, b, a] = rgba(value);
              return toHslaString([...rgb2hsl(r, g, b), a]);
          },
          hsv(value) {
              const [r, g, b, a] = rgba(value);
              return toHsvaString([...rgb2hsv(r, g, b), a]);
          }
      },
      hex: {
          rgb(value) {
              return toRgbaString(rgba(value));
          },
          hsl(value) {
              const [r, g, b, a] = rgba(value);
              return toHslaString([...rgb2hsl(r, g, b), a]);
          },
          hsv(value) {
              const [r, g, b, a] = rgba(value);
              return toHsvaString([...rgb2hsv(r, g, b), a]);
          }
      },
      hsl: {
          hex(value) {
              const [h, s, l, a] = hsla(value);
              return toHexaString([...hsl2rgb(h, s, l), a]);
          },
          rgb(value) {
              const [h, s, l, a] = hsla(value);
              return toRgbaString([...hsl2rgb(h, s, l), a]);
          },
          hsv(value) {
              const [h, s, l, a] = hsla(value);
              return toHsvaString([...hsl2hsv(h, s, l), a]);
          }
      },
      hsv: {
          hex(value) {
              const [h, s, v, a] = hsva(value);
              return toHexaString([...hsv2rgb(h, s, v), a]);
          },
          rgb(value) {
              const [h, s, v, a] = hsva(value);
              return toRgbaString([...hsv2rgb(h, s, v), a]);
          },
          hsl(value) {
              const [h, s, v, a] = hsva(value);
              return toHslaString([...hsv2hsl(h, s, v), a]);
          }
      }
  };
  // implementation
  function convertColor(value, mode, originalMode) {
      originalMode = originalMode || getModeFromValue(value);
      if (!originalMode)
          return null;
      if (originalMode === mode)
          return value;
      const conversions = convert[originalMode];
      return conversions[mode](value);
  }

  const HANDLE_SIZE$2 = '12px';
  const HANDLE_SIZE_NUM$1 = 12;
  const RADIUS$2 = '6px';
  const RADIUS_NUM = 6;
  const GRADIENT = 'linear-gradient(90deg,red,#ff0 16.66%,#0f0 33.33%,#0ff 50%,#00f 66.66%,#f0f 83.33%,red)';
  var HueSlider = defineComponent({
      name: 'HueSlider',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          hue: {
              type: Number,
              required: true
          },
          onUpdateHue: {
              type: Function,
              required: true
          },
          onComplete: Function
      },
      setup(props) {
          const railRef = ref(null);
          function handleMouseDown(e) {
              if (!railRef.value)
                  return;
              on('mousemove', document, handleMouseMove);
              on('mouseup', document, handleMouseUp);
              handleMouseMove(e);
          }
          function handleMouseMove(e) {
              const { value: railEl } = railRef;
              if (!railEl)
                  return;
              const { width, left } = railEl.getBoundingClientRect();
              const newHue = normalizeHue(((e.clientX - left - RADIUS_NUM) / (width - HANDLE_SIZE_NUM$1)) * 360);
              props.onUpdateHue(newHue);
          }
          function handleMouseUp() {
              var _a;
              off('mousemove', document, handleMouseMove);
              off('mouseup', document, handleMouseUp);
              (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
              railRef,
              handleMouseDown
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-slider`, style: {
                  height: HANDLE_SIZE$2,
                  borderRadius: RADIUS$2
              } },
              h("div", { ref: "railRef", style: {
                      boxShadow: 'inset 0 0 2px 0 rgba(0, 0, 0, .24)',
                      boxSizing: 'border-box',
                      backgroundImage: GRADIENT,
                      height: HANDLE_SIZE$2,
                      borderRadius: RADIUS$2,
                      position: 'relative'
                  }, onMousedown: this.handleMouseDown },
                  h("div", { style: {
                          position: 'absolute',
                          left: RADIUS$2,
                          right: RADIUS$2,
                          top: 0,
                          bottom: 0
                      } },
                      h("div", { class: `${clsPrefix}-color-picker-handle`, style: {
                              left: `calc((${this.hue}%) / 359 * 100 - ${RADIUS$2})`,
                              borderRadius: RADIUS$2,
                              width: HANDLE_SIZE$2,
                              height: HANDLE_SIZE$2
                          } },
                          h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                                  backgroundColor: `hsl(${this.hue}, 100%, 50%)`,
                                  borderRadius: RADIUS$2,
                                  width: HANDLE_SIZE$2,
                                  height: HANDLE_SIZE$2
                              } }))))));
      }
  });

  const HANDLE_SIZE$1 = '12px';
  const HANDLE_SIZE_NUM = 12;
  const RADIUS$1 = '6px';
  var AlphaSlider = defineComponent({
      name: 'AlphaSlider',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          rgba: {
              type: Array,
              default: null
          },
          alpha: {
              type: Number,
              default: 0
          },
          onUpdateAlpha: {
              type: Function,
              required: true
          },
          onComplete: Function
      },
      setup(props) {
          const railRef = ref(null);
          function handleMouseDown(e) {
              if (!railRef.value || !props.rgba)
                  return;
              on('mousemove', document, handleMouseMove);
              on('mouseup', document, handleMouseUp);
              handleMouseMove(e);
          }
          function handleMouseMove(e) {
              const { value: railEl } = railRef;
              if (!railEl)
                  return;
              const { width, left } = railEl.getBoundingClientRect();
              const newAlpha = (e.clientX - left) / (width - HANDLE_SIZE_NUM);
              props.onUpdateAlpha(normalizeAlpha(newAlpha));
          }
          function handleMouseUp() {
              var _a;
              off('mousemove', document, handleMouseMove);
              off('mouseup', document, handleMouseUp);
              (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
              railRef,
              railBackgroundImage: computed(() => {
                  const { rgba } = props;
                  if (!rgba)
                      return '';
                  return `linear-gradient(to right, rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, 0) 0%, rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, 1) 100%)`;
              }),
              handleMouseDown
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-slider`, ref: "railRef", style: {
                  height: HANDLE_SIZE$1,
                  borderRadius: RADIUS$1
              }, onMousedown: this.handleMouseDown },
              h("div", { style: {
                      borderRadius: RADIUS$1,
                      position: 'absolute',
                      left: 0,
                      right: 0,
                      top: 0,
                      bottom: 0,
                      overflow: 'hidden'
                  } },
                  h("div", { class: `${clsPrefix}-color-picker-checkboard` }),
                  h("div", { class: `${clsPrefix}-color-picker-slider__image`, style: {
                          backgroundImage: this.railBackgroundImage
                      } })),
              this.rgba && (h("div", { style: {
                      position: 'absolute',
                      left: RADIUS$1,
                      right: RADIUS$1,
                      top: 0,
                      bottom: 0
                  } },
                  h("div", { class: `${clsPrefix}-color-picker-handle`, style: {
                          left: `calc(${this.alpha * 100}% - ${RADIUS$1})`,
                          borderRadius: RADIUS$1,
                          width: HANDLE_SIZE$1,
                          height: HANDLE_SIZE$1
                      } },
                      h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                              backgroundColor: toRgbaString(this.rgba),
                              borderRadius: RADIUS$1,
                              width: HANDLE_SIZE$1,
                              height: HANDLE_SIZE$1
                          } }))))));
      }
  });

  const HANDLE_SIZE = '12px';
  const RADIUS = '6px';
  var Pallete = defineComponent({
      name: 'Pallete',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          rgba: {
              type: Array,
              default: null
          },
          // 0 - 360
          displayedHue: {
              type: Number,
              required: true
          },
          displayedSv: {
              type: Array,
              required: true
          },
          onUpdateSV: {
              type: Function,
              required: true
          },
          onComplete: Function
      },
      setup(props) {
          const palleteRef = ref(null);
          function handleMouseDown(e) {
              if (!palleteRef.value)
                  return;
              on('mousemove', document, handleMouseMove);
              on('mouseup', document, handleMouseUp);
              handleMouseMove(e);
          }
          function handleMouseMove(e) {
              const { value: palleteEl } = palleteRef;
              if (!palleteEl)
                  return;
              const { width, height, left, bottom } = palleteEl.getBoundingClientRect();
              const newV = (bottom - e.clientY) / height;
              const newS = (e.clientX - left) / width;
              const normalizedNewS = 100 * (newS > 1 ? 1 : newS < 0 ? 0 : newS);
              const normalizedNewV = 100 * (newV > 1 ? 1 : newV < 0 ? 0 : newV);
              props.onUpdateSV(normalizedNewS, normalizedNewV);
          }
          function handleMouseUp() {
              var _a;
              off('mousemove', document, handleMouseMove);
              off('mouseup', document, handleMouseUp);
              (_a = props.onComplete) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return {
              palleteRef,
              handleColor: computed(() => {
                  const { rgba } = props;
                  if (!rgba)
                      return '';
                  return `rgb(${rgba[0]}, ${rgba[1]}, ${rgba[2]})`;
              }),
              handleMouseDown
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-pallete`, onMousedown: this.handleMouseDown, ref: "palleteRef" },
              h("div", { class: `${clsPrefix}-color-picker-pallete__layer`, style: {
                      backgroundImage: `linear-gradient(90deg, white, hsl(${this.displayedHue}, 100%, 50%))`
                  } }),
              h("div", { class: `${clsPrefix}-color-picker-pallete__layer ${clsPrefix}-color-picker-pallete__layer--shadowed`, style: {
                      backgroundImage: 'linear-gradient(180deg, rgba(0, 0, 0, 0%), rgba(0, 0, 0, 100%))'
                  } }),
              this.rgba && (h("div", { class: `${clsPrefix}-color-picker-handle`, style: {
                      width: HANDLE_SIZE,
                      height: HANDLE_SIZE,
                      borderRadius: RADIUS,
                      left: `calc(${this.displayedSv[0]}% - ${RADIUS})`,
                      bottom: `calc(${this.displayedSv[1]}% - ${RADIUS})`
                  } },
                  h("div", { class: `${clsPrefix}-color-picker-handle__fill`, style: {
                          backgroundColor: this.handleColor,
                          borderRadius: RADIUS,
                          width: HANDLE_SIZE,
                          height: HANDLE_SIZE
                      } })))));
      }
  });

  const colorPickerInjectionKey = createInjectionKey('n-color-picker');

  // 0 - 255
  function normalizeRgbUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 255));
      }
      return false;
  }
  // 0 - 360
  function normalizeHueUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 360));
      }
      return false;
  }
  // 0 - 100
  function normalizeSlvUnit(value) {
      if (/^\d{1,3}\.?\d*$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value), 100));
      }
      return false;
  }
  function normalizeHexaUnit(value) {
      const trimmedValue = value.trim();
      if (/^#[0-9a-fA-F]+$/.test(trimmedValue)) {
          return [4, 5, 7, 9].includes(trimmedValue.length);
      }
      return false;
  }
  // 0 - 100%
  function normalizeAlphaUnit(value) {
      if (/^\d{1,3}\.?\d*%$/.test(value.trim())) {
          return Math.max(0, Math.min(parseInt(value) / 100, 100));
      }
      return false;
  }
  const inputThemeOverrides = {
      paddingSmall: '0 4px'
  };
  var ColorInputUnit = defineComponent({
      name: 'ColorInputUnit',
      props: {
          label: {
              type: String,
              required: true
          },
          value: {
              type: [Number, String],
              default: null
          },
          showAlpha: Boolean,
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const inputValueRef = ref('');
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { themeRef } = inject(colorPickerInjectionKey, null);
          watchEffect(() => {
              inputValueRef.value = getInputString();
          });
          function getInputString() {
              const { value } = props;
              if (value === null)
                  return '';
              const { label } = props;
              if (label === 'HEX') {
                  return value;
              }
              if (label === 'A') {
                  return `${Math.floor(value * 100)}%`;
              }
              return String(Math.floor(value));
          }
          function handleInputUpdateValue(value) {
              inputValueRef.value = value;
          }
          function handleInputChange(value) {
              let unit;
              let valid;
              switch (props.label) {
                  case 'HEX':
                      valid = normalizeHexaUnit(value);
                      if (valid) {
                          props.onUpdateValue(value);
                      }
                      inputValueRef.value = getInputString(); // to normalized new value
                      break;
                  case 'H':
                      unit = normalizeHueUnit(value);
                      if (unit === false) {
                          inputValueRef.value = getInputString();
                      }
                      else {
                          props.onUpdateValue(unit);
                      }
                      break;
                  case 'S':
                  case 'L':
                  case 'V':
                      unit = normalizeSlvUnit(value);
                      if (unit === false) {
                          inputValueRef.value = getInputString();
                      }
                      else {
                          props.onUpdateValue(unit);
                      }
                      break;
                  case 'A':
                      unit = normalizeAlphaUnit(value);
                      if (unit === false) {
                          inputValueRef.value = getInputString();
                      }
                      else {
                          props.onUpdateValue(unit);
                      }
                      break;
                  case 'R':
                  case 'G':
                  case 'B':
                      unit = normalizeRgbUnit(value);
                      if (unit === false) {
                          inputValueRef.value = getInputString();
                      }
                      else {
                          props.onUpdateValue(unit);
                      }
                      break;
              }
          }
          return {
              mergedTheme: themeRef,
              inputValue: inputValueRef,
              handleInputChange,
              handleInputUpdateValue
          };
      },
      render() {
          const { mergedTheme } = this;
          return (h(NInput, { size: "small", placeholder: this.label, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, builtinThemeOverrides: inputThemeOverrides, value: this.inputValue, onUpdateValue: this.handleInputUpdateValue, onChange: this.handleInputChange, 
              // add more space for xxx% input
              style: this.label === 'A' ? 'flex-grow: 1.25;' : '' }));
      }
  });

  var ColorInput = defineComponent({
      name: 'ColorInput',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          mode: {
              type: String,
              required: true
          },
          modes: {
              type: Array,
              required: true
          },
          showAlpha: {
              type: Boolean,
              required: true
          },
          value: {
              // for hex to get percise value
              type: String,
              default: null
          },
          valueArr: {
              type: Array,
              default: null
          },
          onUpdateValue: {
              type: Function,
              required: true
          },
          onUpdateMode: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          return {
              handleUnitUpdateValue(index, value) {
                  const { showAlpha } = props;
                  if (props.mode === 'hex') {
                      props.onUpdateValue((showAlpha ? toHexaString : toHexString)(value));
                      return;
                  }
                  let nextValueArr;
                  if (props.valueArr === null) {
                      nextValueArr = [0, 0, 0, 0];
                  }
                  else {
                      nextValueArr = Array.from(props.valueArr);
                  }
                  switch (props.mode) {
                      case 'hsv':
                          nextValueArr[index] = value;
                          props.onUpdateValue((showAlpha ? toHsvaString : toHsvString)(nextValueArr));
                          break;
                      case 'rgb':
                          nextValueArr[index] = value;
                          props.onUpdateValue((showAlpha ? toRgbaString : toRgbString)(nextValueArr));
                          break;
                      case 'hsl':
                          nextValueArr[index] = value;
                          props.onUpdateValue((showAlpha ? toHslaString : toHslString)(nextValueArr));
                          break;
                  }
              }
          };
      },
      render() {
          const { clsPrefix, modes } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-input` },
              h("div", { class: `${clsPrefix}-color-picker-input__mode`, onClick: this.onUpdateMode, style: {
                      cursor: modes.length === 1 ? '' : 'pointer'
                  } }, this.mode.toUpperCase() + (this.showAlpha ? 'A' : '')),
              h(NInputGroup, null, {
                  default: () => {
                      const { mode, valueArr, showAlpha } = this;
                      if (mode === 'hex') {
                          // hex and rgba shares the same value arr
                          let hexValue = null;
                          try {
                              hexValue =
                                  valueArr === null
                                      ? null
                                      : (showAlpha ? toHexaString : toHexString)(valueArr);
                          }
                          catch (_a) { }
                          return (h(ColorInputUnit, { label: 'HEX', showAlpha: showAlpha, value: hexValue, onUpdateValue: (unitValue) => {
                                  this.handleUnitUpdateValue(0, unitValue);
                              } }));
                      }
                      return (mode + (showAlpha ? 'a' : '')).split('').map((v, i) => (h(ColorInputUnit, { label: v.toUpperCase(), value: valueArr === null ? null : valueArr[i], onUpdateValue: (unitValue) => {
                              this.handleUnitUpdateValue(i, unitValue);
                          } })));
                  }
              })));
      }
  });

  var ColorPickerTrigger = defineComponent({
      name: 'ColorPickerTrigger',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          value: {
              type: String,
              default: null
          },
          hsla: {
              type: Array,
              default: null
          },
          disabled: Boolean,
          onClick: Function
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { colorPickerSlots, renderLabelRef } = inject(colorPickerInjectionKey, null);
          return () => {
              const { hsla, value, clsPrefix, onClick, disabled } = props;
              const renderLabel = colorPickerSlots.label || renderLabelRef.value;
              return (h("div", { class: [
                      `${clsPrefix}-color-picker-trigger`,
                      disabled && `${clsPrefix}-color-picker-trigger--disabled`
                  ], onClick: disabled ? undefined : onClick },
                  h("div", { class: `${clsPrefix}-color-picker-trigger__fill` },
                      h("div", { class: `${clsPrefix}-color-picker-checkboard` }),
                      h("div", { style: {
                              position: 'absolute',
                              left: 0,
                              right: 0,
                              top: 0,
                              bottom: 0,
                              backgroundColor: hsla ? toHslaString(hsla) : ''
                          } }),
                      value && hsla ? (h("div", { class: `${clsPrefix}-color-picker-trigger__value`, style: {
                              color: hsla[2] > 50 || hsla[3] < 0.5 ? 'black' : 'white'
                          } }, renderLabel ? renderLabel(value) : value)) : null)));
          };
      }
  });

  // Try to normalize the color values to ensure that they are valid CSS colors
  function normalizeColor(color, mode) {
      if (mode === 'hsv') {
          const [h, s, v, a] = hsva(color);
          return toRgbaString([...hsv2rgb(h, s, v), a]);
      }
      // For the mode that is not in preset, we keep the original value.
      // For color names, they are legal to CSS, so we dont deal with them,
      // and only standardize them when outputting.
      return color;
  }
  function getHexFromName(color) {
      const ctx = document.createElement('canvas').getContext('2d');
      if (!ctx) {
          return '#000000';
      }
      ctx.fillStyle = color;
      return ctx.fillStyle;
  }
  var ColorPickerSwatches = defineComponent({
      name: 'ColorPickerSwatches',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          mode: {
              type: String,
              required: true
          },
          swatches: {
              type: Array,
              required: true
          },
          onUpdateColor: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const parsedSwatchesRef = computed(() => props.swatches.map((value) => {
              const mode = getModeFromValue(value);
              return {
                  value,
                  mode,
                  legalValue: normalizeColor(value, mode)
              };
          }));
          function normalizeOutput(parsed) {
              const { mode: modeProp } = props;
              let { value, mode: swatchColorMode } = parsed;
              // color name is converted to hex
              if (!swatchColorMode) {
                  swatchColorMode = 'hex';
                  if (/^[a-zA-Z]+$/.test(value)) {
                      value = getHexFromName(value);
                  }
                  else {
                      // for invalid color, we make it black
                      warn$2('color-picker', `color ${value} in swatches is invalid.`);
                      value = '#000000';
                  }
              }
              if (swatchColorMode === modeProp)
                  return value;
              // swatch value to current mode value
              return convertColor(value, modeProp, swatchColorMode);
          }
          function handleSwatchSelect(parsed) {
              props.onUpdateColor(normalizeOutput(parsed));
          }
          function handleSwatchKeyDown(e, parsed) {
              if (e.key === 'Enter')
                  handleSwatchSelect(parsed);
          }
          return {
              parsedSwatchesRef,
              handleSwatchSelect,
              handleSwatchKeyDown
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-swatches` }, this.parsedSwatchesRef.map((swatch) => (h("div", { class: `${clsPrefix}-color-picker-swatch`, tabindex: 0, onClick: () => {
                  this.handleSwatchSelect(swatch);
              }, onKeydown: (e) => {
                  this.handleSwatchKeyDown(e, swatch);
              } },
              h("div", { class: `${clsPrefix}-color-picker-swatch__fill`, style: { background: swatch.legalValue } }))))));
      }
  });

  var ColorPreview = defineComponent({
      name: 'ColorPreview',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          mode: {
              type: String,
              required: true
          },
          color: {
              type: String,
              default: null,
              validator: (value) => {
                  const mode = getModeFromValue(value);
                  return Boolean(!value || (mode && mode !== 'hsv'));
              }
          },
          onUpdateColor: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          function handleChange(e) {
              var _a;
              // hex
              const value = e.target.value;
              (_a = props.onUpdateColor) === null || _a === void 0 ? void 0 : _a.call(props, convertColor(value.toUpperCase(), props.mode, 'hex'));
              e.stopPropagation();
          }
          return {
              handleChange
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-color-picker-preview__preview` },
              h("span", { class: `${clsPrefix}-color-picker-preview__fill`, style: {
                      background: this.color || '#000000'
                  } }),
              h("input", { class: `${clsPrefix}-color-picker-preview__input`, type: "color", value: this.color, onChange: this.handleChange })));
      }
  });

  // vars:
  // --n-color
  // --n-text-color
  // --n-border-radius
  // --n-panel-font-size
  // --n-font-size
  // --n-bezier
  // --n-height
  // --n-box-shadow
  // --n-divider-color
  var style$19 = c$1([cB('color-picker', `
 display: inline-block;
 box-sizing: border-box;
 height: var(--n-height);
 font-size: var(--n-font-size);
 width: 100%;
 position: relative;
 `), cB('color-picker-panel', `
 margin: 4px 0;
 width: 240px;
 font-size: var(--n-panel-font-size);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition(), cB('input', `
 text-align: center;
 `)]), cB('color-picker-checkboard', `
 background: white; 
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [c$1('&::after', `
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 12px 12px;
 background-position: 0 0, 0 6px, 6px -6px, -6px 0px;
 background-repeat: repeat;
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB('color-picker-slider', `
 margin-bottom: 8px;
 position: relative;
 box-sizing: border-box;
 `, [cE('image', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), c$1('&::after', `
 content: "";
 position: absolute;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 pointer-events: none;
 `)]), cB('color-picker-handle', `
 z-index: 1;
 box-shadow: 0 0 2px 0 rgba(0, 0, 0, .45);
 position: absolute;
 background-color: white;
 overflow: hidden;
 `, [cE('fill', `
 box-sizing: border-box;
 border: 2px solid white;
 `)]), cB('color-picker-pallete', `
 height: 180px;
 position: relative;
 margin-bottom: 8px;
 cursor: crosshair;
 `, [cE('layer', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM('shadowed', `
 box-shadow: inset 0 0 2px 0 rgba(0, 0, 0, .24);
 `)])]), cB('color-picker-preview', `
 display: flex;
 `, [cE('sliders', `
 flex: 1 0 auto;
 `), cE('preview', `
 position: relative;
 height: 30px;
 width: 30px;
 margin: 0 0 8px 6px;
 border-radius: 50%;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 overflow: hidden;
 `), cE('fill', `
 display: block;
 width: 30px;
 height: 30px;
 `), cE('input', `
 position: absolute;
 top: 0;
 left: 0;
 width: 30px;
 height: 30px;
 opacity: 0;
 z-index: 1;
 `)]), cB('color-picker-input', `
 display: flex;
 align-items: center;
 `, [cB('input', `
 flex-grow: 1;
 flex-basis: 0;
 `), cE('mode', `
 width: 72px;
 text-align: center;
 `)]), cB('color-picker-control', `
 padding: 12px;
 `), cB('color-picker-action', `
 display: flex;
 margin-top: -4px;
 border-top: 1px solid var(--n-divider-color);
 padding: 8px 12px;
 justify-content: flex-end;
 `, [cB('button', 'margin-left: 8px;')]), cB('color-picker-trigger', `
 border: var(--n-border);
 height: 100%;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 transition: border-color .3s var(--n-bezier);
 cursor: pointer;
 `, [cE('value', `
 white-space: nowrap;
 position: relative;
 `), cE('fill', `
 border-radius: var(--n-border-radius);
 position: absolute;
 display: flex;
 align-items: center;
 justify-content: center;
 left: 4px;
 right: 4px;
 top: 4px;
 bottom: 4px;
 `), cM('disabled', 'cursor: not-allowed'), cB('color-picker-checkboard', `
 border-radius: var(--n-border-radius);
 `, [c$1('&::after', `
 --n-block-size: calc((var(--n-height) - 8px) / 3);
 background-size: calc(var(--n-block-size) * 2) calc(var(--n-block-size) * 2);
 background-position: 0 0, 0 var(--n-block-size), var(--n-block-size) calc(-1 * var(--n-block-size)), calc(-1 * var(--n-block-size)) 0px; 
 `)])]), cB('color-picker-swatches', `
 display: grid;
 grid-gap: 8px;
 flex-wrap: wrap;
 position: relative;
 grid-template-columns: repeat(auto-fill, 18px);
 margin-top: 10px;
 `, [cB('color-picker-swatch', `
 width: 18px;
 height: 18px;
 background-image: linear-gradient(45deg, #DDD 25%, #0000 25%), linear-gradient(-45deg, #DDD 25%, #0000 25%), linear-gradient(45deg, #0000 75%, #DDD 75%), linear-gradient(-45deg, #0000 75%, #DDD 75%);
 background-size: 8px 8px;
 background-position: 0px 0, 0px 4px, 4px -4px, -4px 0px;
 background-repeat: repeat;
 `, [cE('fill', `
 position: relative;
 width: 100%;
 height: 100%;
 border-radius: 3px;
 box-shadow: rgba(0, 0, 0, .15) 0px 0px 0px 1px inset;
 cursor: pointer;
 `), c$1('&:focus', `
 outline: none;
 `, [cE('fill', [c$1('&::after', `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 background: inherit;
 filter: blur(2px);
 content: "";
 `)])])])])]);

  const colorPickerProps = Object.assign(Object.assign({}, useTheme.props), { value: String, show: {
          type: Boolean,
          default: undefined
      }, defaultShow: Boolean, defaultValue: String, modes: {
          type: Array,
          // no hsva by default since browser doesn't support it
          default: () => ['rgb', 'hex', 'hsl']
      }, placement: {
          type: String,
          default: 'bottom-start'
      }, to: useAdjustedTo.propTo, showAlpha: {
          type: Boolean,
          default: true
      }, showPreview: Boolean, swatches: Array, disabled: {
          type: Boolean,
          default: undefined
      }, actions: {
          type: Array,
          default: null
      }, internalActions: Array, size: String, renderLabel: Function, onComplete: Function, onConfirm: Function, 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array] });
  var NColorPicker = defineComponent({
      name: 'ColorPicker',
      props: colorPickerProps,
      setup(props, { slots }) {
          const selfRef = ref(null);
          let upcomingValue = null;
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const { localeRef } = useLocale('global');
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('ColorPicker', '-color-picker', style$19, colorPickerLight$1, props, mergedClsPrefixRef);
          provide(colorPickerInjectionKey, {
              themeRef,
              renderLabelRef: toRef(props, 'renderLabel'),
              colorPickerSlots: slots
          });
          const uncontrolledShowRef = ref(props.defaultShow);
          const mergedShowRef = useMergedState(toRef(props, 'show'), uncontrolledShowRef);
          function doUpdateShow(value) {
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, value);
              if (_onUpdateShow)
                  call(_onUpdateShow, value);
              uncontrolledShowRef.value = value;
          }
          const { defaultValue } = props;
          const uncontrolledValueRef = ref(defaultValue === undefined
              ? deriveDefaultValue(props.modes, props.showAlpha)
              : defaultValue);
          const mergedValueRef = useMergedState(toRef(props, 'value'), uncontrolledValueRef);
          const undoStackRef = ref([mergedValueRef.value]);
          const valueIndexRef = ref(0);
          const valueModeRef = computed(() => getModeFromValue(mergedValueRef.value));
          const { modes } = props;
          const displayedModeRef = ref(getModeFromValue(mergedValueRef.value) || modes[0] || 'rgb');
          function handleUpdateDisplayedMode() {
              const { modes } = props;
              const { value: displayedMode } = displayedModeRef;
              const currentModeIndex = modes.findIndex((mode) => mode === displayedMode);
              if (~currentModeIndex) {
                  displayedModeRef.value = modes[(currentModeIndex + 1) % modes.length];
              }
              else {
                  displayedModeRef.value = 'rgb';
              }
          }
          let _h, // avoid conflict with render function's h
          s, l, v, r, g, b, a;
          const hsvaRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (!mergedValue)
                  return null;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              switch (valueModeRef.value) {
                  case 'hsv':
                      return hsva(mergedValue);
                  case 'hsl':
                      [_h, s, l, a] = hsla(mergedValue);
                      return [...hsl2hsv(_h, s, l), a];
                  case 'rgb':
                  case 'hex':
                      [r, g, b, a] = rgba(mergedValue);
                      return [...rgb2hsv(r, g, b), a];
              }
          });
          const rgbaRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (!mergedValue)
                  return null;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              switch (valueModeRef.value) {
                  case 'rgb':
                  case 'hex':
                      return rgba(mergedValue);
                  case 'hsv':
                      [_h, s, v, a] = hsva(mergedValue);
                      return [...hsv2rgb(_h, s, v), a];
                  case 'hsl':
                      [_h, s, l, a] = hsla(mergedValue);
                      return [...hsl2rgb(_h, s, l), a];
              }
          });
          const hslaRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (!mergedValue)
                  return null;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              switch (valueModeRef.value) {
                  case 'hsl':
                      return hsla(mergedValue);
                  case 'hsv':
                      [_h, s, v, a] = hsva(mergedValue);
                      return [...hsv2hsl(_h, s, v), a];
                  case 'rgb':
                  case 'hex':
                      [r, g, b, a] = rgba(mergedValue);
                      return [...rgb2hsl(r, g, b), a];
              }
          });
          const mergedValueArrRef = computed(() => {
              switch (displayedModeRef.value) {
                  case 'rgb':
                  case 'hex':
                      return rgbaRef.value;
                  case 'hsv':
                      return hsvaRef.value;
                  case 'hsl':
                      return hslaRef.value;
              }
          });
          const displayedHueRef = ref(0);
          const displayedAlphaRef = ref(1);
          const displayedSvRef = ref([0, 0]);
          function handleUpdateSv(s, v) {
              const { value: hsvaArr } = hsvaRef;
              const hue = displayedHueRef.value;
              const alpha = hsvaArr ? hsvaArr[3] : 1;
              displayedSvRef.value = [s, v];
              const { showAlpha } = props;
              switch (displayedModeRef.value) {
                  case 'hsv':
                      doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s, v, alpha]), 'cursor');
                      break;
                  case 'hsl':
                      doUpdateValue((showAlpha ? toHslaString : toHslString)([
                          ...hsv2hsl(hue, s, v),
                          alpha
                      ]), 'cursor');
                      break;
                  case 'rgb':
                      doUpdateValue((showAlpha ? toRgbaString : toRgbString)([
                          ...hsv2rgb(hue, s, v),
                          alpha
                      ]), 'cursor');
                      break;
                  case 'hex':
                      doUpdateValue((showAlpha ? toHexaString : toHexString)([
                          ...hsv2rgb(hue, s, v),
                          alpha
                      ]), 'cursor');
                      break;
              }
          }
          function handleUpdateHue(hue) {
              displayedHueRef.value = hue;
              const { value: hsvaArr } = hsvaRef;
              if (!hsvaArr) {
                  return;
              }
              const [, s, v, a] = hsvaArr;
              const { showAlpha } = props;
              switch (displayedModeRef.value) {
                  case 'hsv':
                      doUpdateValue((showAlpha ? toHsvaString : toHsvString)([hue, s, v, a]), 'cursor');
                      break;
                  case 'rgb':
                      doUpdateValue((showAlpha ? toRgbaString : toRgbString)([
                          ...hsv2rgb(hue, s, v),
                          a
                      ]), 'cursor');
                      break;
                  case 'hex':
                      doUpdateValue((showAlpha ? toHexaString : toHexString)([
                          ...hsv2rgb(hue, s, v),
                          a
                      ]), 'cursor');
                      break;
                  case 'hsl':
                      doUpdateValue((showAlpha ? toHslaString : toHslString)([
                          ...hsv2hsl(hue, s, v),
                          a
                      ]), 'cursor');
                      break;
              }
          }
          function handleUpdateAlpha(alpha) {
              switch (displayedModeRef.value) {
                  case 'hsv':
                      [_h, s, v] = hsvaRef.value;
                      doUpdateValue(toHsvaString([_h, s, v, alpha]), 'cursor');
                      break;
                  case 'rgb':
                      [r, g, b] = rgbaRef.value;
                      doUpdateValue(toRgbaString([r, g, b, alpha]), 'cursor');
                      break;
                  case 'hex':
                      [r, g, b] = rgbaRef.value;
                      doUpdateValue(toHexaString([r, g, b, alpha]), 'cursor');
                      break;
                  case 'hsl':
                      [_h, s, l] = hslaRef.value;
                      doUpdateValue(toHslaString([_h, s, l, alpha]), 'cursor');
                      break;
              }
              displayedAlphaRef.value = alpha;
          }
          function doUpdateValue(value, updateSource) {
              if (updateSource === 'cursor') {
                  upcomingValue = value;
              }
              else {
                  upcomingValue = null;
              }
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              nTriggerFormChange();
              nTriggerFormInput();
              uncontrolledValueRef.value = value;
          }
          function handleInputUpdateValue(value) {
              doUpdateValue(value, 'input');
              void nextTick(handleComplete);
          }
          function handleComplete(pushStack = true) {
              const { value } = mergedValueRef;
              // no value & only hue changes will complete with no value
              if (value) {
                  const { nTriggerFormChange, nTriggerFormInput } = formItem;
                  const { onComplete } = props;
                  if (onComplete) {
                      onComplete(value);
                  }
                  const { value: undoStack } = undoStackRef;
                  const { value: valueIndex } = valueIndexRef;
                  if (pushStack) {
                      undoStack.splice(valueIndex + 1, undoStack.length, value);
                      valueIndexRef.value = valueIndex + 1;
                  }
                  nTriggerFormChange();
                  nTriggerFormInput();
              }
          }
          function undo() {
              const { value: valueIndex } = valueIndexRef;
              if (valueIndex - 1 < 0)
                  return;
              doUpdateValue(undoStackRef.value[valueIndex - 1], 'input');
              handleComplete(false);
              valueIndexRef.value = valueIndex - 1;
          }
          function redo() {
              const { value: valueIndex } = valueIndexRef;
              if (valueIndex < 0 || valueIndex + 1 >= undoStackRef.value.length)
                  return;
              doUpdateValue(undoStackRef.value[valueIndex + 1], 'input');
              handleComplete(false);
              valueIndexRef.value = valueIndex + 1;
          }
          function handleClear() {
              doUpdateValue(null, 'input');
              doUpdateShow(false);
          }
          function handleConfirm() {
              const { value } = mergedValueRef;
              const { onConfirm } = props;
              if (onConfirm) {
                  onConfirm(value);
              }
              doUpdateShow(false);
          }
          const undoableRef = computed(() => valueIndexRef.value >= 1);
          const redoableRef = computed(() => {
              const { value: undoStack } = undoStackRef;
              return undoStack.length > 1 && valueIndexRef.value < undoStack.length - 1;
          });
          watch(mergedShowRef, (value) => {
              if (!value) {
                  undoStackRef.value = [mergedValueRef.value];
                  valueIndexRef.value = 0;
              }
          });
          watchEffect(() => {
              if (upcomingValue && upcomingValue === mergedValueRef.value) ;
              else {
                  const { value } = hsvaRef;
                  if (value) {
                      displayedHueRef.value = value[0];
                      displayedAlphaRef.value = value[3];
                      displayedSvRef.value = [value[1], value[2]];
                  }
              }
              upcomingValue = null;
          });
          const cssVarsRef = computed(() => {
              const { value: mergedSize } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut }, self: { textColor, color, panelFontSize, boxShadow, border, borderRadius, dividerColor, [createKey('height', mergedSize)]: height, [createKey('fontSize', mergedSize)]: fontSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-color': color,
                  '--n-panel-font-size': panelFontSize,
                  '--n-font-size': fontSize,
                  '--n-box-shadow': boxShadow,
                  '--n-border': border,
                  '--n-border-radius': borderRadius,
                  '--n-height': height,
                  '--n-divider-color': dividerColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('color-picker', computed(() => {
                  return mergedSizeRef.value[0];
              }), cssVarsRef, props)
              : undefined;
          function renderPanel() {
              var _a;
              const { value: rgba } = rgbaRef;
              const { value: displayedHue } = displayedHueRef;
              const { internalActions, modes, actions } = props;
              const { value: mergedTheme } = themeRef;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              return (h("div", { class: [
                      `${mergedClsPrefix}-color-picker-panel`,
                      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value
                  ], onDragstart: (e) => {
                      e.preventDefault();
                  }, style: inlineThemeDisabled
                      ? undefined
                      : cssVarsRef.value },
                  h("div", { class: `${mergedClsPrefix}-color-picker-control` },
                      h(Pallete, { clsPrefix: mergedClsPrefix, rgba: rgba, displayedHue: displayedHue, displayedSv: displayedSvRef.value, onUpdateSV: handleUpdateSv, onComplete: handleComplete }),
                      h("div", { class: `${mergedClsPrefix}-color-picker-preview` },
                          h("div", { class: `${mergedClsPrefix}-color-picker-preview__sliders` },
                              h(HueSlider, { clsPrefix: mergedClsPrefix, hue: displayedHue, onUpdateHue: handleUpdateHue, onComplete: handleComplete }),
                              props.showAlpha ? (h(AlphaSlider, { clsPrefix: mergedClsPrefix, rgba: rgba, alpha: displayedAlphaRef.value, onUpdateAlpha: handleUpdateAlpha, onComplete: handleComplete })) : null),
                          props.showPreview ? (h(ColorPreview, { clsPrefix: mergedClsPrefix, mode: displayedModeRef.value, color: rgbaRef.value && toHexString(rgbaRef.value), onUpdateColor: (color) => {
                                  doUpdateValue(color, 'input');
                              } })) : null),
                      h(ColorInput, { clsPrefix: mergedClsPrefix, showAlpha: props.showAlpha, mode: displayedModeRef.value, modes: modes, onUpdateMode: handleUpdateDisplayedMode, value: mergedValueRef.value, valueArr: mergedValueArrRef.value, onUpdateValue: handleInputUpdateValue }),
                      ((_a = props.swatches) === null || _a === void 0 ? void 0 : _a.length) && (h(ColorPickerSwatches, { clsPrefix: mergedClsPrefix, mode: displayedModeRef.value, swatches: props.swatches, onUpdateColor: (color) => {
                              doUpdateValue(color, 'input');
                          } }))),
                  (actions === null || actions === void 0 ? void 0 : actions.length) ? (h("div", { class: `${mergedClsPrefix}-color-picker-action` },
                      actions.includes('confirm') && (h(NButton, { size: "small", onClick: handleConfirm, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.confirm })),
                      actions.includes('clear') && (h(NButton, { size: "small", onClick: handleClear, disabled: !mergedValueRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.clear })))) : null,
                  slots.action ? (h("div", { class: `${mergedClsPrefix}-color-picker-action` }, { default: slots.action })) : internalActions ? (h("div", { class: `${mergedClsPrefix}-color-picker-action` },
                      internalActions.includes('undo') && (h(NButton, { size: "small", onClick: undo, disabled: !undoableRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.undo })),
                      internalActions.includes('redo') && (h(NButton, { size: "small", onClick: redo, disabled: !redoableRef.value, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button }, { default: () => localeRef.value.redo })))) : null));
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              namespace: namespaceRef,
              selfRef,
              hsla: hslaRef,
              rgba: rgbaRef,
              mergedShow: mergedShowRef,
              mergedDisabled: mergedDisabledRef,
              isMounted: isMounted(),
              adjustedTo: useAdjustedTo(props),
              mergedValue: mergedValueRef,
              handleTriggerClick() {
                  doUpdateShow(true);
              },
              handleClickOutside(e) {
                  var _a;
                  if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
                      return;
                  }
                  doUpdateShow(false);
              },
              renderPanel,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [this.themeClass, `${mergedClsPrefix}-color-picker`], ref: "selfRef", style: this.cssVars },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h(ColorPickerTrigger, { clsPrefix: mergedClsPrefix, value: this.mergedValue, hsla: this.hsla, disabled: this.mergedDisabled, onClick: this.handleTriggerClick }, {
                              label: $slots.label
                          }))
                      }),
                      h(VFollower, { placement: this.placement, show: this.mergedShow, containerClass: this.namespace, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, to: this.adjustedTo }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                              default: () => this.mergedShow
                                  ? withDirectives(this.renderPanel(), [
                                      [
                                          clickoutside$1,
                                          this.handleClickOutside,
                                          undefined,
                                          { capture: true }
                                      ]
                                  ])
                                  : null
                          }))
                      })
                  ]
              })));
      }
  });

  var commonVariables$d = {
      paddingSmall: '12px 16px 12px',
      paddingMedium: '19px 24px 20px',
      paddingLarge: '23px 32px 24px',
      paddingHuge: '27px 40px 28px',
      titleFontSizeSmall: '16px',
      titleFontSizeMedium: '18px',
      titleFontSizeLarge: '18px',
      titleFontSizeHuge: '18px',
      closeIconSize: '18px',
      closeSize: '22px'
  };

  const self$Y = (vars) => {
      const { primaryColor, borderRadius, lineHeight, fontSize, cardColor, textColor2, textColor1, dividerColor, fontWeightStrong, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, modalColor, boxShadow1, popoverColor, actionColor } = vars;
      return Object.assign(Object.assign({}, commonVariables$d), { lineHeight, color: cardColor, colorModal: modalColor, colorPopover: popoverColor, colorTarget: primaryColor, colorEmbedded: actionColor, colorEmbeddedModal: actionColor, colorEmbeddedPopover: actionColor, textColor: textColor2, titleTextColor: textColor1, borderColor: dividerColor, actionColor, titleFontWeight: fontWeightStrong, closeColorHover,
          closeColorPressed, closeBorderRadius: borderRadius, closeIconColor,
          closeIconColorHover,
          closeIconColorPressed, fontSizeSmall: fontSize, fontSizeMedium: fontSize, fontSizeLarge: fontSize, fontSizeHuge: fontSize, boxShadow: boxShadow1, borderRadius });
  };
  const cardLight = {
      name: 'Card',
      common: commonLight,
      self: self$Y
  };
  var cardLight$1 = cardLight;

  // vars:
  // --n-bezier
  // --n-border-radius
  // --n-color
  // --n-color-modal
  // --n-color-popover
  // --n-text-color
  // --n-line-height
  // --n-padding-top
  // --n-padding-bottom
  // --n-padding-left
  // --n-font-size
  // --n-action-color
  // --n-title-font-weight
  // --n-title-font-size
  // --n-title-text-color
  // --n-close-size
  // --n-close-icon-size
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-border-color
  // --n-box-shadow
  // --n-color-embedded
  // --n-color-embedded-modal
  // --n-color-embedded-popover
  var style$18 = c$1([cB('card', `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
    background: 'var(--n-color-modal)'
  }), cM('hoverable', [c$1('&:hover', 'box-shadow: var(--n-box-shadow);')]), cM('content-segmented', [c$1('>', [cE('content', {
    paddingTop: 'var(--n-padding-bottom)'
  })])]), cM('content-soft-segmented', [c$1('>', [cE('content', `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM('footer-segmented', [c$1('>', [cE('footer', {
    paddingTop: 'var(--n-padding-bottom)'
  })])]), cM('footer-soft-segmented', [c$1('>', [cE('footer', `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1('>', [cB('card-header', `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE('main', `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE('extra', `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE('close', `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE('action', `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE('content', 'flex: 1; min-width: 0;'), cE('content, footer', `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1('&:first-child', {
    paddingTop: 'var(--n-padding-bottom)'
  })]), cE('action', `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB('card-cover', `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1('img', `
 display: block;
 width: 100%;
 `)]), cM('bordered', `
 border: 1px solid var(--n-border-color);
 `, [c$1('&:target', 'border-color: var(--n-color-target);')]), cM('action-segmented', [c$1('>', [cE('action', [c$1('&:not(:first-child)', {
    borderTop: '1px solid var(--n-border-color)'
  })])])]), cM('content-segmented, content-soft-segmented', [c$1('>', [cE('content', {
    transition: 'border-color 0.3s var(--n-bezier)'
  }, [c$1('&:not(:first-child)', {
    borderTop: '1px solid var(--n-border-color)'
  })])])]), cM('footer-segmented, footer-soft-segmented', [c$1('>', [cE('footer', {
    transition: 'border-color 0.3s var(--n-bezier)'
  }, [c$1('&:not(:first-child)', {
    borderTop: '1px solid var(--n-border-color)'
  })])])]), cM('embedded', `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB('card', `
 background: var(--n-color-modal);
 `, [cM('embedded', `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB('card', `
 background: var(--n-color-popover);
 `, [cM('embedded', `
 background-color: var(--n-color-embedded-popover);
 `)]))]);

  const cardBaseProps = {
      title: String,
      contentClass: String,
      contentStyle: [Object, String],
      headerClass: String,
      headerStyle: [Object, String],
      headerExtraClass: String,
      headerExtraStyle: [Object, String],
      footerClass: String,
      footerStyle: [Object, String],
      embedded: Boolean,
      segmented: {
          type: [Boolean, Object],
          default: false
      },
      size: {
          type: String,
          default: 'medium'
      },
      bordered: {
          type: Boolean,
          default: true
      },
      closable: Boolean,
      hoverable: Boolean,
      role: String,
      onClose: [Function, Array],
      tag: {
          type: String,
          default: 'div'
      }
  };
  const cardBasePropKeys = keysOf(cardBaseProps);
  const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
  var NCard = defineComponent({
      name: 'Card',
      props: cardProps,
      setup(props) {
          const handleCloseClick = () => {
              const { onClose } = props;
              if (onClose)
                  call(onClose);
          };
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Card', '-card', style$18, cardLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Card', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { self: { color, colorModal, colorTarget, textColor, titleTextColor, titleFontWeight, borderColor, actionColor, borderRadius, lineHeight, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeBorderRadius, closeIconSize, closeSize, boxShadow, colorPopover, colorEmbedded, colorEmbeddedModal, colorEmbeddedPopover, [createKey('padding', size)]: padding, [createKey('fontSize', size)]: fontSize, [createKey('titleFontSize', size)]: titleFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;
              const { top: paddingTop, left: paddingLeft, bottom: paddingBottom } = getMargin(padding);
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-color': color,
                  '--n-color-modal': colorModal,
                  '--n-color-popover': colorPopover,
                  '--n-color-embedded': colorEmbedded,
                  '--n-color-embedded-modal': colorEmbeddedModal,
                  '--n-color-embedded-popover': colorEmbeddedPopover,
                  '--n-color-target': colorTarget,
                  '--n-text-color': textColor,
                  '--n-line-height': lineHeight,
                  '--n-action-color': actionColor,
                  '--n-title-text-color': titleTextColor,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-border-color': borderColor,
                  '--n-box-shadow': boxShadow,
                  // size
                  '--n-padding-top': paddingTop,
                  '--n-padding-bottom': paddingBottom,
                  '--n-padding-left': paddingLeft,
                  '--n-font-size': fontSize,
                  '--n-title-font-size': titleFontSize,
                  '--n-close-size': closeSize,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-border-radius': closeBorderRadius
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('card', computed(() => {
                  return props.size[0];
              }), cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: themeRef,
              handleCloseClick,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { footerStyle, headerExtraClass, headerClass, contentClass, segmented, bordered, hoverable, mergedClsPrefix, rtlEnabled, onRender, embedded, tag: Component, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h(Component, { class: [
                  `${mergedClsPrefix}-card`,
                  this.themeClass,
                  embedded && `${mergedClsPrefix}-card--embedded`,
                  {
                      [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
                      [`${mergedClsPrefix}-card--content${typeof segmented !== 'boolean' && segmented.content === 'soft'
                        ? '-soft'
                        : ''}-segmented`]: segmented === true || (segmented !== false && segmented.content),
                      [`${mergedClsPrefix}-card--footer${typeof segmented !== 'boolean' && segmented.footer === 'soft'
                        ? '-soft'
                        : ''}-segmented`]: segmented === true || (segmented !== false && segmented.footer),
                      [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || (segmented !== false && segmented.action),
                      [`${mergedClsPrefix}-card--bordered`]: bordered,
                      [`${mergedClsPrefix}-card--hoverable`]: hoverable
                  }
              ], style: this.cssVars, role: this.role },
              resolveWrappedSlot($slots.cover, (children) => children && (h("div", { class: `${mergedClsPrefix}-card-cover`, role: "none" }, children))),
              resolveWrappedSlot($slots.header, (children) => {
                  return children || this.title || this.closable ? (h("div", { class: [`${mergedClsPrefix}-card-header`, headerClass], style: this.headerStyle },
                      h("div", { class: `${mergedClsPrefix}-card-header__main`, role: "heading" }, children || this.title),
                      resolveWrappedSlot($slots['header-extra'], (children) => children && (h("div", { class: [
                              `${mergedClsPrefix}-card-header__extra`,
                              headerExtraClass
                          ], style: this.headerExtraStyle }, children))),
                      this.closable ? (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-card-header__close`, onClick: this.handleCloseClick, absolute: true })) : null)) : null;
              }),
              resolveWrappedSlot($slots.default, (children) => children && (h("div", { class: [`${mergedClsPrefix}-card__content`, contentClass], style: this.contentStyle, role: "none" }, children))),
              resolveWrappedSlot($slots.footer, (children) => children && [
                  h("div", { class: [`${mergedClsPrefix}-card__footer`, footerStyle], style: this.footerStyle, role: "none" }, children)
              ]),
              resolveWrappedSlot($slots.action, (children) => children && (h("div", { class: `${mergedClsPrefix}-card__action`, role: "none" }, children)))));
      }
  });

  const self$X = (vars) => {
      return {
          dotSize: '8px',
          dotColor: 'rgba(255, 255, 255, .3)',
          dotColorActive: 'rgba(255, 255, 255, 1)',
          dotColorFocus: 'rgba(255, 255, 255, .5)',
          dotLineWidth: '16px',
          dotLineWidthActive: '24px',
          arrowColor: '#eee'
      };
  };
  const carouselLight = {
      name: 'Carousel',
      common: commonLight,
      self: self$X
  };
  var carouselLight$1 = carouselLight;

  // Because of the nature of the loop slide work,
  // we need to add duplicates to the left and right of the carousel
  // slot    [ 0 1 2 ]
  // display 2 0 1 2 0
  // real    0 1 2 3 4
  function addDuplicateSlides(slides) {
      const { length } = slides;
      if (length > 1) {
          slides.push(duplicateSlide(slides[0], 0, 'append'));
          slides.unshift(duplicateSlide(slides[length - 1], length - 1, 'prepend'));
          return slides;
      }
      return slides;
  }
  function duplicateSlide(child, index, position) {
      return cloneVNode(child, {
          // for patch
          key: `carousel-item-duplicate-${index}-${position}`
      });
  }
  function getDisplayIndex(current, length, duplicatedable) {
      return !duplicatedable
          ? current
          : current === 0
              ? length - 3
              : current === length - 1
                  ? 0
                  : current - 1;
  }
  function getRealIndex(current, duplicatedable) {
      return !duplicatedable ? current : current + 1;
  }
  function getPrevIndex(current, length, duplicatedable) {
      if (current < 0)
          return null;
      return current === 0 ? (duplicatedable ? length - 1 : null) : current - 1;
  }
  function getNextIndex(current, length, duplicatedable) {
      if (current > length - 1)
          return null;
      return current === length - 1 ? (duplicatedable ? 0 : null) : current + 1;
  }
  function getDisplayTotalView(total, duplicatedable) {
      return duplicatedable && total > 3 ? total - 2 : total;
  }

  function isTouchEvent$1(e) {
      return window.TouchEvent && e instanceof window.TouchEvent;
  }

  function calculateSize(element, innerOnly) {
      let { offsetWidth: width, offsetHeight: height } = element;
      if (innerOnly) {
          const style = getComputedStyle(element);
          width =
              width -
                  parseFloat(style.getPropertyValue('padding-left')) -
                  parseFloat(style.getPropertyValue('padding-right'));
          height =
              height -
                  parseFloat(style.getPropertyValue('padding-top')) -
                  parseFloat(style.getPropertyValue('padding-bottom'));
      }
      return { width, height };
  }
  function clampValue(value, min, max) {
      return value < min ? min : value > max ? max : value;
  }
  function resolveSpeed(value) {
      if (value === undefined)
          return 0;
      if (typeof value === 'number')
          return value;
      const timeRE = /^((\d+)?\.?\d+?)(ms|s)?$/;
      const match = value.match(timeRE);
      if (match) {
          const [, number, , unit = 'ms'] = match;
          return Number(number) * (unit === 'ms' ? 1 : 1000);
      }
      return 0;
  }

  const carouselMethodsInjectionKey = createInjectionKey('n-carousel-methods');
  const provideCarouselContext = (contextValue) => {
      provide(carouselMethodsInjectionKey, contextValue);
  };
  const useCarouselContext = (location = 'unknown', component = 'component') => {
      const CarouselContext = inject(carouselMethodsInjectionKey);
      if (!CarouselContext) {
          throwError(location, `\`${component}\` must be placed inside \`n-carousel\`.`);
      }
      return CarouselContext;
  };

  const carouselDotsProps = {
      total: {
          type: Number,
          default: 0
      },
      currentIndex: {
          type: Number,
          default: 0
      },
      dotType: {
          type: String,
          default: 'dot'
      },
      trigger: {
          type: String,
          default: 'click'
      },
      keyboard: Boolean
  };
  var NCarouselDots = defineComponent({
      name: 'CarouselDots',
      props: carouselDotsProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const dotElsRef = ref([]);
          const NCarousel = useCarouselContext();
          function handleKeydown(e, current) {
              switch (e.key) {
                  case 'Enter':
                  case ' ':
                      e.preventDefault();
                      NCarousel.to(current);
                      return;
              }
              if (props.keyboard) {
                  handleKeyboard(e);
              }
          }
          function handleMouseenter(current) {
              if (props.trigger === 'hover') {
                  NCarousel.to(current);
              }
          }
          function handleClick(current) {
              if (props.trigger === 'click') {
                  NCarousel.to(current);
              }
          }
          function handleKeyboard(e) {
              var _a;
              if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
                  return;
              }
              const nodeName = (_a = document.activeElement) === null || _a === void 0 ? void 0 : _a.nodeName.toLowerCase();
              if (nodeName === 'input' || nodeName === 'textarea') {
                  return;
              }
              const { code: keycode } = e;
              const isVerticalNext = keycode === 'PageUp' || keycode === 'ArrowUp';
              const isVerticalPrev = keycode === 'PageDown' || keycode === 'ArrowDown';
              const isHorizontalNext = keycode === 'PageUp' || keycode === 'ArrowRight';
              const isHorizontalPrev = keycode === 'PageDown' || keycode === 'ArrowLeft';
              const vertical = NCarousel.isVertical();
              const wantToNext = vertical ? isVerticalNext : isHorizontalNext;
              const wantToPrev = vertical ? isVerticalPrev : isHorizontalPrev;
              if (!wantToNext && !wantToPrev) {
                  return;
              }
              e.preventDefault();
              if (wantToNext && !NCarousel.isNextDisabled()) {
                  NCarousel.next();
                  focusDot(NCarousel.currentIndexRef.value);
              }
              else if (wantToPrev && !NCarousel.isPrevDisabled()) {
                  NCarousel.prev();
                  focusDot(NCarousel.currentIndexRef.value);
              }
          }
          function focusDot(index) {
              var _a;
              (_a = dotElsRef.value[index]) === null || _a === void 0 ? void 0 : _a.focus();
          }
          onBeforeUpdate(() => (dotElsRef.value.length = 0));
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              dotEls: dotElsRef,
              handleKeydown,
              handleMouseenter,
              handleClick
          };
      },
      render() {
          const { mergedClsPrefix, dotEls } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-carousel__dots`,
                  `${mergedClsPrefix}-carousel__dots--${this.dotType}`
              ], role: "tablist" }, indexMap(this.total, (i) => {
              const selected = i === this.currentIndex;
              return (h("div", { "aria-selected": selected, ref: (el) => dotEls.push(el), role: "button", tabindex: "0", class: [
                      `${mergedClsPrefix}-carousel__dot`,
                      selected && `${mergedClsPrefix}-carousel__dot--active`
                  ], key: i, onClick: () => {
                      this.handleClick(i);
                  }, onMouseenter: () => {
                      this.handleMouseenter(i);
                  }, onKeydown: (e) => {
                      this.handleKeydown(e, i);
                  } }));
          })));
      }
  });

  const backwardIcon = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
      h("g", { fill: "none" },
          h("path", { d: "M10.26 3.2a.75.75 0 0 1 .04 1.06L6.773 8l3.527 3.74a.75.75 0 1 1-1.1 1.02l-4-4.25a.75.75 0 0 1 0-1.02l4-4.25a.75.75 0 0 1 1.06-.04z", fill: "currentColor" }))));
  const forwardIcon = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 16 16" },
      h("g", { fill: "none" },
          h("path", { d: "M5.74 3.2a.75.75 0 0 0-.04 1.06L9.227 8L5.7 11.74a.75.75 0 1 0 1.1 1.02l4-4.25a.75.75 0 0 0 0-1.02l-4-4.25a.75.75 0 0 0-1.06-.04z", fill: "currentColor" }))));
  var NCarouselArrow = defineComponent({
      name: 'CarouselArrow',
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const { isVertical, isPrevDisabled, isNextDisabled, prev, next } = useCarouselContext();
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              isVertical,
              isPrevDisabled,
              isNextDisabled,
              prev,
              next
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-carousel__arrow-group` },
              h("div", { class: [
                      `${mergedClsPrefix}-carousel__arrow`,
                      this.isPrevDisabled() &&
                          `${mergedClsPrefix}-carousel__arrow--disabled`
                  ], role: "button", onClick: this.prev }, backwardIcon),
              h("div", { class: [
                      `${mergedClsPrefix}-carousel__arrow`,
                      this.isNextDisabled() &&
                          `${mergedClsPrefix}-carousel__arrow--disabled`
                  ], role: "button", onClick: this.next }, forwardIcon)));
      }
  });

  const CarouselItemName = 'CarouselItem';
  const isCarouselItem = (child) => { var _a; return ((_a = child.type) === null || _a === void 0 ? void 0 : _a.name) === CarouselItemName; };
  var NCarouselItem = defineComponent({
      name: CarouselItemName,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const NCarousel = useCarouselContext(camelCase$1(CarouselItemName), `n-${camelCase$1(CarouselItemName)}`);
          const selfElRef = ref();
          const indexRef = computed(() => {
              const { value: selfEl } = selfElRef;
              return selfEl ? NCarousel.getSlideIndex(selfEl) : -1;
          });
          const isPrevRef = computed(() => NCarousel.isPrev(indexRef.value));
          const isNextRef = computed(() => NCarousel.isNext(indexRef.value));
          const isActiveRef = computed(() => NCarousel.isActive(indexRef.value));
          const styleRef = computed(() => NCarousel.getSlideStyle(indexRef.value));
          onMounted(() => {
              NCarousel.addSlide(selfElRef.value);
          });
          onBeforeUnmount(() => {
              NCarousel.removeSlide(selfElRef.value);
          });
          function handleClick(event) {
              const { value: index } = indexRef;
              if (index !== undefined) {
                  NCarousel === null || NCarousel === void 0 ? void 0 : NCarousel.onCarouselItemClick(index, event);
              }
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              selfElRef,
              isPrev: isPrevRef,
              isNext: isNextRef,
              isActive: isActiveRef,
              index: indexRef,
              style: styleRef,
              handleClick
          };
      },
      render() {
          var _a;
          const { $slots: slots, mergedClsPrefix, isPrev, isNext, isActive, index, style } = this;
          const className = [
              `${mergedClsPrefix}-carousel__slide`,
              {
                  [`${mergedClsPrefix}-carousel__slide--current`]: isActive,
                  [`${mergedClsPrefix}-carousel__slide--prev`]: isPrev,
                  [`${mergedClsPrefix}-carousel__slide--next`]: isNext
              }
          ];
          return (h("div", { ref: "selfElRef", class: className, role: "option", tabindex: "-1", "data-index": index, "aria-hidden": !isActive, style: style, 
              // We use ts-ignore for vue-tsc, since it seems to patch native event
              // for vue components
              // @ts-expect-error vue's tsx has type for capture events
              onClickCapture: this.handleClick }, (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
              isPrev,
              isNext,
              isActive,
              index
          })));
      }
  });

  // vars:
  // --n-bezier
  // --n-dot-color
  // --n-dot-color-focus
  // --n-dot-color-active
  // --n-dot-size
  // --n-dot-line-width
  // --n-dot-line-width-active
  // --n-arrow-color
  var style$17 = cB('carousel', `
 position: relative;
 width: 100%;
 height: 100%;
 touch-action: pan-y;
 overflow: hidden;
`, [cE('slides', `
 display: flex;
 width: 100%;
 height: 100%;
 transition-timing-function: var(--n-bezier);
 transition-property: transform;
 `, [cE('slide', `
 flex-shrink: 0;
 position: relative;
 width: 100%;
 height: 100%;
 outline: none;
 overflow: hidden;
 `, [c$1('> img', `
 display: block;
 `)])]), cE('dots', `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `, [cM('dot', [cE('dot', `
 height: var(--n-dot-size);
 width: var(--n-dot-size);
 background-color: var(--n-dot-color);
 border-radius: 50%;
 cursor: pointer;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1('&:focus', `
 background-color: var(--n-dot-color-focus);
 `), cM('active', `
 background-color: var(--n-dot-color-active);
 `)])]), cM('line', [cE('dot', `
 border-radius: 9999px;
 width: var(--n-dot-line-width);
 height: 4px;
 background-color: var(--n-dot-color);
 cursor: pointer;
 transition:
 width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [c$1('&:focus', `
 background-color: var(--n-dot-color-focus);
 `), cM('active', `
 width: var(--n-dot-line-width-active);
 background-color: var(--n-dot-color-active);
 `)])])]), cE('arrow', `
 transition: background-color .3s var(--n-bezier);
 cursor: pointer;
 height: 28px;
 width: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 background-color: rgba(255, 255, 255, .2);
 color: var(--n-arrow-color);
 border-radius: 8px;
 user-select: none;
 -webkit-user-select: none;
 font-size: 18px;
 `, [c$1('svg', `
 height: 1em;
 width: 1em;
 `), c$1('&:hover', `
 background-color: rgba(255, 255, 255, .3);
 `)]), cM('vertical', `
 touch-action: pan-x;
 `, [cE('slides', `
 flex-direction: column;
 `), cM('fade', [cE('slide', `
 top: 50%;
 left: unset;
 transform: translateY(-50%);
 `)]), cM('card', [cE('slide', `
 top: 50%;
 left: unset;
 transform: translateY(-50%) translateZ(-400px);
 `, [cM('current', `
 transform: translateY(-50%) translateZ(0);
 `), cM('prev', `
 transform: translateY(-100%) translateZ(-200px);
 `), cM('next', `
 transform: translateY(0%) translateZ(-200px);
 `)])])]), cM('usercontrol', [cE('slides', [c$1('>', [c$1('div', `
 position: absolute;
 top: 50%;
 left: 50%;
 width: 100%;
 height: 100%;
 transform: translate(-50%, -50%);
 `)])])]), cM('left', [cE('dots', `
 transform: translateY(-50%);
 top: 50%;
 left: 12px;
 flex-direction: column;
 `, [cM('line', [cE('dot', `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM('active', `
 height: var(--n-dot-line-width-active);
 `)])])]), cE('dot', `
 margin: 4px 0;
 `)]), cE('arrow-group', `
 position: absolute;
 display: flex;
 flex-wrap: nowrap;
 `), cM('vertical', [cE('arrow', `
 transform: rotate(90deg);
 `)]), cM('show-arrow', [cM('bottom', [cE('dots', `
 transform: translateX(0);
 bottom: 18px;
 left: 18px;
 `)]), cM('top', [cE('dots', `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM('left', [cE('dots', `
 transform: translateX(0);
 top: 18px;
 left: 18px;
 `)]), cM('right', [cE('dots', `
 transform: translateX(0);
 top: 18px;
 right: 18px;
 `)])]), cM('left', [cE('arrow-group', `
 bottom: 12px;
 left: 12px;
 flex-direction: column;
 `, [c$1('> *:first-child', `
 margin-bottom: 12px;
 `)])]), cM('right', [cE('dots', `
 transform: translateY(-50%);
 top: 50%;
 right: 12px;
 flex-direction: column;
 `, [cM('line', [cE('dot', `
 width: 4px;
 height: var(--n-dot-line-width);
 margin: 4px 0;
 transition:
 height .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 `, [cM('active', `
 height: var(--n-dot-line-width-active);
 `)])])]), cE('dot', `
 margin: 4px 0;
 `), cE('arrow-group', `
 bottom: 12px;
 right: 12px;
 flex-direction: column;
 `, [c$1('> *:first-child', `
 margin-bottom: 12px;
 `)])]), cM('top', [cE('dots', `
 transform: translateX(-50%);
 top: 12px;
 left: 50%;
 `, [cM('line', [cE('dot', `
 margin: 0 4px;
 `)])]), cE('dot', `
 margin: 0 4px;
 `), cE('arrow-group', `
 top: 12px;
 right: 12px;
 `, [c$1('> *:first-child', `
 margin-right: 12px;
 `)])]), cM('bottom', [cE('dots', `
 transform: translateX(-50%);
 bottom: 12px;
 left: 50%;
 `, [cM('line', [cE('dot', `
 margin: 0 4px;
 `)])]), cE('dot', `
 margin: 0 4px;
 `), cE('arrow-group', `
 bottom: 12px;
 right: 12px;
 `, [c$1('> *:first-child', `
 margin-right: 12px;
 `)])]), cM('fade', [cE('slide', `
 position: absolute;
 opacity: 0;
 transition-property: opacity;
 pointer-events: none;
 `, [cM('current', `
 opacity: 1;
 pointer-events: auto;
 `)])]), cM('card', [cE('slides', `
 perspective: 1000px;
 `), cE('slide', `
 position: absolute;
 left: 50%;
 opacity: 0;
 transform: translateX(-50%) translateZ(-400px);
 transition-property: opacity, transform;
 `, [cM('current', `
 opacity: 1;
 transform: translateX(-50%) translateZ(0);
 z-index: 1;
 `), cM('prev', `
 opacity: 0.4;
 transform: translateX(-100%) translateZ(-200px);
 `), cM('next', `
 opacity: 0.4;
 transform: translateX(0%) translateZ(-200px);
 `)])])]);

  /* eslint-disable @typescript-eslint/no-unsafe-argument */
  const transitionProperties = [
      'transitionDuration',
      'transitionTimingFunction'
  ];
  const carouselProps = Object.assign(Object.assign({}, useTheme.props), { defaultIndex: {
          type: Number,
          default: 0
      }, currentIndex: Number, showArrow: Boolean, dotType: {
          type: String,
          default: 'dot'
      }, dotPlacement: {
          type: String,
          default: 'bottom'
      }, slidesPerView: {
          type: [Number, String],
          default: 1
      }, spaceBetween: {
          type: Number,
          default: 0
      }, centeredSlides: Boolean, direction: {
          type: String,
          default: 'horizontal'
      }, autoplay: Boolean, interval: {
          type: Number,
          default: 5000
      }, loop: {
          type: Boolean,
          default: true
      }, effect: {
          type: String,
          default: 'slide'
      }, showDots: {
          type: Boolean,
          default: true
      }, trigger: {
          type: String,
          default: 'click'
      }, transitionStyle: {
          type: Object,
          default: () => ({
              transitionDuration: '300ms'
          })
      }, transitionProps: Object, draggable: Boolean, prevSlideStyle: [Object, String], nextSlideStyle: [Object, String], touchable: {
          type: Boolean,
          default: true
      }, mousewheel: Boolean, keyboard: Boolean, 'onUpdate:currentIndex': Function, onUpdateCurrentIndex: Function });
  // only one carousel is allowed to trigger touch globally
  let globalDragging = false;
  var Carousel = defineComponent({
      name: 'Carousel',
      props: carouselProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          // Dom
          const selfElRef = ref(null);
          const slidesElRef = ref(null);
          const slideElsRef = ref([]);
          const slideVNodesRef = { value: [] };
          // Computed states
          const verticalRef = computed(() => props.direction === 'vertical');
          const sizeAxisRef = computed(() => (verticalRef.value ? 'height' : 'width'));
          const spaceAxisRef = computed(() => verticalRef.value ? 'bottom' : 'right');
          const sequenceLayoutRef = computed(() => props.effect === 'slide');
          const duplicatedableRef = computed(
          // duplicate the copy operation in `slide` mode,
          // because only its DOM is sequence layout
          () => props.loop && props.slidesPerView === 1 && sequenceLayoutRef.value);
          // user wants to control the transition animation
          const userWantsControlRef = computed(() => props.effect === 'custom');
          // used to calculate total views
          const displaySlidesPerViewRef = computed(() => !sequenceLayoutRef.value || props.centeredSlides ? 1 : props.slidesPerView);
          // used to calculate the size of each slide
          const realSlidesPerViewRef = computed(() => userWantsControlRef.value ? 1 : props.slidesPerView);
          // we automatically calculate total view for special slides per view
          const autoSlideSizeRef = computed(() => displaySlidesPerViewRef.value === 'auto' ||
              (props.slidesPerView === 'auto' && props.centeredSlides));
          // Carousel size
          const perViewSizeRef = ref({ width: 0, height: 0 });
          const slideSizesRef = computed(() => {
              const { value: slidesEls } = slideElsRef;
              if (!slidesEls.length)
                  return [];
              const { value: autoSlideSize } = autoSlideSizeRef;
              if (autoSlideSize) {
                  return slidesEls.map((slide) => calculateSize(slide));
              }
              const { value: slidesPerView } = realSlidesPerViewRef;
              const { value: perViewSize } = perViewSizeRef;
              const { value: axis } = sizeAxisRef;
              let axisSize = perViewSize[axis];
              if (slidesPerView !== 'auto') {
                  const { spaceBetween } = props;
                  const remaining = axisSize - (slidesPerView - 1) * spaceBetween;
                  const percentage = 1 / Math.max(1, slidesPerView);
                  axisSize = remaining * percentage;
              }
              const slideSize = Object.assign(Object.assign({}, perViewSize), { [axis]: axisSize });
              return slidesEls.map(() => slideSize);
          });
          // The translate required to reach each slide
          const slideTranlatesRef = computed(() => {
              const { value: slideSizes } = slideSizesRef;
              if (!slideSizes.length)
                  return [];
              const { centeredSlides, spaceBetween } = props;
              const { value: axis } = sizeAxisRef;
              const { [axis]: perViewSize } = perViewSizeRef.value;
              let previousTranslate = 0;
              return slideSizes.map(({ [axis]: slideSize }) => {
                  let translate = previousTranslate;
                  if (centeredSlides) {
                      translate += (slideSize - perViewSize) / 2;
                  }
                  previousTranslate += slideSize + spaceBetween;
                  return translate;
              });
          });
          // Styles
          const isMountedRef = ref(false);
          const transitionStyleRef = computed(() => {
              const { transitionStyle } = props;
              return transitionStyle
                  ? keep(transitionStyle, transitionProperties)
                  : {};
          });
          const speedRef = computed(() => userWantsControlRef.value
              ? 0
              : resolveSpeed(transitionStyleRef.value.transitionDuration));
          const slideStylesRef = computed(() => {
              const { value: slidesEls } = slideElsRef;
              if (!slidesEls.length)
                  return [];
              const useComputedSize = !(autoSlideSizeRef.value || realSlidesPerViewRef.value === 1);
              const getSlideSize = (index) => {
                  if (useComputedSize) {
                      const { value: axis } = sizeAxisRef;
                      return {
                          [axis]: `${slideSizesRef.value[index][axis]}px`
                      };
                  }
              };
              if (userWantsControlRef.value) {
                  // We center each slide when user wants to control the transition animation,
                  // so there is no need to calculate the offset
                  return slidesEls.map((_, i) => getSlideSize(i));
              }
              const { effect, spaceBetween } = props;
              const { value: spaceAxis } = spaceAxisRef;
              return slidesEls.reduce((styles, _, i) => {
                  const style = Object.assign(Object.assign({}, getSlideSize(i)), { [`margin-${spaceAxis}`]: `${spaceBetween}px` });
                  styles.push(style);
                  if (isMountedRef.value && (effect === 'fade' || effect === 'card')) {
                      Object.assign(style, transitionStyleRef.value);
                  }
                  return styles;
              }, []);
          });
          // Total
          const totalViewRef = computed(() => {
              const { value: slidesPerView } = displaySlidesPerViewRef;
              const { length: totalSlides } = slideElsRef.value;
              if (slidesPerView !== 'auto') {
                  return Math.max(totalSlides - slidesPerView, 0) + 1;
              }
              else {
                  const { value: slideSizes } = slideSizesRef;
                  const { length } = slideSizes;
                  if (!length)
                      return totalSlides;
                  const { value: translates } = slideTranlatesRef;
                  const { value: axis } = sizeAxisRef;
                  const perViewSize = perViewSizeRef.value[axis];
                  let lastViewSize = slideSizes[slideSizes.length - 1][axis];
                  let i = length;
                  while (i > 1 && lastViewSize < perViewSize) {
                      i--;
                      lastViewSize += translates[i] - translates[i - 1];
                  }
                  return clampValue(i + 1, 1, length);
              }
          });
          const displayTotalViewRef = computed(() => getDisplayTotalView(totalViewRef.value, duplicatedableRef.value));
          // Index
          const defaultRealIndex = getRealIndex(props.defaultIndex, duplicatedableRef.value);
          const uncontrolledDisplayIndexRef = ref(getDisplayIndex(defaultRealIndex, totalViewRef.value, duplicatedableRef.value));
          const mergedDisplayIndexRef = useMergedState(toRef(props, 'currentIndex'), uncontrolledDisplayIndexRef);
          const realIndexRef = computed(() => getRealIndex(mergedDisplayIndexRef.value, duplicatedableRef.value));
          // Reality methods
          function toRealIndex(index) {
              var _a, _b;
              index = clampValue(index, 0, totalViewRef.value - 1);
              const displayIndex = getDisplayIndex(index, totalViewRef.value, duplicatedableRef.value);
              const { value: lastDisplayIndex } = mergedDisplayIndexRef;
              if (displayIndex !== mergedDisplayIndexRef.value) {
                  uncontrolledDisplayIndexRef.value = displayIndex;
                  (_a = props['onUpdate:currentIndex']) === null || _a === void 0 ? void 0 : _a.call(props, displayIndex, lastDisplayIndex);
                  (_b = props.onUpdateCurrentIndex) === null || _b === void 0 ? void 0 : _b.call(props, displayIndex, lastDisplayIndex);
              }
          }
          function getRealPrevIndex(index = realIndexRef.value) {
              return getPrevIndex(index, totalViewRef.value, props.loop);
          }
          function getRealNextIndex(index = realIndexRef.value) {
              return getNextIndex(index, totalViewRef.value, props.loop);
          }
          function isRealPrev(slideOrIndex) {
              const index = getSlideIndex(slideOrIndex);
              return index !== null && getRealPrevIndex() === index;
          }
          function isRealNext(slideOrIndex) {
              const index = getSlideIndex(slideOrIndex);
              return index !== null && getRealNextIndex() === index;
          }
          function isRealActive(slideOrIndex) {
              return realIndexRef.value === getSlideIndex(slideOrIndex);
          }
          // Display methods
          // They are used to deal with the actual values displayed on the UI
          function isDisplayActive(index) {
              return mergedDisplayIndexRef.value === index;
          }
          function isPrevDisabled() {
              return getRealPrevIndex() === null;
          }
          function isNextDisabled() {
              return getRealNextIndex() === null;
          }
          // To
          function to(index) {
              const realIndex = clampValue(getRealIndex(index, duplicatedableRef.value), 0, totalViewRef.value);
              if (index !== mergedDisplayIndexRef.value ||
                  realIndex !== realIndexRef.value) {
                  toRealIndex(realIndex);
              }
          }
          function prev() {
              const prevIndex = getRealPrevIndex();
              if (prevIndex !== null)
                  toRealIndex(prevIndex);
          }
          function next() {
              const nextIndex = getRealNextIndex();
              if (nextIndex !== null)
                  toRealIndex(nextIndex);
          }
          function prevIfSlideTransitionEnd() {
              if (!inTransition || !duplicatedableRef.value)
                  prev();
          }
          function nextIfSlideTransitionEnd() {
              if (!inTransition || !duplicatedableRef.value)
                  next();
          }
          // Translate to
          let inTransition = false;
          // record the translate of each slide, so that it can be restored at touch
          let previousTranslate = 0;
          const translateStyleRef = ref({});
          function updateTranslate(translate, speed = 0) {
              translateStyleRef.value = Object.assign({}, transitionStyleRef.value, {
                  transform: verticalRef.value
                      ? `translateY(${-translate}px)`
                      : `translateX(${-translate}px)`,
                  transitionDuration: `${speed}ms`
              });
          }
          function fixTranslate(speed = 0) {
              if (sequenceLayoutRef.value) {
                  translateTo(realIndexRef.value, speed);
              }
              else if (previousTranslate !== 0) {
                  if (!inTransition && speed > 0) {
                      inTransition = true;
                  }
                  updateTranslate((previousTranslate = 0), speed);
              }
          }
          function translateTo(index, speed) {
              const translate = getTranslate(index);
              if (translate !== previousTranslate && speed > 0) {
                  inTransition = true;
              }
              previousTranslate = getTranslate(realIndexRef.value);
              updateTranslate(translate, speed);
          }
          function getTranslate(index) {
              let translate;
              // Deal with auto slides pre view
              if (index >= totalViewRef.value - 1) {
                  translate = getLastViewTranslate();
              }
              else {
                  translate = slideTranlatesRef.value[index] || 0;
              }
              return translate;
          }
          function getLastViewTranslate() {
              if (displaySlidesPerViewRef.value === 'auto') {
                  const { value: axis } = sizeAxisRef;
                  const { [axis]: perViewSize } = perViewSizeRef.value;
                  const { value: translates } = slideTranlatesRef;
                  const lastTranslate = translates[translates.length - 1];
                  let overallSize;
                  if (lastTranslate === undefined) {
                      overallSize = perViewSize;
                  }
                  else {
                      const { value: slideSizes } = slideSizesRef;
                      overallSize = lastTranslate + slideSizes[slideSizes.length - 1][axis];
                  }
                  // Bring the last slide to the edge
                  return overallSize - perViewSize;
              }
              else {
                  const { value: translates } = slideTranlatesRef;
                  return translates[totalViewRef.value - 1] || 0;
              }
          }
          // Provide
          const carouselContext = {
              currentIndexRef: mergedDisplayIndexRef,
              to,
              prev: prevIfSlideTransitionEnd,
              next: nextIfSlideTransitionEnd,
              isVertical: () => verticalRef.value,
              isHorizontal: () => !verticalRef.value,
              isPrev: isRealPrev,
              isNext: isRealNext,
              isActive: isRealActive,
              isPrevDisabled,
              isNextDisabled,
              getSlideIndex,
              getSlideStyle,
              addSlide,
              removeSlide,
              onCarouselItemClick
          };
          provideCarouselContext(carouselContext);
          function addSlide(slide) {
              if (!slide)
                  return;
              slideElsRef.value.push(slide);
          }
          function removeSlide(slide) {
              if (!slide)
                  return;
              const index = getSlideIndex(slide);
              if (index !== -1) {
                  slideElsRef.value.splice(index, 1);
              }
          }
          function getSlideIndex(slideOrIndex) {
              return typeof slideOrIndex === 'number'
                  ? slideOrIndex
                  : slideOrIndex
                      ? slideElsRef.value.indexOf(slideOrIndex)
                      : -1;
          }
          function getSlideStyle(slide) {
              const index = getSlideIndex(slide);
              if (index !== -1) {
                  const styles = [slideStylesRef.value[index]];
                  const isPrev = carouselContext.isPrev(index);
                  const isNext = carouselContext.isNext(index);
                  if (isPrev) {
                      styles.push(props.prevSlideStyle || '');
                  }
                  if (isNext) {
                      styles.push(props.nextSlideStyle || '');
                  }
                  return normalizeStyle(styles);
              }
          }
          function onCarouselItemClick(index, event) {
              let allowClick = !inTransition && !dragging && !isEffectiveDrag;
              if (props.effect === 'card' && allowClick && !isRealActive(index)) {
                  to(index);
                  allowClick = false;
              }
              if (!allowClick) {
                  event.preventDefault();
                  event.stopPropagation();
              }
          }
          // Autoplay
          let autoplayTimer = null;
          function stopAutoplay() {
              if (autoplayTimer) {
                  clearInterval(autoplayTimer);
                  autoplayTimer = null;
              }
          }
          function resetAutoplay() {
              stopAutoplay();
              const disabled = !props.autoplay || displayTotalViewRef.value < 2;
              if (!disabled) {
                  autoplayTimer = window.setInterval(next, props.interval);
              }
          }
          // Drag
          let dragStartX = 0;
          let dragStartY = 0;
          let dragOffset = 0;
          let dragStartTime = 0;
          let dragging = false;
          let isEffectiveDrag = false;
          function handleTouchstart(event) {
              var _a;
              if (globalDragging)
                  return;
              if (!((_a = slidesElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(event)))) {
                  return;
              }
              globalDragging = true;
              dragging = true;
              isEffectiveDrag = false;
              dragStartTime = Date.now();
              stopAutoplay();
              if (event.type !== 'touchstart' &&
                  !event.target.isContentEditable) {
                  event.preventDefault();
              }
              const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
              if (verticalRef.value) {
                  dragStartY = touchEvent.clientY;
              }
              else {
                  dragStartX = touchEvent.clientX;
              }
              if (props.touchable) {
                  on('touchmove', document, handleTouchmove);
                  on('touchend', document, handleTouchend);
                  on('touchcancel', document, handleTouchend);
              }
              if (props.draggable) {
                  on('mousemove', document, handleTouchmove);
                  on('mouseup', document, handleTouchend);
              }
          }
          function handleTouchmove(event) {
              const { value: vertical } = verticalRef;
              const { value: axis } = sizeAxisRef;
              const touchEvent = isTouchEvent$1(event) ? event.touches[0] : event;
              const offset = vertical
                  ? touchEvent.clientY - dragStartY
                  : touchEvent.clientX - dragStartX;
              const perViewSize = perViewSizeRef.value[axis];
              dragOffset = clampValue(offset, -perViewSize, perViewSize);
              if (event.cancelable) {
                  event.preventDefault();
              }
              if (sequenceLayoutRef.value) {
                  updateTranslate(previousTranslate - dragOffset, 0);
              }
          }
          function handleTouchend() {
              const { value: realIndex } = realIndexRef;
              let currentIndex = realIndex;
              if (!inTransition && dragOffset !== 0 && sequenceLayoutRef.value) {
                  const currentTranslate = previousTranslate - dragOffset;
                  const translates = [
                      ...slideTranlatesRef.value.slice(0, totalViewRef.value - 1),
                      getLastViewTranslate()
                  ];
                  let prevOffset = null;
                  for (let i = 0; i < translates.length; i++) {
                      const offset = Math.abs(translates[i] - currentTranslate);
                      if (prevOffset !== null && prevOffset < offset) {
                          break;
                      }
                      prevOffset = offset;
                      currentIndex = i;
                  }
              }
              if (currentIndex === realIndex) {
                  const timeElapsed = Date.now() - dragStartTime;
                  const { value: axis } = sizeAxisRef;
                  const perViewSize = perViewSizeRef.value[axis];
                  // more than 50% width or faster than 0.4px per ms
                  if (dragOffset > perViewSize / 2 || dragOffset / timeElapsed > 0.4) {
                      currentIndex = getRealPrevIndex(realIndex);
                  }
                  else if (dragOffset < -perViewSize / 2 ||
                      dragOffset / timeElapsed < -0.4) {
                      currentIndex = getRealNextIndex(realIndex);
                  }
              }
              if (currentIndex !== null && currentIndex !== realIndex) {
                  isEffectiveDrag = true;
                  toRealIndex(currentIndex);
                  void nextTick(() => {
                      if (!duplicatedableRef.value ||
                          uncontrolledDisplayIndexRef.value !== mergedDisplayIndexRef.value) {
                          fixTranslate(speedRef.value);
                      }
                  });
              }
              else {
                  fixTranslate(speedRef.value);
              }
              resetDragStatus();
              resetAutoplay();
          }
          function resetDragStatus() {
              if (dragging) {
                  globalDragging = false;
              }
              dragging = false;
              dragStartX = 0;
              dragStartY = 0;
              dragOffset = 0;
              dragStartTime = 0;
              off('touchmove', document, handleTouchmove);
              off('touchend', document, handleTouchend);
              off('touchcancel', document, handleTouchend);
              off('mousemove', document, handleTouchmove);
              off('mouseup', document, handleTouchend);
          }
          function handleTransitionEnd() {
              if (sequenceLayoutRef.value && inTransition) {
                  const { value: realIndex } = realIndexRef;
                  translateTo(realIndex, 0);
              }
              else {
                  resetAutoplay();
              }
              if (sequenceLayoutRef.value) {
                  translateStyleRef.value.transitionDuration = '0ms';
              }
              inTransition = false;
          }
          function handleMousewheel(event) {
              event.preventDefault();
              if (inTransition)
                  return;
              let { deltaX, deltaY } = event;
              if (event.shiftKey && !deltaX) {
                  deltaX = deltaY;
              }
              const prevMultiplier = -1;
              const nextMultiplier = 1;
              const m = (deltaX || deltaY) > 0 ? nextMultiplier : prevMultiplier;
              let rx = 0;
              let ry = 0;
              if (verticalRef.value) {
                  ry = m;
              }
              else {
                  rx = m;
              }
              const responseStep = 10;
              if (ry * deltaY >= responseStep || rx * deltaX >= responseStep) {
                  if (m === nextMultiplier && !isNextDisabled()) {
                      next();
                  }
                  else if (m === prevMultiplier && !isPrevDisabled()) {
                      prev();
                  }
              }
          }
          function handleResize() {
              perViewSizeRef.value = calculateSize(selfElRef.value, true);
              resetAutoplay();
          }
          function handleSlideResize() {
              var _a, _b;
              if (autoSlideSizeRef.value) {
                  (_b = (_a = slideSizesRef.effect).scheduler) === null || _b === void 0 ? void 0 : _b.call(_a);
                  slideSizesRef.effect.run();
              }
          }
          function handleMouseenter() {
              if (props.autoplay) {
                  stopAutoplay();
              }
          }
          function handleMouseleave() {
              if (props.autoplay) {
                  resetAutoplay();
              }
          }
          onMounted(() => {
              watchEffect(resetAutoplay);
              requestAnimationFrame(() => (isMountedRef.value = true));
          });
          onBeforeUnmount(() => {
              resetDragStatus();
              stopAutoplay();
          });
          // Fix index when remounting
          onUpdated(() => {
              const { value: slidesEls } = slideElsRef;
              const { value: slideVNodes } = slideVNodesRef;
              const indexMap = new Map();
              const getDisplayIndex = (el) => 
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              indexMap.has(el) ? indexMap.get(el) : -1;
              let isChanged = false;
              for (let i = 0; i < slidesEls.length; i++) {
                  const index = slideVNodes.findIndex((v) => v.el === slidesEls[i]);
                  if (index !== i) {
                      isChanged = true;
                  }
                  indexMap.set(slidesEls[i], index);
              }
              if (isChanged) {
                  slidesEls.sort((a, b) => getDisplayIndex(a) - getDisplayIndex(b));
              }
          });
          watch(realIndexRef, (realIndex, lastRealIndex) => {
              if (realIndex === lastRealIndex)
                  return;
              resetAutoplay();
              if (sequenceLayoutRef.value) {
                  if (duplicatedableRef.value && displayTotalViewRef.value > 2) {
                      const { value: length } = totalViewRef;
                      if (realIndex === length - 2 && lastRealIndex === 1) {
                          realIndex = 0;
                      }
                      else if (realIndex === 1 && lastRealIndex === length - 2) {
                          realIndex = length - 1;
                      }
                  }
                  translateTo(realIndex, speedRef.value);
              }
              else {
                  fixTranslate();
              }
          }, { immediate: true });
          watch([duplicatedableRef, displaySlidesPerViewRef], () => void nextTick(() => {
              toRealIndex(realIndexRef.value);
          }));
          watch(slideTranlatesRef, () => {
              sequenceLayoutRef.value && fixTranslate();
          }, {
              deep: true
          });
          watch(sequenceLayoutRef, (value) => {
              if (!value) {
                  inTransition = false;
                  // if the current mode does not support translate, reset the position of the wrapper
                  updateTranslate((previousTranslate = 0));
              }
              else {
                  fixTranslate();
              }
          });
          const slidesControlListenersRef = computed(() => {
              return {
                  onTouchstartPassive: props.touchable ? handleTouchstart : undefined,
                  onMousedown: props.draggable ? handleTouchstart : undefined,
                  onWheel: props.mousewheel ? handleMousewheel : undefined
              };
          });
          const arrowSlotPropsRef = computed(() => (Object.assign(Object.assign({}, keep(carouselContext, [
              'to',
              'prev',
              'next',
              'isPrevDisabled',
              'isNextDisabled'
          ])), { total: displayTotalViewRef.value, currentIndex: mergedDisplayIndexRef.value })));
          const dotSlotPropsRef = computed(() => ({
              total: displayTotalViewRef.value,
              currentIndex: mergedDisplayIndexRef.value,
              to: carouselContext.to
          }));
          const caroulseExposedMethod = {
              getCurrentIndex: () => mergedDisplayIndexRef.value,
              to,
              prev,
              next
          };
          const themeRef = useTheme('Carousel', '-carousel', style$17, carouselLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { dotSize, dotColor, dotColorActive, dotColorFocus, dotLineWidth, dotLineWidthActive, arrowColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-dot-color': dotColor,
                  '--n-dot-color-focus': dotColorFocus,
                  '--n-dot-color-active': dotColorActive,
                  '--n-dot-size': dotSize,
                  '--n-dot-line-width': dotLineWidth,
                  '--n-dot-line-width-active': dotLineWidthActive,
                  '--n-arrow-color': arrowColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('carousel', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({ mergedClsPrefix: mergedClsPrefixRef, selfElRef,
              slidesElRef, slideVNodes: slideVNodesRef, duplicatedable: duplicatedableRef, userWantsControl: userWantsControlRef, autoSlideSize: autoSlideSizeRef, displayIndex: mergedDisplayIndexRef, realIndex: realIndexRef, slideStyles: slideStylesRef, translateStyle: translateStyleRef, slidesControlListeners: slidesControlListenersRef, handleTransitionEnd,
              handleResize,
              handleSlideResize,
              handleMouseenter,
              handleMouseleave, isActive: isDisplayActive, arrowSlotProps: arrowSlotPropsRef, dotSlotProps: dotSlotPropsRef }, caroulseExposedMethod), { cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a;
          const { mergedClsPrefix, showArrow, userWantsControl, slideStyles, dotType, dotPlacement, slidesControlListeners, transitionProps = {}, arrowSlotProps, dotSlotProps, $slots: { default: defaultSlot, dots: dotsSlot, arrow: arrowSlot } } = this;
          const children = (defaultSlot && flatten$3(defaultSlot())) || [];
          let slides = filterCarouselItem(children);
          if (!slides.length) {
              slides = children.map((ch) => (h(NCarouselItem, null, {
                  default: () => cloneVNode(ch)
              })));
          }
          if (this.duplicatedable) {
              slides = addDuplicateSlides(slides);
          }
          this.slideVNodes.value = slides;
          // When users need to customize the size of the slide,
          // we listen to them to fix the current translate
          if (this.autoSlideSize) {
              slides = slides.map((slide) => (h(VResizeObserver, { onResize: this.handleSlideResize }, {
                  default: () => slide
              })));
          }
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", Object.assign({ ref: "selfElRef", class: [
                  this.themeClass,
                  `${mergedClsPrefix}-carousel`,
                  this.direction === 'vertical' &&
                      `${mergedClsPrefix}-carousel--vertical`,
                  this.showArrow && `${mergedClsPrefix}-carousel--show-arrow`,
                  `${mergedClsPrefix}-carousel--${dotPlacement}`,
                  `${mergedClsPrefix}-carousel--${this.direction}`,
                  `${mergedClsPrefix}-carousel--${this.effect}`,
                  userWantsControl && `${mergedClsPrefix}-carousel--usercontrol`
              ], style: this.cssVars }, slidesControlListeners, { onMouseenter: this.handleMouseenter, onMouseleave: this.handleMouseleave }),
              h(VResizeObserver, { onResize: this.handleResize }, {
                  default: () => (h("div", { ref: "slidesElRef", class: `${mergedClsPrefix}-carousel__slides`, role: "listbox", style: this.translateStyle, onTransitionend: this.handleTransitionEnd }, userWantsControl
                      ? slides.map((slide, i) => (h("div", { style: slideStyles[i], key: i }, withDirectives(h(Transition, Object.assign({}, transitionProps), {
                          default: () => slide
                      }), [[vShow, this.isActive(i)]]))))
                      : slides))
              }),
              this.showDots &&
                  dotSlotProps.total > 1 &&
                  resolveSlotWithProps(dotsSlot, dotSlotProps, () => [
                      h(NCarouselDots, { key: dotType + dotPlacement, total: dotSlotProps.total, currentIndex: dotSlotProps.currentIndex, dotType: dotType, trigger: this.trigger, keyboard: this.keyboard })
                  ]),
              showArrow &&
                  resolveSlotWithProps(arrowSlot, arrowSlotProps, () => [
                      h(NCarouselArrow, null)
                  ])));
      }
  });
  function filterCarouselItem(vnodes) {
      return vnodes.reduce((carouselItems, vnode) => {
          if (isCarouselItem(vnode)) {
              carouselItems.push(vnode);
          }
          return carouselItems;
      }, []);
  }

  var commonVariables$c = {
      sizeSmall: '14px',
      sizeMedium: '16px',
      sizeLarge: '18px',
      labelPadding: '0 8px',
      labelFontWeight: '400'
  };

  const self$W = (vars) => {
      const { baseColor, inputColorDisabled, cardColor, modalColor, popoverColor, textColorDisabled, borderColor, primaryColor, textColor2, fontSizeSmall, fontSizeMedium, fontSizeLarge, borderRadiusSmall, lineHeight } = vars;
      return Object.assign(Object.assign({}, commonVariables$c), { labelLineHeight: lineHeight, fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge, borderRadius: borderRadiusSmall, color: baseColor, colorChecked: primaryColor, colorDisabled: inputColorDisabled, colorDisabledChecked: inputColorDisabled, colorTableHeader: cardColor, colorTableHeaderModal: modalColor, colorTableHeaderPopover: popoverColor, checkMarkColor: baseColor, checkMarkColorDisabled: textColorDisabled, checkMarkColorDisabledChecked: textColorDisabled, border: `1px solid ${borderColor}`, borderDisabled: `1px solid ${borderColor}`, borderDisabledChecked: `1px solid ${borderColor}`, borderChecked: `1px solid ${primaryColor}`, borderFocus: `1px solid ${primaryColor}`, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`, textColor: textColor2, textColorDisabled });
  };
  const checkboxLight = {
      name: 'Checkbox',
      common: commonLight,
      self: self$W
  };
  var checkboxLight$1 = checkboxLight;

  const self$V = (vars) => {
      const { borderRadius, boxShadow2, popoverColor, textColor2, textColor3, primaryColor, textColorDisabled, dividerColor, hoverColor, fontSizeMedium, heightMedium } = vars;
      return {
          menuBorderRadius: borderRadius,
          menuColor: popoverColor,
          menuBoxShadow: boxShadow2,
          menuDividerColor: dividerColor,
          menuHeight: 'calc(var(--n-option-height) * 6.6)',
          optionArrowColor: textColor3,
          optionHeight: heightMedium,
          optionFontSize: fontSizeMedium,
          optionColorHover: hoverColor,
          optionTextColor: textColor2,
          optionTextColorActive: primaryColor,
          optionTextColorDisabled: textColorDisabled,
          optionCheckMarkColor: primaryColor,
          loadingColor: primaryColor,
          columnWidth: '180px'
      };
  };
  const cascaderLight = createTheme({
      name: 'Cascader',
      common: commonLight,
      peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          InternalSelection: internalSelectionLight$1,
          Scrollbar: scrollbarLight$1,
          Checkbox: checkboxLight$1,
          Empty: emptyLight$1
      },
      self: self$V
  });
  var cascaderLight$1 = cascaderLight;

  function getRawNodePath(tmNodes) {
      if (!tmNodes)
          return null;
      return tmNodes.map((tmNode) => tmNode.rawNode);
  }
  function createSelectOptions(tmNodes, checkStrategyIsChild, labelField, separator) {
      const selectOptions = [];
      const path = [];
      function traverse(_tmNodes) {
          for (const tmNode of _tmNodes) {
              if (tmNode.disabled)
                  continue;
              const { rawNode } = tmNode;
              path.push(rawNode);
              if (tmNode.isLeaf || !checkStrategyIsChild) {
                  selectOptions.push({
                      label: getPathLabel(tmNode, separator, labelField),
                      value: tmNode.key,
                      rawNode: tmNode.rawNode,
                      path: Array.from(path)
                  });
              }
              if (!tmNode.isLeaf && tmNode.children) {
                  traverse(tmNode.children);
              }
              path.pop();
          }
      }
      traverse(tmNodes);
      return selectOptions;
  }
  function getPathLabel(node, separator, labelField) {
      const path = [];
      while (node) {
          path.push(node.rawNode[labelField]);
          node = node.parent;
      }
      return path.reverse().join(separator);
  }

  var CheckMark = (h("svg", { viewBox: "0 0 64 64", class: "check-icon" },
      h("path", { d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z" })));

  var LineMark = (h("svg", { viewBox: "0 0 100 100", class: "line-icon" },
      h("path", { d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z" })));

  const checkboxGroupInjectionKey = createInjectionKey('n-checkbox-group');
  const checkboxGroupProps = {
      min: Number,
      max: Number,
      size: String,
      value: Array,
      defaultValue: {
          type: Array,
          default: null
      },
      disabled: {
          type: Boolean,
          default: undefined
      },
      'onUpdate:value': [Function, Array],
      onUpdateValue: [Function, Array],
      // deprecated
      onChange: [Function, Array]
  };
  var NCheckboxGroup = defineComponent({
      name: 'CheckboxGroup',
      props: checkboxGroupProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = computed(() => props.value);
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedCount = computed(() => {
              var _a;
              return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
          });
          const valueSetRef = computed(() => {
              if (Array.isArray(mergedValueRef.value)) {
                  return new Set(mergedValueRef.value);
              }
              return new Set();
          });
          function toggleCheckbox(checked, checkboxValue) {
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              const { onChange, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              if (Array.isArray(mergedValueRef.value)) {
                  const groupValue = Array.from(mergedValueRef.value);
                  const index = groupValue.findIndex((value) => value === checkboxValue);
                  if (checked) {
                      if (!~index) {
                          groupValue.push(checkboxValue);
                          if (onUpdateValue) {
                              call(onUpdateValue, groupValue, {
                                  actionType: 'check',
                                  value: checkboxValue
                              });
                          }
                          if (_onUpdateValue) {
                              call(_onUpdateValue, groupValue, {
                                  actionType: 'check',
                                  value: checkboxValue
                              });
                          }
                          nTriggerFormInput();
                          nTriggerFormChange();
                          uncontrolledValueRef.value = groupValue;
                          // deprecated
                          if (onChange)
                              call(onChange, groupValue);
                      }
                  }
                  else {
                      if (~index) {
                          groupValue.splice(index, 1);
                          if (onUpdateValue) {
                              call(onUpdateValue, groupValue, {
                                  actionType: 'uncheck',
                                  value: checkboxValue
                              });
                          }
                          if (_onUpdateValue) {
                              call(_onUpdateValue, groupValue, {
                                  actionType: 'uncheck',
                                  value: checkboxValue
                              });
                          }
                          if (onChange)
                              call(onChange, groupValue); // deprecated
                          uncontrolledValueRef.value = groupValue;
                          nTriggerFormInput();
                          nTriggerFormChange();
                      }
                  }
              }
              else {
                  if (checked) {
                      if (onUpdateValue) {
                          call(onUpdateValue, [checkboxValue], {
                              actionType: 'check',
                              value: checkboxValue
                          });
                      }
                      if (_onUpdateValue) {
                          call(_onUpdateValue, [checkboxValue], {
                              actionType: 'check',
                              value: checkboxValue
                          });
                      }
                      if (onChange)
                          call(onChange, [checkboxValue]); // deprecated
                      uncontrolledValueRef.value = [checkboxValue];
                      nTriggerFormInput();
                      nTriggerFormChange();
                  }
                  else {
                      if (onUpdateValue) {
                          call(onUpdateValue, [], {
                              actionType: 'uncheck',
                              value: checkboxValue
                          });
                      }
                      if (_onUpdateValue) {
                          call(_onUpdateValue, [], {
                              actionType: 'uncheck',
                              value: checkboxValue
                          });
                      }
                      if (onChange)
                          call(onChange, []); // deprecated
                      uncontrolledValueRef.value = [];
                      nTriggerFormInput();
                      nTriggerFormChange();
                  }
              }
          }
          provide(checkboxGroupInjectionKey, {
              checkedCountRef: checkedCount,
              maxRef: toRef(props, 'max'),
              minRef: toRef(props, 'min'),
              valueSetRef,
              disabledRef: mergedDisabledRef,
              mergedSizeRef,
              toggleCheckbox
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef
          };
      },
      render() {
          return (h("div", { class: `${this.mergedClsPrefix}-checkbox-group`, role: "group" }, this.$slots));
      }
  });

  // vars:
  // --n-label-line-height
  // --n-bezier
  // --n-size
  // --n-border
  // --n-border-focus
  // --n-border-checked
  // --n-border-disabled
  // --n-border-disabled-checked
  // --n-box-shadow-focus
  // --n-color
  // --n-color-checked
  // --n-color-table
  // --n-color-table-modal
  // --n-color-disabled
  // --n-color-disabled-checked
  // --n-text-color
  // --n-text-color-disabled
  // --n-check-mark-color
  // --n-check-mark-color-disabled
  // --n-check-mark-color-disabled-checked
  // --n-border-radius
  // --n-font-size
  // --n-label-padding
  var style$16 = c$1([cB('checkbox', `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [cM('show-label', 'line-height: var(--n-label-line-height);'), c$1('&:hover', [cB('checkbox-box', [cE('border', 'border: var(--n-border-checked);')])]), c$1('&:focus:not(:active)', [cB('checkbox-box', [cE('border', `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM('inside-table', [cB('checkbox-box', `
 background-color: var(--n-merged-color-table);
 `)]), cM('checked', [cB('checkbox-box', `
 background-color: var(--n-color-checked);
 `, [cB('checkbox-icon', [
  // if not set width to 100%, safari & old chrome won't display the icon
  c$1('.check-icon', `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM('indeterminate', [cB('checkbox-box', [cB('checkbox-icon', [c$1('.check-icon', `
 opacity: 0;
 transform: scale(.5);
 `), c$1('.line-icon', `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM('checked, indeterminate', [c$1('&:focus:not(:active)', [cB('checkbox-box', [cE('border', `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB('checkbox-box', `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE('border', {
    border: 'var(--n-border-checked)'
  })])]), cM('disabled', {
    cursor: 'not-allowed'
  }, [cM('checked', [cB('checkbox-box', `
 background-color: var(--n-color-disabled-checked);
 `, [cE('border', {
    border: 'var(--n-border-disabled-checked)'
  }), cB('checkbox-icon', [c$1('.check-icon, .line-icon', {
    fill: 'var(--n-check-mark-color-disabled-checked)'
  })])])]), cB('checkbox-box', `
 background-color: var(--n-color-disabled);
 `, [cE('border', `
 border: var(--n-border-disabled);
 `), cB('checkbox-icon', [c$1('.check-icon, .line-icon', `
 fill: var(--n-check-mark-color-disabled);
 `)])]), cE('label', `
 color: var(--n-text-color-disabled);
 `)]), cB('checkbox-box-wrapper', `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB('checkbox-box', `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE('border', `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB('checkbox-icon', `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1('.check-icon, .line-icon', `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
    left: '1px',
    top: '1px'
  })])]), cE('label', `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1('&:empty', {
    display: 'none'
  })])]),
  // modal table header checkbox
  insideModal(cB('checkbox', `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
  // popover table header checkbox
  insidePopover(cB('checkbox', `
 --n-merged-color-table: var(--n-color-table-popover);
 `))]);

  const checkboxProps = Object.assign(Object.assign({}, useTheme.props), { size: String, checked: {
          type: [Boolean, String, Number],
          default: undefined
      }, defaultChecked: {
          type: [Boolean, String, Number],
          default: false
      }, value: [String, Number], disabled: {
          type: Boolean,
          default: undefined
      }, indeterminate: Boolean, label: String, focusable: {
          type: Boolean,
          default: true
      }, checkedValue: {
          type: [Boolean, String, Number],
          default: true
      }, uncheckedValue: {
          type: [Boolean, String, Number],
          default: false
      }, 'onUpdate:checked': [Function, Array], onUpdateChecked: [Function, Array], 
      // private
      privateInsideTable: Boolean, 
      // deprecated
      onChange: [Function, Array] });
  var NCheckbox = defineComponent({
      name: 'Checkbox',
      props: checkboxProps,
      setup(props) {
          const selfRef = ref(null);
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const formItem = useFormItem(props, {
              mergedSize(NFormItem) {
                  const { size } = props;
                  if (size !== undefined)
                      return size;
                  if (NCheckboxGroup) {
                      const { value: mergedSize } = NCheckboxGroup.mergedSizeRef;
                      if (mergedSize !== undefined) {
                          return mergedSize;
                      }
                  }
                  if (NFormItem) {
                      const { mergedSize } = NFormItem;
                      if (mergedSize !== undefined)
                          return mergedSize.value;
                  }
                  return 'medium';
              },
              mergedDisabled(NFormItem) {
                  const { disabled } = props;
                  if (disabled !== undefined)
                      return disabled;
                  if (NCheckboxGroup) {
                      if (NCheckboxGroup.disabledRef.value)
                          return true;
                      const { maxRef: { value: max }, checkedCountRef } = NCheckboxGroup;
                      if (max !== undefined &&
                          checkedCountRef.value >= max &&
                          !renderedCheckedRef.value) {
                          return true;
                      }
                      const { minRef: { value: min } } = NCheckboxGroup;
                      if (min !== undefined &&
                          checkedCountRef.value <= min &&
                          renderedCheckedRef.value) {
                          return true;
                      }
                  }
                  if (NFormItem) {
                      return NFormItem.disabled.value;
                  }
                  return false;
              }
          });
          const { mergedDisabledRef, mergedSizeRef } = formItem;
          const NCheckboxGroup = inject(checkboxGroupInjectionKey, null);
          const uncontrolledCheckedRef = ref(props.defaultChecked);
          const controlledCheckedRef = toRef(props, 'checked');
          const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
          const renderedCheckedRef = useMemo(() => {
              if (NCheckboxGroup) {
                  const groupValueSet = NCheckboxGroup.valueSetRef.value;
                  if (groupValueSet && props.value !== undefined) {
                      return groupValueSet.has(props.value);
                  }
                  return false;
              }
              else {
                  return mergedCheckedRef.value === props.checkedValue;
              }
          });
          const themeRef = useTheme('Checkbox', '-checkbox', style$16, checkboxLight$1, props, mergedClsPrefixRef);
          function toggle(e) {
              if (NCheckboxGroup && props.value !== undefined) {
                  NCheckboxGroup.toggleCheckbox(!renderedCheckedRef.value, props.value);
              }
              else {
                  const { onChange, 'onUpdate:checked': _onUpdateCheck, onUpdateChecked } = props;
                  const { nTriggerFormInput, nTriggerFormChange } = formItem;
                  const nextChecked = renderedCheckedRef.value
                      ? props.uncheckedValue
                      : props.checkedValue;
                  if (_onUpdateCheck) {
                      call(_onUpdateCheck, nextChecked, e);
                  }
                  if (onUpdateChecked) {
                      call(onUpdateChecked, nextChecked, e);
                  }
                  if (onChange)
                      call(onChange, nextChecked, e); // deprecated
                  nTriggerFormInput();
                  nTriggerFormChange();
                  uncontrolledCheckedRef.value = nextChecked;
              }
          }
          function handleClick(e) {
              if (!mergedDisabledRef.value) {
                  toggle(e);
              }
          }
          function handleKeyUp(e) {
              if (mergedDisabledRef.value)
                  return;
              switch (e.key) {
                  case ' ':
                  case 'Enter':
                      toggle(e);
              }
          }
          function handleKeyDown(e) {
              switch (e.key) {
                  case ' ':
                      e.preventDefault();
              }
          }
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                  var _a;
                  (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              }
          };
          const rtlEnabledRef = useRtl('Checkbox', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { value: mergedSize } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut }, self: { borderRadius, color, colorChecked, colorDisabled, colorTableHeader, colorTableHeaderModal, colorTableHeaderPopover, checkMarkColor, checkMarkColorDisabled, border, borderFocus, borderDisabled, borderChecked, boxShadowFocus, textColor, textColorDisabled, checkMarkColorDisabledChecked, colorDisabledChecked, borderDisabledChecked, labelPadding, labelLineHeight, labelFontWeight, [createKey('fontSize', mergedSize)]: fontSize, [createKey('size', mergedSize)]: size } } = themeRef.value;
              return {
                  '--n-label-line-height': labelLineHeight,
                  '--n-label-font-weight': labelFontWeight,
                  '--n-size': size,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-border': border,
                  '--n-border-checked': borderChecked,
                  '--n-border-focus': borderFocus,
                  '--n-border-disabled': borderDisabled,
                  '--n-border-disabled-checked': borderDisabledChecked,
                  '--n-box-shadow-focus': boxShadowFocus,
                  '--n-color': color,
                  '--n-color-checked': colorChecked,
                  '--n-color-table': colorTableHeader,
                  '--n-color-table-modal': colorTableHeaderModal,
                  '--n-color-table-popover': colorTableHeaderPopover,
                  '--n-color-disabled': colorDisabled,
                  '--n-color-disabled-checked': colorDisabledChecked,
                  '--n-text-color': textColor,
                  '--n-text-color-disabled': textColorDisabled,
                  '--n-check-mark-color': checkMarkColor,
                  '--n-check-mark-color-disabled': checkMarkColorDisabled,
                  '--n-check-mark-color-disabled-checked': checkMarkColorDisabledChecked,
                  '--n-font-size': fontSize,
                  '--n-label-padding': labelPadding
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('checkbox', computed(() => mergedSizeRef.value[0]), cssVarsRef, props)
              : undefined;
          return Object.assign(formItem, exposedMethods, {
              rtlEnabled: rtlEnabledRef,
              selfRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedDisabled: mergedDisabledRef,
              renderedChecked: renderedCheckedRef,
              mergedTheme: themeRef,
              labelId: createId(),
              handleClick,
              handleKeyUp,
              handleKeyDown,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
      },
      render() {
          var _a;
          const { $slots, renderedChecked, mergedDisabled, indeterminate, privateInsideTable, cssVars, labelId, label, mergedClsPrefix, focusable, handleKeyUp, handleKeyDown, handleClick } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const labelNode = resolveWrappedSlot($slots.default, (children) => {
              if (label || children) {
                  return (h("span", { class: `${mergedClsPrefix}-checkbox__label`, id: labelId }, label || children));
              }
              return null;
          });
          return (h("div", { ref: "selfRef", class: [
                  `${mergedClsPrefix}-checkbox`,
                  this.themeClass,
                  this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`,
                  renderedChecked && `${mergedClsPrefix}-checkbox--checked`,
                  mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`,
                  indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`,
                  privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`,
                  labelNode && `${mergedClsPrefix}-checkbox--show-label`
              ], tabindex: mergedDisabled || !focusable ? undefined : 0, role: "checkbox", "aria-checked": indeterminate ? 'mixed' : renderedChecked, "aria-labelledby": labelId, style: cssVars, onKeyup: handleKeyUp, onKeydown: handleKeyDown, onClick: handleClick, onMousedown: () => {
                  on('selectstart', window, (e) => {
                      e.preventDefault();
                  }, {
                      once: true
                  });
              } },
              h("div", { class: `${mergedClsPrefix}-checkbox-box-wrapper` },
                  "\u00A0",
                  h("div", { class: `${mergedClsPrefix}-checkbox-box` },
                      h(NIconSwitchTransition, null, {
                          default: () => this.indeterminate ? (h("div", { key: "indeterminate", class: `${mergedClsPrefix}-checkbox-icon` }, LineMark)) : (h("div", { key: "check", class: `${mergedClsPrefix}-checkbox-icon` }, CheckMark))
                      }),
                      h("div", { class: `${mergedClsPrefix}-checkbox-box__border` }))),
              labelNode));
      }
  });

  const cascaderInjectionKey = createInjectionKey('n-cascader');

  var NCascaderOption = defineComponent({
      name: 'NCascaderOption',
      props: {
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          const { expandTriggerRef, remoteRef, multipleRef, mergedValueRef, checkedKeysRef, indeterminateKeysRef, hoverKeyPathRef, keyboardKeyRef, loadingKeySetRef, cascadeRef, mergedCheckStrategyRef, onLoadRef, mergedClsPrefixRef, mergedThemeRef, labelFieldRef, showCheckboxRef, updateHoverKey, updateKeyboardKey, addLoadingKey, deleteLoadingKey, closeMenu, doCheck, doUncheck, renderLabelRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(cascaderInjectionKey);
          const valueRef = computed(() => props.tmNode.key);
          const useHoverTriggerRef = computed(() => {
              const { value: expandTrigger } = expandTriggerRef;
              const { value: remote } = remoteRef;
              return !remote && expandTrigger === 'hover';
          });
          const mergedHandleMouseEnterRef = computed(() => {
              if (useHoverTriggerRef.value) {
                  return handleMouseEnter;
              }
              return undefined;
          });
          const mergedHandleMouseMoveRef = computed(() => {
              if (useHoverTriggerRef.value) {
                  return handleMouseMove;
              }
              return undefined;
          });
          const checkedRef = useMemo(() => {
              const { value: multiple } = multipleRef;
              if (!multiple)
                  return mergedValueRef.value === valueRef.value;
              return checkedKeysRef.value.includes(valueRef.value);
          });
          const indeterminateRef = useMemo(() => {
              if (!multipleRef.value)
                  return false;
              return indeterminateKeysRef.value.includes(valueRef.value);
          });
          const hoverPendingRef = useMemo(() => {
              return hoverKeyPathRef.value.includes(valueRef.value);
          });
          const keyboardPendingRef = useMemo(() => {
              const { value: keyboardKey } = keyboardKeyRef;
              if (keyboardKey === null)
                  return false;
              return keyboardKey === valueRef.value;
          });
          const isLoadingRef = useMemo(() => {
              if (remoteRef.value) {
                  return loadingKeySetRef.value.has(valueRef.value);
              }
              return false;
          });
          const isLeafRef = computed(() => props.tmNode.isLeaf);
          const disabledRef = computed(() => props.tmNode.disabled);
          const labelRef = computed(() => props.tmNode.rawNode[labelFieldRef.value]);
          const isShallowLoadedRef = computed(() => {
              return props.tmNode.shallowLoaded;
          });
          function handleClick(e) {
              if (disabledRef.value)
                  return;
              const { value: remote } = remoteRef;
              const { value: loadingKeySet } = loadingKeySetRef;
              const { value: onLoad } = onLoadRef;
              const { value } = valueRef;
              const { value: isLeaf } = isLeafRef;
              const { value: isShallowLoaded } = isShallowLoadedRef;
              if (!happensIn(e, 'checkbox')) {
                  if (remote && !isShallowLoaded && !loadingKeySet.has(value) && onLoad) {
                      addLoadingKey(value);
                      onLoad(props.tmNode.rawNode)
                          .then(() => {
                          deleteLoadingKey(value);
                      })
                          .catch(() => {
                          deleteLoadingKey(value);
                      });
                  }
                  updateHoverKey(value);
                  updateKeyboardKey(value);
              }
              if (isLeaf) {
                  toggleCheckbox();
              }
          }
          function handleMouseEnter() {
              if (!useHoverTriggerRef.value || disabledRef.value)
                  return;
              const { value } = valueRef;
              updateHoverKey(value);
              updateKeyboardKey(value);
          }
          function handleMouseMove() {
              if (!useHoverTriggerRef.value)
                  return;
              handleMouseEnter();
          }
          function handleCheckboxUpdateValue() {
              const { value: isLeaf } = isLeafRef;
              if (!isLeaf)
                  toggleCheckbox();
          }
          function toggleCheckbox() {
              const { value: multiple } = multipleRef;
              const { value } = valueRef;
              if (multiple) {
                  if (indeterminateRef.value || checkedRef.value) {
                      doUncheck(value);
                  }
                  else {
                      doCheck(value);
                  }
              }
              else {
                  doCheck(value);
                  closeMenu(true);
              }
          }
          return {
              checkStrategy: mergedCheckStrategyRef,
              multiple: multipleRef,
              cascade: cascadeRef,
              checked: checkedRef,
              indeterminate: indeterminateRef,
              hoverPending: hoverPendingRef,
              keyboardPending: keyboardPendingRef,
              isLoading: isLoadingRef,
              showCheckbox: showCheckboxRef,
              isLeaf: isLeafRef,
              disabled: disabledRef,
              label: labelRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef,
              handleClick,
              handleCheckboxUpdateValue,
              mergedHandleMouseEnter: mergedHandleMouseEnterRef,
              mergedHandleMouseMove: mergedHandleMouseMoveRef,
              renderLabel: renderLabelRef
          };
      },
      render() {
          const { mergedClsPrefix, renderLabel } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-cascader-option`,
                  {
                      [`${mergedClsPrefix}-cascader-option--pending`]: this.keyboardPending || this.hoverPending,
                      [`${mergedClsPrefix}-cascader-option--disabled`]: this.disabled,
                      [`${mergedClsPrefix}-cascader-option--show-prefix`]: this.showCheckbox
                  }
              ], onMouseenter: this.mergedHandleMouseEnter, onMousemove: this.mergedHandleMouseMove, onClick: this.handleClick },
              this.showCheckbox ? (h("div", { class: `${mergedClsPrefix}-cascader-option__prefix` },
                  h(NCheckbox, { focusable: false, "data-checkbox": true, disabled: this.disabled, checked: this.checked, indeterminate: this.indeterminate, theme: this.mergedTheme.peers.Checkbox, themeOverrides: this.mergedTheme.peerOverrides.Checkbox, onUpdateChecked: this.handleCheckboxUpdateValue }))) : null,
              h("span", { class: `${mergedClsPrefix}-cascader-option__label` }, renderLabel
                  ? renderLabel(this.tmNode.rawNode, this.checked)
                  : this.label),
              h("div", { class: `${mergedClsPrefix}-cascader-option__suffix` },
                  h("div", { class: `${mergedClsPrefix}-cascader-option-icon-placeholder` }, !this.isLeaf ? (h(NBaseLoading, { clsPrefix: mergedClsPrefix, scale: 0.85, strokeWidth: 24, show: this.isLoading, class: `${mergedClsPrefix}-cascader-option-icon` }, {
                      default: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "arrow", class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--arrow` }, {
                          default: () => h(ChevronRightIcon, null)
                      }))
                  })) : this.checkStrategy === 'child' &&
                      !(this.multiple && this.cascade) ? (h(Transition, { name: "fade-in-scale-up-transition" }, {
                      default: () => this.checked ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-option-icon ${mergedClsPrefix}-cascader-option-icon--checkmark` }, { default: () => h(FinishedIcon, null) })) : null
                  })) : null))));
      }
  });

  var NCascaderSubmenu = defineComponent({
      name: 'CascaderSubmenu',
      props: {
          depth: {
              type: Number,
              required: true
          },
          tmNodes: {
              type: Array,
              required: true
          }
      },
      setup() {
          const { virtualScrollRef, mergedClsPrefixRef, mergedThemeRef, optionHeightRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(cascaderInjectionKey);
          const scrollbarInstRef = ref(null);
          const vlInstRef = ref(null);
          const inst = {
              scroll(index, elSize) {
                  var _a, _b;
                  if (virtualScrollRef.value) {
                      (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
                          index
                      });
                  }
                  else {
                      (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
                          index,
                          elSize
                      });
                  }
              }
          };
          return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedTheme: mergedThemeRef, scrollbarInstRef,
              vlInstRef, virtualScroll: virtualScrollRef, itemSize: computed(() => depx(optionHeightRef.value)), handleVlScroll: () => {
                  var _a;
                  (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
              }, getVlContainer: () => {
                  var _a;
                  return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
              }, getVlContent: () => {
                  var _a;
                  return (_a = vlInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
              } }, inst);
      },
      render() {
          const { mergedClsPrefix, mergedTheme, virtualScroll } = this;
          return (h("div", { class: [
                  virtualScroll && `${mergedClsPrefix}-cascader-submenu--virtual`,
                  `${mergedClsPrefix}-cascader-submenu`
              ] },
              h(NScrollbar, { ref: "scrollbarInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.getVlContainer : undefined, content: virtualScroll ? this.getVlContent : undefined }, {
                  default: () => virtualScroll ? (h(VVirtualList, { items: this.tmNodes, itemSize: this.itemSize, onScroll: this.handleVlScroll, showScrollbar: false, ref: "vlInstRef" }, {
                      default: ({ item: tmNode }) => (h(NCascaderOption, { key: tmNode.key, tmNode: tmNode }))
                  })) : (this.tmNodes.map((tmNode) => (h(NCascaderOption, { key: tmNode.key, tmNode: tmNode }))))
              })));
      }
  });

  var CascaderMenu = defineComponent({
      name: 'NCascaderMenu',
      props: {
          value: [String, Number, Array],
          placement: {
              type: String,
              default: 'bottom-start'
          },
          show: Boolean,
          menuModel: {
              type: Array,
              required: true
          },
          loading: Boolean,
          onFocus: {
              type: Function,
              required: true
          },
          onBlur: {
              type: Function,
              required: true
          },
          onKeydown: {
              type: Function,
              required: true
          },
          onMousedown: {
              type: Function,
              required: true
          },
          onTabout: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const { localeRef, isMountedRef, mergedClsPrefixRef, syncCascaderMenuPosition, handleCascaderMenuClickOutside, mergedThemeRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(cascaderInjectionKey);
          const submenuInstRefs = [];
          const maskInstRef = ref(null);
          const selfElRef = ref(null);
          function handleResize() {
              syncCascaderMenuPosition();
          }
          useOnResize(selfElRef, handleResize);
          function showErrorMessage(label) {
              var _a;
              const { value: { loadingRequiredMessage } } = localeRef;
              (_a = maskInstRef.value) === null || _a === void 0 ? void 0 : _a.showOnce(loadingRequiredMessage(label));
          }
          function handleClickOutside(e) {
              handleCascaderMenuClickOutside(e);
          }
          function handleFocusin(e) {
              const { value: selfEl } = selfElRef;
              if (!selfEl)
                  return;
              if (!selfEl.contains(e.relatedTarget)) {
                  props.onFocus(e);
              }
          }
          function handleFocusout(e) {
              const { value: selfEl } = selfElRef;
              if (!selfEl)
                  return;
              if (!selfEl.contains(e.relatedTarget)) {
                  props.onBlur(e);
              }
          }
          const exposedRef = {
              scroll(depth, index, elSize) {
                  const submenuInst = submenuInstRefs[depth];
                  if (submenuInst) {
                      submenuInst.scroll(index, elSize);
                  }
              },
              showErrorMessage
          };
          return Object.assign({ isMounted: isMountedRef, mergedClsPrefix: mergedClsPrefixRef, selfElRef,
              submenuInstRefs,
              maskInstRef, mergedTheme: mergedThemeRef, handleFocusin,
              handleFocusout,
              handleClickOutside }, exposedRef);
      },
      render() {
          const { submenuInstRefs, mergedClsPrefix, mergedTheme } = this;
          return (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
              default: () => {
                  if (!this.show)
                      return null;
                  return withDirectives(h("div", { tabindex: "0", ref: "selfElRef", class: `${mergedClsPrefix}-cascader-menu`, onMousedown: this.onMousedown, onFocusin: this.handleFocusin, onFocusout: this.handleFocusout, onKeydown: this.onKeydown },
                      this.menuModel[0].length ? (h("div", { class: `${mergedClsPrefix}-cascader-submenu-wrapper` },
                          this.menuModel.map((submenuOptions, index) => (h(NCascaderSubmenu, { ref: ((instance) => {
                                  if (instance) {
                                      submenuInstRefs[index] = instance;
                                  }
                              }), key: index, tmNodes: submenuOptions, depth: index + 1 }))),
                          h(NBaseMenuMask, { clsPrefix: mergedClsPrefix, ref: "maskInstRef" }))) : (h("div", { class: `${mergedClsPrefix}-cascader-menu__empty` }, resolveSlot(this.$slots.empty, () => [
                          h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
                      ]))),
                      resolveWrappedSlot(this.$slots.action, (children) => children && (h("div", { class: `${mergedClsPrefix}-cascader-menu-action`, "data-action": true }, children))),
                      h(FocusDetector, { onFocus: this.onTabout })), [
                      [
                          clickoutside$1,
                          this.handleClickOutside,
                          undefined,
                          { capture: true }
                      ]
                  ]);
              }
          }));
      }
  });

  var CascaderSelectMenu = defineComponent({
      name: 'NCascaderSelectMenu',
      props: {
          value: {
              type: [String, Number, Array],
              default: null
          },
          show: Boolean,
          pattern: {
              type: String,
              default: ''
          },
          multiple: Boolean,
          tmNodes: {
              type: Array,
              default: () => []
          },
          filter: Function,
          labelField: {
              type: String,
              required: true
          },
          separator: {
              type: String,
              required: true
          }
      },
      setup(props) {
          const { isMountedRef, mergedValueRef, mergedClsPrefixRef, mergedThemeRef, mergedCheckStrategyRef, slots: cascaderSlots, syncSelectMenuPosition, closeMenu, handleSelectMenuClickOutside, doUncheck: cascaderDoUncheck, doCheck: cascaderDoCheck, clearPattern
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(cascaderInjectionKey);
          const menuInstRef = ref(null);
          const selectOptionsRef = computed(() => {
              return createSelectOptions(props.tmNodes, mergedCheckStrategyRef.value === 'child', props.labelField, props.separator);
          });
          const mergedFilterRef = computed(() => {
              const { filter } = props;
              if (filter)
                  return filter;
              const { labelField } = props;
              return (pattern, _, path) => path.some((option) => option[labelField] && ~option[labelField].indexOf(pattern));
          });
          const filteredSelectOptionsRef = computed(() => {
              const { pattern } = props;
              const { value: mergedFilter } = mergedFilterRef;
              return (pattern
                  ? selectOptionsRef.value.filter((option) => {
                      return mergedFilter(pattern, option.rawNode, option.path);
                  })
                  : selectOptionsRef.value).map((option) => ({
                  value: option.value,
                  label: option.label
              }));
          });
          const selectTreeMateRef = computed(() => {
              return createTreeMate(filteredSelectOptionsRef.value, createTmOptions('value', 'children'));
          });
          function handleResize() {
              syncSelectMenuPosition();
          }
          function handleToggle(tmNode) {
              doCheck(tmNode);
          }
          // We don't care what type the tmNode is, we only care about its key
          function doCheck(tmNode) {
              if (props.multiple) {
                  const { value: mergedValue } = mergedValueRef;
                  if (Array.isArray(mergedValue)) {
                      if (!mergedValue.includes(tmNode.key)) {
                          cascaderDoCheck(tmNode.key);
                      }
                      else {
                          cascaderDoUncheck(tmNode.key);
                      }
                  }
                  else if (mergedValue === null) {
                      cascaderDoCheck(tmNode.key);
                  }
                  clearPattern();
              }
              else {
                  cascaderDoCheck(tmNode.key);
                  // currently the select menu is set to focusable
                  // however just leave it here
                  closeMenu(true);
              }
          }
          function prev() {
              var _a;
              (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
          }
          function next() {
              var _a;
              (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.next();
          }
          function enter() {
              var _a;
              if (menuInstRef) {
                  const pendingOptionTmNode = (_a = menuInstRef.value) === null || _a === void 0 ? void 0 : _a.getPendingTmNode();
                  if (pendingOptionTmNode) {
                      doCheck(pendingOptionTmNode);
                  }
                  return true;
              }
              return false;
          }
          function handleClickOutside(e) {
              handleSelectMenuClickOutside(e);
          }
          const exposedRef = {
              prev,
              next,
              enter
          };
          return Object.assign({ isMounted: isMountedRef, mergedTheme: mergedThemeRef, mergedClsPrefix: mergedClsPrefixRef, menuInstRef, selectTreeMate: selectTreeMateRef, handleResize,
              handleToggle,
              handleClickOutside,
              cascaderSlots }, exposedRef);
      },
      render() {
          const { mergedClsPrefix, isMounted, mergedTheme, cascaderSlots } = this;
          return (h(Transition, { name: "fade-in-scale-up-transition", appear: isMounted }, {
              default: () => this.show
                  ? withDirectives(h(NInternalSelectMenu, { ref: "menuInstRef", onResize: this.handleResize, clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-cascader-menu`, autoPending: true, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, theme: mergedTheme.peers.InternalSelectMenu, treeMate: this.selectTreeMate, multiple: this.multiple, value: this.value, onToggle: this.handleToggle }, {
                      empty: () => resolveSlot(cascaderSlots['not-found'], () => [])
                  }), [
                      [
                          clickoutside$1,
                          this.handleClickOutside,
                          undefined,
                          { capture: true }
                      ]
                  ])
                  : null
          }));
      }
  });

  // vars:
  // --n-menu-border-radius
  // --n-menu-box-shadow
  // --n-menu-height
  // --n-menu-color
  // --n-menu-divider-color
  // --n-option-height
  // --n-option-font-size
  // --n-option-text-color
  // --n-option-text-color-disabled
  // --n-option-text-color-active
  // --n-option-color-hover
  // --n-option-check-mark-color
  // --n-option-arrow-color
  // --n-menu-mask-color
  // --n-loading-color
  var style$15 = c$1([cB('cascader-menu', `
 outline: none;
 position: relative;
 margin: 4px 0;
 display: flex;
 flex-flow: column nowrap;
 border-radius: var(--n-menu-border-radius);
 overflow: hidden;
 box-shadow: var(--n-menu-box-shadow);
 color: var(--n-option-text-color);
 background-color: var(--n-menu-color);
 `, [fadeInScaleUpTransition({
    transformOrigin: 'inherit',
    duration: '0.2s'
  }), cE('empty', `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cB('scrollbar', {
    // if width not set, cascader select menu's inner scroll area's width is
    // not correct, which won't change after select menu width is set
    width: '100%'
  }), cB('base-menu-mask', {
    backgroundColor: 'var(--n-menu-mask-color)'
  }), cB('base-loading', {
    color: 'var(--n-loading-color)'
  }), cB('cascader-submenu-wrapper', `
 position: relative;
 display: flex;
 flex-wrap: nowrap;
 `), cB('cascader-submenu', `
 height: var(--n-menu-height);
 min-width: var(--n-column-width);
 position: relative;
 `, [cM('virtual', `
 width: var(--n-column-width);
 `), cB('scrollbar-content', {
    position: 'relative'
  }), c$1('&:first-child', `
 border-top-left-radius: var(--n-menu-border-radius);
 border-bottom-left-radius: var(--n-menu-border-radius);
 `), c$1('&:last-child', `
 border-top-right-radius: var(--n-menu-border-radius);
 border-bottom-right-radius: var(--n-menu-border-radius);
 `), c$1('&:not(:first-child)', `
 border-left: 1px solid var(--n-menu-divider-color);
 `)]), cB('cascader-menu-action', `
 box-sizing: border-box;
 padding: 8px;
 border-top: 1px solid var(--n-menu-divider-color);
 `), cB('cascader-option', `
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 padding: 0 0 0 18px;
 box-sizing: border-box;
 min-width: 182px;
 background-color: #0000;
 display: flex;
 align-items: center;
 white-space: nowrap;
 position: relative;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color 0.2s var(--n-bezier);
 `, [cM('show-prefix', {
    paddingLeft: 0
  }), cE('label', `
 flex: 1 0 0;
 overflow: hidden;
 text-overflow: ellipsis;
 `), cE('prefix', {
    width: '32px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }), cE('suffix', {
    width: '32px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center'
  }), cB('cascader-option-icon-placeholder', {
    lineHeight: 0,
    position: 'relative',
    width: '16px',
    height: '16px',
    fontSize: '16px'
  }, [cB('cascader-option-icon', [cM('checkmark', {
    color: 'var(--n-option-check-mark-color)'
  }, [fadeInScaleUpTransition({
    originalTransition: 'background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)'
  })]), cM('arrow', {
    color: 'var(--n-option-arrow-color)'
  })])]), cM('selected', {
    color: 'var(--n-option-text-color-active)'
  }), cM('active', {
    color: 'var(--n-option-text-color-active)',
    backgroundColor: 'var(--n-option-color-hover)'
  }), cM('pending', {
    backgroundColor: 'var(--n-option-color-hover)'
  }), c$1('&:hover', {
    backgroundColor: 'var(--n-option-color-hover)'
  }), cM('disabled', `
 color: var(--n-option-text-color-disabled);
 background-color: #0000;
 cursor: not-allowed;
 `, [cB('cascader-option-icon', [cM('arrow', {
    color: 'var(--n-option-text-color-disabled)'
  })])])])]), cB('cascader', `
 z-index: auto;
 position: relative;
 width: 100%;
 `)]);

  const cascaderProps = Object.assign(Object.assign({}, useTheme.props), { allowCheckingNotLoaded: Boolean, to: useAdjustedTo.propTo, bordered: {
          type: Boolean,
          default: undefined
      }, options: {
          type: Array,
          default: () => []
      }, value: [String, Number, Array], defaultValue: {
          type: [String, Number, Array],
          default: null
      }, placeholder: String, multiple: Boolean, size: String, filterable: Boolean, disabled: {
          type: Boolean,
          default: undefined
      }, disabledField: {
          type: String,
          default: 'disabled'
      }, expandTrigger: {
          type: String,
          default: 'click'
      }, clearable: Boolean, clearFilterAfterSelect: {
          type: Boolean,
          default: true
      }, remote: Boolean, onLoad: Function, separator: {
          type: String,
          default: ' / '
      }, filter: Function, placement: {
          type: String,
          default: 'bottom-start'
      }, cascade: {
          type: Boolean,
          default: true
      }, leafOnly: Boolean, showPath: {
          type: Boolean,
          default: true
      }, show: {
          type: Boolean,
          default: undefined
      }, maxTagCount: [String, Number], menuProps: Object, filterMenuProps: Object, virtualScroll: {
          type: Boolean,
          default: true
      }, checkStrategy: {
          type: String,
          default: 'all'
      }, valueField: {
          type: String,
          default: 'value'
      }, labelField: {
          type: String,
          default: 'label'
      }, childrenField: {
          type: String,
          default: 'children'
      }, renderLabel: Function, status: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], onBlur: Function, onFocus: Function, 
      // deprecated
      onChange: [Function, Array] });
  var Cascader = defineComponent({
      name: 'Cascader',
      props: cascaderProps,
      setup(props, { slots }) {
          const { mergedBorderedRef, mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Cascader', '-cascader', style$15, cascaderLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale('Cascader');
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = computed(() => props.value);
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const mergedCheckStrategyRef = computed(() => {
              return props.leafOnly ? 'child' : props.checkStrategy;
          });
          const patternRef = ref('');
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const cascaderMenuInstRef = ref(null);
          const selectMenuInstRef = ref(null);
          const triggerInstRef = ref(null);
          const keyboardKeyRef = ref(null);
          const hoverKeyRef = ref(null);
          const loadingKeySetRef = ref(new Set());
          const selectMenuFollowerRef = ref(null);
          const cascaderMenuFollowerRef = ref(null);
          const adjustedToRef = useAdjustedTo(props);
          const focusedRef = ref(false);
          const addLoadingKey = (key) => {
              loadingKeySetRef.value.add(key);
          };
          const deleteLoadingKey = (key) => {
              loadingKeySetRef.value.delete(key);
          };
          const treeMateRef = computed(() => {
              const { valueField, childrenField, disabledField } = props;
              return createTreeMate(props.options, {
                  getDisabled(node) {
                      return node[disabledField];
                  },
                  getKey(node) {
                      return node[valueField];
                  },
                  getChildren(node) {
                      return node[childrenField];
                  }
              });
          });
          const mergedKeysRef = computed(() => {
              const { cascade, multiple } = props;
              if (multiple && Array.isArray(mergedValueRef.value)) {
                  return treeMateRef.value.getCheckedKeys(mergedValueRef.value, {
                      cascade,
                      allowNotLoaded: props.allowCheckingNotLoaded
                  });
              }
              else {
                  return {
                      checkedKeys: [],
                      indeterminateKeys: []
                  };
              }
          });
          const checkedKeysRef = computed(() => mergedKeysRef.value.checkedKeys);
          const indeterminateKeysRef = computed(() => mergedKeysRef.value.indeterminateKeys);
          const menuModelRef = computed(() => {
              const { treeNodePath, treeNode } = treeMateRef.value.getPath(hoverKeyRef.value);
              let ret;
              if (treeNode === null) {
                  ret = [treeMateRef.value.treeNodes];
              }
              else {
                  ret = treeNodePath.map((treeNode) => treeNode.siblings);
                  if (!treeNode.isLeaf &&
                      !loadingKeySetRef.value.has(treeNode.key) &&
                      treeNode.children) {
                      ret.push(treeNode.children);
                  }
              }
              return ret;
          });
          const hoverKeyPathRef = computed(() => {
              const { keyPath } = treeMateRef.value.getPath(hoverKeyRef.value);
              return keyPath;
          });
          const optionHeightRef = computed(() => {
              return themeRef.value.self.optionHeight;
          });
          if (isReactive(props.options)) {
              watch(props.options, (value, oldValue) => {
                  if (!(value === oldValue)) {
                      hoverKeyRef.value = null;
                      keyboardKeyRef.value = null;
                  }
              });
          }
          function doUpdateShow(value) {
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow) {
                  call(onUpdateShow, value);
              }
              if (_onUpdateShow) {
                  call(_onUpdateShow, value);
              }
              uncontrolledShowRef.value = value;
          }
          function doUpdateValue(value, option, optionPath) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateValue) {
                  call(onUpdateValue, value, option, optionPath);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, option, optionPath);
              }
              if (onChange) {
                  call(onChange, value, option, optionPath);
              }
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function updateKeyboardKey(key) {
              keyboardKeyRef.value = key;
          }
          function updateHoverKey(key) {
              hoverKeyRef.value = key;
          }
          function getOptionsByKeys(keys) {
              const { value: { getNode } } = treeMateRef;
              return keys.map((keys) => { var _a; return ((_a = getNode(keys)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });
          }
          function doCheck(key) {
              var _a;
              const { cascade, multiple, filterable } = props;
              const { value: { check, getNode, getPath } } = treeMateRef;
              if (multiple) {
                  try {
                      const { checkedKeys } = check(key, mergedKeysRef.value.checkedKeys, {
                          cascade,
                          checkStrategy: mergedCheckStrategyRef.value,
                          allowNotLoaded: props.allowCheckingNotLoaded
                      });
                      doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), checkedKeys.map((checkedKey) => { var _a; return getRawNodePath((_a = getPath(checkedKey)) === null || _a === void 0 ? void 0 : _a.treeNodePath); }));
                      if (filterable)
                          focusSelectionInput();
                      keyboardKeyRef.value = key;
                      hoverKeyRef.value = key;
                  }
                  catch (err) {
                      if (err instanceof SubtreeNotLoadedError) {
                          if (cascaderMenuInstRef.value) {
                              const tmNode = getNode(key);
                              if (tmNode !== null) {
                                  cascaderMenuInstRef.value.showErrorMessage(tmNode.rawNode[props.labelField]);
                              }
                          }
                      }
                      else {
                          throw err;
                      }
                  }
              }
              else {
                  if (mergedCheckStrategyRef.value === 'child') {
                      const tmNode = getNode(key);
                      if (tmNode === null || tmNode === void 0 ? void 0 : tmNode.isLeaf) {
                          doUpdateValue(key, tmNode.rawNode, getRawNodePath(getPath(key).treeNodePath));
                      }
                      else {
                          return false;
                      }
                  }
                  else {
                      const tmNode = getNode(key);
                      doUpdateValue(key, (tmNode === null || tmNode === void 0 ? void 0 : tmNode.rawNode) || null, getRawNodePath((_a = getPath(key)) === null || _a === void 0 ? void 0 : _a.treeNodePath));
                  }
              }
              return true;
          }
          function doUncheck(key) {
              const { cascade, multiple } = props;
              if (multiple) {
                  const { value: { uncheck, getNode, getPath } } = treeMateRef;
                  const { checkedKeys } = uncheck(key, mergedKeysRef.value.checkedKeys, {
                      cascade,
                      checkStrategy: mergedCheckStrategyRef.value,
                      allowNotLoaded: props.allowCheckingNotLoaded
                  });
                  doUpdateValue(checkedKeys, checkedKeys.map((checkedKey) => { var _a; return ((_a = getNode(checkedKey)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; }), checkedKeys.map((checkedKey) => { var _a; return getRawNodePath((_a = getPath(checkedKey)) === null || _a === void 0 ? void 0 : _a.treeNodePath); }));
                  keyboardKeyRef.value = key;
                  hoverKeyRef.value = key;
              }
          }
          const selectedOptionsRef = computed(() => {
              if (props.multiple) {
                  const { showPath, separator, labelField, cascade } = props;
                  const { getCheckedKeys, getNode } = treeMateRef.value;
                  const value = getCheckedKeys(checkedKeysRef.value, {
                      cascade,
                      checkStrategy: mergedCheckStrategyRef.value,
                      allowNotLoaded: props.allowCheckingNotLoaded
                  }).checkedKeys;
                  return value.map((key) => {
                      const node = getNode(key);
                      if (node === null) {
                          return {
                              label: String(key),
                              value: key
                          };
                      }
                      else {
                          return {
                              label: showPath
                                  ? getPathLabel(node, separator, labelField)
                                  : node.rawNode[labelField],
                              value: node.key
                          };
                      }
                  });
              }
              else
                  return [];
          });
          const selectedOptionRef = computed(() => {
              const { multiple, showPath, separator, labelField } = props;
              const { value } = mergedValueRef;
              if (!multiple && !Array.isArray(value)) {
                  const { getNode } = treeMateRef.value;
                  if (value === null) {
                      return null;
                  }
                  const node = getNode(value);
                  if (node === null) {
                      return {
                          label: String(value),
                          value
                      };
                  }
                  else {
                      return {
                          label: showPath
                              ? getPathLabel(node, separator, labelField)
                              : node.rawNode[labelField],
                          value: node.key
                      };
                  }
              }
              else
                  return null;
          });
          const uncontrolledShowRef = ref(false);
          const controlledShowRef = toRef(props, 'show');
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const localizedPlaceholderRef = computed(() => {
              const { placeholder } = props;
              if (placeholder !== undefined)
                  return placeholder;
              return localeRef.value.placeholder;
          });
          // select option related
          const showSelectMenuRef = computed(() => {
              return !!(props.filterable && patternRef.value);
          });
          // init hover key
          watch(mergedShowRef, (show) => {
              if (!show)
                  return;
              if (props.multiple)
                  return;
              const { value } = mergedValueRef;
              if (!Array.isArray(value) && value !== null) {
                  keyboardKeyRef.value = value;
                  hoverKeyRef.value = value;
                  void nextTick(() => {
                      var _a;
                      if (!mergedShowRef.value)
                          return;
                      const { value: hoverKey } = hoverKeyRef;
                      if (mergedValueRef.value !== null) {
                          const node = treeMateRef.value.getNode(hoverKey);
                          if (node) {
                              (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
                          }
                      }
                  });
              }
              else {
                  keyboardKeyRef.value = null;
                  hoverKeyRef.value = null;
              }
          }, {
              immediate: true
          });
          // --- methods
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function focusSelectionInput() {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function focusSelection() {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function openMenu() {
              if (!mergedDisabledRef.value) {
                  patternRef.value = '';
                  doUpdateShow(true);
                  if (props.filterable) {
                      focusSelectionInput();
                  }
              }
          }
          function closeMenu(returnFocus = false) {
              if (returnFocus) {
                  focusSelection();
              }
              doUpdateShow(false);
              patternRef.value = '';
          }
          function handleCascaderMenuClickOutside(e) {
              var _a;
              if (showSelectMenuRef.value)
                  return;
              if (mergedShowRef.value) {
                  if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                      closeMenu();
                  }
              }
          }
          function handleSelectMenuClickOutside(e) {
              if (!showSelectMenuRef.value)
                  return;
              handleCascaderMenuClickOutside(e);
          }
          function clearPattern() {
              if (props.clearFilterAfterSelect)
                  patternRef.value = '';
          }
          // --- keyboard
          function move(direction) {
              var _a, _b, _c;
              const { value: keyboardKey } = keyboardKeyRef;
              const { value: treeMate } = treeMateRef;
              switch (direction) {
                  case 'prev':
                      if (keyboardKey !== null) {
                          const node = treeMate.getPrev(keyboardKey, { loop: true });
                          if (node !== null) {
                              updateKeyboardKey(node.key);
                              (_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.scroll(node.level, node.index, depx(optionHeightRef.value));
                          }
                      }
                      break;
                  case 'next':
                      if (keyboardKey === null) {
                          const node = treeMate.getFirstAvailableNode();
                          if (node !== null) {
                              updateKeyboardKey(node.key);
                              (_b = cascaderMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.scroll(node.level, node.index, depx(optionHeightRef.value));
                          }
                      }
                      else {
                          const node = treeMate.getNext(keyboardKey, { loop: true });
                          if (node !== null) {
                              updateKeyboardKey(node.key);
                              (_c = cascaderMenuInstRef.value) === null || _c === void 0 ? void 0 : _c.scroll(node.level, node.index, depx(optionHeightRef.value));
                          }
                      }
                      break;
                  case 'child':
                      if (keyboardKey !== null) {
                          const currentNode = treeMate.getNode(keyboardKey);
                          if (currentNode !== null) {
                              if (currentNode.shallowLoaded) {
                                  const node = treeMate.getChild(keyboardKey);
                                  if (node !== null) {
                                      updateHoverKey(keyboardKey);
                                      updateKeyboardKey(node.key);
                                  }
                              }
                              else {
                                  const { value: loadingKeySet } = loadingKeySetRef;
                                  if (!loadingKeySet.has(keyboardKey)) {
                                      addLoadingKey(keyboardKey);
                                      updateHoverKey(keyboardKey);
                                      const { onLoad } = props;
                                      if (onLoad) {
                                          onLoad(currentNode.rawNode)
                                              .then(() => {
                                              deleteLoadingKey(keyboardKey);
                                          })
                                              .catch(() => {
                                              deleteLoadingKey(keyboardKey);
                                          });
                                      }
                                  }
                              }
                          }
                      }
                      break;
                  case 'parent':
                      if (keyboardKey !== null) {
                          const node = treeMate.getParent(keyboardKey);
                          if (node !== null) {
                              updateKeyboardKey(node.key);
                              const parentNode = node.getParent();
                              if (parentNode === null) {
                                  updateHoverKey(null);
                              }
                              else {
                                  updateHoverKey(parentNode.key);
                              }
                          }
                      }
                      break;
              }
          }
          function handleKeydown(e) {
              var _a, _b;
              switch (e.key) {
                  case ' ':
                  case 'ArrowDown':
                  case 'ArrowUp':
                      if (props.filterable && mergedShowRef.value) {
                          break;
                      }
                      e.preventDefault();
                      break;
              }
              if (happensIn(e, 'action'))
                  return;
              switch (e.key) {
                  case ' ':
                      if (props.filterable)
                          return;
                  // eslint-disable-next-line no-fallthrough
                  case 'Enter':
                      if (!mergedShowRef.value) {
                          openMenu();
                      }
                      else {
                          const { value: showSelectMenu } = showSelectMenuRef;
                          const { value: keyboardKey } = keyboardKeyRef;
                          if (!showSelectMenu) {
                              if (keyboardKey !== null) {
                                  if (checkedKeysRef.value.includes(keyboardKey) ||
                                      indeterminateKeysRef.value.includes(keyboardKey)) {
                                      doUncheck(keyboardKey);
                                  }
                                  else {
                                      const checkIsValid = doCheck(keyboardKey);
                                      if (!props.multiple && checkIsValid) {
                                          closeMenu(true);
                                      }
                                  }
                              }
                          }
                          else {
                              if (selectMenuInstRef.value) {
                                  const hasCorrespondingOption = selectMenuInstRef.value.enter();
                                  if (hasCorrespondingOption)
                                      clearPattern();
                              }
                          }
                      }
                      break;
                  case 'ArrowUp':
                      e.preventDefault();
                      if (mergedShowRef.value) {
                          if (showSelectMenuRef.value) {
                              (_a = selectMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.prev();
                          }
                          else {
                              move('prev');
                          }
                      }
                      break;
                  case 'ArrowDown':
                      e.preventDefault();
                      if (mergedShowRef.value) {
                          if (showSelectMenuRef.value) {
                              (_b = selectMenuInstRef.value) === null || _b === void 0 ? void 0 : _b.next();
                          }
                          else {
                              move('next');
                          }
                      }
                      else {
                          openMenu();
                      }
                      break;
                  case 'ArrowLeft':
                      e.preventDefault();
                      if (mergedShowRef.value && !showSelectMenuRef.value) {
                          move('parent');
                      }
                      break;
                  case 'ArrowRight':
                      e.preventDefault();
                      if (mergedShowRef.value && !showSelectMenuRef.value) {
                          move('child');
                      }
                      break;
                  case 'Escape':
                      if (mergedShowRef.value) {
                          markEventEffectPerformed(e);
                          closeMenu(true);
                      }
              }
          }
          function handleMenuKeydown(e) {
              handleKeydown(e);
          }
          // --- search
          function handleClear(e) {
              e.stopPropagation();
              if (props.multiple) {
                  doUpdateValue([], [], []);
              }
              else {
                  doUpdateValue(null, null, null);
              }
          }
          function handleTriggerFocus(e) {
              var _a;
              if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
                  focusedRef.value = true;
                  doFocus(e);
              }
          }
          function handleTriggerBlur(e) {
              var _a;
              if (!((_a = cascaderMenuInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
                  focusedRef.value = false;
                  doBlur(e);
                  closeMenu();
              }
          }
          function handleMenuFocus(e) {
              var _a;
              if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
                  focusedRef.value = true;
                  doFocus(e);
              }
          }
          function handleMenuBlur(e) {
              var _a;
              if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
                  focusedRef.value = false;
                  doBlur(e);
              }
          }
          function handleMenuMousedown(e) {
              if (!happensIn(e, 'action')) {
                  if (props.multiple && props.filter) {
                      e.preventDefault();
                      focusSelectionInput();
                  }
              }
          }
          function handleMenuTabout() {
              closeMenu(true);
          }
          function handleTriggerClick() {
              if (props.filterable) {
                  openMenu();
              }
              else {
                  if (mergedShowRef.value) {
                      closeMenu(true);
                  }
                  else {
                      openMenu();
                  }
              }
          }
          function handlePatternInput(e) {
              patternRef.value = e.target.value;
          }
          function handleDeleteOption(option) {
              const { multiple } = props;
              const { value: mergedValue } = mergedValueRef;
              if (multiple &&
                  Array.isArray(mergedValue) &&
                  option.value !== undefined) {
                  doUncheck(option.value);
              }
              else {
                  doUpdateValue(null, null, null);
              }
          }
          // sync position
          function syncSelectMenuPosition() {
              var _a;
              (_a = selectMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function syncCascaderMenuPosition() {
              var _a;
              (_a = cascaderMenuFollowerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleTriggerResize() {
              if (mergedShowRef.value) {
                  if (showSelectMenuRef.value) {
                      syncSelectMenuPosition();
                  }
                  else {
                      syncCascaderMenuPosition();
                  }
              }
          }
          const showCheckboxRef = computed(() => {
              if (props.multiple && props.cascade)
                  return true;
              if (mergedCheckStrategyRef.value !== 'child')
                  return true;
              return false;
          });
          provide(cascaderInjectionKey, {
              slots,
              mergedClsPrefixRef,
              mergedThemeRef: themeRef,
              mergedValueRef,
              checkedKeysRef,
              indeterminateKeysRef,
              hoverKeyPathRef,
              mergedCheckStrategyRef,
              showCheckboxRef,
              cascadeRef: toRef(props, 'cascade'),
              multipleRef: toRef(props, 'multiple'),
              keyboardKeyRef,
              hoverKeyRef,
              remoteRef: toRef(props, 'remote'),
              loadingKeySetRef,
              expandTriggerRef: toRef(props, 'expandTrigger'),
              isMountedRef: isMounted(),
              onLoadRef: toRef(props, 'onLoad'),
              virtualScrollRef: toRef(props, 'virtualScroll'),
              optionHeightRef,
              localeRef,
              labelFieldRef: toRef(props, 'labelField'),
              renderLabelRef: toRef(props, 'renderLabel'),
              syncCascaderMenuPosition,
              syncSelectMenuPosition,
              updateKeyboardKey,
              updateHoverKey,
              addLoadingKey,
              deleteLoadingKey,
              doCheck,
              doUncheck,
              closeMenu,
              handleSelectMenuClickOutside,
              handleCascaderMenuClickOutside,
              clearPattern
          });
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                  var _a;
                  (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              },
              getCheckedData: () => {
                  if (showCheckboxRef.value) {
                      const checkedKeys = checkedKeysRef.value;
                      return {
                          keys: checkedKeys,
                          options: getOptionsByKeys(checkedKeys)
                      };
                  }
                  return {
                      keys: [],
                      options: []
                  };
              },
              getIndeterminateData: () => {
                  if (showCheckboxRef.value) {
                      const indeterminateKeys = indeterminateKeysRef.value;
                      return {
                          keys: indeterminateKeys,
                          options: getOptionsByKeys(indeterminateKeys)
                      };
                  }
                  return {
                      keys: [],
                      options: []
                  };
              }
          };
          const cssVarsRef = computed(() => {
              const { self: { optionArrowColor, optionTextColor, optionTextColorActive, optionTextColorDisabled, optionCheckMarkColor, menuColor, menuBoxShadow, menuDividerColor, menuBorderRadius, menuHeight, optionColorHover, optionHeight, optionFontSize, loadingColor, columnWidth }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-menu-border-radius': menuBorderRadius,
                  '--n-menu-box-shadow': menuBoxShadow,
                  '--n-menu-height': menuHeight,
                  '--n-column-width': columnWidth,
                  '--n-menu-color': menuColor,
                  '--n-menu-divider-color': menuDividerColor,
                  '--n-option-height': optionHeight,
                  '--n-option-font-size': optionFontSize,
                  '--n-option-text-color': optionTextColor,
                  '--n-option-text-color-disabled': optionTextColorDisabled,
                  '--n-option-text-color-active': optionTextColorActive,
                  '--n-option-color-hover': optionColorHover,
                  '--n-option-check-mark-color': optionCheckMarkColor,
                  '--n-option-arrow-color': optionArrowColor,
                  '--n-menu-mask-color': changeColor(menuColor, { alpha: 0.75 }),
                  '--n-loading-color': loadingColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('cascader', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedMethods), { handleTriggerResize, mergedStatus: mergedStatusRef, selectMenuFollowerRef,
              cascaderMenuFollowerRef,
              triggerInstRef,
              selectMenuInstRef,
              cascaderMenuInstRef, mergedBordered: mergedBorderedRef, mergedClsPrefix: mergedClsPrefixRef, namespace: namespaceRef, mergedValue: mergedValueRef, mergedShow: mergedShowRef, showSelectMenu: showSelectMenuRef, pattern: patternRef, treeMate: treeMateRef, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, localizedPlaceholder: localizedPlaceholderRef, selectedOption: selectedOptionRef, selectedOptions: selectedOptionsRef, adjustedTo: adjustedToRef, menuModel: menuModelRef, handleMenuTabout,
              handleMenuFocus,
              handleMenuBlur,
              handleMenuKeydown,
              handleMenuMousedown,
              handleTriggerFocus,
              handleTriggerBlur,
              handleTriggerClick,
              handleClear,
              handleDeleteOption,
              handlePatternInput,
              handleKeydown, focused: focusedRef, optionHeight: optionHeightRef, mergedTheme: themeRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-cascader` },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h(NInternalSelection, { onResize: this.handleTriggerResize, ref: "triggerInstRef", status: this.mergedStatus, clsPrefix: mergedClsPrefix, maxTagCount: this.maxTagCount, bordered: this.mergedBordered, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, active: this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, focused: this.focused, onFocus: this.handleTriggerFocus, onBlur: this.handleTriggerBlur, onClick: this.handleTriggerClick, onClear: this.handleClear, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onKeydown: this.handleKeydown }, {
                              arrow: () => { var _a, _b; return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a); }
                          }))
                      }),
                      h(VFollower, { key: "cascaderMenu", ref: "cascaderMenuFollowerRef", show: this.mergedShow && !this.showSelectMenu, containerClass: this.namespace, placement: this.placement, width: !this.options.length ? 'target' : undefined, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, to: this.adjustedTo }, {
                          default: () => {
                              var _a;
                              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                              const { menuProps } = this;
                              return (h(CascaderMenu, Object.assign({}, menuProps, { ref: "cascaderMenuInstRef", class: [this.themeClass, menuProps === null || menuProps === void 0 ? void 0 : menuProps.class], value: this.mergedValue, show: this.mergedShow && !this.showSelectMenu, menuModel: this.menuModel, style: [
                                      this.cssVars,
                                      menuProps === null || menuProps === void 0 ? void 0 : menuProps.style
                                  ], onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onMousedown: this.handleMenuMousedown, onTabout: this.handleMenuTabout }), {
                                  action: () => { var _a, _b; return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a); },
                                  empty: () => { var _a, _b; return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a); }
                              }));
                          }
                      }),
                      h(VFollower, { key: "selectMenu", ref: "selectMenuFollowerRef", show: this.mergedShow && this.showSelectMenu, containerClass: this.namespace, width: "target", placement: this.placement, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
                          default: () => {
                              var _a;
                              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                              const { filterMenuProps } = this;
                              return (h(CascaderSelectMenu, Object.assign({}, filterMenuProps, { ref: "selectMenuInstRef", class: [this.themeClass, filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.class], value: this.mergedValue, show: this.mergedShow && this.showSelectMenu, pattern: this.pattern, multiple: this.multiple, tmNodes: this.treeMate.treeNodes, filter: this.filter, labelField: this.labelField, separator: this.separator, style: [
                                      this.cssVars,
                                      filterMenuProps === null || filterMenuProps === void 0 ? void 0 : filterMenuProps.style
                                  ] })));
                          }
                      })
                  ]
              })));
      }
  });

  const self$U = (vars) => {
      const { textColor2, fontSize, fontWeightStrong, textColor3 } = vars;
      return {
          textColor: textColor2,
          fontSize,
          fontWeightStrong,
          // extracted from hljs atom-one-light.scss
          'mono-3': '#a0a1a7',
          'hue-1': '#0184bb',
          'hue-2': '#4078f2',
          'hue-3': '#a626a4',
          'hue-4': '#50a14f',
          'hue-5': '#e45649',
          'hue-5-2': '#c91243',
          'hue-6': '#986801',
          'hue-6-2': '#c18401',
          // line-number styles
          lineNumberTextColor: textColor3
      };
  };
  const codeLight = {
      name: 'Code',
      common: commonLight,
      self: self$U
  };
  var codeLight$1 = codeLight;

  // vars:
  // --n-font-size
  // --n-font-family
  // --n-font-weight-strong
  // --n-bezier
  // --n-text-color
  // --n-mono-3
  // --n-hue-1
  // --n-hue-2
  // --n-hue-3
  // --n-hue-4
  // --n-hue-5
  // --n-hue-5-2
  // --n-hue-6
  // --n-hue-6-2
  // --n-line-number-color
  // --n-line-number-text-color
  var style$14 = c$1([cB('code', `
 font-size: var(--n-font-size);
 font-family: var(--n-font-family);
 `, [cM('show-line-numbers', `
 display: flex;
 `), cE('line-numbers', `
 user-select: none;
 padding-right: 12px;
 text-align: right;
 transition: color .3s var(--n-bezier);
 color: var(--n-line-number-text-color);
 `), cM('word-wrap', [c$1('pre', `
 white-space: pre-wrap;
 word-break: break-all;
 `)]), c$1('pre', `
 margin: 0;
 line-height: inherit;
 font-size: inherit;
 font-family: inherit;
 `), c$1('[class^=hljs]', `
 color: var(--n-text-color);
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), ({
    props
  }) => {
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    const codeClass = `${props.bPrefix}code`;
    return [`${codeClass} .hljs-comment,
 ${codeClass} .hljs-quote {
 color: var(--n-mono-3);
 font-style: italic;
 }`, `${codeClass} .hljs-doctag,
 ${codeClass} .hljs-keyword,
 ${codeClass} .hljs-formula {
 color: var(--n-hue-3);
 }`, `${codeClass} .hljs-section,
 ${codeClass} .hljs-name,
 ${codeClass} .hljs-selector-tag,
 ${codeClass} .hljs-deletion,
 ${codeClass} .hljs-subst {
 color: var(--n-hue-5);
 }`, `${codeClass} .hljs-literal {
 color: var(--n-hue-1);
 }`, `${codeClass} .hljs-string,
 ${codeClass} .hljs-regexp,
 ${codeClass} .hljs-addition,
 ${codeClass} .hljs-attribute,
 ${codeClass} .hljs-meta-string {
 color: var(--n-hue-4);
 }`, `${codeClass} .hljs-built_in,
 ${codeClass} .hljs-class .hljs-title {
 color: var(--n-hue-6-2);
 }`, `${codeClass} .hljs-attr,
 ${codeClass} .hljs-variable,
 ${codeClass} .hljs-template-variable,
 ${codeClass} .hljs-type,
 ${codeClass} .hljs-selector-class,
 ${codeClass} .hljs-selector-attr,
 ${codeClass} .hljs-selector-pseudo,
 ${codeClass} .hljs-number {
 color: var(--n-hue-6);
 }`, `${codeClass} .hljs-symbol,
 ${codeClass} .hljs-bullet,
 ${codeClass} .hljs-link,
 ${codeClass} .hljs-meta,
 ${codeClass} .hljs-selector-id,
 ${codeClass} .hljs-title {
 color: var(--n-hue-2);
 }`, `${codeClass} .hljs-emphasis {
 font-style: italic;
 }`, `${codeClass} .hljs-strong {
 font-weight: var(--n-font-weight-strong);
 }`, `${codeClass} .hljs-link {
 text-decoration: underline;
 }`];
  }]);

  const codeProps = Object.assign(Object.assign({}, useTheme.props), { language: String, code: {
          type: String,
          default: ''
      }, trim: {
          type: Boolean,
          default: true
      }, hljs: Object, uri: Boolean, inline: Boolean, wordWrap: Boolean, showLineNumbers: Boolean, 
      // In n-log, we only need to mount code's style for highlight
      internalFontSize: Number, internalNoHighlight: Boolean });
  var NCode = defineComponent({
      name: 'Code',
      props: codeProps,
      setup(props, { slots }) {
          const { internalNoHighlight } = props;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig();
          const codeRef = ref(null);
          const hljsRef = internalNoHighlight ? { value: undefined } : useHljs(props);
          const createCodeHtml = (language, code, trim) => {
              const { value: hljs } = hljsRef;
              if (!hljs) {
                  return null;
              }
              if (!(language && hljs.getLanguage(language))) {
                  return null;
              }
              return hljs.highlight(trim ? code.trim() : code, {
                  language
              }).value;
          };
          const mergedShowLineNumbersRef = computed(() => {
              if (props.inline || props.wordWrap)
                  return false;
              return props.showLineNumbers;
          });
          const setCode = () => {
              if (slots.default)
                  return;
              const { value: codeEl } = codeRef;
              if (!codeEl)
                  return;
              const { language } = props;
              const code = props.uri
                  ? window.decodeURIComponent(props.code)
                  : props.code;
              if (language) {
                  const html = createCodeHtml(language, code, props.trim);
                  if (html !== null) {
                      if (props.inline) {
                          codeEl.innerHTML = html;
                      }
                      else {
                          const prevPreEl = codeEl.querySelector('.__code__');
                          if (prevPreEl)
                              codeEl.removeChild(prevPreEl);
                          const preEl = document.createElement('pre');
                          preEl.className = '__code__';
                          preEl.innerHTML = html;
                          codeEl.appendChild(preEl);
                      }
                      return;
                  }
              }
              if (props.inline) {
                  codeEl.textContent = code;
                  return;
              }
              const maybePreEl = codeEl.querySelector('.__code__');
              if (maybePreEl) {
                  maybePreEl.textContent = code;
              }
              else {
                  const wrap = document.createElement('pre');
                  wrap.className = '__code__';
                  wrap.textContent = code;
                  codeEl.innerHTML = '';
                  codeEl.appendChild(wrap);
              }
          };
          onMounted(setCode);
          watch(toRef(props, 'language'), setCode);
          watch(toRef(props, 'code'), setCode);
          if (!internalNoHighlight)
              watch(hljsRef, setCode);
          const themeRef = useTheme('Code', '-code', style$14, codeLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut, fontFamilyMono }, self: { textColor, fontSize, fontWeightStrong, lineNumberTextColor, 
              // extracted from hljs atom-one-light.scss
              'mono-3': $1, 'hue-1': $2, 'hue-2': $3, 'hue-3': $4, 'hue-4': $5, 'hue-5': $6, 'hue-5-2': $7, 'hue-6': $8, 'hue-6-2': $9 } } = themeRef.value;
              const { internalFontSize } = props;
              return {
                  '--n-font-size': internalFontSize ? `${internalFontSize}px` : fontSize,
                  '--n-font-family': fontFamilyMono,
                  '--n-font-weight-strong': fontWeightStrong,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-mono-3': $1,
                  '--n-hue-1': $2,
                  '--n-hue-2': $3,
                  '--n-hue-3': $4,
                  '--n-hue-4': $5,
                  '--n-hue-5': $6,
                  '--n-hue-5-2': $7,
                  '--n-hue-6': $8,
                  '--n-hue-6-2': $9,
                  '--n-line-number-text-color': lineNumberTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('code', computed(() => {
                  return `${props.internalFontSize || 'a'}`;
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              codeRef,
              mergedShowLineNumbers: mergedShowLineNumbersRef,
              lineNumbers: computed(() => {
                  let number = 1;
                  const numbers = [];
                  let lastIsLineWrap = false;
                  for (const char of props.code) {
                      if (char === '\n') {
                          lastIsLineWrap = true;
                          numbers.push(number++);
                      }
                      else {
                          lastIsLineWrap = false;
                      }
                  }
                  if (!lastIsLineWrap) {
                      numbers.push(number++);
                  }
                  return numbers.join('\n');
              }),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a, _b;
          const { mergedClsPrefix, wordWrap, mergedShowLineNumbers, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("code", { class: [
                  `${mergedClsPrefix}-code`,
                  this.themeClass,
                  wordWrap && `${mergedClsPrefix}-code--word-wrap`,
                  mergedShowLineNumbers && `${mergedClsPrefix}-code--show-line-numbers`
              ], style: this.cssVars, ref: "codeRef" },
              mergedShowLineNumbers ? (h("pre", { class: `${mergedClsPrefix}-code__line-numbers` }, this.lineNumbers)) : null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 :
              _b.call(_a)));
      }
  });

  const self$T = (vars) => {
      const { fontWeight, textColor1, textColor2, textColorDisabled, dividerColor, fontSize } = vars;
      return {
          titleFontSize: fontSize,
          titleFontWeight: fontWeight,
          dividerColor,
          titleTextColor: textColor1,
          titleTextColorDisabled: textColorDisabled,
          fontSize,
          textColor: textColor2,
          arrowColor: textColor2,
          arrowColorDisabled: textColorDisabled,
          itemMargin: '16px 0 0 0',
          titlePadding: '16px 0 0 0'
      };
  };
  const collapseLight = {
      name: 'Collapse',
      common: commonLight,
      self: self$T
  };
  var collapseLight$1 = collapseLight;

  // vars:
  // --n-font-size
  // --n-bezier
  // --n-text-color
  // --n-divider-color
  // --n-title-padding
  // --n-title-font-size
  // --n-title-text-color
  // --n-title-font-weight
  // --n-arrow-color
  // --n-arrow-color-disabled
  // --n-title-text-color-disabled
  // --n-item-margin
  var style$13 = cB('collapse', 'width: 100%;', [cB('collapse-item', `
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 margin: var(--n-item-margin);
 `, [cM('disabled', [cE('header', 'cursor: not-allowed;', [cE('header-main', `
 color: var(--n-title-text-color-disabled);
 `), cB('collapse-item-arrow', `
 color: var(--n-arrow-color-disabled);
 `)])]), cB('collapse-item', 'margin-left: 32px;'), c$1('&:first-child', 'margin-top: 0;'), c$1('&:first-child >', [cE('header', 'padding-top: 0;')]), cM('left-arrow-placement', [cE('header', [cB('collapse-item-arrow', 'margin-right: 4px;')])]), cM('right-arrow-placement', [cE('header', [cB('collapse-item-arrow', 'margin-left: 4px;')])]), cE('content-wrapper', [cE('content-inner', 'padding-top: 16px;'), fadeInHeightExpandTransition({
    duration: '0.15s'
  })]), cM('active', [cE('header', [cM('active', [cB('collapse-item-arrow', 'transform: rotate(90deg);')])])]), c$1('&:not(:first-child)', 'border-top: 1px solid var(--n-divider-color);'), cE('header', `
 font-size: var(--n-title-font-size);
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition: color .3s var(--n-bezier);
 position: relative;
 padding: var(--n-title-padding);
 color: var(--n-title-text-color);
 cursor: pointer;
 `, [cE('header-main', `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 color: var(--n-title-text-color);
 `), cE('header-extra', `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cB('collapse-item-arrow', `
 display: flex;
 transition:
 transform .15s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: 18px;
 color: var(--n-arrow-color);
 `)])])]);

  const collapseProps = Object.assign(Object.assign({}, useTheme.props), { defaultExpandedNames: {
          type: [Array, String],
          default: null
      }, expandedNames: [Array, String], arrowPlacement: {
          type: String,
          default: 'left'
      }, accordion: {
          type: Boolean,
          default: false
      }, displayDirective: {
          type: String,
          default: 'if'
      }, onItemHeaderClick: [Function, Array], 'onUpdate:expandedNames': [Function, Array], onUpdateExpandedNames: [Function, Array], 
      // deprecated
      onExpandedNamesChange: {
          type: [Function, Array],
          validator: () => {
              return true;
          },
          default: undefined
      } });
  const collapseInjectionKey = createInjectionKey('n-collapse');
  var NCollapse = defineComponent({
      name: 'Collapse',
      props: collapseProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const uncontrolledExpandedNamesRef = ref(props.defaultExpandedNames);
          const controlledExpandedNamesRef = computed(() => props.expandedNames);
          const mergedExpandedNamesRef = useMergedState(controlledExpandedNamesRef, uncontrolledExpandedNamesRef);
          const themeRef = useTheme('Collapse', '-collapse', style$13, collapseLight$1, props, mergedClsPrefixRef);
          function doUpdateExpandedNames(names) {
              const { 'onUpdate:expandedNames': _onUpdateExpandedNames, onUpdateExpandedNames, onExpandedNamesChange } = props;
              if (onUpdateExpandedNames) {
                  call(onUpdateExpandedNames, names);
              }
              if (_onUpdateExpandedNames) {
                  call(_onUpdateExpandedNames, names);
              }
              if (onExpandedNamesChange) {
                  call(onExpandedNamesChange, names);
              }
              uncontrolledExpandedNamesRef.value = names;
          }
          function doItemHeaderClick(info) {
              const { onItemHeaderClick } = props;
              if (onItemHeaderClick) {
                  call(onItemHeaderClick, info);
              }
          }
          function toggleItem(collapse, name, event) {
              const { accordion } = props;
              const { value: expandedNames } = mergedExpandedNamesRef;
              if (accordion) {
                  if (collapse) {
                      doUpdateExpandedNames([name]);
                      doItemHeaderClick({ name, expanded: true, event });
                  }
                  else {
                      doUpdateExpandedNames([]);
                      doItemHeaderClick({ name, expanded: false, event });
                  }
              }
              else {
                  if (!Array.isArray(expandedNames)) {
                      doUpdateExpandedNames([name]);
                      doItemHeaderClick({ name, expanded: true, event });
                  }
                  else {
                      const activeNames = expandedNames.slice();
                      const index = activeNames.findIndex((activeName) => name === activeName);
                      if (~index) {
                          activeNames.splice(index, 1);
                          doUpdateExpandedNames(activeNames);
                          doItemHeaderClick({ name, expanded: false, event });
                      }
                      else {
                          activeNames.push(name);
                          doUpdateExpandedNames(activeNames);
                          doItemHeaderClick({ name, expanded: true, event });
                      }
                  }
              }
          }
          provide(collapseInjectionKey, {
              props,
              mergedClsPrefixRef,
              expandedNamesRef: mergedExpandedNamesRef,
              slots,
              toggleItem
          });
          const rtlEnabledRef = useRtl('Collapse', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { titleFontWeight, dividerColor, titlePadding, titleTextColor, titleTextColorDisabled, textColor, arrowColor, fontSize, titleFontSize, arrowColorDisabled, itemMargin } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-divider-color': dividerColor,
                  '--n-title-padding': titlePadding,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-text-color': titleTextColor,
                  '--n-title-text-color-disabled': titleTextColorDisabled,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-arrow-color': arrowColor,
                  '--n-arrow-color-disabled': arrowColorDisabled,
                  '--n-item-margin': itemMargin
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('collapse', undefined, cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedTheme: themeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [
                  `${this.mergedClsPrefix}-collapse`,
                  this.rtlEnabled && `${this.mergedClsPrefix}-collapse--rtl`,
                  this.themeClass
              ], style: this.cssVars }, this.$slots));
      }
  });

  var NCollapseItemContent = defineComponent({
      name: 'CollapseItemContent',
      props: {
          displayDirective: {
              type: String,
              required: true
          },
          show: Boolean,
          clsPrefix: {
              type: String,
              required: true
          }
      },
      setup(props) {
          const onceTrueRef = useFalseUntilTruthy(toRef(props, 'show'));
          return {
              onceTrue: onceTrueRef
          };
      },
      render() {
          return (h(NFadeInExpandTransition, null, {
              default: () => {
                  const { show, displayDirective, onceTrue, clsPrefix } = this;
                  const useVShow = displayDirective === 'show' && onceTrue;
                  const contentNode = (h("div", { class: `${clsPrefix}-collapse-item__content-wrapper` },
                      h("div", { class: `${clsPrefix}-collapse-item__content-inner` }, this.$slots)));
                  return useVShow
                      ? withDirectives(contentNode, [[vShow, show]])
                      : show
                          ? contentNode
                          : null;
              }
          }));
      }
  });

  const collapseItemProps = {
      title: String,
      name: [String, Number],
      disabled: Boolean,
      displayDirective: String
  };
  var NCollapseItem = defineComponent({
      name: 'CollapseItem',
      props: collapseItemProps,
      setup(props) {
          const { mergedRtlRef } = useConfig(props);
          const randomName = createId();
          const mergedNameRef = useMemo(() => {
              var _a;
              return (_a = props.name) !== null && _a !== void 0 ? _a : randomName;
          });
          const NCollapse = inject(collapseInjectionKey);
          if (!NCollapse) {
              throwError('collapse-item', '`n-collapse-item` must be placed inside `n-collapse`.');
          }
          const { expandedNamesRef, props: collapseProps, mergedClsPrefixRef, slots: collapseSlots } = NCollapse;
          const collapsedRef = computed(() => {
              const { value: expandedNames } = expandedNamesRef;
              if (Array.isArray(expandedNames)) {
                  const { value: name } = mergedNameRef;
                  return !~expandedNames.findIndex((expandedName) => expandedName === name);
              }
              else if (expandedNames) {
                  const { value: name } = mergedNameRef;
                  return name !== expandedNames;
              }
              return true;
          });
          const rtlEnabledRef = useRtl('Collapse', mergedRtlRef, mergedClsPrefixRef);
          return {
              rtlEnabled: rtlEnabledRef,
              collapseSlots,
              randomName,
              mergedClsPrefix: mergedClsPrefixRef,
              collapsed: collapsedRef,
              mergedDisplayDirective: computed(() => {
                  const { displayDirective } = props;
                  if (displayDirective) {
                      return displayDirective;
                  }
                  else {
                      return collapseProps.displayDirective;
                  }
              }),
              arrowPlacement: computed(() => {
                  return collapseProps.arrowPlacement;
              }),
              handleClick(e) {
                  if (NCollapse && !props.disabled) {
                      NCollapse.toggleItem(collapsedRef.value, mergedNameRef.value, e);
                  }
              }
          };
      },
      render() {
          const { collapseSlots, $slots, arrowPlacement, collapsed, mergedDisplayDirective, mergedClsPrefix, disabled } = this;
          const headerNode = resolveSlotWithProps($slots.header, { collapsed }, () => [this.title]);
          const headerExtraSlot = $slots['header-extra'] || collapseSlots['header-extra'];
          const arrowSlot = $slots.arrow || collapseSlots.arrow;
          return (h("div", { class: [
                  `${mergedClsPrefix}-collapse-item`,
                  `${mergedClsPrefix}-collapse-item--${arrowPlacement}-arrow-placement`,
                  disabled && `${mergedClsPrefix}-collapse-item--disabled`,
                  !collapsed && `${mergedClsPrefix}-collapse-item--active`
              ] },
              h("div", { class: [
                      `${mergedClsPrefix}-collapse-item__header`,
                      !collapsed && `${mergedClsPrefix}-collapse-item__header--active`
                  ] },
                  h("div", { class: `${mergedClsPrefix}-collapse-item__header-main`, onClick: this.handleClick },
                      arrowPlacement === 'right' && headerNode,
                      h("div", { class: `${mergedClsPrefix}-collapse-item-arrow`, key: this.rtlEnabled ? 0 : 1 }, resolveSlotWithProps(arrowSlot, { collapsed }, () => {
                          var _a;
                          return [
                              h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                  default: (_a = collapseSlots.expandIcon) !== null && _a !== void 0 ? _a : (() => this.rtlEnabled ? (h(ChevronLeftIcon, null)) : (h(ChevronRightIcon, null)))
                              })
                          ];
                      })),
                      arrowPlacement === 'left' && headerNode),
                  resolveWrappedSlotWithProps(headerExtraSlot, { collapsed }, (children) => (h("div", { class: `${mergedClsPrefix}-collapse-item__header-extra`, onClick: this.handleClick }, children)))),
              h(NCollapseItemContent, { clsPrefix: mergedClsPrefix, displayDirective: mergedDisplayDirective, show: !collapsed }, $slots)));
      }
  });

  var style$12 = cB('collapse-transition', {
    width: '100%'
  }, [fadeInHeightExpandTransition()]);

  const self$S = (vars) => {
      const { cubicBezierEaseInOut } = vars;
      return {
          bezier: cubicBezierEaseInOut
      };
  };
  const collapseTransitionLight = {
      name: 'CollapseTransition',
      common: commonLight,
      self: self$S
  };
  var collapseTransitionLight$1 = collapseTransitionLight;

  const collapseTransitionProps = Object.assign(Object.assign({}, useTheme.props), { show: {
          type: Boolean,
          default: true
      }, appear: Boolean, 
      // The collapsed is implemented with mistake, collapsed=true would make it show
      // However there's no possibility to change so I just let it deprecated and use
      // `show` prop instead.
      /** @deprecated */
      collapsed: {
          type: Boolean,
          default: undefined
      } });
  var CollapseTransition = defineComponent({
      name: 'CollapseTransition',
      props: collapseTransitionProps,
      inheritAttrs: false,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const mergedThemeRef = useTheme('CollapseTransition', '-collapse-transition', style$12, collapseTransitionLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('CollapseTransition', mergedRtlRef, mergedClsPrefixRef);
          const mergedShowRef = computed(() => {
              if (props.collapsed !== undefined) {
                  // No mistake, it's implemented with error at first, just keep it here
                  return props.collapsed;
              }
              return props.show;
          });
          const cssVarsRef = computed(() => {
              const { self: { bezier } } = mergedThemeRef.value;
              return {
                  '--n-bezier': bezier
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('collapse-transition', undefined, cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedShow: mergedShowRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          return (h(NFadeInExpandTransition, { appear: this.appear }, {
              default: () => {
                  var _a;
                  if (!this.mergedShow)
                      return;
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  return h('div', // Don't use jsx since it would cause useless spread in each rendering
                  mergeProps({
                      class: [
                          `${this.mergedClsPrefix}-collapse-transition`,
                          this.rtlEnabled &&
                              `${this.mergedClsPrefix}-collapse-transition--rtl`,
                          this.themeClass
                      ],
                      style: this.cssVars
                  }, this.$attrs), this.$slots);
              }
          }));
      }
  });

  const configProviderProps = {
      abstract: Boolean,
      bordered: {
          type: Boolean,
          default: undefined
      },
      clsPrefix: { type: String, default: defaultClsPrefix },
      locale: Object,
      dateLocale: Object,
      namespace: String,
      rtl: Array,
      tag: {
          type: String,
          default: 'div'
      },
      hljs: Object,
      katex: Object,
      theme: Object,
      themeOverrides: Object,
      componentOptions: Object,
      icons: Object,
      breakpoints: Object,
      preflightStyleDisabled: Boolean,
      inlineThemeDisabled: {
          type: Boolean,
          default: undefined
      },
      // deprecated
      as: {
          type: String,
          validator: () => {
              warn$2('config-provider', '`as` is deprecated, please use `tag` instead.');
              return true;
          },
          default: undefined
      }
  };
  var NConfigProvider = defineComponent({
      name: 'ConfigProvider',
      alias: ['App'],
      props: configProviderProps,
      setup(props) {
          const NConfigProvider = inject(configProviderInjectionKey, null);
          const mergedThemeRef = computed(() => {
              const { theme } = props;
              if (theme === null)
                  return undefined;
              const inheritedTheme = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeRef.value;
              return theme === undefined
                  ? inheritedTheme
                  : inheritedTheme === undefined
                      ? theme
                      : Object.assign({}, inheritedTheme, theme);
          });
          const mergedThemeOverridesRef = computed(() => {
              const { themeOverrides } = props;
              // stop inheriting themeOverrides
              if (themeOverrides === null)
                  return undefined;
              // use inherited themeOverrides
              if (themeOverrides === undefined) {
                  return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
              }
              else {
                  const inheritedThemeOverrides = NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedThemeOverridesRef.value;
                  if (inheritedThemeOverrides === undefined) {
                      // no inherited, use self overrides
                      return themeOverrides;
                  }
                  else {
                      // merge overrides
                      return merge$2({}, inheritedThemeOverrides, themeOverrides);
                  }
              }
          });
          const mergedNamespaceRef = useMemo(() => {
              const { namespace } = props;
              return namespace === undefined
                  ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedNamespaceRef.value
                  : namespace;
          });
          const mergedBorderedRef = useMemo(() => {
              const { bordered } = props;
              return bordered === undefined
                  ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBorderedRef.value
                  : bordered;
          });
          const mergedIconsRef = computed(() => {
              const { icons } = props;
              return icons === undefined ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedIconsRef.value : icons;
          });
          const mergedComponentPropsRef = computed(() => {
              const { componentOptions } = props;
              if (componentOptions !== undefined)
                  return componentOptions;
              return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedComponentPropsRef.value;
          });
          const mergedClsPrefixRef = computed(() => {
              const { clsPrefix } = props;
              if (clsPrefix !== undefined)
                  return clsPrefix;
              if (NConfigProvider)
                  return NConfigProvider.mergedClsPrefixRef.value;
              return defaultClsPrefix;
          });
          const mergedRtlRef = computed(() => {
              var _a;
              const { rtl } = props;
              if (rtl === undefined) {
                  return NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedRtlRef.value;
              }
              const rtlEnabledState = {};
              for (const rtlInfo of rtl) {
                  rtlEnabledState[rtlInfo.name] = markRaw(rtlInfo);
                  (_a = rtlInfo.peers) === null || _a === void 0 ? void 0 : _a.forEach((peerRtlInfo) => {
                      if (!(peerRtlInfo.name in rtlEnabledState)) {
                          rtlEnabledState[peerRtlInfo.name] = markRaw(peerRtlInfo);
                      }
                  });
              }
              return rtlEnabledState;
          });
          const mergedBreakpointsRef = computed(() => {
              return props.breakpoints || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedBreakpointsRef.value);
          });
          const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.inlineThemeDisabled);
          const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.preflightStyleDisabled);
          const mergedThemeHashRef = computed(() => {
              const { value: theme } = mergedThemeRef;
              const { value: mergedThemeOverrides } = mergedThemeOverridesRef;
              const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
              const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
              if (themeName) {
                  if (hasThemeOverrides) {
                      return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
                  }
                  return themeName;
              }
              else {
                  if (hasThemeOverrides) {
                      return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
                  }
                  return '';
              }
          });
          provide(configProviderInjectionKey, {
              mergedThemeHashRef,
              mergedBreakpointsRef,
              mergedRtlRef,
              mergedIconsRef,
              mergedComponentPropsRef,
              mergedBorderedRef,
              mergedNamespaceRef,
              mergedClsPrefixRef,
              mergedLocaleRef: computed(() => {
                  const { locale } = props;
                  if (locale === null)
                      return undefined;
                  return locale === undefined
                      ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedLocaleRef.value
                      : locale;
              }),
              mergedDateLocaleRef: computed(() => {
                  const { dateLocale } = props;
                  if (dateLocale === null)
                      return undefined;
                  return dateLocale === undefined
                      ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedDateLocaleRef.value
                      : dateLocale;
              }),
              mergedHljsRef: computed(() => {
                  const { hljs } = props;
                  return hljs === undefined ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedHljsRef.value : hljs;
              }),
              mergedKatexRef: computed(() => {
                  const { katex } = props;
                  return katex === undefined
                      ? NConfigProvider === null || NConfigProvider === void 0 ? void 0 : NConfigProvider.mergedKatexRef.value
                      : katex;
              }),
              mergedThemeRef,
              mergedThemeOverridesRef,
              inlineThemeDisabled: inlineThemeDisabled || false,
              preflightStyleDisabled: preflightStyleDisabled || false
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedBordered: mergedBorderedRef,
              mergedNamespace: mergedNamespaceRef,
              mergedTheme: mergedThemeRef,
              mergedThemeOverrides: mergedThemeOverridesRef
          };
      },
      render() {
          var _a, _b, _c, _d;
          return !this.abstract
              ? h(this.as || this.tag, {
                  class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
              }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
              : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
      }
  });

  const countdownProps = {
      duration: {
          type: Number,
          default: 0
      },
      active: {
          type: Boolean,
          default: true
      },
      precision: {
          type: Number,
          default: 0
      },
      render: Function,
      onFinish: Function
  };
  var Countdown = defineComponent({
      name: 'Countdown',
      props: countdownProps,
      setup(props) {
          let timerId = null;
          let elapsed = 0;
          let finished = false;
          // in ms
          const distanceRef = ref(0);
          watchEffect(() => {
              distanceRef.value = props.duration;
          });
          let pnow = -1;
          function getDistance(time) {
              return props.duration - elapsed + pnow - time;
          }
          function getTimeInfo(distance) {
              const hours = Math.floor(distance / 3600000);
              const minutes = Math.floor((distance % 3600000) / 60000);
              const seconds = Math.floor((distance % 60000) / 1000);
              const milliseconds = Math.floor(distance % 1000);
              return {
                  hours,
                  minutes,
                  seconds,
                  milliseconds
              };
          }
          function getDisplayValue(info) {
              const { hours, minutes, seconds, milliseconds } = info;
              const { precision } = props;
              switch (precision) {
                  case 0:
                      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                  default:
                      return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(Math.floor(milliseconds / (precision === 1 ? 100 : precision === 2 ? 10 : 1))).padStart(precision, '0')}`;
              }
          }
          const frame = () => {
              var _a;
              const { precision } = props;
              const distance = getDistance(performance.now());
              if (distance <= 0) {
                  distanceRef.value = 0;
                  stopTimer();
                  if (!finished) {
                      finished = true;
                      (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
                  }
                  return;
              }
              let leftTime;
              switch (precision) {
                  case 3:
                  case 2:
                      leftTime = distance % 34; // about 30 fps
                      break;
                  case 1:
                      leftTime = distance % 100;
                      break;
                  default:
                      leftTime = distance % 1000;
              }
              distanceRef.value = distance;
              timerId = window.setTimeout(() => {
                  frame();
              }, leftTime);
          };
          const stopTimer = () => {
              if (timerId !== null) {
                  window.clearTimeout(timerId);
                  timerId = null;
              }
          };
          onMounted(() => {
              watchEffect(() => {
                  if (props.active) {
                      pnow = performance.now();
                      frame();
                  }
                  else {
                      const now = performance.now();
                      if (pnow !== -1) {
                          elapsed += now - pnow;
                      }
                      stopTimer();
                  }
              });
          });
          onBeforeUnmount(() => {
              stopTimer();
          });
          function reset() {
              distanceRef.value = props.duration;
              elapsed = 0;
              pnow = performance.now();
              if (props.active && finished) {
                  frame();
              }
              finished = false;
          }
          const countdownExposedMethod = {
              reset
          };
          return Object.assign(countdownExposedMethod, {
              distance: distanceRef,
              getTimeInfo,
              getDisplayValue
          });
      },
      render() {
          const { render, precision, distance, getTimeInfo, getDisplayValue } = this;
          let timeInfo;
          switch (precision) {
              case 0:
                  timeInfo = getTimeInfo(distance + 999);
                  timeInfo.milliseconds = 0;
                  break;
              case 1:
                  timeInfo = getTimeInfo(distance + 99);
                  timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 100) * 100;
                  break;
              case 2:
                  timeInfo = getTimeInfo(distance + 9);
                  timeInfo.milliseconds = Math.floor(timeInfo.milliseconds / 10) * 10;
                  break;
              case 3:
                  timeInfo = getTimeInfo(distance);
          }
          if (render) {
              return render(timeInfo);
          }
          else {
              return getDisplayValue(timeInfo);
          }
      }
  });

  const easeOut = (t) => 1 - Math.pow(1 - t, 5);
  function tween(props) {
      const { from, to, duration, onUpdate, onFinish } = props;
      const tick = () => {
          const current = performance.now();
          const elapsedTime = Math.min(current - startTime, duration);
          const currentValue = from + (to - from) * easeOut(elapsedTime / duration);
          if (elapsedTime === duration) {
              onFinish();
              return;
          }
          onUpdate(currentValue);
          requestAnimationFrame(tick);
      };
      const startTime = performance.now();
      tick();
  }

  const numberAnimationProps = {
      to: {
          type: Number,
          default: 0
      },
      precision: {
          type: Number,
          default: 0
      },
      showSeparator: Boolean,
      locale: String,
      from: { type: Number, default: 0 },
      active: {
          type: Boolean,
          default: true
      },
      duration: {
          type: Number,
          default: 2000
      },
      onFinish: Function
  };
  var NumberAnimation = defineComponent({
      name: 'NumberAnimation',
      props: numberAnimationProps,
      setup(props) {
          const { localeRef } = useLocale('name');
          const { duration } = props;
          const displayedValueRef = ref(props.from);
          const mergedLocaleRef = computed(() => {
              const { locale } = props;
              if (locale !== undefined)
                  return locale;
              return localeRef.value;
          });
          let animating = false;
          const onUpdate = (currentValue) => {
              displayedValueRef.value = currentValue;
          };
          const onFinish = () => {
              var _a;
              displayedValueRef.value = props.to;
              animating = false;
              (_a = props.onFinish) === null || _a === void 0 ? void 0 : _a.call(props);
          };
          const animate = (from = props.from, to = props.to) => {
              animating = true;
              displayedValueRef.value = props.from;
              if (from !== to) {
                  tween({
                      from,
                      to,
                      duration,
                      onUpdate,
                      onFinish
                  });
              }
          };
          const formattedValueRef = computed(() => {
              var _a;
              const formatted = round$1(displayedValueRef.value, props.precision).toFixed(props.precision);
              const splitValue = formatted.split('.');
              const numberFormatter = new Intl.NumberFormat(mergedLocaleRef.value);
              const decimalSeparator = (_a = numberFormatter
                  .formatToParts(0.5)
                  .find((part) => part.type === 'decimal')) === null || _a === void 0 ? void 0 : _a.value;
              const integer = props.showSeparator
                  ? numberFormatter.format(Number(splitValue[0]))
                  : splitValue[0];
              const decimal = splitValue[1];
              return {
                  integer,
                  decimal,
                  decimalSeparator
              };
          });
          function play() {
              if (animating)
                  return;
              animate();
          }
          onMounted(() => {
              watchEffect(() => {
                  if (props.active)
                      animate();
              });
          });
          const exposedMethods = { play };
          return Object.assign({ formattedValue: formattedValueRef }, exposedMethods);
      },
      render() {
          const { formattedValue: { integer, decimal, decimalSeparator } } = this;
          return [integer, decimal ? decimalSeparator : null, decimal];
      }
  });

  function self$R(vars) {
      const { boxShadow2 } = vars;
      return {
          menuBoxShadow: boxShadow2
      };
  }
  const popselectLight = createTheme({
      name: 'Popselect',
      common: commonLight,
      peers: {
          Popover: popoverLight$1,
          InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$R
  });
  var popselectLight$1 = popselectLight;

  const popselectInjectionKey = createInjectionKey('n-popselect');

  // --n-menu-box-shadow
  var style$11 = cB('popselect-menu', `
 box-shadow: var(--n-menu-box-shadow);
`);

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const panelProps$1 = {
      multiple: Boolean,
      value: {
          type: [String, Number, Array],
          default: null
      },
      cancelable: Boolean,
      options: {
          type: Array,
          default: () => []
      },
      size: {
          type: String,
          default: 'medium'
      },
      scrollable: Boolean,
      'onUpdate:value': [Function, Array],
      onUpdateValue: [Function, Array],
      onMouseenter: Function,
      onMouseleave: Function,
      renderLabel: Function,
      showCheckmark: {
          type: Boolean,
          default: undefined
      },
      nodeProps: Function,
      virtualScroll: Boolean,
      // deprecated
      onChange: [Function, Array]
  };
  const panelPropKeys$1 = keysOf(panelProps$1);
  var NPopselectPanel = defineComponent({
      name: 'PopselectPanel',
      props: panelProps$1,
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NPopselect = inject(popselectInjectionKey);
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Popselect', '-pop-select', style$11, popselectLight$1, NPopselect.props, mergedClsPrefixRef);
          const treeMateRef = computed(() => {
              return createTreeMate(props.options, createTmOptions('value', 'children'));
          });
          function doUpdateValue(value, option) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
              if (onUpdateValue)
                  call(onUpdateValue, value, option);
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, option);
              }
              if (onChange)
                  call(onChange, value, option);
          }
          function handleToggle(tmNode) {
              toggle(tmNode.key);
          }
          function handleMenuMousedown(e) {
              if (!happensIn(e, 'action'))
                  e.preventDefault();
          }
          function toggle(value) {
              const { value: { getNode } } = treeMateRef;
              if (props.multiple) {
                  if (Array.isArray(props.value)) {
                      const newValue = [];
                      const newOptions = [];
                      let shouldAddValue = true;
                      props.value.forEach((v) => {
                          if (v === value) {
                              shouldAddValue = false;
                              return;
                          }
                          const tmNode = getNode(v);
                          if (tmNode) {
                              newValue.push(tmNode.key);
                              newOptions.push(tmNode.rawNode);
                          }
                      });
                      if (shouldAddValue) {
                          newValue.push(value);
                          newOptions.push(getNode(value).rawNode);
                      }
                      doUpdateValue(newValue, newOptions);
                  }
                  else {
                      const tmNode = getNode(value);
                      if (tmNode) {
                          doUpdateValue([value], [tmNode.rawNode]);
                      }
                  }
              }
              else {
                  if (props.value === value && props.cancelable) {
                      doUpdateValue(null, null);
                  }
                  else {
                      const tmNode = getNode(value);
                      if (tmNode) {
                          doUpdateValue(value, tmNode.rawNode);
                      }
                      const { 'onUpdate:show': _onUpdateShow, onUpdateShow } = NPopselect.props;
                      if (_onUpdateShow)
                          call(_onUpdateShow, false);
                      if (onUpdateShow)
                          call(onUpdateShow, false);
                      NPopselect.setShow(false);
                  }
              }
              void nextTick(() => {
                  NPopselect.syncPosition();
              });
          }
          watch(toRef(props, 'options'), () => {
              void nextTick(() => {
                  NPopselect.syncPosition();
              });
          });
          const cssVarsRef = computed(() => {
              const { self: { menuBoxShadow } } = themeRef.value;
              return {
                  '--n-menu-box-shadow': menuBoxShadow
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('select', undefined, cssVarsRef, NPopselect.props)
              : undefined;
          return {
              mergedTheme: NPopselect.mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              treeMate: treeMateRef,
              handleToggle,
              handleMenuMousedown,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h(NInternalSelectMenu, { clsPrefix: this.mergedClsPrefix, focusable: true, nodeProps: this.nodeProps, class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass], style: this.cssVars, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu, multiple: this.multiple, treeMate: this.treeMate, size: this.size, value: this.value, virtualScroll: this.virtualScroll, scrollable: this.scrollable, renderLabel: this.renderLabel, onToggle: this.handleToggle, onMouseenter: this.onMouseenter, onMouseleave: this.onMouseenter, onMousedown: this.handleMenuMousedown, showCheckmark: this.showCheckmark }, {
              header: () => { var _a, _b; return ((_b = (_a = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a)) || []; },
              action: () => { var _a, _b; return ((_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a)) || []; },
              empty: () => { var _a, _b; return ((_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)) || []; }
          }));
      }
  });

  const popselectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), omit(popoverBaseProps, ['showArrow', 'arrow'])), { placement: Object.assign(Object.assign({}, popoverBaseProps.placement), { default: 'bottom' }), trigger: {
          type: String,
          default: 'hover'
      } }), panelProps$1);
  var NPopselect = defineComponent({
      name: 'Popselect',
      props: popselectProps,
      inheritAttrs: false,
      __popover__: true,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Popselect', '-popselect', undefined, popselectLight$1, props, mergedClsPrefixRef);
          const popoverInstRef = ref(null);
          function syncPosition() {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function setShow(value) {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
          }
          provide(popselectInjectionKey, {
              props,
              mergedThemeRef: themeRef,
              syncPosition,
              setShow
          });
          const exposedMethods = {
              syncPosition,
              setShow
          };
          return Object.assign(Object.assign({}, exposedMethods), { popoverInstRef, mergedTheme: themeRef });
      },
      render() {
          const { mergedTheme } = this;
          const popoverProps = {
              theme: mergedTheme.peers.Popover,
              themeOverrides: mergedTheme.peerOverrides.Popover,
              builtinThemeOverrides: {
                  padding: '0'
              },
              ref: 'popoverInstRef',
              internalRenderBody: (className, ref, style, onMouseenter, onMouseleave) => {
                  const { $attrs } = this;
                  return (h(NPopselectPanel, Object.assign({}, $attrs, { class: [$attrs.class, className], style: [$attrs.style, ...style] }, keep(this.$props, panelPropKeys$1), { ref: createRefSetter(ref), onMouseenter: mergeEventHandlers([
                          onMouseenter,
                          $attrs.onMouseenter
                      ]), onMouseleave: mergeEventHandlers([
                          onMouseleave,
                          $attrs.onMouseleave
                      ]) }), {
                      header: () => { var _a, _b; return (_b = (_a = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a); },
                      action: () => { var _a, _b; return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a); },
                      empty: () => { var _a, _b; return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a); }
                  }));
              }
          };
          return (h(NPopover, Object.assign({}, omit(this.$props, panelPropKeys$1), popoverProps, { internalDeactivateImmediately: true }), {
              trigger: () => { var _a, _b; return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a); }
          }));
      }
  });

  function self$Q(vars) {
      const { boxShadow2 } = vars;
      return {
          menuBoxShadow: boxShadow2
      };
  }
  const selectLight = createTheme({
      name: 'Select',
      common: commonLight,
      peers: {
          InternalSelection: internalSelectionLight$1,
          InternalSelectMenu: internalSelectMenuLight$1
      },
      self: self$Q
  });
  var selectLight$1 = selectLight;

  // --n-menu-box-shadow
  var style$10 = c$1([cB('select', `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB('select-menu', `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: 'background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)'
  })])]);

  const selectProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, bordered: {
          type: Boolean,
          default: undefined
      }, clearable: Boolean, clearFilterAfterSelect: {
          type: Boolean,
          default: true
      }, options: {
          type: Array,
          default: () => []
      }, defaultValue: {
          type: [String, Number, Array],
          default: null
      }, keyboard: {
          type: Boolean,
          default: true
      }, value: [String, Number, Array], placeholder: String, menuProps: Object, multiple: Boolean, size: String, filterable: Boolean, disabled: {
          type: Boolean,
          default: undefined
      }, remote: Boolean, loading: Boolean, filter: Function, placement: {
          type: String,
          default: 'bottom-start'
      }, widthMode: {
          type: String,
          default: 'trigger'
      }, tag: Boolean, onCreate: Function, fallbackOption: {
          type: [Function, Boolean],
          default: undefined
      }, show: {
          type: Boolean,
          default: undefined
      }, showArrow: {
          type: Boolean,
          default: true
      }, maxTagCount: [Number, String], consistentMenuWidth: {
          type: Boolean,
          default: true
      }, virtualScroll: {
          type: Boolean,
          default: true
      }, labelField: {
          type: String,
          default: 'label'
      }, valueField: {
          type: String,
          default: 'value'
      }, childrenField: {
          type: String,
          default: 'children'
      }, renderLabel: Function, renderOption: Function, renderTag: Function, 'onUpdate:value': [Function, Array], inputProps: Object, nodeProps: Function, ignoreComposition: { type: Boolean, default: true }, showOnFocus: Boolean, 
      // for jsx
      onUpdateValue: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], onFocus: [Function, Array], onScroll: [Function, Array], onSearch: [Function, Array], onUpdateShow: [Function, Array], 'onUpdate:show': [Function, Array], displayDirective: {
          type: String,
          default: 'show'
      }, resetMenuOnOptionsChange: {
          type: Boolean,
          default: true
      }, status: String, showCheckmark: {
          type: Boolean,
          default: true
      }, 
      /** deprecated */
      onChange: [Function, Array], items: Array });
  var NSelect = defineComponent({
      name: 'Select',
      props: selectProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedBorderedRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Select', '-select', style$10, selectLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const focusedRef = ref(false);
          const patternRef = ref('');
          const treeMateRef = computed(() => {
              const { valueField, childrenField } = props;
              const options = createTmOptions(valueField, childrenField);
              return createTreeMate(filteredOptionsRef.value, options);
          });
          const valOptMapRef = computed(() => createValOptMap(localOptionsRef.value, props.valueField, props.childrenField));
          const uncontrolledShowRef = ref(false);
          const mergedShowRef = useMergedState(toRef(props, 'show'), uncontrolledShowRef);
          const triggerRef = ref(null);
          const followerRef = ref(null);
          const menuRef = ref(null);
          const { localeRef } = useLocale('Select');
          const localizedPlaceholderRef = computed(() => {
              var _a;
              return (_a = props.placeholder) !== null && _a !== void 0 ? _a : localeRef.value.placeholder;
          });
          const compitableOptionsRef = useCompitable(props, ['items', 'options']);
          const emptyArray = [];
          const createdOptionsRef = ref([]);
          const beingCreatedOptionsRef = ref([]);
          const memoValOptMapRef = ref(new Map());
          const wrappedFallbackOptionRef = computed(() => {
              const { fallbackOption } = props;
              if (fallbackOption === undefined) {
                  const { labelField, valueField } = props;
                  return (value) => ({
                      [labelField]: String(value),
                      [valueField]: value
                  });
              }
              if (fallbackOption === false)
                  return false;
              return (value) => {
                  return Object.assign(fallbackOption(value), {
                      value
                  });
              };
          });
          const localOptionsRef = computed(() => {
              return beingCreatedOptionsRef.value.concat(createdOptionsRef.value).concat(compitableOptionsRef.value);
          });
          const resolvedFilterRef = computed(() => {
              const { filter } = props;
              if (filter)
                  return filter;
              const { labelField, valueField } = props;
              return (pattern, option) => {
                  if (!option)
                      return false;
                  const label = option[labelField];
                  if (typeof label === 'string') {
                      return patternMatched(pattern, label);
                  }
                  const value = option[valueField];
                  if (typeof value === 'string') {
                      return patternMatched(pattern, value);
                  }
                  if (typeof value === 'number') {
                      return patternMatched(pattern, String(value));
                  }
                  return false;
              };
          });
          const filteredOptionsRef = computed(() => {
              if (props.remote) {
                  return compitableOptionsRef.value;
              }
              else {
                  const { value: localOptions } = localOptionsRef;
                  const { value: pattern } = patternRef;
                  if (!pattern.length || !props.filterable) {
                      return localOptions;
                  }
                  else {
                      return filterOptions(localOptions, resolvedFilterRef.value, pattern, props.childrenField);
                  }
              }
          });
          function getMergedOptions(values) {
              const remote = props.remote;
              const { value: memoValOptMap } = memoValOptMapRef;
              const { value: valOptMap } = valOptMapRef;
              const { value: wrappedFallbackOption } = wrappedFallbackOptionRef;
              const options = [];
              values.forEach((value) => {
                  if (valOptMap.has(value)) {
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      options.push(valOptMap.get(value));
                  }
                  else if (remote && memoValOptMap.has(value)) {
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      options.push(memoValOptMap.get(value));
                  }
                  else if (wrappedFallbackOption) {
                      const option = wrappedFallbackOption(value);
                      if (option) {
                          options.push(option);
                      }
                  }
              });
              return options;
          }
          const selectedOptionsRef = computed(() => {
              if (props.multiple) {
                  const { value: values } = mergedValueRef;
                  if (!Array.isArray(values))
                      return [];
                  return getMergedOptions(values);
              }
              return null;
          });
          const selectedOptionRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (!props.multiple && !Array.isArray(mergedValue)) {
                  if (mergedValue === null)
                      return null;
                  return getMergedOptions([mergedValue])[0] || null;
              }
              return null;
          });
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          function doUpdateValue(value, option) {
              const { onChange, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              if (onChange)
                  call(onChange, value, option);
              if (onUpdateValue)
                  call(onUpdateValue, value, option);
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, option);
              }
              uncontrolledValueRef.value = value;
              nTriggerFormChange();
              nTriggerFormInput();
          }
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doClear() {
              const { onClear } = props;
              if (onClear)
                  call(onClear);
          }
          function doFocus(e) {
              const { onFocus, showOnFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
              if (showOnFocus) {
                  openMenu();
              }
          }
          function doSearch(value) {
              const { onSearch } = props;
              if (onSearch)
                  call(onSearch, value);
          }
          function doScroll(e) {
              const { onScroll } = props;
              if (onScroll)
                  call(onScroll, e);
          }
          // remote related methods
          function updateMemorizedOptions() {
              var _a;
              const { remote, multiple } = props;
              if (remote) {
                  const { value: memoValOptMap } = memoValOptMapRef;
                  if (multiple) {
                      const { valueField } = props;
                      (_a = selectedOptionsRef.value) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
                          memoValOptMap.set(option[valueField], option);
                      });
                  }
                  else {
                      const option = selectedOptionRef.value;
                      if (option) {
                          memoValOptMap.set(option[props.valueField], option);
                      }
                  }
              }
          }
          // menu related methods
          function doUpdateShow(value) {
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, value);
              if (_onUpdateShow)
                  call(_onUpdateShow, value);
              uncontrolledShowRef.value = value;
          }
          function openMenu() {
              if (!mergedDisabledRef.value) {
                  doUpdateShow(true);
                  uncontrolledShowRef.value = true;
                  if (props.filterable) {
                      focusSelectionInput();
                  }
              }
          }
          function closeMenu() {
              doUpdateShow(false);
          }
          function handleMenuAfterLeave() {
              patternRef.value = '';
              beingCreatedOptionsRef.value = emptyArray;
          }
          const activeWithoutMenuOpenRef = ref(false);
          function onTriggerInputFocus() {
              if (props.filterable) {
                  activeWithoutMenuOpenRef.value = true;
              }
          }
          function onTriggerInputBlur() {
              if (props.filterable) {
                  activeWithoutMenuOpenRef.value = false;
                  if (!mergedShowRef.value) {
                      handleMenuAfterLeave();
                  }
              }
          }
          function handleTriggerClick() {
              if (mergedDisabledRef.value)
                  return;
              if (!mergedShowRef.value) {
                  openMenu();
              }
              else {
                  if (!props.filterable) {
                      // already focused, don't need to return focus
                      closeMenu();
                  }
                  else {
                      focusSelectionInput();
                  }
              }
          }
          function handleTriggerBlur(e) {
              var _a, _b;
              if ((_b = (_a = menuRef.value) === null || _a === void 0 ? void 0 : _a.selfRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) {
                  return;
              }
              focusedRef.value = false;
              doBlur(e);
              // outside select, don't need to return focus
              closeMenu();
          }
          function handleTriggerFocus(e) {
              doFocus(e);
              focusedRef.value = true;
          }
          function handleMenuFocus(e) {
              focusedRef.value = true;
          }
          function handleMenuBlur(e) {
              var _a;
              if ((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))
                  return;
              focusedRef.value = false;
              doBlur(e);
              // outside select, don't need to return focus
              closeMenu();
          }
          function handleMenuTabOut() {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              closeMenu();
          }
          function handleMenuClickOutside(e) {
              var _a;
              if (mergedShowRef.value) {
                  if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                      // outside select, don't need to return focus
                      closeMenu();
                  }
              }
          }
          function createClearedMultipleSelectValue(value) {
              if (!Array.isArray(value))
                  return [];
              if (wrappedFallbackOptionRef.value) {
                  // if option has a fallback, I can't help user to clear some unknown value
                  return Array.from(value);
              }
              else {
                  // if there's no option fallback, unappeared options are treated as invalid
                  const { remote } = props;
                  const { value: valOptMap } = valOptMapRef;
                  if (remote) {
                      const { value: memoValOptMap } = memoValOptMapRef;
                      return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
                  }
                  else {
                      return value.filter((v) => valOptMap.has(v));
                  }
              }
          }
          function handleToggleByTmNode(tmNode) {
              handleToggleByOption(tmNode.rawNode);
          }
          function handleToggleByOption(option) {
              if (mergedDisabledRef.value)
                  return;
              const { tag, remote, clearFilterAfterSelect, valueField } = props;
              if (tag && !remote) {
                  const { value: beingCreatedOptions } = beingCreatedOptionsRef;
                  const beingCreatedOption = beingCreatedOptions[0] || null;
                  if (beingCreatedOption) {
                      const createdOptions = createdOptionsRef.value;
                      if (!createdOptions.length) {
                          createdOptionsRef.value = [beingCreatedOption];
                      }
                      else {
                          createdOptions.push(beingCreatedOption);
                      }
                      beingCreatedOptionsRef.value = emptyArray;
                  }
              }
              if (remote) {
                  memoValOptMapRef.value.set(option[valueField], option);
              }
              if (props.multiple) {
                  const changedValue = createClearedMultipleSelectValue(mergedValueRef.value);
                  const index = changedValue.findIndex((value) => value === option[valueField]);
                  if (~index) {
                      changedValue.splice(index, 1);
                      if (tag && !remote) {
                          const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                          if (~createdOptionIndex) {
                              createdOptionsRef.value.splice(createdOptionIndex, 1);
                              if (clearFilterAfterSelect)
                                  patternRef.value = '';
                          }
                      }
                  }
                  else {
                      changedValue.push(option[valueField]);
                      if (clearFilterAfterSelect)
                          patternRef.value = '';
                  }
                  doUpdateValue(changedValue, getMergedOptions(changedValue));
              }
              else {
                  if (tag && !remote) {
                      const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                      if (~createdOptionIndex) {
                          createdOptionsRef.value = [
                              createdOptionsRef.value[createdOptionIndex]
                          ];
                      }
                      else {
                          createdOptionsRef.value = emptyArray;
                      }
                  }
                  focusSelection();
                  closeMenu();
                  doUpdateValue(option[valueField], option);
              }
          }
          function getCreatedOptionIndex(optionValue) {
              const createdOptions = createdOptionsRef.value;
              return createdOptions.findIndex((createdOption) => createdOption[props.valueField] === optionValue);
          }
          function handlePatternInput(e) {
              if (!mergedShowRef.value) {
                  openMenu();
              }
              const { value } = e.target;
              patternRef.value = value;
              const { tag, remote } = props;
              doSearch(value);
              if (tag && !remote) {
                  if (!value) {
                      beingCreatedOptionsRef.value = emptyArray;
                      return;
                  }
                  const { onCreate } = props;
                  const optionBeingCreated = onCreate
                      ? onCreate(value)
                      : { [props.labelField]: value, [props.valueField]: value };
                  const { valueField, labelField } = props;
                  if (compitableOptionsRef.value.some((option) => {
                      return (option[valueField] === optionBeingCreated[valueField] ||
                          option[labelField] === optionBeingCreated[labelField]);
                  }) ||
                      createdOptionsRef.value.some((option) => {
                          return (option[valueField] === optionBeingCreated[valueField] ||
                              option[labelField] === optionBeingCreated[labelField]);
                      })) {
                      beingCreatedOptionsRef.value = emptyArray;
                  }
                  else {
                      beingCreatedOptionsRef.value = [optionBeingCreated];
                  }
              }
          }
          function handleClear(e) {
              e.stopPropagation();
              const { multiple } = props;
              if (!multiple && props.filterable) {
                  closeMenu();
              }
              doClear();
              if (multiple) {
                  doUpdateValue([], []);
              }
              else {
                  doUpdateValue(null, null);
              }
          }
          function handleMenuMousedown(e) {
              if (!happensIn(e, 'action') && !happensIn(e, 'empty'))
                  e.preventDefault();
          }
          // scroll events on menu
          function handleMenuScroll(e) {
              doScroll(e);
          }
          // keyboard events
          // also for menu keydown
          function handleKeydown(e) {
              var _a, _b, _c, _d, _e;
              if (!props.keyboard) {
                  e.preventDefault();
                  return;
              }
              switch (e.key) {
                  case ' ':
                      if (props.filterable)
                          break;
                      else {
                          e.preventDefault();
                      }
                  // eslint-disable-next-line no-fallthrough
                  case 'Enter':
                      if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.isComposing)) {
                          if (mergedShowRef.value) {
                              const pendingTmNode = (_b = menuRef.value) === null || _b === void 0 ? void 0 : _b.getPendingTmNode();
                              if (pendingTmNode) {
                                  handleToggleByTmNode(pendingTmNode);
                              }
                              else if (!props.filterable) {
                                  closeMenu();
                                  focusSelection();
                              }
                          }
                          else {
                              openMenu();
                              if (props.tag && activeWithoutMenuOpenRef.value) {
                                  const beingCreatedOption = beingCreatedOptionsRef.value[0];
                                  if (beingCreatedOption) {
                                      const optionValue = beingCreatedOption[props.valueField];
                                      const { value: mergedValue } = mergedValueRef;
                                      if (props.multiple) {
                                          if (Array.isArray(mergedValue) &&
                                              mergedValue.some((value) => value === optionValue)) ;
                                          else {
                                              handleToggleByOption(beingCreatedOption);
                                          }
                                      }
                                      else {
                                          handleToggleByOption(beingCreatedOption);
                                      }
                                  }
                              }
                          }
                      }
                      e.preventDefault();
                      break;
                  case 'ArrowUp':
                      e.preventDefault();
                      if (props.loading)
                          return;
                      if (mergedShowRef.value) {
                          (_c = menuRef.value) === null || _c === void 0 ? void 0 : _c.prev();
                      }
                      break;
                  case 'ArrowDown':
                      e.preventDefault();
                      if (props.loading)
                          return;
                      if (mergedShowRef.value) {
                          (_d = menuRef.value) === null || _d === void 0 ? void 0 : _d.next();
                      }
                      else {
                          openMenu();
                      }
                      break;
                  case 'Escape':
                      if (mergedShowRef.value) {
                          markEventEffectPerformed(e);
                          closeMenu();
                      }
                      (_e = triggerRef.value) === null || _e === void 0 ? void 0 : _e.focus();
                      break;
              }
          }
          function focusSelection() {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function focusSelectionInput() {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function handleTriggerOrMenuResize() {
              var _a;
              if (!mergedShowRef.value)
                  return;
              (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          updateMemorizedOptions();
          watch(toRef(props, 'options'), updateMemorizedOptions);
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              focusInput: () => {
                  var _a;
                  (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
              },
              blur: () => {
                  var _a;
                  (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              },
              blurInput: () => {
                  var _a;
                  (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blurInput();
              }
          };
          const cssVarsRef = computed(() => {
              const { self: { menuBoxShadow } } = themeRef.value;
              return {
                  '--n-menu-box-shadow': menuBoxShadow
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('select', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedMethods), { mergedStatus: mergedStatusRef, mergedClsPrefix: mergedClsPrefixRef, mergedBordered: mergedBorderedRef, namespace: namespaceRef, treeMate: treeMateRef, isMounted: isMounted(), triggerRef,
              menuRef, pattern: patternRef, uncontrolledShow: uncontrolledShowRef, mergedShow: mergedShowRef, adjustedTo: useAdjustedTo(props), uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, followerRef, localizedPlaceholder: localizedPlaceholderRef, selectedOption: selectedOptionRef, selectedOptions: selectedOptionsRef, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, focused: focusedRef, activeWithoutMenuOpen: activeWithoutMenuOpenRef, inlineThemeDisabled,
              onTriggerInputFocus,
              onTriggerInputBlur,
              handleTriggerOrMenuResize,
              handleMenuFocus,
              handleMenuBlur,
              handleMenuTabOut,
              handleTriggerClick, handleToggle: handleToggleByTmNode, handleDeleteOption: handleToggleByOption, handlePatternInput,
              handleClear,
              handleTriggerBlur,
              handleTriggerFocus,
              handleKeydown,
              handleMenuAfterLeave,
              handleMenuClickOutside,
              handleMenuScroll, handleMenuKeydown: handleKeydown, handleMenuMousedown, mergedTheme: themeRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          return (h("div", { class: `${this.mergedClsPrefix}-select` },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h(NInternalSelection, { ref: "triggerRef", inlineThemeDisabled: this.inlineThemeDisabled, status: this.mergedStatus, inputProps: this.inputProps, clsPrefix: this.mergedClsPrefix, showArrow: this.showArrow, maxTagCount: this.maxTagCount, bordered: this.mergedBordered, active: this.activeWithoutMenuOpen || this.mergedShow, pattern: this.pattern, placeholder: this.localizedPlaceholder, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, multiple: this.multiple, renderTag: this.renderTag, renderLabel: this.renderLabel, filterable: this.filterable, clearable: this.clearable, disabled: this.mergedDisabled, size: this.mergedSize, theme: this.mergedTheme.peers.InternalSelection, labelField: this.labelField, valueField: this.valueField, themeOverrides: this.mergedTheme.peerOverrides.InternalSelection, loading: this.loading, focused: this.focused, onClick: this.handleTriggerClick, onDeleteOption: this.handleDeleteOption, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onBlur: this.handleTriggerBlur, onFocus: this.handleTriggerFocus, onKeydown: this.handleKeydown, onPatternBlur: this.onTriggerInputBlur, onPatternFocus: this.onTriggerInputFocus, onResize: this.handleTriggerOrMenuResize, ignoreComposition: this.ignoreComposition }, {
                              arrow: () => { var _a, _b; return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)]; }
                          }))
                      }),
                      h(VFollower, { ref: "followerRef", show: this.mergedShow, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? 'target' : undefined, minWidth: "target", placement: this.placement }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onAfterLeave: this.handleMenuAfterLeave }, {
                              default: () => {
                                  var _a, _b, _c;
                                  if (!(this.mergedShow ||
                                      this.displayDirective === 'show')) {
                                      return null;
                                  }
                                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                                  return withDirectives(h(NInternalSelectMenu, Object.assign({}, this.menuProps, { ref: "menuRef", onResize: this.handleTriggerOrMenuResize, inlineThemeDisabled: this.inlineThemeDisabled, virtualScroll: this.consistentMenuWidth && this.virtualScroll, class: [
                                          `${this.mergedClsPrefix}-select-menu`,
                                          this.themeClass,
                                          (_b = this.menuProps) === null || _b === void 0 ? void 0 : _b.class
                                      ], clsPrefix: this.mergedClsPrefix, focusable: true, labelField: this.labelField, valueField: this.valueField, autoPending: true, nodeProps: this.nodeProps, theme: this.mergedTheme.peers.InternalSelectMenu, themeOverrides: this.mergedTheme.peerOverrides
                                          .InternalSelectMenu, treeMate: this.treeMate, multiple: this.multiple, size: "medium", renderOption: this.renderOption, renderLabel: this.renderLabel, value: this.mergedValue, style: [(_c = this.menuProps) === null || _c === void 0 ? void 0 : _c.style, this.cssVars], onToggle: this.handleToggle, onScroll: this.handleMenuScroll, onFocus: this.handleMenuFocus, onBlur: this.handleMenuBlur, onKeydown: this.handleMenuKeydown, onTabOut: this.handleMenuTabOut, onMousedown: this.handleMenuMousedown, show: this.mergedShow, showCheckmark: this.showCheckmark, resetMenuOnOptionsChange: this.resetMenuOnOptionsChange }), {
                                      empty: () => { var _a, _b; return [(_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)]; },
                                      action: () => { var _a, _b; return [(_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a)]; }
                                  }), this.displayDirective === 'show'
                                      ? [
                                          [vShow, this.mergedShow],
                                          [
                                              clickoutside$1,
                                              this.handleMenuClickOutside,
                                              undefined,
                                              { capture: true }
                                          ]
                                      ]
                                      : [
                                          [
                                              clickoutside$1,
                                              this.handleMenuClickOutside,
                                              undefined,
                                              { capture: true }
                                          ]
                                      ]);
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  var commonVariables$b = {
      itemPaddingSmall: '0 4px',
      itemMarginSmall: '0 0 0 8px',
      itemMarginSmallRtl: '0 8px 0 0',
      itemPaddingMedium: '0 4px',
      itemMarginMedium: '0 0 0 8px',
      itemMarginMediumRtl: '0 8px 0 0',
      itemPaddingLarge: '0 4px',
      itemMarginLarge: '0 0 0 8px',
      itemMarginLargeRtl: '0 8px 0 0',
      buttonIconSizeSmall: '14px',
      buttonIconSizeMedium: '16px',
      buttonIconSizeLarge: '18px',
      inputWidthSmall: '60px',
      selectWidthSmall: 'unset',
      inputMarginSmall: '0 0 0 8px',
      inputMarginSmallRtl: '0 8px 0 0',
      selectMarginSmall: '0 0 0 8px',
      prefixMarginSmall: '0 8px 0 0',
      suffixMarginSmall: '0 0 0 8px',
      inputWidthMedium: '60px',
      selectWidthMedium: 'unset',
      inputMarginMedium: '0 0 0 8px',
      inputMarginMediumRtl: '0 8px 0 0',
      selectMarginMedium: '0 0 0 8px',
      prefixMarginMedium: '0 8px 0 0',
      suffixMarginMedium: '0 0 0 8px',
      inputWidthLarge: '60px',
      selectWidthLarge: 'unset',
      inputMarginLarge: '0 0 0 8px',
      inputMarginLargeRtl: '0 8px 0 0',
      selectMarginLarge: '0 0 0 8px',
      prefixMarginLarge: '0 8px 0 0',
      suffixMarginLarge: '0 0 0 8px'
  };

  const self$P = (vars) => {
      const { textColor2, primaryColor, primaryColorHover, primaryColorPressed, inputColorDisabled, textColorDisabled, borderColor, borderRadius, 
      // item font size
      fontSizeTiny, fontSizeSmall, fontSizeMedium, 
      // item size
      heightTiny, heightSmall, heightMedium } = vars;
      return Object.assign(Object.assign({}, commonVariables$b), { buttonColor: '#0000', buttonColorHover: '#0000', buttonColorPressed: '#0000', buttonBorder: `1px solid ${borderColor}`, buttonBorderHover: `1px solid ${borderColor}`, buttonBorderPressed: `1px solid ${borderColor}`, buttonIconColor: textColor2, buttonIconColorHover: textColor2, buttonIconColorPressed: textColor2, itemTextColor: textColor2, itemTextColorHover: primaryColorHover, itemTextColorPressed: primaryColorPressed, itemTextColorActive: primaryColor, itemTextColorDisabled: textColorDisabled, itemColor: '#0000', itemColorHover: '#0000', itemColorPressed: '#0000', itemColorActive: '#0000', itemColorActiveHover: '#0000', itemColorDisabled: inputColorDisabled, itemBorder: '1px solid #0000', itemBorderHover: '1px solid #0000', itemBorderPressed: '1px solid #0000', itemBorderActive: `1px solid ${primaryColor}`, itemBorderDisabled: `1px solid ${borderColor}`, itemBorderRadius: borderRadius, itemSizeSmall: heightTiny, itemSizeMedium: heightSmall, itemSizeLarge: heightMedium, itemFontSizeSmall: fontSizeTiny, itemFontSizeMedium: fontSizeSmall, itemFontSizeLarge: fontSizeMedium, jumperFontSizeSmall: fontSizeTiny, jumperFontSizeMedium: fontSizeSmall, jumperFontSizeLarge: fontSizeMedium, jumperTextColor: textColor2, jumperTextColorDisabled: textColorDisabled });
  };
  const paginationLight = createTheme({
      name: 'Pagination',
      common: commonLight,
      peers: {
          Select: selectLight$1,
          Input: inputLight$1,
          Popselect: popselectLight$1
      },
      self: self$P
  });
  var paginationLight$1 = paginationLight;

  function createPageItemsInfo(currentPage, pageCount, pageSlot) {
      let hasFastBackward = false;
      let hasFastForward = false;
      let fastBackwardTo = 1;
      let fastForwardTo = pageCount;
      if (pageCount === 1) {
          return {
              hasFastBackward: false,
              hasFastForward: false,
              fastForwardTo,
              fastBackwardTo,
              items: [
                  {
                      type: 'page',
                      label: 1,
                      active: currentPage === 1,
                      mayBeFastBackward: false,
                      mayBeFastForward: false
                  }
              ]
          };
      }
      if (pageCount === 2) {
          return {
              hasFastBackward: false,
              hasFastForward: false,
              fastForwardTo,
              fastBackwardTo,
              items: [
                  {
                      type: 'page',
                      label: 1,
                      active: currentPage === 1,
                      mayBeFastBackward: false,
                      mayBeFastForward: false
                  },
                  {
                      type: 'page',
                      label: 2,
                      active: currentPage === 2,
                      mayBeFastBackward: true,
                      mayBeFastForward: false
                  }
              ]
          };
      }
      const firstPage = 1;
      const lastPage = pageCount;
      let middleStart = currentPage;
      let middleEnd = currentPage;
      const middleDelta = (pageSlot - 5) / 2;
      middleEnd += Math.ceil(middleDelta);
      middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
      middleStart -= Math.floor(middleDelta);
      middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
      let leftSplit = false;
      let rightSplit = false;
      if (middleStart > firstPage + 2)
          leftSplit = true;
      if (middleEnd < lastPage - 2)
          rightSplit = true;
      const items = [];
      items.push({
          type: 'page',
          label: 1,
          active: currentPage === 1,
          mayBeFastBackward: false,
          mayBeFastForward: false
      });
      if (leftSplit) {
          hasFastBackward = true;
          fastBackwardTo = middleStart - 1;
          items.push({
              type: 'fast-backward',
              active: false,
              label: undefined,
              options: createRange(firstPage + 1, middleStart - 1)
          });
      }
      else if (lastPage >= firstPage + 1) {
          items.push({
              type: 'page',
              label: firstPage + 1,
              mayBeFastBackward: true,
              mayBeFastForward: false,
              active: currentPage === firstPage + 1
          });
      }
      for (let i = middleStart; i <= middleEnd; ++i) {
          items.push({
              type: 'page',
              label: i,
              mayBeFastBackward: false,
              mayBeFastForward: false,
              active: currentPage === i
          });
      }
      if (rightSplit) {
          hasFastForward = true;
          fastForwardTo = middleEnd + 1;
          items.push({
              type: 'fast-forward',
              active: false,
              label: undefined,
              options: createRange(middleEnd + 1, lastPage - 1)
          });
      }
      else if (middleEnd === lastPage - 2 &&
          items[items.length - 1].label !== lastPage - 1) {
          items.push({
              type: 'page',
              mayBeFastForward: true,
              mayBeFastBackward: false,
              label: lastPage - 1,
              active: currentPage === lastPage - 1
          });
      }
      if (items[items.length - 1].label !== lastPage) {
          items.push({
              type: 'page',
              mayBeFastForward: false,
              mayBeFastBackward: false,
              label: lastPage,
              active: currentPage === lastPage
          });
      }
      return {
          hasFastBackward,
          hasFastForward,
          fastBackwardTo,
          fastForwardTo,
          items
      };
  }
  function createRange(from, to) {
      const range = [];
      for (let i = from; i <= to; ++i) {
          range.push({
              label: `${i}`,
              value: i
          });
      }
      return range;
  }

  const hoverStyleProps = `
 background: var(--n-item-color-hover);
 color: var(--n-item-text-color-hover);
 border: var(--n-item-border-hover);
`;
  const hoverStyleChildren$1 = [cM('button', `
 background: var(--n-button-color-hover);
 border: var(--n-button-border-hover);
 color: var(--n-button-icon-color-hover);
 `)];
  // vars:
  // --n-item-font-size
  // --n-select-width
  // --n-input-width
  // --n-input-margin
  // --n-item-size
  // --n-item-text-color
  // --n-item-text-color-disabled
  // --n-item-text-color-hover
  // --n-item-text-color-active
  // --n-item-color
  // --n-item-color-hover
  // --n-item-color-disabled
  // --n-item-color-active
  // --n-item-color-active-hover
  // --n-item-border
  // --n-item-border-hover
  // --n-item-border-disabled
  // --n-item-border-active
  // --n-item-padding
  // --n-item-font-size
  // --n-item-border-radius
  // --n-bezier
  // --n-jumper-font-size
  // --n-jumper-text-color
  // --n-jumper-text-color-disabled
  // --n-item-margin
  // --n-button-icon-size
  // --n-button-icon-color
  // --n-button-icon-color-hover
  // --n-button-icon-color-pressed
  // --n-prefix-margin
  // --n-suffix-margin
  // --n-button-color
  // --n-button-color-hover
  // --n-button-color-pressed
  var style$$ = cB('pagination', `
 display: flex;
 vertical-align: middle;
 font-size: var(--n-item-font-size);
 flex-wrap: nowrap;
`, [cB('pagination-prefix', `
 display: flex;
 align-items: center;
 margin: var(--n-prefix-margin);
 `), cB('pagination-suffix', `
 display: flex;
 align-items: center;
 margin: var(--n-suffix-margin);
 `), c$1('> *:not(:first-child)', `
 margin: var(--n-item-margin);
 `), cB('select', `
 width: var(--n-select-width);
 `), c$1('&.transition-disabled', [cB('pagination-item', 'transition: none!important;')]), cB('pagination-quick-jumper', `
 white-space: nowrap;
 display: flex;
 color: var(--n-jumper-text-color);
 transition: color .3s var(--n-bezier);
 align-items: center;
 font-size: var(--n-jumper-font-size);
 `, [cB('input', `
 margin: var(--n-input-margin);
 width: var(--n-input-width);
 `)]), cB('pagination-item', `
 position: relative;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 display: flex;
 align-items: center;
 justify-content: center;
 box-sizing: border-box;
 min-width: var(--n-item-size);
 height: var(--n-item-size);
 padding: var(--n-item-padding);
 background-color: var(--n-item-color);
 color: var(--n-item-text-color);
 border-radius: var(--n-item-border-radius);
 border: var(--n-item-border);
 fill: var(--n-button-icon-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 fill .3s var(--n-bezier);
 `, [cM('button', `
 background: var(--n-button-color);
 color: var(--n-button-icon-color);
 border: var(--n-button-border);
 padding: 0;
 `, [cB('base-icon', `
 font-size: var(--n-button-icon-size);
 `)]), cNotM('disabled', [cM('hover', hoverStyleProps, hoverStyleChildren$1), c$1('&:hover', hoverStyleProps, hoverStyleChildren$1), c$1('&:active', `
 background: var(--n-item-color-pressed);
 color: var(--n-item-text-color-pressed);
 border: var(--n-item-border-pressed);
 `, [cM('button', `
 background: var(--n-button-color-pressed);
 border: var(--n-button-border-pressed);
 color: var(--n-button-icon-color-pressed);
 `)]), cM('active', `
 background: var(--n-item-color-active);
 color: var(--n-item-text-color-active);
 border: var(--n-item-border-active);
 `, [c$1('&:hover', `
 background: var(--n-item-color-active-hover);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `, [cM('active, button', `
 background-color: var(--n-item-color-disabled);
 border: var(--n-item-border-disabled);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 `, [cB('pagination-quick-jumper', `
 color: var(--n-jumper-text-color-disabled);
 `)]), cM('simple', `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cB('pagination-quick-jumper', [cB('input', `
 margin: 0;
 `)])])]);

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const paginationProps = Object.assign(Object.assign({}, useTheme.props), { simple: Boolean, page: Number, defaultPage: {
          type: Number,
          default: 1
      }, itemCount: Number, pageCount: Number, defaultPageCount: {
          type: Number,
          default: 1
      }, showSizePicker: Boolean, pageSize: Number, defaultPageSize: Number, pageSizes: {
          type: Array,
          default() {
              return [10];
          }
      }, showQuickJumper: Boolean, size: {
          type: String,
          default: 'medium'
      }, disabled: Boolean, pageSlot: {
          type: Number,
          default: 9
      }, selectProps: Object, prev: Function, next: Function, goto: Function, prefix: Function, suffix: Function, label: Function, displayOrder: {
          type: Array,
          default: ['pages', 'size-picker', 'quick-jumper']
      }, to: useAdjustedTo.propTo, 'onUpdate:page': [Function, Array], onUpdatePage: [Function, Array], 'onUpdate:pageSize': [Function, Array], onUpdatePageSize: [Function, Array], 
      /** @deprecated */
      onPageSizeChange: [Function, Array], 
      /** @deprecated */
      onChange: [Function, Array] });
  var NPagination = defineComponent({
      name: 'Pagination',
      props: paginationProps,
      setup(props) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Pagination', '-pagination', style$$, paginationLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale('Pagination');
          const selfRef = ref(null);
          const uncontrolledPageRef = ref(props.defaultPage);
          const getDefaultPageSize = () => {
              const { defaultPageSize } = props;
              if (defaultPageSize !== undefined)
                  return defaultPageSize;
              const pageSizeOption = props.pageSizes[0];
              if (typeof pageSizeOption === 'number')
                  return pageSizeOption;
              return pageSizeOption.value || 10;
          };
          const uncontrolledPageSizeRef = ref(getDefaultPageSize());
          const mergedPageRef = useMergedState(toRef(props, 'page'), uncontrolledPageRef);
          const mergedPageSizeRef = useMergedState(toRef(props, 'pageSize'), uncontrolledPageSizeRef);
          const mergedPageCountRef = computed(() => {
              // item count has high priority, for it can affect prefix slot rendering
              const { itemCount } = props;
              if (itemCount !== undefined) {
                  return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
              }
              const { pageCount } = props;
              if (pageCount !== undefined)
                  return Math.max(pageCount, 1);
              return 1;
          });
          const jumperValueRef = ref('');
          watchEffect(() => {
              void props.simple;
              jumperValueRef.value = String(mergedPageRef.value);
          });
          const fastForwardActiveRef = ref(false);
          const fastBackwardActiveRef = ref(false);
          const showFastForwardMenuRef = ref(false);
          const showFastBackwardMenuRef = ref(false);
          const handleFastForwardMouseenter = () => {
              if (props.disabled)
                  return;
              fastForwardActiveRef.value = true;
              disableTransitionOneTick();
          };
          const handleFastForwardMouseleave = () => {
              if (props.disabled)
                  return;
              fastForwardActiveRef.value = false;
              disableTransitionOneTick();
          };
          const handleFastBackwardMouseenter = () => {
              fastBackwardActiveRef.value = true;
              disableTransitionOneTick();
          };
          const handleFastBackwardMouseleave = () => {
              fastBackwardActiveRef.value = false;
              disableTransitionOneTick();
          };
          const handleMenuSelect = (value) => {
              doUpdatePage(value);
          };
          const pageItemsInfo = computed(() => createPageItemsInfo(mergedPageRef.value, mergedPageCountRef.value, props.pageSlot));
          watchEffect(() => {
              if (!pageItemsInfo.value.hasFastBackward) {
                  fastBackwardActiveRef.value = false;
                  showFastBackwardMenuRef.value = false;
              }
              else if (!pageItemsInfo.value.hasFastForward) {
                  fastForwardActiveRef.value = false;
                  showFastForwardMenuRef.value = false;
              }
          });
          const pageSizeOptionsRef = computed(() => {
              const suffix = localeRef.value.selectionSuffix;
              return props.pageSizes.map((size) => {
                  if (typeof size === 'number') {
                      return {
                          label: `${size} / ${suffix}`,
                          value: size
                      };
                  }
                  else {
                      return size;
                  }
              });
          });
          const inputSizeRef = computed(() => {
              var _a, _b;
              return (((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.inputSize) ||
                  smallerSize(props.size));
          });
          const selectSizeRef = computed(() => {
              var _a, _b;
              return (((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.selectSize) ||
                  smallerSize(props.size));
          });
          const startIndexRef = computed(() => {
              return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
          });
          const endIndexRef = computed(() => {
              const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
              const { itemCount } = props;
              if (itemCount !== undefined) {
                  return endIndex > itemCount - 1 ? itemCount - 1 : endIndex;
              }
              return endIndex;
          });
          const mergedItemCountRef = computed(() => {
              const { itemCount } = props;
              if (itemCount !== undefined)
                  return itemCount;
              return (props.pageCount || 1) * mergedPageSizeRef.value;
          });
          const rtlEnabledRef = useRtl('Pagination', mergedRtlRef, mergedClsPrefixRef);
          const disableTransitionOneTick = () => {
              void nextTick(() => {
                  var _a;
                  const { value: selfEl } = selfRef;
                  if (!selfEl)
                      return;
                  selfEl.classList.add('transition-disabled');
                  void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
                  selfEl.classList.remove('transition-disabled');
              });
          };
          function doUpdatePage(page) {
              if (page === mergedPageRef.value)
                  return;
              const { 'onUpdate:page': _onUpdatePage, onUpdatePage, onChange, simple } = props;
              if (_onUpdatePage)
                  call(_onUpdatePage, page);
              if (onUpdatePage)
                  call(onUpdatePage, page);
              // deprecated
              if (onChange)
                  call(onChange, page);
              uncontrolledPageRef.value = page;
              if (simple) {
                  jumperValueRef.value = String(page);
              }
          }
          function doUpdatePageSize(pageSize) {
              if (pageSize === mergedPageSizeRef.value)
                  return;
              const { 'onUpdate:pageSize': _onUpdatePageSize, onUpdatePageSize, onPageSizeChange } = props;
              if (_onUpdatePageSize)
                  call(_onUpdatePageSize, pageSize);
              if (onUpdatePageSize)
                  call(onUpdatePageSize, pageSize);
              // deprecated
              if (onPageSizeChange)
                  call(onPageSizeChange, pageSize);
              uncontrolledPageSizeRef.value = pageSize;
              // update new page when overflows.
              // we may have different update strategy, but i've no time to impl it
              if (mergedPageCountRef.value < mergedPageRef.value) {
                  doUpdatePage(mergedPageCountRef.value);
              }
          }
          function forward() {
              if (props.disabled)
                  return;
              const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
              doUpdatePage(page);
          }
          function backward() {
              if (props.disabled)
                  return;
              const page = Math.max(mergedPageRef.value - 1, 1);
              doUpdatePage(page);
          }
          function fastForward() {
              if (props.disabled)
                  return;
              const page = Math.min(pageItemsInfo.value.fastForwardTo, mergedPageCountRef.value);
              doUpdatePage(page);
          }
          function fastBackward() {
              if (props.disabled)
                  return;
              const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
              doUpdatePage(page);
          }
          function handleSizePickerChange(value) {
              doUpdatePageSize(value);
          }
          function doQuickJump() {
              const page = parseInt(jumperValueRef.value);
              if (Number.isNaN(page))
                  return;
              doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
              if (!props.simple) {
                  jumperValueRef.value = '';
              }
          }
          function handleQuickJumperChange() {
              doQuickJump();
          }
          function handlePageItemClick(pageItem) {
              if (props.disabled)
                  return;
              switch (pageItem.type) {
                  case 'page':
                      doUpdatePage(pageItem.label);
                      break;
                  case 'fast-backward':
                      fastBackward();
                      break;
                  case 'fast-forward':
                      fastForward();
                      break;
              }
          }
          function handleJumperInput(value) {
              jumperValueRef.value = value.replace(/\D+/g, '');
          }
          watchEffect(() => {
              void mergedPageRef.value;
              void mergedPageSizeRef.value;
              disableTransitionOneTick();
          });
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { self: { buttonBorder, buttonBorderHover, buttonBorderPressed, buttonIconColor, buttonIconColorHover, buttonIconColorPressed, itemTextColor, itemTextColorHover, itemTextColorPressed, itemTextColorActive, itemTextColorDisabled, itemColor, itemColorHover, itemColorPressed, itemColorActive, itemColorActiveHover, itemColorDisabled, itemBorder, itemBorderHover, itemBorderPressed, itemBorderActive, itemBorderDisabled, itemBorderRadius, jumperTextColor, jumperTextColorDisabled, buttonColor, buttonColorHover, buttonColorPressed, [createKey('itemPadding', size)]: itemPadding, [createKey('itemMargin', size)]: itemMargin, [createKey('inputWidth', size)]: inputWidth, [createKey('selectWidth', size)]: selectWidth, [createKey('inputMargin', size)]: inputMargin, [createKey('selectMargin', size)]: selectMargin, [createKey('jumperFontSize', size)]: jumperFontSize, [createKey('prefixMargin', size)]: prefixMargin, [createKey('suffixMargin', size)]: suffixMargin, [createKey('itemSize', size)]: itemSize, [createKey('buttonIconSize', size)]: buttonIconSize, [createKey('itemFontSize', size)]: itemFontSize, [`${createKey('itemMargin', size)}Rtl`]: itemMarginRtl, [`${createKey('inputMargin', size)}Rtl`]: inputMarginRtl }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-prefix-margin': prefixMargin,
                  '--n-suffix-margin': suffixMargin,
                  '--n-item-font-size': itemFontSize,
                  '--n-select-width': selectWidth,
                  '--n-select-margin': selectMargin,
                  '--n-input-width': inputWidth,
                  '--n-input-margin': inputMargin,
                  '--n-input-margin-rtl': inputMarginRtl,
                  '--n-item-size': itemSize,
                  '--n-item-text-color': itemTextColor,
                  '--n-item-text-color-disabled': itemTextColorDisabled,
                  '--n-item-text-color-hover': itemTextColorHover,
                  '--n-item-text-color-active': itemTextColorActive,
                  '--n-item-text-color-pressed': itemTextColorPressed,
                  '--n-item-color': itemColor,
                  '--n-item-color-hover': itemColorHover,
                  '--n-item-color-disabled': itemColorDisabled,
                  '--n-item-color-active': itemColorActive,
                  '--n-item-color-active-hover': itemColorActiveHover,
                  '--n-item-color-pressed': itemColorPressed,
                  '--n-item-border': itemBorder,
                  '--n-item-border-hover': itemBorderHover,
                  '--n-item-border-disabled': itemBorderDisabled,
                  '--n-item-border-active': itemBorderActive,
                  '--n-item-border-pressed': itemBorderPressed,
                  '--n-item-padding': itemPadding,
                  '--n-item-border-radius': itemBorderRadius,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-jumper-font-size': jumperFontSize,
                  '--n-jumper-text-color': jumperTextColor,
                  '--n-jumper-text-color-disabled': jumperTextColorDisabled,
                  '--n-item-margin': itemMargin,
                  '--n-item-margin-rtl': itemMarginRtl,
                  '--n-button-icon-size': buttonIconSize,
                  '--n-button-icon-color': buttonIconColor,
                  '--n-button-icon-color-hover': buttonIconColorHover,
                  '--n-button-icon-color-pressed': buttonIconColorPressed,
                  '--n-button-color-hover': buttonColorHover,
                  '--n-button-color': buttonColor,
                  '--n-button-color-pressed': buttonColorPressed,
                  '--n-button-border': buttonBorder,
                  '--n-button-border-hover': buttonBorderHover,
                  '--n-button-border-pressed': buttonBorderPressed
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('pagination', computed(() => {
                  let hash = '';
                  const { size } = props;
                  hash += size[0];
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              locale: localeRef,
              selfRef,
              mergedPage: mergedPageRef,
              pageItems: computed(() => {
                  return pageItemsInfo.value.items;
              }),
              mergedItemCount: mergedItemCountRef,
              jumperValue: jumperValueRef,
              pageSizeOptions: pageSizeOptionsRef,
              mergedPageSize: mergedPageSizeRef,
              inputSize: inputSizeRef,
              selectSize: selectSizeRef,
              mergedTheme: themeRef,
              mergedPageCount: mergedPageCountRef,
              startIndex: startIndexRef,
              endIndex: endIndexRef,
              showFastForwardMenu: showFastForwardMenuRef,
              showFastBackwardMenu: showFastBackwardMenuRef,
              fastForwardActive: fastForwardActiveRef,
              fastBackwardActive: fastBackwardActiveRef,
              handleMenuSelect,
              handleFastForwardMouseenter,
              handleFastForwardMouseleave,
              handleFastBackwardMouseenter,
              handleFastBackwardMouseleave,
              handleJumperInput,
              handleBackwardClick: backward,
              handleForwardClick: forward,
              handlePageItemClick,
              handleSizePickerChange,
              handleQuickJumperChange,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          // it's ok to expand all prop here since no slots' deps
          const { $slots, mergedClsPrefix, disabled, cssVars, mergedPage, mergedPageCount, pageItems, showSizePicker, showQuickJumper, mergedTheme, locale, inputSize, selectSize, mergedPageSize, pageSizeOptions, jumperValue, simple, prev, next, prefix, suffix, label, goto, handleJumperInput, handleSizePickerChange, handleBackwardClick, handlePageItemClick, handleForwardClick, handleQuickJumperChange, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderPrefix = $slots.prefix || prefix;
          const renderSuffix = $slots.suffix || suffix;
          const renderPrev = prev || $slots.prev;
          const renderNext = next || $slots.next;
          const renderLabel = label || $slots.label;
          return (h("div", { ref: "selfRef", class: [
                  `${mergedClsPrefix}-pagination`,
                  this.themeClass,
                  this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`,
                  disabled && `${mergedClsPrefix}-pagination--disabled`,
                  simple && `${mergedClsPrefix}-pagination--simple`
              ], style: cssVars },
              renderPrefix ? (h("div", { class: `${mergedClsPrefix}-pagination-prefix` }, renderPrefix({
                  page: mergedPage,
                  pageSize: mergedPageSize,
                  pageCount: mergedPageCount,
                  startIndex: this.startIndex,
                  endIndex: this.endIndex,
                  itemCount: this.mergedItemCount
              }))) : null,
              this.displayOrder.map((part) => {
                  switch (part) {
                      case 'pages':
                          return (h(Fragment, null,
                              h("div", { class: [
                                      `${mergedClsPrefix}-pagination-item`,
                                      !renderPrev &&
                                          `${mergedClsPrefix}-pagination-item--button`,
                                      (mergedPage <= 1 ||
                                          mergedPage > mergedPageCount ||
                                          disabled) &&
                                          `${mergedClsPrefix}-pagination-item--disabled`
                                  ], onClick: handleBackwardClick }, renderPrev ? (renderPrev({
                                  page: mergedPage,
                                  pageSize: mergedPageSize,
                                  pageCount: mergedPageCount,
                                  startIndex: this.startIndex,
                                  endIndex: this.endIndex,
                                  itemCount: this.mergedItemCount
                              })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                  default: () => this.rtlEnabled ? h(ForwardIcon, null) : h(BackwardIcon, null)
                              }))),
                              simple ? (h(Fragment, null,
                                  h("div", { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                                      h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled: disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange })),
                                  "\u00A0/ ",
                                  mergedPageCount)) : (pageItems.map((pageItem, index) => {
                                  let contentNode;
                                  let onMouseenter;
                                  let onMouseleave;
                                  const { type } = pageItem;
                                  switch (type) {
                                      case 'page':
                                          // eslint-disable-next-line no-case-declarations
                                          const pageNode = pageItem.label;
                                          if (renderLabel) {
                                              contentNode = renderLabel({
                                                  type: 'page',
                                                  node: pageNode,
                                                  active: pageItem.active
                                              });
                                          }
                                          else {
                                              contentNode = pageNode;
                                          }
                                          break;
                                      case 'fast-forward':
                                          // eslint-disable-next-line no-case-declarations
                                          const fastForwardNode = this.fastForwardActive ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                              default: () => this.rtlEnabled ? (h(FastBackwardIcon, null)) : (h(FastForwardIcon, null))
                                          })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(MoreIcon, null) }));
                                          if (renderLabel) {
                                              contentNode = renderLabel({
                                                  type: 'fast-forward',
                                                  node: fastForwardNode,
                                                  active: this.fastForwardActive ||
                                                      this.showFastForwardMenu
                                              });
                                          }
                                          else {
                                              contentNode = fastForwardNode;
                                          }
                                          onMouseenter = this.handleFastForwardMouseenter;
                                          onMouseleave = this.handleFastForwardMouseleave;
                                          break;
                                      case 'fast-backward':
                                          // eslint-disable-next-line no-case-declarations
                                          const fastBackwardNode = this.fastBackwardActive ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                              default: () => this.rtlEnabled ? (h(FastForwardIcon, null)) : (h(FastBackwardIcon, null))
                                          })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(MoreIcon, null) }));
                                          if (renderLabel) {
                                              contentNode = renderLabel({
                                                  type: 'fast-backward',
                                                  node: fastBackwardNode,
                                                  active: this.fastBackwardActive ||
                                                      this.showFastBackwardMenu
                                              });
                                          }
                                          else {
                                              contentNode = fastBackwardNode;
                                          }
                                          onMouseenter = this.handleFastBackwardMouseenter;
                                          onMouseleave = this.handleFastBackwardMouseleave;
                                          break;
                                  }
                                  const itemNode = (h("div", { key: index, class: [
                                          `${mergedClsPrefix}-pagination-item`,
                                          pageItem.active &&
                                              `${mergedClsPrefix}-pagination-item--active`,
                                          type !== 'page' &&
                                              ((type === 'fast-backward' &&
                                                  this.showFastBackwardMenu) ||
                                                  (type === 'fast-forward' &&
                                                      this.showFastForwardMenu)) &&
                                              `${mergedClsPrefix}-pagination-item--hover`,
                                          disabled &&
                                              `${mergedClsPrefix}-pagination-item--disabled`,
                                          type === 'page' &&
                                              `${mergedClsPrefix}-pagination-item--clickable`
                                      ], onClick: () => {
                                          handlePageItemClick(pageItem);
                                      }, onMouseenter: onMouseenter, onMouseleave: onMouseleave }, contentNode));
                                  if (type === 'page' &&
                                      !pageItem.mayBeFastBackward &&
                                      !pageItem.mayBeFastForward) {
                                      return itemNode;
                                  }
                                  else {
                                      const key = pageItem.type === 'page'
                                          ? pageItem.mayBeFastBackward
                                              ? 'fast-backward'
                                              : 'fast-forward'
                                          : pageItem.type;
                                      return (h(NPopselect, { to: this.to, key: key, disabled: disabled, trigger: "hover", virtualScroll: true, style: { width: '60px' }, theme: mergedTheme.peers.Popselect, themeOverrides: mergedTheme.peerOverrides.Popselect, builtinThemeOverrides: {
                                              peers: {
                                                  InternalSelectMenu: {
                                                      height: 'calc(var(--n-option-height) * 4.6)'
                                                  }
                                              }
                                          }, nodeProps: () => ({
                                              style: {
                                                  justifyContent: 'center'
                                              }
                                          }), show: type === 'page'
                                              ? false
                                              : type === 'fast-backward'
                                                  ? this.showFastBackwardMenu
                                                  : this.showFastForwardMenu, onUpdateShow: (value) => {
                                              if (type === 'page')
                                                  return;
                                              if (value) {
                                                  if (type === 'fast-backward') {
                                                      this.showFastBackwardMenu = value;
                                                  }
                                                  else {
                                                      this.showFastForwardMenu = value;
                                                  }
                                              }
                                              else {
                                                  this.showFastBackwardMenu = false;
                                                  this.showFastForwardMenu = false;
                                              }
                                          }, options: pageItem.type !== 'page' ? pageItem.options : [], onUpdateValue: this.handleMenuSelect, scrollable: true, showCheckmark: false }, { default: () => itemNode }));
                                  }
                              })),
                              h("div", { class: [
                                      `${mergedClsPrefix}-pagination-item`,
                                      !renderNext &&
                                          `${mergedClsPrefix}-pagination-item--button`,
                                      {
                                          [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 ||
                                              mergedPage >= mergedPageCount ||
                                              disabled
                                      }
                                  ], onClick: handleForwardClick }, renderNext ? (renderNext({
                                  page: mergedPage,
                                  pageSize: mergedPageSize,
                                  pageCount: mergedPageCount,
                                  itemCount: this.mergedItemCount,
                                  startIndex: this.startIndex,
                                  endIndex: this.endIndex
                              })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                  default: () => this.rtlEnabled ? h(BackwardIcon, null) : h(ForwardIcon, null)
                              })))));
                      case 'size-picker': {
                          return !simple && showSizePicker ? (h(NSelect, Object.assign({ consistentMenuWidth: false, placeholder: "", showCheckmark: false, to: this.to }, this.selectProps, { size: selectSize, options: pageSizeOptions, value: mergedPageSize, disabled: disabled, theme: mergedTheme.peers.Select, themeOverrides: mergedTheme.peerOverrides.Select, onUpdateValue: handleSizePickerChange }))) : null;
                      }
                      case 'quick-jumper':
                          return !simple && showQuickJumper ? (h("div", { class: `${mergedClsPrefix}-pagination-quick-jumper` },
                              goto
                                  ? goto()
                                  : resolveSlot(this.$slots.goto, () => [locale.goto]),
                              h(NInput, { value: jumperValue, onUpdateValue: handleJumperInput, size: inputSize, placeholder: "", disabled: disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onChange: handleQuickJumperChange }))) : null;
                      default:
                          return null;
                  }
              }),
              renderSuffix ? (h("div", { class: `${mergedClsPrefix}-pagination-suffix` }, renderSuffix({
                  page: mergedPage,
                  pageSize: mergedPageSize,
                  pageCount: mergedPageCount,
                  startIndex: this.startIndex,
                  endIndex: this.endIndex,
                  itemCount: this.mergedItemCount
              }))) : null));
      }
  });

  var commonVars$8 = {
      padding: '8px 14px'
  };

  const self$O = (vars) => {
      const { borderRadius, boxShadow2, baseColor } = vars;
      return Object.assign(Object.assign({}, commonVars$8), { borderRadius, boxShadow: boxShadow2, color: composite(baseColor, 'rgba(0, 0, 0, .85)'), textColor: baseColor });
  };
  const tooltipLight = createTheme({
      name: 'Tooltip',
      common: commonLight,
      peers: {
          Popover: popoverLight$1
      },
      self: self$O
  });
  var tooltipLight$1 = tooltipLight;

  const ellipsisLight = createTheme({
      name: 'Ellipsis',
      common: commonLight,
      peers: {
          Tooltip: tooltipLight$1
      }
  });
  var ellipsisLight$1 = ellipsisLight;

  var commonVariables$a = {
      radioSizeSmall: '14px',
      radioSizeMedium: '16px',
      radioSizeLarge: '18px',
      labelPadding: '0 8px',
      labelFontWeight: '400'
  };

  const self$N = (vars) => {
      const { borderColor, primaryColor, baseColor, textColorDisabled, inputColorDisabled, textColor2, opacityDisabled, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, heightSmall, heightMedium, heightLarge, lineHeight } = vars;
      return Object.assign(Object.assign({}, commonVariables$a), { labelLineHeight: lineHeight, buttonHeightSmall: heightSmall, buttonHeightMedium: heightMedium, buttonHeightLarge: heightLarge, fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge, boxShadow: `inset 0 0 0 1px ${borderColor}`, boxShadowActive: `inset 0 0 0 1px ${primaryColor}`, boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}`, boxShadowHover: `inset 0 0 0 1px ${primaryColor}`, boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`, color: baseColor, colorDisabled: inputColorDisabled, colorActive: '#0000', textColor: textColor2, textColorDisabled, dotColorActive: primaryColor, dotColorDisabled: borderColor, buttonBorderColor: borderColor, buttonBorderColorActive: primaryColor, buttonBorderColorHover: borderColor, buttonColor: baseColor, buttonColorActive: baseColor, buttonTextColor: textColor2, buttonTextColorActive: primaryColor, buttonTextColorHover: primaryColor, opacityDisabled, buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, { alpha: 0.3 })}`, buttonBoxShadowHover: 'inset 0 0 0 1px #0000', buttonBoxShadow: 'inset 0 0 0 1px #0000', buttonBorderRadius: borderRadius });
  };
  const radioLight = {
      name: 'Radio',
      common: commonLight,
      self: self$N
  };
  var radioLight$1 = radioLight;

  var commonVariables$9 = {
      padding: '4px 0',
      optionIconSizeSmall: '14px',
      optionIconSizeMedium: '16px',
      optionIconSizeLarge: '16px',
      optionIconSizeHuge: '18px',
      optionSuffixWidthSmall: '14px',
      optionSuffixWidthMedium: '14px',
      optionSuffixWidthLarge: '16px',
      optionSuffixWidthHuge: '16px',
      optionIconSuffixWidthSmall: '32px',
      optionIconSuffixWidthMedium: '32px',
      optionIconSuffixWidthLarge: '36px',
      optionIconSuffixWidthHuge: '36px',
      optionPrefixWidthSmall: '14px',
      optionPrefixWidthMedium: '14px',
      optionPrefixWidthLarge: '16px',
      optionPrefixWidthHuge: '16px',
      optionIconPrefixWidthSmall: '36px',
      optionIconPrefixWidthMedium: '36px',
      optionIconPrefixWidthLarge: '40px',
      optionIconPrefixWidthHuge: '40px'
  };

  const self$M = (vars) => {
      const { primaryColor, textColor2, dividerColor, hoverColor, popoverColor, invertedColor, borderRadius, fontSizeSmall, fontSizeMedium, fontSizeLarge, fontSizeHuge, heightSmall, heightMedium, heightLarge, heightHuge, textColor3, opacityDisabled } = vars;
      return Object.assign(Object.assign({}, commonVariables$9), { optionHeightSmall: heightSmall, optionHeightMedium: heightMedium, optionHeightLarge: heightLarge, optionHeightHuge: heightHuge, borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge, 
          // non-inverted
          optionTextColor: textColor2, optionTextColorHover: textColor2, optionTextColorActive: primaryColor, optionTextColorChildActive: primaryColor, color: popoverColor, dividerColor, suffixColor: textColor2, prefixColor: textColor2, optionColorHover: hoverColor, optionColorActive: changeColor(primaryColor, { alpha: 0.1 }), groupHeaderTextColor: textColor3, 
          // inverted
          optionTextColorInverted: '#BBB', optionTextColorHoverInverted: '#FFF', optionTextColorActiveInverted: '#FFF', optionTextColorChildActiveInverted: '#FFF', colorInverted: invertedColor, dividerColorInverted: '#BBB', suffixColorInverted: '#BBB', prefixColorInverted: '#BBB', optionColorHoverInverted: primaryColor, optionColorActiveInverted: primaryColor, groupHeaderTextColorInverted: '#AAA', optionOpacityDisabled: opacityDisabled });
  };
  const dropdownLight = createTheme({
      name: 'Dropdown',
      common: commonLight,
      peers: {
          Popover: popoverLight$1
      },
      self: self$M
  });
  var dropdownLight$1 = dropdownLight;

  var commonVariables$8 = {
      thPaddingSmall: '8px',
      thPaddingMedium: '12px',
      thPaddingLarge: '12px',
      tdPaddingSmall: '8px',
      tdPaddingMedium: '12px',
      tdPaddingLarge: '12px',
      sorterSize: '15px',
      resizableContainerSize: '8px',
      resizableSize: '2px',
      filterSize: '15px',
      paginationMargin: '12px 0 0 0',
      emptyPadding: '48px 0',
      actionPadding: '8px 12px',
      actionButtonMargin: '0 8px 0 0'
  };

  const self$L = (vars) => {
      const { cardColor, modalColor, popoverColor, textColor2, textColor1, tableHeaderColor, tableColorHover, iconColor, primaryColor, fontWeightStrong, borderRadius, lineHeight, fontSizeSmall, fontSizeMedium, fontSizeLarge, dividerColor, heightSmall, opacityDisabled, tableColorStriped } = vars;
      return Object.assign(Object.assign({}, commonVariables$8), { actionDividerColor: dividerColor, lineHeight,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge, borderColor: composite(cardColor, dividerColor), tdColorHover: composite(cardColor, tableColorHover), tdColorStriped: composite(cardColor, tableColorStriped), thColor: composite(cardColor, tableHeaderColor), thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover), tdColor: cardColor, tdTextColor: textColor2, thTextColor: textColor1, thFontWeight: fontWeightStrong, thButtonColorHover: tableColorHover, thIconColor: iconColor, thIconColorActive: primaryColor, 
          // modal
          borderColorModal: composite(modalColor, dividerColor), tdColorHoverModal: composite(modalColor, tableColorHover), tdColorStripedModal: composite(modalColor, tableColorStriped), thColorModal: composite(modalColor, tableHeaderColor), thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover), tdColorModal: modalColor, 
          // popover
          borderColorPopover: composite(popoverColor, dividerColor), tdColorHoverPopover: composite(popoverColor, tableColorHover), tdColorStripedPopover: composite(popoverColor, tableColorStriped), thColorPopover: composite(popoverColor, tableHeaderColor), thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover), tdColorPopover: popoverColor, boxShadowBefore: 'inset -12px 0 8px -12px rgba(0, 0, 0, .18)', boxShadowAfter: 'inset 12px 0 8px -12px rgba(0, 0, 0, .18)', 
          // loading
          loadingColor: primaryColor, loadingSize: heightSmall, opacityLoading: opacityDisabled });
  };
  const dataTableLight = createTheme({
      name: 'DataTable',
      common: commonLight,
      peers: {
          Button: buttonLight$1,
          Checkbox: checkboxLight$1,
          Radio: radioLight$1,
          Pagination: paginationLight$1,
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1,
          Popover: popoverLight$1,
          Ellipsis: ellipsisLight$1,
          Dropdown: dropdownLight$1
      },
      self: self$L
  });
  var dataTableLight$1 = dataTableLight;

  // Tooltip: popover wearing waistcoat
  const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
  var NTooltip = defineComponent({
      name: 'Tooltip',
      props: tooltipProps,
      __popover__: true,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Tooltip', '-tooltip', undefined, tooltipLight$1, props, mergedClsPrefixRef);
          const popoverRef = ref(null);
          const tooltipExposedMethod = {
              syncPosition() {
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  popoverRef.value.syncPosition();
              },
              setShow(show) {
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                  popoverRef.value.setShow(show);
              }
          };
          return Object.assign(Object.assign({}, tooltipExposedMethod), { popoverRef, mergedTheme: themeRef, popoverThemeOverrides: computed(() => {
                  return themeRef.value.self;
              }) });
      },
      render() {
          const { mergedTheme, internalExtraClass } = this;
          return h(NPopover, Object.assign(Object.assign({}, this.$props), { theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, builtinThemeOverrides: this.popoverThemeOverrides, internalExtraClass: internalExtraClass.concat('tooltip'), ref: 'popoverRef' }), this.$slots);
      }
  });

  var style$_ = cB('ellipsis', {
    overflow: 'hidden'
  }, [cNotM('line-clamp', `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM('line-clamp', `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM('cursor-pointer', `
 cursor: pointer;
 `)]);

  function createLineClampClass(clsPrefix) {
      return `${clsPrefix}-ellipsis--line-clamp`;
  }
  function createCursorClass(clsPrefix, cursor) {
      return `${clsPrefix}-ellipsis--cursor-${cursor}`;
  }
  const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), { expandTrigger: String, lineClamp: [Number, String], tooltip: {
          type: [Boolean, Object],
          default: true
      } });
  var NEllipsis = defineComponent({
      name: 'Ellipsis',
      inheritAttrs: false,
      props: ellipsisProps,
      setup(props, { slots, attrs }) {
          const mergedClsPrefixRef = useMergedClsPrefix();
          const mergedTheme = useTheme('Ellipsis', '-ellipsis', style$_, ellipsisLight$1, props, mergedClsPrefixRef);
          const triggerRef = ref(null);
          const triggerInnerRef = ref(null);
          const tooltipRef = ref(null);
          const expandedRef = ref(false);
          const ellipsisStyleRef = computed(() => {
              const { lineClamp } = props;
              const { value: expanded } = expandedRef;
              if (lineClamp !== undefined) {
                  return {
                      textOverflow: '',
                      '-webkit-line-clamp': expanded ? '' : lineClamp
                  };
              }
              else {
                  return {
                      textOverflow: expanded ? '' : 'ellipsis',
                      '-webkit-line-clamp': ''
                  };
              }
          });
          function getTooltipDisabled() {
              let tooltipDisabled = false;
              const { value: expanded } = expandedRef;
              if (expanded)
                  return true;
              const { value: trigger } = triggerRef;
              if (trigger) {
                  const { lineClamp } = props;
                  // we need to apply style here, since the dom may be updated in
                  // nextTick, measure dom size will derive wrong result
                  syncEllipsisStyle(trigger);
                  if (lineClamp !== undefined) {
                      tooltipDisabled = trigger.scrollHeight <= trigger.offsetHeight;
                  }
                  else {
                      const { value: triggerInner } = triggerInnerRef;
                      if (triggerInner) {
                          tooltipDisabled =
                              triggerInner.getBoundingClientRect().width <=
                                  trigger.getBoundingClientRect().width;
                      }
                  }
                  syncCursorStyle(trigger, tooltipDisabled);
              }
              return tooltipDisabled;
          }
          const handleClickRef = computed(() => {
              return props.expandTrigger === 'click'
                  ? () => {
                      var _a;
                      const { value: expanded } = expandedRef;
                      if (expanded) {
                          (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
                      }
                      expandedRef.value = !expanded;
                  }
                  : undefined;
          });
          onDeactivated(() => {
              var _a;
              if (props.tooltip) {
                  (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
              }
          });
          const renderTrigger = () => (h("span", Object.assign({}, mergeProps(attrs, {
              class: [
                  `${mergedClsPrefixRef.value}-ellipsis`,
                  props.lineClamp !== undefined
                      ? createLineClampClass(mergedClsPrefixRef.value)
                      : undefined,
                  props.expandTrigger === 'click'
                      ? createCursorClass(mergedClsPrefixRef.value, 'pointer')
                      : undefined
              ],
              style: ellipsisStyleRef.value
          }), { ref: "triggerRef", onClick: handleClickRef.value, onMouseenter: 
              // get tooltip disabled will derive cursor style
              props.expandTrigger === 'click' ? getTooltipDisabled : undefined }), props.lineClamp ? slots : h("span", { ref: "triggerInnerRef" }, slots)));
          function syncEllipsisStyle(trigger) {
              if (!trigger)
                  return;
              const latestStyle = ellipsisStyleRef.value;
              const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
              if (props.lineClamp !== undefined) {
                  syncTriggerClass(trigger, lineClampClass, 'add');
              }
              else {
                  syncTriggerClass(trigger, lineClampClass, 'remove');
              }
              for (const key in latestStyle) {
                  // guard can make it a little faster
                  if (trigger.style[key] !== latestStyle[key]) {
                      trigger.style[key] = latestStyle[key];
                  }
              }
          }
          function syncCursorStyle(trigger, tooltipDisabled) {
              const cursorClass = createCursorClass(mergedClsPrefixRef.value, 'pointer');
              if (props.expandTrigger === 'click' && !tooltipDisabled) {
                  syncTriggerClass(trigger, cursorClass, 'add');
              }
              else {
                  syncTriggerClass(trigger, cursorClass, 'remove');
              }
          }
          function syncTriggerClass(trigger, styleClass, action) {
              if (action === 'add') {
                  if (!trigger.classList.contains(styleClass)) {
                      trigger.classList.add(styleClass);
                  }
              }
              else {
                  if (trigger.classList.contains(styleClass)) {
                      trigger.classList.remove(styleClass);
                  }
              }
          }
          return {
              mergedTheme,
              triggerRef,
              triggerInnerRef,
              tooltipRef,
              handleClick: handleClickRef,
              renderTrigger,
              getTooltipDisabled
          };
      },
      render() {
          var _a;
          const { tooltip, renderTrigger, $slots } = this;
          if (tooltip) {
              const { mergedTheme } = this;
              return (h(NTooltip, Object.assign({ ref: "tooltipRef", placement: "top" }, tooltip, { getDisabled: this.getTooltipDisabled, theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip }), {
                  trigger: renderTrigger,
                  default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
              }));
          }
          else
              return renderTrigger();
      }
  });

  const NPerformantEllipsis = defineComponent({
      name: 'PerformantEllipsis',
      props: ellipsisProps,
      inheritAttrs: false,
      setup(props, { attrs, slots }) {
          const mouseEnteredRef = ref(false);
          const mergedClsPrefixRef = useMergedClsPrefix();
          useStyle('-ellipsis', style$_, mergedClsPrefixRef);
          // Modified from Ellipsis.tsx
          const renderTrigger = () => {
              const { lineClamp } = props;
              const mergedClsPrefix = mergedClsPrefixRef.value;
              return (h("span", Object.assign({}, mergeProps(attrs, {
                  class: [
                      `${mergedClsPrefix}-ellipsis`,
                      lineClamp !== undefined
                          ? createLineClampClass(mergedClsPrefix)
                          : undefined,
                      props.expandTrigger === 'click'
                          ? createCursorClass(mergedClsPrefix, 'pointer')
                          : undefined
                  ],
                  style: lineClamp === undefined
                      ? {
                          textOverflow: 'ellipsis'
                      }
                      : {
                          '-webkit-line-clamp': lineClamp
                      }
              }), { onMouseenter: () => {
                      mouseEnteredRef.value = true;
                  } }), lineClamp ? slots : h("span", null, slots)));
          };
          return {
              mouseEntered: mouseEnteredRef,
              renderTrigger
          };
      },
      render() {
          if (this.mouseEntered) {
              return h(NEllipsis, mergeProps({}, this.$attrs, this.$props), this.$slots);
          }
          else {
              return this.renderTrigger();
          }
      }
  });

  var RenderSorter = defineComponent({
      name: 'DataTableRenderSorter',
      props: {
          render: {
              type: Function,
              required: true
          },
          order: {
              // asc, desc
              type: [String, Boolean],
              default: false
          }
      },
      render() {
          const { render, order } = this;
          return render({
              order
          });
      }
  });

  const dataTableProps = Object.assign(Object.assign({}, useTheme.props), { onUnstableColumnResize: Function, pagination: {
          type: [Object, Boolean],
          default: false
      }, paginateSinglePage: {
          type: Boolean,
          default: true
      }, minHeight: [Number, String], maxHeight: [Number, String], 
      // Use any type as row data to make prop data acceptable
      columns: {
          type: Array,
          default: () => []
      }, rowClassName: [String, Function], rowProps: Function, rowKey: Function, summary: [Function], data: {
          type: Array,
          default: () => []
      }, loading: Boolean, bordered: {
          type: Boolean,
          default: undefined
      }, bottomBordered: {
          type: Boolean,
          default: undefined
      }, striped: Boolean, scrollX: [Number, String], defaultCheckedRowKeys: {
          type: Array,
          default: () => []
      }, checkedRowKeys: Array, singleLine: {
          type: Boolean,
          default: true
      }, singleColumn: Boolean, size: {
          type: String,
          default: 'medium'
      }, remote: Boolean, defaultExpandedRowKeys: {
          type: Array,
          default: []
      }, defaultExpandAll: Boolean, expandedRowKeys: Array, stickyExpandedRows: Boolean, virtualScroll: Boolean, tableLayout: {
          type: String,
          default: 'auto'
      }, allowCheckingNotLoaded: Boolean, cascade: {
          type: Boolean,
          default: true
      }, childrenKey: {
          type: String,
          default: 'children'
      }, indent: {
          type: Number,
          default: 16
      }, flexHeight: Boolean, summaryPlacement: {
          type: String,
          default: 'bottom'
      }, paginationBehaviorOnFilter: {
          type: String,
          default: 'current'
      }, scrollbarProps: Object, renderCell: Function, renderExpandIcon: Function, spinProps: { type: Object, default: {} }, onLoad: Function, 'onUpdate:page': [Function, Array], onUpdatePage: [Function, Array], 'onUpdate:pageSize': [Function, Array], onUpdatePageSize: [Function, Array], 'onUpdate:sorter': [Function, Array], onUpdateSorter: [Function, Array], 'onUpdate:filters': [Function, Array], onUpdateFilters: [Function, Array], 'onUpdate:checkedRowKeys': [Function, Array], onUpdateCheckedRowKeys: [Function, Array], 'onUpdate:expandedRowKeys': [Function, Array], onUpdateExpandedRowKeys: [Function, Array], onScroll: Function, 
      // deprecated
      onPageChange: [Function, Array], onPageSizeChange: [Function, Array], onSorterChange: [Function, Array], onFiltersChange: [Function, Array], onCheckedRowKeysChange: [Function, Array] });
  const dataTableInjectionKey = createInjectionKey('n-data-table');

  var SortButton = defineComponent({
      name: 'SortIcon',
      props: {
          column: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          const { mergedComponentPropsRef } = useConfig();
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedSortStateRef, mergedClsPrefixRef } = inject(dataTableInjectionKey);
          const sortStateRef = computed(() => mergedSortStateRef.value.find((state) => state.columnKey === props.column.key));
          const activeRef = computed(() => {
              return sortStateRef.value !== undefined;
          });
          const mergedSortOrderRef = computed(() => {
              const { value: sortState } = sortStateRef;
              if (sortState && activeRef.value) {
                  return sortState.order;
              }
              return false;
          });
          const mergedRenderSorterRef = computed(() => {
              var _a, _b;
              return (((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderSorter) ||
                  props.column.renderSorter);
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              active: activeRef,
              mergedSortOrder: mergedSortOrderRef,
              mergedRenderSorter: mergedRenderSorterRef
          };
      },
      render() {
          const { mergedRenderSorter, mergedSortOrder, mergedClsPrefix } = this;
          const { renderSorterIcon } = this.column;
          return mergedRenderSorter ? (h(RenderSorter, { render: mergedRenderSorter, order: mergedSortOrder })) : (h("span", { class: [
                  `${mergedClsPrefix}-data-table-sorter`,
                  mergedSortOrder === 'ascend' &&
                      `${mergedClsPrefix}-data-table-sorter--asc`,
                  mergedSortOrder === 'descend' &&
                      `${mergedClsPrefix}-data-table-sorter--desc`
              ] }, renderSorterIcon ? (renderSorterIcon({ order: mergedSortOrder })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ArrowDownIcon, null) }))));
      }
  });

  var RenderFilter = defineComponent({
      name: 'DataTableRenderFilter',
      props: {
          render: {
              type: Function,
              required: true
          },
          active: {
              type: Boolean,
              default: false
          },
          show: {
              type: Boolean,
              default: false
          }
      },
      render() {
          const { render, active, show } = this;
          return render({
              active,
              show
          });
      }
  });

  const radioBaseProps = {
      name: String,
      value: {
          type: [String, Number, Boolean],
          default: 'on'
      },
      checked: {
          type: Boolean,
          default: undefined
      },
      defaultChecked: Boolean,
      disabled: {
          type: Boolean,
          default: undefined
      },
      label: String,
      size: String,
      onUpdateChecked: [Function, Array],
      'onUpdate:checked': [Function, Array],
      // deprecated
      checkedValue: {
          type: Boolean,
          default: undefined
      }
  };
  const radioGroupInjectionKey = createInjectionKey('n-radio-group');
  function setup(props) {
      const formItem = useFormItem(props, {
          mergedSize(NFormItem) {
              const { size } = props;
              if (size !== undefined)
                  return size;
              if (NRadioGroup) {
                  const { mergedSizeRef: { value: mergedSize } } = NRadioGroup;
                  if (mergedSize !== undefined) {
                      return mergedSize;
                  }
              }
              if (NFormItem) {
                  return NFormItem.mergedSize.value;
              }
              return 'medium';
          },
          mergedDisabled(NFormItem) {
              if (props.disabled)
                  return true;
              if (NRadioGroup === null || NRadioGroup === void 0 ? void 0 : NRadioGroup.disabledRef.value)
                  return true;
              if (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.disabled.value)
                  return true;
              return false;
          }
      });
      const { mergedSizeRef, mergedDisabledRef } = formItem;
      const inputRef = ref(null);
      const labelRef = ref(null);
      const NRadioGroup = inject(radioGroupInjectionKey, null);
      const uncontrolledCheckedRef = ref(props.defaultChecked);
      const controlledCheckedRef = toRef(props, 'checked');
      const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
      const renderSafeCheckedRef = useMemo(() => {
          if (NRadioGroup)
              return NRadioGroup.valueRef.value === props.value;
          return mergedCheckedRef.value;
      });
      const mergedNameRef = useMemo(() => {
          const { name } = props;
          if (name !== undefined)
              return name;
          if (NRadioGroup)
              return NRadioGroup.nameRef.value;
      });
      const focusRef = ref(false);
      function doUpdateChecked() {
          if (NRadioGroup) {
              const { doUpdateValue } = NRadioGroup;
              const { value } = props;
              call(doUpdateValue, value);
          }
          else {
              const { onUpdateChecked, 'onUpdate:checked': _onUpdateChecked } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateChecked)
                  call(onUpdateChecked, true);
              if (_onUpdateChecked)
                  call(_onUpdateChecked, true);
              nTriggerFormInput();
              nTriggerFormChange();
              uncontrolledCheckedRef.value = true;
          }
      }
      function toggle() {
          if (mergedDisabledRef.value)
              return;
          if (!renderSafeCheckedRef.value) {
              doUpdateChecked();
          }
      }
      function handleRadioInputChange() {
          toggle();
      }
      function handleRadioInputBlur() {
          focusRef.value = false;
      }
      function handleRadioInputFocus() {
          focusRef.value = true;
      }
      return {
          mergedClsPrefix: NRadioGroup
              ? NRadioGroup.mergedClsPrefixRef
              : useConfig(props).mergedClsPrefixRef,
          inputRef,
          labelRef,
          mergedName: mergedNameRef,
          mergedDisabled: mergedDisabledRef,
          uncontrolledChecked: uncontrolledCheckedRef,
          renderSafeChecked: renderSafeCheckedRef,
          focus: focusRef,
          mergedSize: mergedSizeRef,
          handleRadioInputChange,
          handleRadioInputBlur,
          handleRadioInputFocus
      };
  }

  // vars:
  // --n-bezier
  // --n-box-shadow
  // --n-box-shadow-active
  // --n-box-shadow-disabled
  // --n-box-shadow-focus
  // --n-box-shadow-hover
  // --n-color
  // --n-color-disabled
  // --n-dot-color-active
  // --n-dot-color-disabled
  // --n-font-size
  // --n-radio-size
  // --n-text-color
  // --n-text-color-disabled
  // --n-label-padding
  // --n-label-line-height
  // --n-color-active
  var style$Z = cB('radio', `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM('checked', [cE('dot', `
 background-color: var(--n-color-active);
 `)]), cE('dot-wrapper', `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB('radio-input', `
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 cursor: pointer;
 `), cE('dot', `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c$1('&::before', `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM('checked', {
    boxShadow: 'var(--n-box-shadow-active)'
  }, [c$1('&::before', `
 opacity: 1;
 transform: scale(1);
 `)])]), cE('label', `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM('disabled', `
 cursor: pointer;
 `, [c$1('&:hover', [cE('dot', {
    boxShadow: 'var(--n-box-shadow-hover)'
  })]), cM('focus', [c$1('&:not(:active)', [cE('dot', {
    boxShadow: 'var(--n-box-shadow-focus)'
  })])])]), cM('disabled', `
 cursor: not-allowed;
 `, [cE('dot', {
    boxShadow: 'var(--n-box-shadow-disabled)',
    backgroundColor: 'var(--n-color-disabled)'
  }, [c$1('&::before', {
    backgroundColor: 'var(--n-dot-color-disabled)'
  }), cM('checked', `
 opacity: 1;
 `)]), cE('label', {
    color: 'var(--n-text-color-disabled)'
  }), cB('radio-input', `
 cursor: not-allowed;
 `)])]);

  const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
  var NRadio = defineComponent({
      name: 'Radio',
      props: radioProps,
      setup(props) {
          const radio = setup(props);
          const themeRef = useTheme('Radio', '-radio', style$Z, radioLight$1, props, radio.mergedClsPrefix);
          const cssVarsRef = computed(() => {
              const { mergedSize: { value: size } } = radio;
              const { common: { cubicBezierEaseInOut }, self: { boxShadow, boxShadowActive, boxShadowDisabled, boxShadowFocus, boxShadowHover, color, colorDisabled, colorActive, textColor, textColorDisabled, dotColorActive, dotColorDisabled, labelPadding, labelLineHeight, labelFontWeight, [createKey('fontSize', size)]: fontSize, [createKey('radioSize', size)]: radioSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-label-line-height': labelLineHeight,
                  '--n-label-font-weight': labelFontWeight,
                  '--n-box-shadow': boxShadow,
                  '--n-box-shadow-active': boxShadowActive,
                  '--n-box-shadow-disabled': boxShadowDisabled,
                  '--n-box-shadow-focus': boxShadowFocus,
                  '--n-box-shadow-hover': boxShadowHover,
                  '--n-color': color,
                  '--n-color-active': colorActive,
                  '--n-color-disabled': colorDisabled,
                  '--n-dot-color-active': dotColorActive,
                  '--n-dot-color-disabled': dotColorDisabled,
                  '--n-font-size': fontSize,
                  '--n-radio-size': radioSize,
                  '--n-text-color': textColor,
                  '--n-text-color-disabled': textColorDisabled,
                  '--n-label-padding': labelPadding
              };
          });
          const { inlineThemeDisabled, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('Radio', mergedRtlRef, mergedClsPrefixRef);
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('radio', computed(() => radio.mergedSize.value[0]), cssVarsRef, props)
              : undefined;
          return Object.assign(radio, {
              rtlEnabled: rtlEnabledRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
      },
      render() {
          const { $slots, mergedClsPrefix, onRender, label } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("label", { class: [
                  `${mergedClsPrefix}-radio`,
                  this.themeClass,
                  {
                      [`${mergedClsPrefix}-radio--rtl`]: this.rtlEnabled,
                      [`${mergedClsPrefix}-radio--disabled`]: this.mergedDisabled,
                      [`${mergedClsPrefix}-radio--checked`]: this.renderSafeChecked,
                      [`${mergedClsPrefix}-radio--focus`]: this.focus
                  }
              ], style: this.cssVars },
              h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
              h("div", { class: `${mergedClsPrefix}-radio__dot-wrapper` },
                  "\u00A0",
                  h("div", { class: [
                          `${mergedClsPrefix}-radio__dot`,
                          this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`
                      ] })),
              resolveWrappedSlot($slots.default, (children) => {
                  if (!children && !label)
                      return null;
                  return (h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || label));
              })));
      }
  });

  // vars:
  // --n-bezier
  // --n-button-border-color
  // --n-button-border-color-active
  // --n-height
  // --n-opacity-disabled
  // --n-font-size
  var style$Y = cB('radio-group', `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE('splitor', `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM('checked', {
    backgroundColor: 'var(--n-button-border-color-active)'
  }), cM('disabled', {
    opacity: 'var(--n-opacity-disabled)'
  })]), cM('button-group', `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB('radio-button', {
    height: 'var(--n-height)',
    lineHeight: 'var(--n-height)'
  }), cE('splitor', {
    height: 'var(--n-height)'
  })]), cB('radio-button', `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB('radio-input', `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE('state-border', `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c$1('&:first-child', `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE('state-border', `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c$1('&:last-child', `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE('state-border', `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM('disabled', `
 cursor: pointer;
 `, [c$1('&:hover', [cE('state-border', `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM('checked', {
    color: 'var(--n-button-text-color-hover)'
  })]), cM('focus', [c$1('&:not(:active)', [cE('state-border', {
    boxShadow: 'var(--n-button-box-shadow-focus)'
  })])])]), cM('checked', `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM('disabled', `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);

  function mapSlot(defaultSlot, value, clsPrefix) {
      var _a;
      const children = [];
      let isButtonGroup = false;
      for (let i = 0; i < defaultSlot.length; ++i) {
          const wrappedInstance = defaultSlot[i];
          const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
          if (name === 'RadioButton') {
              isButtonGroup = true;
          }
          const instanceProps = wrappedInstance.props;
          if (name !== 'RadioButton') {
              children.push(wrappedInstance);
              continue;
          }
          if (i === 0) {
              children.push(wrappedInstance);
          }
          else {
              const lastInstanceProps = children[children.length - 1]
                  .props;
              const lastInstanceChecked = value === lastInstanceProps.value;
              const lastInstanceDisabled = lastInstanceProps.disabled;
              const currentInstanceChecked = value === instanceProps.value;
              const currentInstanceDisabled = instanceProps.disabled;
              /**
               * Priority of button splitor:
               * !disabled  checked >
               *  disabled  checked >
               * !disabled !checked >
               *  disabled !checked
               */
              const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
              const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
              const lastInstanceClass = {
                  [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
                  [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
              };
              const currentInstanceClass = {
                  [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
                  [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
              };
              const splitorClass = lastInstancePriority < currentInstancePriority
                  ? currentInstanceClass
                  : lastInstanceClass;
              children.push(h("div", { class: [`${clsPrefix}-radio-group__splitor`, splitorClass] }), wrappedInstance);
          }
      }
      return {
          children,
          isButtonGroup
      };
  }
  const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), { name: String, value: [String, Number, Boolean], defaultValue: {
          type: [String, Number, Boolean],
          default: null
      }, size: String, disabled: {
          type: Boolean,
          default: undefined
      }, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array] });
  var NRadioGroup = defineComponent({
      name: 'RadioGroup',
      props: radioGroupProps,
      setup(props) {
          const selfElRef = ref(null);
          const { mergedSizeRef, mergedDisabledRef, nTriggerFormChange, nTriggerFormInput, nTriggerFormBlur, nTriggerFormFocus } = useFormItem(props);
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Radio', '-radio-group', style$Y, radioLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              if (onUpdateValue) {
                  call(onUpdateValue, value);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value);
              }
              uncontrolledValueRef.value = value;
              nTriggerFormChange();
              nTriggerFormInput();
          }
          function handleFocusin(e) {
              const { value: selfEl } = selfElRef;
              if (!selfEl)
                  return;
              if (selfEl.contains(e.relatedTarget))
                  return;
              nTriggerFormFocus();
          }
          function handleFocusout(e) {
              const { value: selfEl } = selfElRef;
              if (!selfEl)
                  return;
              if (selfEl.contains(e.relatedTarget))
                  return;
              nTriggerFormBlur();
          }
          provide(radioGroupInjectionKey, {
              mergedClsPrefixRef,
              nameRef: toRef(props, 'name'),
              valueRef: mergedValueRef,
              disabledRef: mergedDisabledRef,
              mergedSizeRef,
              doUpdateValue
          });
          const rtlEnabledRef = useRtl('Radio', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { value: size } = mergedSizeRef;
              const { common: { cubicBezierEaseInOut }, self: { buttonBorderColor, buttonBorderColorActive, buttonBorderRadius, buttonBoxShadow, buttonBoxShadowFocus, buttonBoxShadowHover, buttonColor, buttonColorActive, buttonTextColor, buttonTextColorActive, buttonTextColorHover, opacityDisabled, [createKey('buttonHeight', size)]: height, [createKey('fontSize', size)]: fontSize } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-button-border-color': buttonBorderColor,
                  '--n-button-border-color-active': buttonBorderColorActive,
                  '--n-button-border-radius': buttonBorderRadius,
                  '--n-button-box-shadow': buttonBoxShadow,
                  '--n-button-box-shadow-focus': buttonBoxShadowFocus,
                  '--n-button-box-shadow-hover': buttonBoxShadowHover,
                  '--n-button-color': buttonColor,
                  '--n-button-color-active': buttonColorActive,
                  '--n-button-text-color': buttonTextColor,
                  '--n-button-text-color-hover': buttonTextColorHover,
                  '--n-button-text-color-active': buttonTextColorActive,
                  '--n-height': height,
                  '--n-opacity-disabled': opacityDisabled
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('radio-group', computed(() => mergedSizeRef.value[0]), cssVarsRef, props)
              : undefined;
          return {
              selfElRef,
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedValue: mergedValueRef,
              handleFocusout,
              handleFocusin,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedValue, mergedClsPrefix, handleFocusin, handleFocusout } = this;
          const { children, isButtonGroup } = mapSlot(flatten$3(getSlot$1(this)), mergedValue, mergedClsPrefix);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { onFocusin: handleFocusin, onFocusout: handleFocusout, ref: "selfElRef", class: [
                  `${mergedClsPrefix}-radio-group`,
                  this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`,
                  this.themeClass,
                  isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`
              ], style: this.cssVars }, children));
      }
  });

  const radioButtonProps = radioBaseProps;
  var RadioButton = defineComponent({
      name: 'RadioButton',
      props: radioBaseProps,
      setup,
      render() {
          const { mergedClsPrefix } = this;
          return (h("label", { class: [
                  `${mergedClsPrefix}-radio-button`,
                  this.mergedDisabled && `${mergedClsPrefix}-radio-button--disabled`,
                  this.renderSafeChecked && `${mergedClsPrefix}-radio-button--checked`,
                  this.focus && [`${mergedClsPrefix}-radio-button--focus`]
              ] },
              h("input", { ref: "inputRef", type: "radio", class: `${mergedClsPrefix}-radio-input`, value: this.value, name: this.mergedName, checked: this.renderSafeChecked, disabled: this.mergedDisabled, onChange: this.handleRadioInputChange, onFocus: this.handleRadioInputFocus, onBlur: this.handleRadioInputBlur }),
              h("div", { class: `${mergedClsPrefix}-radio-button__state-border` }),
              resolveWrappedSlot(this.$slots.default, (children) => {
                  if (!children && !this.label)
                      return null;
                  return (h("div", { ref: "labelRef", class: `${mergedClsPrefix}-radio__label` }, children || this.label));
              })));
      }
  });

  const SELECTION_COL_WIDTH = 40;
  const EXPAND_COL_WIDTH = 40;
  function getNumberColWidth(col) {
      if (col.type === 'selection') {
          return col.width === undefined ? SELECTION_COL_WIDTH : depx(col.width);
      }
      if (col.type === 'expand') {
          return col.width === undefined ? EXPAND_COL_WIDTH : depx(col.width);
      }
      if ('children' in col)
          return undefined;
      if (typeof col.width === 'string') {
          return depx(col.width);
      }
      return col.width;
  }
  function getStringColWidth(col) {
      var _a, _b;
      if (col.type === 'selection') {
          return formatLength((_a = col.width) !== null && _a !== void 0 ? _a : SELECTION_COL_WIDTH);
      }
      if (col.type === 'expand') {
          return formatLength((_b = col.width) !== null && _b !== void 0 ? _b : EXPAND_COL_WIDTH);
      }
      if ('children' in col) {
          return undefined;
      }
      return formatLength(col.width);
  }
  function getColKey(col) {
      if (col.type === 'selection')
          return '__n_selection__';
      if (col.type === 'expand')
          return '__n_expand__';
      return col.key;
  }
  function createShallowClonedObject(object) {
      if (!object)
          return object;
      if (typeof object === 'object') {
          return Object.assign({}, object);
      }
      return object;
  }
  function getFlagOfOrder(order) {
      if (order === 'ascend')
          return 1;
      else if (order === 'descend')
          return -1;
      return 0;
  }
  // priority: min-width > max-width > width
  function clampValueFollowCSSRules(value, min, max) {
      if (max !== undefined) {
          value = Math.min(value, typeof max === 'number' ? max : parseFloat(max));
      }
      if (min !== undefined) {
          value = Math.max(value, typeof min === 'number' ? min : parseFloat(min));
      }
      return value;
  }
  function createCustomWidthStyle(column, resizedWidth) {
      if (resizedWidth !== undefined) {
          return {
              width: resizedWidth,
              minWidth: resizedWidth,
              maxWidth: resizedWidth
          };
      }
      const width = getStringColWidth(column);
      const { minWidth, maxWidth } = column;
      return {
          width,
          minWidth: formatLength(minWidth) || width,
          maxWidth: formatLength(maxWidth)
      };
  }
  function createRowClassName(row, index, rowClassName) {
      if (typeof rowClassName === 'function')
          return rowClassName(row, index);
      return rowClassName || '';
  }
  // for compatibility
  // If column.filterOptionValues or column.defaultFilterOptionValues is set, use
  // array value
  function shouldUseArrayInSingleMode(column) {
      return (column.filterOptionValues !== undefined ||
          (column.filterOptionValue === undefined &&
              column.defaultFilterOptionValues !== undefined));
  }
  function isColumnSortable(column) {
      if ('children' in column)
          return false;
      return !!column.sorter;
  }
  function isColumnResizable(column) {
      if ('children' in column && !!column.children.length)
          return false;
      return !!column.resizable;
  }
  function isColumnFilterable(column) {
      if ('children' in column)
          return false;
      return (!!column.filter && (!!column.filterOptions || !!column.renderFilterMenu));
  }
  function getNextOrderOf(order) {
      if (!order)
          return 'descend';
      else if (order === 'descend')
          return 'ascend';
      return false;
  }
  function createNextSorter(column, currentSortState) {
      if (column.sorter === undefined)
          return null;
      if (currentSortState === null || currentSortState.columnKey !== column.key) {
          return {
              columnKey: column.key,
              sorter: column.sorter,
              order: getNextOrderOf(false)
          };
      }
      else {
          return Object.assign(Object.assign({}, currentSortState), { order: getNextOrderOf(currentSortState.order) });
      }
  }
  function isColumnSorting(column, mergedSortState) {
      return (mergedSortState.find((state) => state.columnKey === column.key && state.order) !== undefined);
  }

  var NDataTableFilterMenu = defineComponent({
      name: 'DataTableFilterMenu',
      props: {
          column: {
              type: Object,
              required: true
          },
          radioGroupName: {
              type: String,
              required: true
          },
          multiple: {
              type: Boolean,
              required: true
          },
          value: {
              type: [Array, String, Number],
              default: null
          },
          options: {
              type: Array,
              required: true
          },
          onConfirm: {
              type: Function,
              required: true
          },
          onClear: {
              type: Function,
              required: true
          },
          onChange: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const { mergedClsPrefixRef, mergedThemeRef, localeRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          // to be compared with changed value
          // const initialValueRef = ref(props.value)
          const temporalValueRef = ref(props.value);
          const checkboxGroupValueRef = computed(() => {
              const { value: temporalValue } = temporalValueRef;
              if (!Array.isArray(temporalValue))
                  return null;
              return temporalValue;
          });
          const radioGroupValueRef = computed(() => {
              const { value: temporalValue } = temporalValueRef;
              if (shouldUseArrayInSingleMode(props.column)) {
                  return ((Array.isArray(temporalValue) &&
                      temporalValue.length &&
                      temporalValue[0]) ||
                      null);
              }
              if (!Array.isArray(temporalValue))
                  return temporalValue;
              return null;
          });
          function doChange(value) {
              props.onChange(value);
          }
          function handleChange(value) {
              if (props.multiple && Array.isArray(value)) {
                  temporalValueRef.value = value;
              }
              else if (shouldUseArrayInSingleMode(props.column) &&
                  !Array.isArray(value)) {
                  /** this branch is for compatibility */
                  temporalValueRef.value = [value];
              }
              else {
                  temporalValueRef.value = value;
              }
          }
          function handleConfirmClick() {
              doChange(temporalValueRef.value);
              props.onConfirm();
          }
          function handleClearClick() {
              if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
                  doChange([]);
              }
              else {
                  doChange(null);
              }
              props.onClear();
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef,
              locale: localeRef,
              checkboxGroupValue: checkboxGroupValueRef,
              radioGroupValue: radioGroupValueRef,
              handleChange,
              handleConfirmClick,
              handleClearClick
          };
      },
      render() {
          const { mergedTheme, locale, mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-data-table-filter-menu` },
              h(NScrollbar, null, {
                  default: () => {
                      const { checkboxGroupValue, handleChange } = this;
                      return this.multiple ? (h(NCheckboxGroup, { value: checkboxGroupValue, class: `${mergedClsPrefix}-data-table-filter-menu__group`, onUpdateValue: handleChange }, {
                          default: () => this.options.map((option) => {
                              return (h(NCheckbox, { key: option.value, theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, value: option.value }, { default: () => option.label }));
                          })
                      })) : (h(NRadioGroup, { name: this.radioGroupName, class: `${mergedClsPrefix}-data-table-filter-menu__group`, value: this.radioGroupValue, onUpdateValue: this.handleChange }, {
                          default: () => this.options.map((option) => (h(NRadio, { key: option.value, value: option.value, theme: mergedTheme.peers.Radio, themeOverrides: mergedTheme.peerOverrides.Radio }, { default: () => option.label })))
                      }));
                  }
              }),
              h("div", { class: `${mergedClsPrefix}-data-table-filter-menu__action` },
                  h(NButton, { size: "tiny", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleClearClick }, { default: () => locale.clear }),
                  h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, type: "primary", size: "tiny", onClick: this.handleConfirmClick }, { default: () => locale.confirm }))));
      }
  });

  function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
      const nextFilterState = Object.assign({}, currentFilterState);
      nextFilterState[columnKey] = mergedFilterValue;
      return nextFilterState;
  }
  var FilterButton = defineComponent({
      name: 'DataTableFilterButton',
      props: {
          column: {
              type: Object,
              required: true
          },
          options: {
              type: Array,
              default: () => []
          }
      },
      setup(props) {
          const { mergedComponentPropsRef } = useConfig();
          const { mergedThemeRef, mergedClsPrefixRef, mergedFilterStateRef, filterMenuCssVarsRef, paginationBehaviorOnFilterRef, doUpdatePage, doUpdateFilters
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          const showPopoverRef = ref(false);
          const filterStateRef = mergedFilterStateRef;
          const filterMultipleRef = computed(() => {
              return props.column.filterMultiple !== false;
          });
          const mergedFilterValueRef = computed(() => {
              const filterValue = filterStateRef.value[props.column.key];
              if (filterValue === undefined) {
                  const { value: multiple } = filterMultipleRef;
                  if (multiple)
                      return [];
                  else
                      return null;
              }
              return filterValue;
          });
          const activeRef = computed(() => {
              const { value: filterValue } = mergedFilterValueRef;
              if (Array.isArray(filterValue)) {
                  return filterValue.length > 0;
              }
              return filterValue !== null;
          });
          const mergedRenderFilterRef = computed(() => {
              var _a, _b;
              return (((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderFilter) ||
                  props.column.renderFilter);
          });
          function handleFilterChange(mergedFilterValue) {
              const nextFilterState = createFilterState(filterStateRef.value, props.column.key, mergedFilterValue);
              doUpdateFilters(nextFilterState, props.column);
              if (paginationBehaviorOnFilterRef.value === 'first') {
                  doUpdatePage(1);
              }
          }
          function handleFilterMenuCancel() {
              showPopoverRef.value = false;
          }
          function handleFilterMenuConfirm() {
              showPopoverRef.value = false;
          }
          return {
              mergedTheme: mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              active: activeRef,
              showPopover: showPopoverRef,
              mergedRenderFilter: mergedRenderFilterRef,
              filterMultiple: filterMultipleRef,
              mergedFilterValue: mergedFilterValueRef,
              filterMenuCssVars: filterMenuCssVarsRef,
              handleFilterChange,
              handleFilterMenuConfirm,
              handleFilterMenuCancel
          };
      },
      render() {
          const { mergedTheme, mergedClsPrefix, handleFilterMenuCancel } = this;
          return (h(NPopover, { show: this.showPopover, onUpdateShow: (v) => (this.showPopover = v), trigger: "click", theme: mergedTheme.peers.Popover, themeOverrides: mergedTheme.peerOverrides.Popover, placement: "bottom", style: { padding: 0 } }, {
              trigger: () => {
                  const { mergedRenderFilter } = this;
                  if (mergedRenderFilter) {
                      return (h(RenderFilter, { "data-data-table-filter": true, render: mergedRenderFilter, active: this.active, show: this.showPopover }));
                  }
                  const { renderFilterIcon } = this.column;
                  return (h("div", { "data-data-table-filter": true, class: [
                          `${mergedClsPrefix}-data-table-filter`,
                          {
                              [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
                              [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
                          }
                      ] }, renderFilterIcon ? (renderFilterIcon({
                      active: this.active,
                      show: this.showPopover
                  })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(FilterIcon, null) }))));
              },
              default: () => {
                  const { renderFilterMenu } = this.column;
                  return renderFilterMenu ? (renderFilterMenu({ hide: handleFilterMenuCancel })) : (h(NDataTableFilterMenu, { style: this.filterMenuCssVars, radioGroupName: String(this.column.key), multiple: this.filterMultiple, value: this.mergedFilterValue, options: this.options, column: this.column, onChange: this.handleFilterChange, onClear: this.handleFilterMenuCancel, onConfirm: this.handleFilterMenuConfirm }));
              }
          }));
      }
  });

  var ResizeButton = defineComponent({
      name: 'ColumnResizeButton',
      props: {
          onResizeStart: Function,
          onResize: Function,
          onResizeEnd: Function
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedClsPrefixRef } = inject(dataTableInjectionKey);
          const activeRef = ref(false);
          let startX = 0;
          function getMouseX(e) {
              return e.clientX;
          }
          function handleMousedown(e) {
              var _a;
              e.preventDefault();
              const alreadyStarted = activeRef.value;
              startX = getMouseX(e);
              activeRef.value = true;
              if (!alreadyStarted) {
                  on('mousemove', window, handleMousemove);
                  on('mouseup', window, handleMouseup);
                  (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(props);
              }
          }
          function handleMousemove(e) {
              var _a;
              (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, getMouseX(e) - startX);
          }
          function handleMouseup() {
              var _a;
              activeRef.value = false;
              (_a = props.onResizeEnd) === null || _a === void 0 ? void 0 : _a.call(props);
              off('mousemove', window, handleMousemove);
              off('mouseup', window, handleMouseup);
          }
          onBeforeUnmount(() => {
              off('mousemove', window, handleMousemove);
              off('mouseup', window, handleMouseup);
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              active: activeRef,
              handleMousedown
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("span", { "data-data-table-resizable": true, class: [
                  `${mergedClsPrefix}-data-table-resize-button`,
                  this.active && `${mergedClsPrefix}-data-table-resize-button--active`
              ], onMousedown: this.handleMousedown }));
      }
  });

  var NDropdownDivider = defineComponent({
      name: 'DropdownDivider',
      props: {
          clsPrefix: {
              type: String,
              required: true
          }
      },
      render() {
          return h("div", { class: `${this.clsPrefix}-dropdown-divider` });
      }
  });

  const self$K = (vars) => {
      const { textColorBase, opacity1, opacity2, opacity3, opacity4, opacity5 } = vars;
      return {
          color: textColorBase,
          opacity1Depth: opacity1,
          opacity2Depth: opacity2,
          opacity3Depth: opacity3,
          opacity4Depth: opacity4,
          opacity5Depth: opacity5
      };
  };
  const iconLight = {
      name: 'Icon',
      common: commonLight,
      self: self$K
  };
  var iconLight$1 = iconLight;

  // vars:
  // --n-bezier
  // --n-color
  // --n-opacity
  var style$X = cB('icon', `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
 transform: translateZ(0);
`, [cM('color-transition', {
    transition: 'color .3s var(--n-bezier)'
  }), cM('depth', {
    color: 'var(--n-color)'
  }, [c$1('svg', {
    opacity: 'var(--n-opacity)',
    transition: 'opacity .3s var(--n-bezier)'
  })]), c$1('svg', {
    height: '1em',
    width: '1em'
  })]);

  const iconProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number], size: [Number, String], color: String, component: Object });
  const NIcon = defineComponent({
      _n_icon__: true,
      name: 'Icon',
      inheritAttrs: false,
      props: iconProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Icon', '-icon', style$X, iconLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { depth } = props;
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              if (depth !== undefined) {
                  const { color, [`opacity${depth}Depth`]: opacity } = self;
                  return {
                      '--n-bezier': cubicBezierEaseInOut,
                      '--n-color': color,
                      '--n-opacity': opacity
                  };
              }
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color': '',
                  '--n-opacity': ''
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('icon', computed(() => `${props.depth || 'd'}`), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedStyle: computed(() => {
                  const { size, color } = props;
                  return {
                      fontSize: formatLength(size),
                      color
                  };
              }),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { $parent, depth, mergedClsPrefix, component, onRender, themeClass } = this;
          if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
              warn$2('icon', "don't wrap `n-icon` inside `n-icon`");
          }
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return h('i', mergeProps(this.$attrs, {
              role: 'img',
              class: [
                  `${mergedClsPrefix}-icon`,
                  themeClass,
                  {
                      [`${mergedClsPrefix}-icon--depth`]: depth,
                      [`${mergedClsPrefix}-icon--color-transition`]: depth !== undefined
                  }
              ],
              style: [this.cssVars, this.mergedStyle]
          }), component ? h(component) : this.$slots);
      }
  });

  const dropdownMenuInjectionKey = createInjectionKey('n-dropdown-menu');
  const dropdownInjectionKey = createInjectionKey('n-dropdown');
  const dropdownOptionInjectionKey = createInjectionKey('n-dropdown-option');

  function isSubmenuNode(rawNode, childrenField) {
      return (rawNode.type === 'submenu' ||
          (rawNode.type === undefined && rawNode[childrenField] !== undefined));
  }
  function isGroupNode(rawNode) {
      return rawNode.type === 'group';
  }
  function isDividerNode$1(rawNode) {
      return rawNode.type === 'divider';
  }
  function isRenderNode(rawNode) {
      return rawNode.type === 'render';
  }

  var NDropdownOption = defineComponent({
      name: 'DropdownOption',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          },
          parentKey: {
              type: [String, Number],
              default: null
          },
          placement: {
              type: String,
              default: 'right-start'
          },
          props: Object,
          scrollable: Boolean
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NDropdown = inject(dropdownInjectionKey);
          const { hoverKeyRef, keyboardKeyRef, lastToggledSubmenuKeyRef, pendingKeyPathRef, activeKeyPathRef, animatedRef, mergedShowRef, renderLabelRef, renderIconRef, labelFieldRef, childrenFieldRef, renderOptionRef, nodePropsRef, menuPropsRef } = NDropdown;
          const NDropdownOption = inject(dropdownOptionInjectionKey, null);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NDropdownMenu = inject(dropdownMenuInjectionKey);
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NPopoverBody = inject(popoverBodyInjectionKey);
          const rawNodeRef = computed(() => props.tmNode.rawNode);
          const hasSubmenuRef = computed(() => {
              const { value: childrenField } = childrenFieldRef;
              return isSubmenuNode(props.tmNode.rawNode, childrenField);
          });
          const mergedDisabledRef = computed(() => {
              const { disabled } = props.tmNode;
              return disabled;
          });
          const showSubmenuRef = computed(() => {
              if (!hasSubmenuRef.value)
                  return false;
              const { key, disabled } = props.tmNode;
              if (disabled)
                  return false;
              const { value: hoverKey } = hoverKeyRef;
              const { value: keyboardKey } = keyboardKeyRef;
              const { value: lastToggledSubmenuKey } = lastToggledSubmenuKeyRef;
              const { value: pendingKeyPath } = pendingKeyPathRef;
              if (hoverKey !== null)
                  return pendingKeyPath.includes(key);
              if (keyboardKey !== null) {
                  return (pendingKeyPath.includes(key) &&
                      pendingKeyPath[pendingKeyPath.length - 1] !== key);
              }
              if (lastToggledSubmenuKey !== null)
                  return pendingKeyPath.includes(key);
              return false;
          });
          const shouldDelayRef = computed(() => {
              return keyboardKeyRef.value === null && !animatedRef.value;
          });
          const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
          const parentEnteringSubmenuRef = computed(() => {
              return !!(NDropdownOption === null || NDropdownOption === void 0 ? void 0 : NDropdownOption.enteringSubmenuRef.value);
          });
          const enteringSubmenuRef = ref(false);
          provide(dropdownOptionInjectionKey, {
              enteringSubmenuRef
          });
          // methods
          function handleSubmenuBeforeEnter() {
              enteringSubmenuRef.value = true;
          }
          function handleSubmenuAfterEnter() {
              enteringSubmenuRef.value = false;
          }
          function handleMouseEnter() {
              const { parentKey, tmNode } = props;
              if (tmNode.disabled)
                  return;
              if (!mergedShowRef.value)
                  return;
              lastToggledSubmenuKeyRef.value = parentKey;
              keyboardKeyRef.value = null;
              hoverKeyRef.value = tmNode.key;
          }
          function handleMouseMove() {
              const { tmNode } = props;
              if (tmNode.disabled)
                  return;
              if (!mergedShowRef.value)
                  return;
              if (hoverKeyRef.value === tmNode.key)
                  return;
              handleMouseEnter();
          }
          function handleMouseLeave(e) {
              if (props.tmNode.disabled)
                  return;
              if (!mergedShowRef.value)
                  return;
              const { relatedTarget } = e;
              if (relatedTarget &&
                  !happensIn({ target: relatedTarget }, 'dropdownOption') &&
                  !happensIn({ target: relatedTarget }, 'scrollbarRail')) {
                  hoverKeyRef.value = null;
              }
          }
          function handleClick() {
              const { value: hasSubmenu } = hasSubmenuRef;
              const { tmNode } = props;
              if (!mergedShowRef.value)
                  return;
              if (!hasSubmenu && !tmNode.disabled) {
                  NDropdown.doSelect(tmNode.key, tmNode.rawNode);
                  NDropdown.doUpdateShow(false);
              }
          }
          return {
              labelField: labelFieldRef,
              renderLabel: renderLabelRef,
              renderIcon: renderIconRef,
              siblingHasIcon: NDropdownMenu.showIconRef,
              siblingHasSubmenu: NDropdownMenu.hasSubmenuRef,
              menuProps: menuPropsRef,
              popoverBody: NPopoverBody,
              animated: animatedRef,
              mergedShowSubmenu: computed(() => {
                  return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
              }),
              rawNode: rawNodeRef,
              hasSubmenu: hasSubmenuRef,
              pending: useMemo(() => {
                  const { value: pendingKeyPath } = pendingKeyPathRef;
                  const { key } = props.tmNode;
                  return pendingKeyPath.includes(key);
              }),
              childActive: useMemo(() => {
                  const { value: activeKeyPath } = activeKeyPathRef;
                  const { key } = props.tmNode;
                  const index = activeKeyPath.findIndex((k) => key === k);
                  if (index === -1)
                      return false;
                  return index < activeKeyPath.length - 1;
              }),
              active: useMemo(() => {
                  const { value: activeKeyPath } = activeKeyPathRef;
                  const { key } = props.tmNode;
                  const index = activeKeyPath.findIndex((k) => key === k);
                  if (index === -1)
                      return false;
                  return index === activeKeyPath.length - 1;
              }),
              mergedDisabled: mergedDisabledRef,
              renderOption: renderOptionRef,
              nodeProps: nodePropsRef,
              handleClick,
              handleMouseMove,
              handleMouseEnter,
              handleMouseLeave,
              handleSubmenuBeforeEnter,
              handleSubmenuAfterEnter
          };
      },
      render() {
          var _a, _b;
          const { animated, rawNode, mergedShowSubmenu, clsPrefix, siblingHasIcon, siblingHasSubmenu, renderLabel, renderIcon, renderOption, nodeProps, props, scrollable } = this;
          let submenuVNode = null;
          if (mergedShowSubmenu) {
              const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(this, rawNode, rawNode.children);
              submenuVNode = (h(NDropdownMenu, Object.assign({}, submenuNodeProps, { clsPrefix: clsPrefix, scrollable: this.scrollable, tmNodes: this.tmNode.children, parentKey: this.tmNode.key })));
          }
          const builtinProps = {
              class: [
                  `${clsPrefix}-dropdown-option-body`,
                  this.pending && `${clsPrefix}-dropdown-option-body--pending`,
                  this.active && `${clsPrefix}-dropdown-option-body--active`,
                  this.childActive && `${clsPrefix}-dropdown-option-body--child-active`,
                  this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`
              ],
              onMousemove: this.handleMouseMove,
              onMouseenter: this.handleMouseEnter,
              onMouseleave: this.handleMouseLeave,
              onClick: this.handleClick
          };
          const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = (h("div", Object.assign({ class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class], "data-dropdown-option": true }, optionNodeProps),
              h('div', mergeProps(builtinProps, props), [
                  h("div", { class: [
                          `${clsPrefix}-dropdown-option-body__prefix`,
                          siblingHasIcon &&
                              `${clsPrefix}-dropdown-option-body__prefix--show-icon`
                      ] }, [renderIcon ? renderIcon(rawNode) : render$1(rawNode.icon)]),
                  h("div", { "data-dropdown-option": true, class: `${clsPrefix}-dropdown-option-body__label` }, renderLabel
                      ? renderLabel(rawNode)
                      : render$1((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)),
                  h("div", { "data-dropdown-option": true, class: [
                          `${clsPrefix}-dropdown-option-body__suffix`,
                          siblingHasSubmenu &&
                              `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
                      ] }, this.hasSubmenu ? (h(NIcon, null, {
                      default: () => h(ChevronRightIcon, null)
                  })) : null)
              ]),
              this.hasSubmenu ? (h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h("div", { class: `${clsPrefix}-dropdown-offset-container` },
                              h(VFollower, { show: this.mergedShowSubmenu, placement: this.placement, to: scrollable
                                      ? this.popoverBody || undefined
                                      : undefined, teleportDisabled: !scrollable }, {
                                  default: () => {
                                      return (h("div", { class: `${clsPrefix}-dropdown-menu-wrapper` }, animated ? (h(Transition, { onBeforeEnter: this.handleSubmenuBeforeEnter, onAfterEnter: this.handleSubmenuAfterEnter, name: "fade-in-scale-up-transition", appear: true }, {
                                          default: () => submenuVNode
                                      })) : (submenuVNode)));
                                  }
                              })))
                      })
                  ]
              })) : null));
          if (renderOption) {
              return renderOption({ node, option: rawNode });
          }
          return node;
      }
  });

  var NDropdownGroupHeader = defineComponent({
      name: 'DropdownGroupHeader',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup() {
          const { showIconRef, hasSubmenuRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dropdownMenuInjectionKey);
          const { renderLabelRef, labelFieldRef, nodePropsRef, renderOptionRef } = 
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(dropdownInjectionKey);
          return {
              labelField: labelFieldRef,
              showIcon: showIconRef,
              hasSubmenu: hasSubmenuRef,
              renderLabel: renderLabelRef,
              nodeProps: nodePropsRef,
              renderOption: renderOptionRef
          };
      },
      render() {
          var _a;
          const { clsPrefix, hasSubmenu, showIcon, nodeProps, renderLabel, renderOption } = this;
          const { rawNode } = this.tmNode;
          const node = (h("div", Object.assign({ class: `${clsPrefix}-dropdown-option` }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)),
              h("div", { class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group` },
                  h("div", { "data-dropdown-option": true, class: [
                          `${clsPrefix}-dropdown-option-body__prefix`,
                          showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`
                      ] }, render$1(rawNode.icon)),
                  h("div", { class: `${clsPrefix}-dropdown-option-body__label`, "data-dropdown-option": true }, renderLabel
                      ? renderLabel(rawNode)
                      : render$1((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])),
                  h("div", { class: [
                          `${clsPrefix}-dropdown-option-body__suffix`,
                          hasSubmenu &&
                              `${clsPrefix}-dropdown-option-body__suffix--has-submenu`
                      ], "data-dropdown-option": true }))));
          if (renderOption) {
              return renderOption({ node, option: rawNode });
          }
          return node;
      }
  });

  var NDropdownGroup = defineComponent({
      name: 'NDropdownGroup',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          },
          parentKey: {
              type: [String, Number],
              default: null
          }
      },
      render() {
          const { tmNode, parentKey, clsPrefix } = this;
          const { children } = tmNode;
          return (h(Fragment, null,
              h(NDropdownGroupHeader, { clsPrefix: clsPrefix, tmNode: tmNode, key: tmNode.key }), children === null || children === void 0 ? void 0 :
              children.map((child) => {
                  const { rawNode } = child;
                  if (rawNode.show === false)
                      return null;
                  if (isDividerNode$1(rawNode)) {
                      return h(NDropdownDivider, {
                          clsPrefix,
                          key: child.key
                      });
                  }
                  if (child.isGroup) {
                      warn$2('dropdown', '`group` node is not allowed to be put in `group` node.');
                      return null;
                  }
                  return (h(NDropdownOption, { clsPrefix: clsPrefix, tmNode: child, parentKey: parentKey, key: child.key }));
              })));
      }
  });

  var NDropdownRenderOption = defineComponent({
      name: 'DropdownRenderOption',
      props: {
          tmNode: {
              type: Object,
              required: true
          }
      },
      render() {
          const { rawNode: { render, props } } = this.tmNode;
          return h('div', props, [render === null || render === void 0 ? void 0 : render()]);
      }
  });

  var NDropdownMenu = defineComponent({
      name: 'DropdownMenu',
      props: {
          scrollable: Boolean,
          showArrow: Boolean,
          arrowStyle: [String, Object],
          clsPrefix: {
              type: String,
              required: true
          },
          tmNodes: {
              type: Array,
              default: () => []
          },
          parentKey: {
              type: [String, Number],
              default: null
          }
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { renderIconRef, childrenFieldRef } = inject(dropdownInjectionKey);
          provide(dropdownMenuInjectionKey, {
              showIconRef: computed(() => {
                  const renderIcon = renderIconRef.value;
                  return props.tmNodes.some((tmNode) => {
                      var _a;
                      if (tmNode.isGroup) {
                          return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
                      }
                      const { rawNode } = tmNode;
                      return renderIcon ? renderIcon(rawNode) : rawNode.icon;
                  });
              }),
              hasSubmenuRef: computed(() => {
                  const { value: childrenField } = childrenFieldRef;
                  return props.tmNodes.some((tmNode) => {
                      var _a;
                      if (tmNode.isGroup) {
                          return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({ rawNode: rawChild }) => isSubmenuNode(rawChild, childrenField));
                      }
                      const { rawNode } = tmNode;
                      return isSubmenuNode(rawNode, childrenField);
                  });
              })
          });
          const bodyRef = ref(null);
          provide(modalBodyInjectionKey, null);
          provide(drawerBodyInjectionKey, null);
          provide(popoverBodyInjectionKey, bodyRef);
          return {
              bodyRef
          };
      },
      render() {
          const { parentKey, clsPrefix, scrollable } = this;
          const menuOptionsNode = this.tmNodes.map((tmNode) => {
              const { rawNode } = tmNode;
              if (rawNode.show === false)
                  return null;
              if (isRenderNode(rawNode)) {
                  return (h(NDropdownRenderOption, { tmNode: tmNode, key: tmNode.key }));
              }
              if (isDividerNode$1(rawNode)) {
                  return h(NDropdownDivider, { clsPrefix: clsPrefix, key: tmNode.key });
              }
              if (isGroupNode(rawNode)) {
                  return (h(NDropdownGroup, { clsPrefix: clsPrefix, tmNode: tmNode, parentKey: parentKey, key: tmNode.key }));
              }
              return (h(NDropdownOption, { clsPrefix: clsPrefix, tmNode: tmNode, parentKey: parentKey, key: tmNode.key, props: rawNode.props, scrollable: scrollable }));
          });
          return (h("div", { class: [
                  `${clsPrefix}-dropdown-menu`,
                  scrollable && `${clsPrefix}-dropdown-menu--scrollable`
              ], ref: "bodyRef" },
              scrollable ? (h(XScrollbar, { contentClass: `${clsPrefix}-dropdown-menu__content` }, {
                  default: () => menuOptionsNode
              })) : (menuOptionsNode),
              this.showArrow
                  ? renderArrow({
                      clsPrefix,
                      arrowStyle: this.arrowStyle,
                      arrowClass: undefined,
                      arrowWrapperClass: undefined,
                      arrowWrapperStyle: undefined
                  })
                  : null));
      }
  });

  // vars:
  // --n-bezier
  // --n-font-size
  // --n-padding
  // --n-border-radius
  // --n-option-height
  // --n-option-prefix-width
  // --n-option-icon-prefix-width
  // --n-option-suffix-width
  // --n-option-icon-suffix-width
  // --n-color
  // --n-option-color-hover
  // --n-option-color-active
  // --n-divider-color
  // --n-option-text-color
  // --n-option-text-color-hover
  // --n-option-text-color-active
  // --n-option-text-color-child-active
  // --n-prefix-color
  // --n-suffix-color
  // --n-option-icon-size
  // --n-option-opacity-disabled
  // shared with popover
  // --n-box-shadow
  var style$W = cB('dropdown-menu', `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB('dropdown-option', `
 position: relative;
 `, [c$1('a', `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1('&::before', `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB('dropdown-option-body', `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1('&::before', `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM('disabled', [cM('pending', `
 color: var(--n-option-text-color-hover);
 `, [cE('prefix, suffix', `
 color: var(--n-option-text-color-hover);
 `), c$1('&::before', 'background-color: var(--n-option-color-hover);')]), cM('active', `
 color: var(--n-option-text-color-active);
 `, [cE('prefix, suffix', `
 color: var(--n-option-text-color-active);
 `), c$1('&::before', 'background-color: var(--n-option-color-active);')]), cM('child-active', `
 color: var(--n-option-text-color-child-active);
 `, [cE('prefix, suffix', `
 color: var(--n-option-text-color-child-active);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM('group', `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE('prefix', `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM('show-icon', `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE('prefix', `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM('show-icon', `
 width: var(--n-option-icon-prefix-width);
 `), cB('icon', `
 font-size: var(--n-option-icon-size);
 `)]), cE('label', `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE('suffix', `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM('has-submenu', `
 width: var(--n-option-icon-suffix-width);
 `), cB('icon', `
 font-size: var(--n-option-icon-size);
 `)]), cB('dropdown-menu', 'pointer-events: all;')]), cB('dropdown-offset-container', `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB('dropdown-divider', `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB('dropdown-menu-wrapper', `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1('>', [cB('scrollbar', `
 height: inherit;
 max-height: inherit;
 `)]), cNotM('scrollable', `
 padding: var(--n-padding);
 `), cM('scrollable', [cE('content', `
 padding: var(--n-padding);
 `)])]);

  const dropdownBaseProps = {
      animated: {
          type: Boolean,
          default: true
      },
      keyboard: {
          type: Boolean,
          default: true
      },
      size: {
          type: String,
          default: 'medium'
      },
      inverted: Boolean,
      placement: {
          type: String,
          default: 'bottom'
      },
      onSelect: [Function, Array],
      options: {
          type: Array,
          default: () => []
      },
      menuProps: Function,
      showArrow: Boolean,
      renderLabel: Function,
      renderIcon: Function,
      renderOption: Function,
      nodeProps: Function,
      labelField: {
          type: String,
          default: 'label'
      },
      keyField: {
          type: String,
          default: 'key'
      },
      childrenField: {
          type: String,
          default: 'children'
      },
      // for menu, not documented
      value: [String, Number]
  };
  const popoverPropKeys = Object.keys(popoverBaseProps);
  const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
  var NDropdown = defineComponent({
      name: 'Dropdown',
      inheritAttrs: false,
      props: dropdownProps,
      setup(props) {
          const uncontrolledShowRef = ref(false);
          const mergedShowRef = useMergedState(toRef(props, 'show'), uncontrolledShowRef);
          const treemateRef = computed(() => {
              const { keyField, childrenField } = props;
              return createTreeMate(props.options, {
                  getKey(node) {
                      return node[keyField];
                  },
                  getDisabled(node) {
                      return node.disabled === true;
                  },
                  getIgnored(node) {
                      return node.type === 'divider' || node.type === 'render';
                  },
                  getChildren(node) {
                      return node[childrenField];
                  }
              });
          });
          const tmNodesRef = computed(() => {
              return treemateRef.value.treeNodes;
          });
          const hoverKeyRef = ref(null);
          const keyboardKeyRef = ref(null);
          const lastToggledSubmenuKeyRef = ref(null);
          const pendingKeyRef = computed(() => {
              var _a, _b, _c;
              return ((_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null);
          });
          const pendingKeyPathRef = computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
          const activeKeyPathRef = computed(() => treemateRef.value.getPath(props.value).keyPath);
          const keyboardEnabledRef = useMemo(() => {
              return props.keyboard && mergedShowRef.value;
          });
          useKeyboard$1({
              keydown: {
                  ArrowUp: {
                      prevent: true,
                      handler: handleKeydownUp
                  },
                  ArrowRight: {
                      prevent: true,
                      handler: handleKeydownRight
                  },
                  ArrowDown: {
                      prevent: true,
                      handler: handleKeydownDown
                  },
                  ArrowLeft: {
                      prevent: true,
                      handler: handleKeydownLeft
                  },
                  Enter: {
                      prevent: true,
                      handler: handleKeydownEnter
                  },
                  Escape: handleKeydownEsc
              }
          }, keyboardEnabledRef);
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Dropdown', '-dropdown', style$W, dropdownLight$1, props, mergedClsPrefixRef);
          provide(dropdownInjectionKey, {
              labelFieldRef: toRef(props, 'labelField'),
              childrenFieldRef: toRef(props, 'childrenField'),
              renderLabelRef: toRef(props, 'renderLabel'),
              renderIconRef: toRef(props, 'renderIcon'),
              hoverKeyRef,
              keyboardKeyRef,
              lastToggledSubmenuKeyRef,
              pendingKeyPathRef,
              activeKeyPathRef,
              animatedRef: toRef(props, 'animated'),
              mergedShowRef,
              nodePropsRef: toRef(props, 'nodeProps'),
              renderOptionRef: toRef(props, 'renderOption'),
              menuPropsRef: toRef(props, 'menuProps'),
              doSelect,
              doUpdateShow
          });
          // watch
          watch(mergedShowRef, (value) => {
              if (!props.animated && !value) {
                  clearPendingState();
              }
          });
          // methods
          function doSelect(key, node) {
              const { onSelect } = props;
              if (onSelect)
                  call(onSelect, key, node);
          }
          function doUpdateShow(value) {
              const { 'onUpdate:show': _onUpdateShow, onUpdateShow } = props;
              if (_onUpdateShow)
                  call(_onUpdateShow, value);
              if (onUpdateShow)
                  call(onUpdateShow, value);
              uncontrolledShowRef.value = value;
          }
          function clearPendingState() {
              hoverKeyRef.value = null;
              keyboardKeyRef.value = null;
              lastToggledSubmenuKeyRef.value = null;
          }
          function handleKeydownEsc() {
              doUpdateShow(false);
          }
          function handleKeydownLeft() {
              handleKeydown('left');
          }
          function handleKeydownRight() {
              handleKeydown('right');
          }
          function handleKeydownUp() {
              handleKeydown('up');
          }
          function handleKeydownDown() {
              handleKeydown('down');
          }
          function handleKeydownEnter() {
              const pendingNode = getPendingNode();
              if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
                  doSelect(pendingNode.key, pendingNode.rawNode);
                  doUpdateShow(false);
              }
          }
          function getPendingNode() {
              var _a;
              const { value: treeMate } = treemateRef;
              const { value: pendingKey } = pendingKeyRef;
              if (!treeMate || pendingKey === null)
                  return null;
              return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
          }
          function handleKeydown(direction) {
              const { value: pendingKey } = pendingKeyRef;
              const { value: { getFirstAvailableNode } } = treemateRef;
              let nextKeyboardKey = null;
              if (pendingKey === null) {
                  const firstNode = getFirstAvailableNode();
                  if (firstNode !== null) {
                      nextKeyboardKey = firstNode.key;
                  }
              }
              else {
                  const currentNode = getPendingNode();
                  if (currentNode) {
                      let nextNode;
                      switch (direction) {
                          case 'down':
                              nextNode = currentNode.getNext();
                              break;
                          case 'up':
                              nextNode = currentNode.getPrev();
                              break;
                          case 'right':
                              nextNode = currentNode.getChild();
                              break;
                          case 'left':
                              nextNode = currentNode.getParent();
                              break;
                      }
                      if (nextNode)
                          nextKeyboardKey = nextNode.key;
                  }
              }
              if (nextKeyboardKey !== null) {
                  hoverKeyRef.value = null;
                  keyboardKeyRef.value = nextKeyboardKey;
              }
          }
          const cssVarsRef = computed(() => {
              const { size, inverted } = props;
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { padding, dividerColor, borderRadius, optionOpacityDisabled, [createKey('optionIconSuffixWidth', size)]: optionIconSuffixWidth, [createKey('optionSuffixWidth', size)]: optionSuffixWidth, [createKey('optionIconPrefixWidth', size)]: optionIconPrefixWidth, [createKey('optionPrefixWidth', size)]: optionPrefixWidth, [createKey('fontSize', size)]: fontSize, [createKey('optionHeight', size)]: optionHeight, [createKey('optionIconSize', size)]: optionIconSize } = self;
              const vars = {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-padding': padding,
                  '--n-border-radius': borderRadius,
                  '--n-option-height': optionHeight,
                  '--n-option-prefix-width': optionPrefixWidth,
                  '--n-option-icon-prefix-width': optionIconPrefixWidth,
                  '--n-option-suffix-width': optionSuffixWidth,
                  '--n-option-icon-suffix-width': optionIconSuffixWidth,
                  '--n-option-icon-size': optionIconSize,
                  '--n-divider-color': dividerColor,
                  '--n-option-opacity-disabled': optionOpacityDisabled
              };
              // writing like this is the fastest method
              if (inverted) {
                  vars['--n-color'] = self.colorInverted;
                  vars['--n-option-color-hover'] = self.optionColorHoverInverted;
                  vars['--n-option-color-active'] = self.optionColorActiveInverted;
                  vars['--n-option-text-color'] = self.optionTextColorInverted;
                  vars['--n-option-text-color-hover'] = self.optionTextColorHoverInverted;
                  vars['--n-option-text-color-active'] =
                      self.optionTextColorActiveInverted;
                  vars['--n-option-text-color-child-active'] =
                      self.optionTextColorChildActiveInverted;
                  vars['--n-prefix-color'] = self.prefixColorInverted;
                  vars['--n-suffix-color'] = self.suffixColorInverted;
                  vars['--n-group-header-text-color'] = self.groupHeaderTextColorInverted;
              }
              else {
                  vars['--n-color'] = self.color;
                  vars['--n-option-color-hover'] = self.optionColorHover;
                  vars['--n-option-color-active'] = self.optionColorActive;
                  vars['--n-option-text-color'] = self.optionTextColor;
                  vars['--n-option-text-color-hover'] = self.optionTextColorHover;
                  vars['--n-option-text-color-active'] = self.optionTextColorActive;
                  vars['--n-option-text-color-child-active'] =
                      self.optionTextColorChildActive;
                  vars['--n-prefix-color'] = self.prefixColor;
                  vars['--n-suffix-color'] = self.suffixColor;
                  vars['--n-group-header-text-color'] = self.groupHeaderTextColor;
              }
              return vars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('dropdown', computed(() => `${props.size[0]}${props.inverted ? 'i' : ''}`), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: themeRef,
              // data
              tmNodes: tmNodesRef,
              // show
              mergedShow: mergedShowRef,
              // methods
              handleAfterLeave: () => {
                  if (!props.animated)
                      return;
                  clearPendingState();
              },
              doUpdateShow,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const renderPopoverBody = (className, ref, style, onMouseenter, onMouseleave) => {
              var _a;
              const { mergedClsPrefix, menuProps } = this;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(undefined, this.tmNodes.map((v) => v.rawNode))) || {};
              const dropdownProps = {
                  ref: createRefSetter(ref),
                  class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
                  clsPrefix: mergedClsPrefix,
                  tmNodes: this.tmNodes,
                  style: [...style, this.cssVars],
                  showArrow: this.showArrow,
                  arrowStyle: this.arrowStyle,
                  scrollable: this.scrollable,
                  onMouseenter,
                  onMouseleave
              };
              return h(NDropdownMenu, mergeProps(this.$attrs, dropdownProps, menuNodeProps));
          };
          const { mergedTheme } = this;
          const popoverProps = {
              show: this.mergedShow,
              theme: mergedTheme.peers.Popover,
              themeOverrides: mergedTheme.peerOverrides.Popover,
              internalOnAfterLeave: this.handleAfterLeave,
              internalRenderBody: renderPopoverBody,
              onUpdateShow: this.doUpdateShow,
              'onUpdate:show': undefined
          };
          return (h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps), {
              trigger: () => { var _a, _b; return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a); }
          }));
      }
  });

  const allKey = '_n_all__';
  const noneKey = '_n_none__';
  function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
      if (!options)
          return () => { };
      return (key) => {
          for (const option of options) {
              switch (key) {
                  case allKey:
                      doCheckAll(true);
                      return;
                  case noneKey:
                      doUncheckAll(true);
                      return;
                  default:
                      if (typeof option === 'object' && option.key === key) {
                          option.onSelect(rawPaginatedDataRef.value);
                          return;
                      }
              }
          }
      };
  }
  function createDropdownOptions(options, localeRef) {
      if (!options)
          return [];
      return options.map((option) => {
          switch (option) {
              case 'all':
                  return {
                      label: localeRef.checkTableAll,
                      key: allKey
                  };
              case 'none':
                  return {
                      label: localeRef.uncheckTableAll,
                      key: noneKey
                  };
              default:
                  return option;
          }
      });
  }
  var SelectionMenu = defineComponent({
      name: 'DataTableSelectionMenu',
      props: {
          clsPrefix: {
              type: String,
              required: true
          }
      },
      setup(props) {
          const { props: dataTableProps, localeRef, checkOptionsRef, rawPaginatedDataRef, doCheckAll, doUncheckAll
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          const handleSelectRef = computed(() => createSelectHandler(checkOptionsRef.value, rawPaginatedDataRef, doCheckAll, doUncheckAll));
          const optionsRef = computed(() => createDropdownOptions(checkOptionsRef.value, localeRef.value));
          return () => {
              var _a, _b, _c, _d;
              const { clsPrefix } = props;
              return (h(NDropdown, { theme: (_b = (_a = dataTableProps.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Dropdown, themeOverrides: (_d = (_c = dataTableProps.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Dropdown, options: optionsRef.value, onSelect: handleSelectRef.value }, {
                  default: () => (h(NBaseIcon, { clsPrefix: clsPrefix, class: `${clsPrefix}-data-table-check-extra` }, {
                      default: () => h(ChevronDownIcon, null)
                  }))
              }));
          };
      }
  });

  function renderTitle(column) {
      return typeof column.title === 'function'
          ? column.title(column)
          : column.title;
  }
  var TableHeader = defineComponent({
      name: 'DataTableHeader',
      props: {
          discrete: {
              type: Boolean,
              default: true
          }
      },
      setup() {
          const { mergedClsPrefixRef, scrollXRef, fixedColumnLeftMapRef, fixedColumnRightMapRef, mergedCurrentPageRef, allRowsCheckedRef, someRowsCheckedRef, rowsRef, colsRef, mergedThemeRef, checkOptionsRef, mergedSortStateRef, componentId, mergedTableLayoutRef, headerCheckboxDisabledRef, onUnstableColumnResize, doUpdateResizableWidth, handleTableHeaderScroll, deriveNextSorter, doUncheckAll, doCheckAll
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          const cellElsRef = ref({});
          function getCellActualWidth(key) {
              const element = cellElsRef.value[key];
              return element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width;
          }
          function handleCheckboxUpdateChecked() {
              if (allRowsCheckedRef.value) {
                  doUncheckAll();
              }
              else {
                  doCheckAll();
              }
          }
          function handleColHeaderClick(e, column) {
              if (happensIn(e, 'dataTableFilter') ||
                  happensIn(e, 'dataTableResizable')) {
                  return;
              }
              if (!isColumnSortable(column))
                  return;
              const activeSorter = mergedSortStateRef.value.find((state) => state.columnKey === column.key) || null;
              const nextSorter = createNextSorter(column, activeSorter);
              deriveNextSorter(nextSorter);
          }
          const resizeStartWidthMap = new Map();
          function handleColumnResizeStart(column) {
              resizeStartWidthMap.set(column.key, getCellActualWidth(column.key));
          }
          function handleColumnResize(column, displacementX) {
              const startWidth = resizeStartWidthMap.get(column.key);
              if (startWidth === undefined) {
                  return;
              }
              const widthAfterResize = startWidth + displacementX;
              const limitWidth = clampValueFollowCSSRules(widthAfterResize, column.minWidth, column.maxWidth);
              onUnstableColumnResize(widthAfterResize, limitWidth, column, getCellActualWidth);
              doUpdateResizableWidth(column, limitWidth);
          }
          return {
              cellElsRef,
              componentId,
              mergedSortState: mergedSortStateRef,
              mergedClsPrefix: mergedClsPrefixRef,
              scrollX: scrollXRef,
              fixedColumnLeftMap: fixedColumnLeftMapRef,
              fixedColumnRightMap: fixedColumnRightMapRef,
              currentPage: mergedCurrentPageRef,
              allRowsChecked: allRowsCheckedRef,
              someRowsChecked: someRowsCheckedRef,
              rows: rowsRef,
              cols: colsRef,
              mergedTheme: mergedThemeRef,
              checkOptions: checkOptionsRef,
              mergedTableLayout: mergedTableLayoutRef,
              headerCheckboxDisabled: headerCheckboxDisabledRef,
              handleCheckboxUpdateChecked,
              handleColHeaderClick,
              handleTableHeaderScroll,
              handleColumnResizeStart,
              handleColumnResize
          };
      },
      render() {
          const { cellElsRef, mergedClsPrefix, fixedColumnLeftMap, fixedColumnRightMap, currentPage, allRowsChecked, someRowsChecked, rows, cols, mergedTheme, checkOptions, componentId, discrete, mergedTableLayout, headerCheckboxDisabled, mergedSortState, handleColHeaderClick, handleCheckboxUpdateChecked, handleColumnResizeStart, handleColumnResize } = this;
          const theadVNode = (h("thead", { class: `${mergedClsPrefix}-data-table-thead`, "data-n-id": componentId }, rows.map((row) => {
              return (h("tr", { class: `${mergedClsPrefix}-data-table-tr` }, row.map(({ column, colSpan, rowSpan, isLast }) => {
                  var _a, _b;
                  const key = getColKey(column);
                  const { ellipsis } = column;
                  const createColumnVNode = () => {
                      if (column.type === 'selection') {
                          return column.multiple !== false ? (h(Fragment, null,
                              h(NCheckbox, { key: currentPage, privateInsideTable: true, checked: allRowsChecked, indeterminate: someRowsChecked, disabled: headerCheckboxDisabled, onUpdateChecked: handleCheckboxUpdateChecked }),
                              checkOptions ? (h(SelectionMenu, { clsPrefix: mergedClsPrefix })) : null)) : null;
                      }
                      return (h(Fragment, null,
                          h("div", { class: `${mergedClsPrefix}-data-table-th__title-wrapper` },
                              h("div", { class: `${mergedClsPrefix}-data-table-th__title` }, ellipsis === true ||
                                  (ellipsis && !ellipsis.tooltip) ? (h("div", { class: `${mergedClsPrefix}-data-table-th__ellipsis` }, renderTitle(column))) // eslint-disable-next-line @typescript-eslint/prefer-optional-chain
                                  : ellipsis && typeof ellipsis === 'object' ? (h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), {
                                      default: () => renderTitle(column)
                                  })) : (renderTitle(column))),
                              isColumnSortable(column) ? (h(SortButton, { column: column })) : null),
                          isColumnFilterable(column) ? (h(FilterButton, { column: column, options: column.filterOptions })) : null,
                          isColumnResizable(column) ? (h(ResizeButton, { onResizeStart: () => {
                                  handleColumnResizeStart(column);
                              }, onResize: (displacementX) => {
                                  handleColumnResize(column, displacementX);
                              } })) : null));
                  };
                  const leftFixed = key in fixedColumnLeftMap;
                  const rightFixed = key in fixedColumnRightMap;
                  return (h("th", { ref: (el) => (cellElsRef[key] = el), key: key, style: {
                          textAlign: column.titleAlign || column.align,
                          left: pxfy((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start),
                          right: pxfy((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.start)
                      }, colspan: colSpan, rowspan: rowSpan, "data-col-key": key, class: [
                          `${mergedClsPrefix}-data-table-th`,
                          (leftFixed || rightFixed) &&
                              `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? 'left' : 'right'}`,
                          {
                              [`${mergedClsPrefix}-data-table-th--hover`]: isColumnSorting(column, mergedSortState),
                              [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
                              [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
                              [`${mergedClsPrefix}-data-table-th--selection`]: column.type === 'selection',
                              [`${mergedClsPrefix}-data-table-th--last`]: isLast
                          },
                          column.className
                      ], onClick: column.type !== 'selection' &&
                          column.type !== 'expand' &&
                          !('children' in column)
                          ? (e) => {
                              handleColHeaderClick(e, column);
                          }
                          : undefined }, createColumnVNode()));
              })));
          })));
          if (!discrete) {
              return theadVNode;
          }
          const { handleTableHeaderScroll, scrollX } = this;
          return (h("div", { class: `${mergedClsPrefix}-data-table-base-table-header`, onScroll: handleTableHeaderScroll },
              h("table", { ref: "body", class: `${mergedClsPrefix}-data-table-table`, style: {
                      minWidth: formatLength(scrollX),
                      tableLayout: mergedTableLayout
                  } },
                  h("colgroup", null, cols.map((col) => (h("col", { key: col.key, style: col.style })))),
                  theadVNode)));
      }
  });

  var Cell = defineComponent({
      name: 'DataTableCell',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          row: {
              type: Object,
              required: true
          },
          index: {
              type: Number,
              required: true
          },
          column: {
              type: Object,
              required: true
          },
          isSummary: Boolean,
          mergedTheme: {
              type: Object,
              required: true
          },
          renderCell: Function
      },
      render() {
          const { isSummary, column, row, renderCell } = this;
          let cell;
          const { render, key, ellipsis } = column;
          if (render && !isSummary) {
              cell = render(row, this.index);
          }
          else {
              if (isSummary) {
                  cell = row[key].value;
              }
              else {
                  cell = renderCell
                      ? renderCell(get(row, key), row, column)
                      : get(row, key);
              }
          }
          if (ellipsis) {
              if (typeof ellipsis === 'object') {
                  const { mergedTheme } = this;
                  if (column.ellipsisComponent === 'performant-ellipsis') {
                      return (h(NPerformantEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), { default: () => cell }));
                  }
                  return (h(NEllipsis, Object.assign({}, ellipsis, { theme: mergedTheme.peers.Ellipsis, themeOverrides: mergedTheme.peerOverrides.Ellipsis }), { default: () => cell }));
              }
              else {
                  return (h("span", { class: `${this.clsPrefix}-data-table-td__ellipsis` }, cell));
              }
          }
          return cell;
      }
  });

  var ExpandTrigger = defineComponent({
      name: 'DataTableExpandTrigger',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          expanded: Boolean,
          loading: Boolean,
          onClick: {
              type: Function,
              required: true
          },
          renderExpandIcon: {
              type: Function
          }
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: [
                  `${clsPrefix}-data-table-expand-trigger`,
                  this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`
              ], onClick: this.onClick, onMousedown: (e) => {
                  e.preventDefault();
              } },
              h(NIconSwitchTransition, null, {
                  default: () => {
                      return this.loading ? (h(NBaseLoading, { key: "loading", clsPrefix: this.clsPrefix, radius: 85, strokeWidth: 15, scale: 0.88 })) : this.renderExpandIcon ? (this.renderExpandIcon({
                          expanded: this.expanded
                      })) : (h(NBaseIcon, { clsPrefix: clsPrefix, key: "base-icon" }, {
                          default: () => h(ChevronRightIcon, null)
                      }));
                  }
              })));
      }
  });

  // Extract the checkbox to avoid useless rendering in table body
  var RenderSafeCheckbox = defineComponent({
      name: 'DataTableBodyCheckbox',
      props: {
          rowKey: {
              type: [String, Number],
              required: true
          },
          disabled: {
              type: Boolean,
              required: true
          },
          onUpdateChecked: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const { mergedCheckedRowKeySetRef, mergedInderminateRowKeySetRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          return () => {
              const { rowKey } = props;
              return (h(NCheckbox, { privateInsideTable: true, disabled: props.disabled, indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey), checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked }));
          };
      }
  });

  // Extract the radio to avoid useless rendering in table body
  var RenderSafeRadio = defineComponent({
      name: 'DataTableBodyRadio',
      props: {
          rowKey: {
              type: [String, Number],
              required: true
          },
          disabled: {
              type: Boolean,
              required: true
          },
          onUpdateChecked: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          const { mergedCheckedRowKeySetRef, componentId
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          return () => {
              const { rowKey } = props;
              return (h(NRadio, { name: componentId, disabled: props.disabled, checked: mergedCheckedRowKeySetRef.value.has(rowKey), onUpdateChecked: props.onUpdateChecked }));
          };
      }
  });

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  function flatten(rowInfos, expandedRowKeys) {
      const fRows = [];
      function traverse(rs, rootIndex) {
          rs.forEach((r) => {
              if (r.children && expandedRowKeys.has(r.key)) {
                  fRows.push({
                      tmNode: r,
                      striped: false,
                      key: r.key,
                      index: rootIndex
                  });
                  traverse(r.children, rootIndex);
              }
              else {
                  fRows.push({
                      key: r.key,
                      tmNode: r,
                      striped: false,
                      index: rootIndex
                  });
              }
          });
      }
      rowInfos.forEach((rowInfo) => {
          fRows.push(rowInfo);
          const { children } = rowInfo.tmNode;
          if (children && expandedRowKeys.has(rowInfo.key)) {
              traverse(children, rowInfo.index);
          }
      });
      return fRows;
  }
  const VirtualListItemWrapper = defineComponent({
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          id: {
              type: String,
              required: true
          },
          cols: {
              type: Array,
              required: true
          },
          onMouseenter: Function,
          onMouseleave: Function
      },
      render() {
          const { clsPrefix, id, cols, onMouseenter, onMouseleave } = this;
          return (h("table", { style: { tableLayout: 'fixed' }, class: `${clsPrefix}-data-table-table`, onMouseenter: onMouseenter, onMouseleave: onMouseleave },
              h("colgroup", null, cols.map((col) => (h("col", { key: col.key, style: col.style })))),
              h("tbody", { "data-n-id": id, class: `${clsPrefix}-data-table-tbody` }, this.$slots)));
      }
  });
  var TableBody = defineComponent({
      name: 'DataTableBody',
      props: {
          onResize: Function,
          showHeader: Boolean,
          flexHeight: Boolean,
          bodyStyle: Object
      },
      setup(props) {
          const { slots: dataTableSlots, bodyWidthRef, mergedExpandedRowKeysRef, mergedClsPrefixRef, mergedThemeRef, scrollXRef, colsRef, paginatedDataRef, rawPaginatedDataRef, fixedColumnLeftMapRef, fixedColumnRightMapRef, mergedCurrentPageRef, rowClassNameRef, leftActiveFixedColKeyRef, leftActiveFixedChildrenColKeysRef, rightActiveFixedColKeyRef, rightActiveFixedChildrenColKeysRef, renderExpandRef, hoverKeyRef, summaryRef, mergedSortStateRef, virtualScrollRef, componentId, mergedTableLayoutRef, childTriggerColIndexRef, indentRef, rowPropsRef, maxHeightRef, stripedRef, loadingRef, onLoadRef, loadingKeySetRef, expandableRef, stickyExpandedRowsRef, renderExpandIconRef, summaryPlacementRef, treeMateRef, scrollbarPropsRef, setHeaderScrollLeft, doUpdateExpandedRowKeys, handleTableBodyScroll, doCheck, doUncheck, renderCell
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          const scrollbarInstRef = ref(null);
          const virtualListRef = ref(null);
          const emptyElRef = ref(null);
          const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
          // If header is not inside & empty is displayed, no table part would be
          // shown. So to collect a body width, we need to put a ref on empty element
          const shouldDisplaySomeTablePartRef = useMemo(() => props.showHeader || !emptyRef.value);
          // If no body is shown, we shouldn't show scrollbar
          const bodyShowHeaderOnlyRef = useMemo(() => {
              return props.showHeader || emptyRef.value;
          });
          let lastSelectedKey = '';
          const mergedExpandedRowKeySetRef = computed(() => {
              return new Set(mergedExpandedRowKeysRef.value);
          });
          function getRowInfo(key) {
              var _a;
              return (_a = treeMateRef.value.getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
          }
          function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
              const rowInfo = getRowInfo(tmNode.key);
              if (!rowInfo) {
                  warn$2('data-table', `fail to get row data with key ${tmNode.key}`);
                  return;
              }
              if (shiftKey) {
                  const lastIndex = paginatedDataRef.value.findIndex((item) => item.key === lastSelectedKey);
                  if (lastIndex !== -1) {
                      const currentIndex = paginatedDataRef.value.findIndex((item) => item.key === tmNode.key);
                      const start = Math.min(lastIndex, currentIndex);
                      const end = Math.max(lastIndex, currentIndex);
                      const rowKeysToCheck = [];
                      paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
                          if (!r.disabled) {
                              rowKeysToCheck.push(r.key);
                          }
                      });
                      if (checked) {
                          doCheck(rowKeysToCheck, false, rowInfo);
                      }
                      else {
                          doUncheck(rowKeysToCheck, rowInfo);
                      }
                      lastSelectedKey = tmNode.key;
                      return;
                  }
              }
              if (checked) {
                  doCheck(tmNode.key, false, rowInfo);
              }
              else {
                  doUncheck(tmNode.key, rowInfo);
              }
              lastSelectedKey = tmNode.key;
          }
          function handleRadioUpdateChecked(tmNode) {
              const rowInfo = getRowInfo(tmNode.key);
              if (!rowInfo) {
                  warn$2('data-table', `fail to get row data with key ${tmNode.key}`);
                  return;
              }
              doCheck(tmNode.key, true, rowInfo);
          }
          function getScrollContainer() {
              if (!shouldDisplaySomeTablePartRef.value) {
                  const { value: emptyEl } = emptyElRef;
                  if (emptyEl) {
                      return emptyEl;
                  }
                  else {
                      return null;
                  }
              }
              if (virtualScrollRef.value) {
                  return virtualListContainer();
              }
              const { value } = scrollbarInstRef;
              if (value)
                  return value.containerRef;
              return null;
          }
          // For table row with children, tmNode is non-nullable
          // For table row is expandable but is not tree data, tmNode is null
          function handleUpdateExpanded(key, tmNode) {
              var _a;
              if (loadingKeySetRef.value.has(key))
                  return;
              const { value: mergedExpandedRowKeys } = mergedExpandedRowKeysRef;
              const index = mergedExpandedRowKeys.indexOf(key);
              const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
              if (~index) {
                  nextExpandedKeys.splice(index, 1);
                  doUpdateExpandedRowKeys(nextExpandedKeys);
              }
              else {
                  if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
                      loadingKeySetRef.value.add(key);
                      void ((_a = onLoadRef
                          .value) === null || _a === void 0 ? void 0 : _a.call(onLoadRef, tmNode.rawNode).then(() => {
                          const { value: futureMergedExpandedRowKeys } = mergedExpandedRowKeysRef;
                          const futureNextExpandedKeys = Array.from(futureMergedExpandedRowKeys);
                          const index = futureNextExpandedKeys.indexOf(key);
                          if (!~index) {
                              futureNextExpandedKeys.push(key);
                          }
                          doUpdateExpandedRowKeys(futureNextExpandedKeys);
                      }).finally(() => {
                          loadingKeySetRef.value.delete(key);
                      }));
                  }
                  else {
                      nextExpandedKeys.push(key);
                      doUpdateExpandedRowKeys(nextExpandedKeys);
                  }
              }
          }
          function handleMouseleaveTable() {
              hoverKeyRef.value = null;
          }
          function virtualListContainer() {
              const { value } = virtualListRef;
              return (value === null || value === void 0 ? void 0 : value.listElRef) || null;
          }
          function virtualListContent() {
              const { value } = virtualListRef;
              return (value === null || value === void 0 ? void 0 : value.itemsElRef) || null;
          }
          function handleVirtualListScroll(e) {
              var _a;
              handleTableBodyScroll(e);
              (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function handleVirtualListResize(e) {
              var _a;
              const { onResize } = props;
              if (onResize)
                  onResize(e);
              (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          const exposedMethods = {
              getScrollContainer,
              scrollTo(arg0, arg1) {
                  var _a, _b;
                  if (virtualScrollRef.value) {
                      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                      (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
                  }
                  else {
                      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                      (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(arg0, arg1);
                  }
              }
          };
          // manually control shadow style to avoid rerender
          const style = c$1([
              ({ props: cProps }) => {
                  const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
                      if (leftActiveFixedColKey === null)
                          return null;
                      return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`, { boxShadow: 'var(--n-box-shadow-after)' });
                  };
                  const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
                      if (rightActiveFixedColKey === null)
                          return null;
                      return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`, { boxShadow: 'var(--n-box-shadow-before)' });
                  };
                  return c$1([
                      createActiveLeftFixedStyle(cProps.leftActiveFixedColKey),
                      createActiveRightFixedStyle(cProps.rightActiveFixedColKey),
                      cProps.leftActiveFixedChildrenColKeys.map((leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)),
                      cProps.rightActiveFixedChildrenColKeys.map((rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey))
                  ]);
              }
          ]);
          let fixedStyleMounted = false;
          watchEffect(() => {
              const { value: leftActiveFixedColKey } = leftActiveFixedColKeyRef;
              const { value: leftActiveFixedChildrenColKeys } = leftActiveFixedChildrenColKeysRef;
              const { value: rightActiveFixedColKey } = rightActiveFixedColKeyRef;
              const { value: rightActiveFixedChildrenColKeys } = rightActiveFixedChildrenColKeysRef;
              if (!fixedStyleMounted &&
                  leftActiveFixedColKey === null &&
                  rightActiveFixedColKey === null) {
                  return;
              }
              const cProps = {
                  leftActiveFixedColKey,
                  leftActiveFixedChildrenColKeys,
                  rightActiveFixedColKey,
                  rightActiveFixedChildrenColKeys,
                  componentId
              };
              style.mount({
                  id: `n-${componentId}`,
                  force: true,
                  props: cProps,
                  anchorMetaName: cssrAnchorMetaName
              });
              fixedStyleMounted = true;
          });
          onUnmounted(() => {
              style.unmount({
                  id: `n-${componentId}`
              });
          });
          return Object.assign({ bodyWidth: bodyWidthRef, summaryPlacement: summaryPlacementRef, dataTableSlots,
              componentId,
              scrollbarInstRef,
              virtualListRef,
              emptyElRef, summary: summaryRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: mergedThemeRef, scrollX: scrollXRef, cols: colsRef, loading: loadingRef, bodyShowHeaderOnly: bodyShowHeaderOnlyRef, shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef, empty: emptyRef, paginatedDataAndInfo: computed(() => {
                  const { value: striped } = stripedRef;
                  let hasChildren = false;
                  const data = paginatedDataRef.value.map(striped
                      ? (tmNode, index) => {
                          if (!tmNode.isLeaf)
                              hasChildren = true;
                          return {
                              tmNode,
                              key: tmNode.key,
                              striped: index % 2 === 1,
                              index
                          };
                      }
                      : (tmNode, index) => {
                          if (!tmNode.isLeaf)
                              hasChildren = true;
                          return {
                              tmNode,
                              key: tmNode.key,
                              striped: false,
                              index
                          };
                      });
                  return {
                      data,
                      hasChildren
                  };
              }), rawPaginatedData: rawPaginatedDataRef, fixedColumnLeftMap: fixedColumnLeftMapRef, fixedColumnRightMap: fixedColumnRightMapRef, currentPage: mergedCurrentPageRef, rowClassName: rowClassNameRef, renderExpand: renderExpandRef, mergedExpandedRowKeySet: mergedExpandedRowKeySetRef, hoverKey: hoverKeyRef, mergedSortState: mergedSortStateRef, virtualScroll: virtualScrollRef, mergedTableLayout: mergedTableLayoutRef, childTriggerColIndex: childTriggerColIndexRef, indent: indentRef, rowProps: rowPropsRef, maxHeight: maxHeightRef, loadingKeySet: loadingKeySetRef, expandable: expandableRef, stickyExpandedRows: stickyExpandedRowsRef, renderExpandIcon: renderExpandIconRef, scrollbarProps: scrollbarPropsRef, setHeaderScrollLeft,
              handleVirtualListScroll,
              handleVirtualListResize,
              handleMouseleaveTable,
              virtualListContainer,
              virtualListContent,
              handleTableBodyScroll,
              handleCheckboxUpdateChecked,
              handleRadioUpdateChecked,
              handleUpdateExpanded,
              renderCell }, exposedMethods);
      },
      render() {
          const { mergedTheme, scrollX, mergedClsPrefix, virtualScroll, maxHeight, mergedTableLayout, flexHeight, loadingKeySet, onResize, setHeaderScrollLeft } = this;
          const scrollable = scrollX !== undefined || maxHeight !== undefined || flexHeight;
          // For a basic table with auto layout whose content may overflow we will
          // make it scrollable, which differs from browser's native behavior.
          // For native behavior, see
          // https://developer.mozilla.org/en-US/docs/Web/CSS/table-layout
          const isBasicAutoLayout = !scrollable && mergedTableLayout === 'auto';
          const xScrollable = scrollX !== undefined || isBasicAutoLayout;
          const contentStyle = {
              minWidth: formatLength(scrollX) || '100%'
          };
          if (scrollX)
              contentStyle.width = '100%';
          const tableNode = (h(NScrollbar, Object.assign({}, this.scrollbarProps, { ref: "scrollbarInstRef", scrollable: scrollable || isBasicAutoLayout, class: `${mergedClsPrefix}-data-table-base-table-body`, style: this.bodyStyle, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, contentStyle: contentStyle, container: virtualScroll ? this.virtualListContainer : undefined, content: virtualScroll ? this.virtualListContent : undefined, horizontalRailStyle: { zIndex: 3 }, verticalRailStyle: { zIndex: 3 }, xScrollable: xScrollable, onScroll: virtualScroll ? undefined : this.handleTableBodyScroll, internalOnUpdateScrollLeft: setHeaderScrollLeft, onResize: onResize }), {
              default: () => {
                  // coordinate to pass if there are cells that cross row & col
                  const cordToPass = {};
                  // coordinate to related hover keys
                  const cordKey = {};
                  const { cols, paginatedDataAndInfo, mergedTheme, fixedColumnLeftMap, fixedColumnRightMap, currentPage, rowClassName, mergedSortState, mergedExpandedRowKeySet, stickyExpandedRows, componentId, childTriggerColIndex, expandable, rowProps, handleMouseleaveTable, renderExpand, summary, handleCheckboxUpdateChecked, handleRadioUpdateChecked, handleUpdateExpanded } = this;
                  const { length: colCount } = cols;
                  let mergedData;
                  // if there is children in data, we should expand mergedData first
                  const { data: paginatedData, hasChildren } = paginatedDataAndInfo;
                  const mergedPaginationData = hasChildren
                      ? flatten(paginatedData, mergedExpandedRowKeySet)
                      : paginatedData;
                  if (summary) {
                      const summaryRows = summary(this.rawPaginatedData);
                      if (Array.isArray(summaryRows)) {
                          const summaryRowData = summaryRows.map((row, i) => ({
                              isSummaryRow: true,
                              key: `__n_summary__${i}`,
                              tmNode: {
                                  rawNode: row,
                                  disabled: true
                              },
                              index: -1
                          }));
                          mergedData =
                              this.summaryPlacement === 'top'
                                  ? [...summaryRowData, ...mergedPaginationData]
                                  : [...mergedPaginationData, ...summaryRowData];
                      }
                      else {
                          const summaryRowData = {
                              isSummaryRow: true,
                              key: '__n_summary__',
                              tmNode: {
                                  rawNode: summaryRows,
                                  disabled: true
                              },
                              index: -1
                          };
                          mergedData =
                              this.summaryPlacement === 'top'
                                  ? [summaryRowData, ...mergedPaginationData]
                                  : [...mergedPaginationData, summaryRowData];
                      }
                  }
                  else {
                      mergedData = mergedPaginationData;
                  }
                  const indentStyle = hasChildren
                      ? { width: pxfy(this.indent) }
                      : undefined;
                  // Tile the data of the expanded row
                  const displayedData = [];
                  mergedData.forEach((rowInfo) => {
                      if (renderExpand &&
                          mergedExpandedRowKeySet.has(rowInfo.key) &&
                          (!expandable || expandable(rowInfo.tmNode.rawNode))) {
                          displayedData.push(rowInfo, {
                              isExpandedRow: true,
                              key: `${rowInfo.key}-expand`, // solve key repeat of the expanded row
                              tmNode: rowInfo.tmNode,
                              index: rowInfo.index
                          });
                      }
                      else {
                          displayedData.push(rowInfo);
                      }
                  });
                  const { length: rowCount } = displayedData;
                  const rowIndexToKey = {};
                  paginatedData.forEach(({ tmNode }, rowIndex) => {
                      rowIndexToKey[rowIndex] = tmNode.key;
                  });
                  const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
                  const bodyWidthPx = bodyWidth === null ? undefined : `${bodyWidth}px`;
                  const renderRow = (rowInfo, displayedRowIndex, isVirtual) => {
                      const { index: actualRowIndex } = rowInfo;
                      if ('isExpandedRow' in rowInfo) {
                          const { tmNode: { key, rawNode } } = rowInfo;
                          return (h("tr", { class: `${mergedClsPrefix}-data-table-tr ${mergedClsPrefix}-data-table-tr--expanded`, key: `${key}__expand` },
                              h("td", { class: [
                                      `${mergedClsPrefix}-data-table-td`,
                                      `${mergedClsPrefix}-data-table-td--last-col`,
                                      displayedRowIndex + 1 === rowCount &&
                                          `${mergedClsPrefix}-data-table-td--last-row`
                                  ], colspan: colCount }, stickyExpandedRows ? (h("div", { class: `${mergedClsPrefix}-data-table-expand`, style: {
                                      width: bodyWidthPx
                                  } }, renderExpand(rawNode, actualRowIndex))) : (renderExpand(rawNode, actualRowIndex)))));
                      }
                      const isSummary = 'isSummaryRow' in rowInfo;
                      const striped = !isSummary && rowInfo.striped;
                      const { tmNode, key: rowKey } = rowInfo;
                      const { rawNode: rowData } = tmNode;
                      const expanded = mergedExpandedRowKeySet.has(rowKey);
                      const props = rowProps
                          ? rowProps(rowData, actualRowIndex)
                          : undefined;
                      const mergedRowClassName = typeof rowClassName === 'string'
                          ? rowClassName
                          : createRowClassName(rowData, actualRowIndex, rowClassName);
                      const row = (h("tr", Object.assign({ onMouseenter: () => {
                              this.hoverKey = rowKey;
                          }, key: rowKey, class: [
                              `${mergedClsPrefix}-data-table-tr`,
                              isSummary && `${mergedClsPrefix}-data-table-tr--summary`,
                              striped && `${mergedClsPrefix}-data-table-tr--striped`,
                              expanded && `${mergedClsPrefix}-data-table-tr--expanded`,
                              mergedRowClassName
                          ] }, props), cols.map((col, colIndex) => {
                          var _a, _b, _c, _d, _e;
                          if (displayedRowIndex in cordToPass) {
                              const cordOfRowToPass = cordToPass[displayedRowIndex];
                              const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                              if (~indexInCordOfRowToPass) {
                                  cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                                  return null;
                              }
                          }
                          // TODO: Simplify row calculation
                          const { column } = col;
                          const colKey = getColKey(col);
                          const { rowSpan, colSpan } = column;
                          const mergedColSpan = isSummary
                              ? ((_a = rowInfo.tmNode.rawNode[colKey]) === null || _a === void 0 ? void 0 : _a.colSpan) || 1 // optional for #1276
                              : colSpan
                                  ? colSpan(rowData, actualRowIndex)
                                  : 1;
                          const mergedRowSpan = isSummary
                              ? ((_b = rowInfo.tmNode.rawNode[colKey]) === null || _b === void 0 ? void 0 : _b.rowSpan) || 1 // optional for #1276
                              : rowSpan
                                  ? rowSpan(rowData, actualRowIndex)
                                  : 1;
                          const isLastCol = colIndex + mergedColSpan === colCount;
                          const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
                          const isCrossRowTd = mergedRowSpan > 1;
                          if (isCrossRowTd) {
                              cordKey[displayedRowIndex] = {
                                  [colIndex]: []
                              };
                          }
                          if (mergedColSpan > 1 || isCrossRowTd) {
                              for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                                  if (isCrossRowTd) {
                                      cordKey[displayedRowIndex][colIndex].push(rowIndexToKey[i]);
                                  }
                                  for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                                      if (i === displayedRowIndex && j === colIndex) {
                                          continue;
                                      }
                                      if (!(i in cordToPass)) {
                                          cordToPass[i] = [j];
                                      }
                                      else {
                                          cordToPass[i].push(j);
                                      }
                                  }
                              }
                          }
                          const hoverKey = isCrossRowTd ? this.hoverKey : null;
                          const { cellProps } = column;
                          const resolvedCellProps = cellProps === null || cellProps === void 0 ? void 0 : cellProps(rowData, actualRowIndex);
                          const indentOffsetStyle = {
                              '--indent-offset': ''
                          };
                          return (h("td", Object.assign({}, resolvedCellProps, { key: colKey, style: [
                                  {
                                      textAlign: column.align || undefined,
                                      left: pxfy((_c = fixedColumnLeftMap[colKey]) === null || _c === void 0 ? void 0 : _c.start),
                                      right: pxfy((_d = fixedColumnRightMap[colKey]) === null || _d === void 0 ? void 0 : _d.start)
                                  },
                                  indentOffsetStyle,
                                  (resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.style) || ''
                              ], colspan: mergedColSpan, rowspan: isVirtual ? undefined : mergedRowSpan, "data-col-key": colKey, class: [
                                  `${mergedClsPrefix}-data-table-td`,
                                  column.className,
                                  resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.class,
                                  isSummary &&
                                      `${mergedClsPrefix}-data-table-td--summary`,
                                  ((hoverKey !== null &&
                                      cordKey[displayedRowIndex][colIndex].includes(hoverKey)) ||
                                      isColumnSorting(column, mergedSortState)) &&
                                      `${mergedClsPrefix}-data-table-td--hover`,
                                  column.fixed &&
                                      `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`,
                                  column.align &&
                                      `${mergedClsPrefix}-data-table-td--${column.align}-align`,
                                  column.type === 'selection' &&
                                      `${mergedClsPrefix}-data-table-td--selection`,
                                  column.type === 'expand' &&
                                      `${mergedClsPrefix}-data-table-td--expand`,
                                  isLastCol &&
                                      `${mergedClsPrefix}-data-table-td--last-col`,
                                  isLastRow &&
                                      `${mergedClsPrefix}-data-table-td--last-row`
                              ] }),
                              hasChildren && colIndex === childTriggerColIndex
                                  ? [
                                      repeat((indentOffsetStyle['--indent-offset'] =
                                          isSummary ? 0 : rowInfo.tmNode.level), h("div", { class: `${mergedClsPrefix}-data-table-indent`, style: indentStyle })),
                                      isSummary || rowInfo.tmNode.isLeaf ? (h("div", { class: `${mergedClsPrefix}-data-table-expand-placeholder` })) : (h(ExpandTrigger, { class: `${mergedClsPrefix}-data-table-expand-trigger`, clsPrefix: mergedClsPrefix, expanded: expanded, renderExpandIcon: this.renderExpandIcon, loading: loadingKeySet.has(rowInfo.key), onClick: () => {
                                              handleUpdateExpanded(rowKey, rowInfo.tmNode);
                                          } }))
                                  ]
                                  : null,
                              column.type === 'selection' ? (!isSummary ? (column.multiple === false ? (h(RenderSafeRadio, { key: currentPage, rowKey: rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: () => {
                                      handleRadioUpdateChecked(rowInfo.tmNode);
                                  } })) : (h(RenderSafeCheckbox, { key: currentPage, rowKey: rowKey, disabled: rowInfo.tmNode.disabled, onUpdateChecked: (checked, e) => {
                                      handleCheckboxUpdateChecked(rowInfo.tmNode, checked, e.shiftKey);
                                  } }))) : null) : column.type === 'expand' ? (!isSummary ? (!column.expandable ||
                                  ((_e = column.expandable) === null || _e === void 0 ? void 0 : _e.call(column, rowData)) ? (h(ExpandTrigger, { clsPrefix: mergedClsPrefix, expanded: expanded, renderExpandIcon: this.renderExpandIcon, onClick: () => {
                                      handleUpdateExpanded(rowKey, null);
                                  } })) : null) : null) : (h(Cell, { clsPrefix: mergedClsPrefix, index: actualRowIndex, row: rowData, column: column, isSummary: isSummary, mergedTheme: mergedTheme, renderCell: this.renderCell }))));
                      })));
                      return row;
                  };
                  if (!virtualScroll) {
                      return (h("table", { class: `${mergedClsPrefix}-data-table-table`, onMouseleave: handleMouseleaveTable, style: {
                              tableLayout: this.mergedTableLayout
                          } },
                          h("colgroup", null, cols.map((col) => (h("col", { key: col.key, style: col.style })))),
                          this.showHeader ? h(TableHeader, { discrete: false }) : null,
                          !this.empty ? (h("tbody", { "data-n-id": componentId, class: `${mergedClsPrefix}-data-table-tbody` }, displayedData.map((rowInfo, displayedRowIndex) => {
                              return renderRow(rowInfo, displayedRowIndex, false);
                          }))) : null));
                  }
                  else {
                      return (h(VVirtualList, { ref: "virtualListRef", items: displayedData, itemSize: 28, visibleItemsTag: VirtualListItemWrapper, visibleItemsProps: {
                              clsPrefix: mergedClsPrefix,
                              id: componentId,
                              cols,
                              onMouseleave: handleMouseleaveTable
                          }, showScrollbar: false, onResize: this.handleVirtualListResize, onScroll: this.handleVirtualListScroll, itemsStyle: contentStyle, itemResizable: true }, {
                          default: ({ item, index }) => renderRow(item, index, true)
                      }));
                  }
              }
          }));
          if (this.empty) {
              const createEmptyNode = () => (h("div", { class: [
                      `${mergedClsPrefix}-data-table-empty`,
                      this.loading && `${mergedClsPrefix}-data-table-empty--hide`
                  ], style: this.bodyStyle, ref: "emptyElRef" }, resolveSlot(this.dataTableSlots.empty, () => [
                  h(NEmpty, { theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
              ])));
              if (this.shouldDisplaySomeTablePart) {
                  return (h(Fragment, null,
                      tableNode,
                      createEmptyNode()));
              }
              else {
                  return (h(VResizeObserver, { onResize: this.onResize }, { default: createEmptyNode }));
              }
          }
          return tableNode;
      }
  });

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  var MainTable = defineComponent({
      setup() {
          const { mergedClsPrefixRef, rightFixedColumnsRef, leftFixedColumnsRef, bodyWidthRef, maxHeightRef, minHeightRef, flexHeightRef, syncScrollState
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dataTableInjectionKey);
          const headerInstRef = ref(null);
          const bodyInstRef = ref(null);
          const selfElRef = ref(null);
          const fixedStateInitializedRef = ref(!(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length));
          const bodyStyleRef = computed(() => {
              return {
                  maxHeight: formatLength(maxHeightRef.value),
                  minHeight: formatLength(minHeightRef.value)
              };
          });
          function handleBodyResize(entry) {
              bodyWidthRef.value = entry.contentRect.width;
              syncScrollState();
              if (!fixedStateInitializedRef.value) {
                  fixedStateInitializedRef.value = true;
              }
          }
          function getHeaderElement() {
              const { value } = headerInstRef;
              if (value) {
                  return value.$el;
              }
              return null;
          }
          function getBodyElement() {
              const { value } = bodyInstRef;
              if (value) {
                  return value.getScrollContainer();
              }
              return null;
          }
          const exposedMethods = {
              getBodyElement,
              getHeaderElement,
              scrollTo(arg0, arg1) {
                  var _a;
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  (_a = bodyInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
              }
          };
          watchEffect(() => {
              const { value: selfEl } = selfElRef;
              if (!selfEl)
                  return;
              const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
              if (fixedStateInitializedRef.value) {
                  setTimeout(() => {
                      selfEl.classList.remove(transitionDisabledClass);
                  }, 0);
              }
              else {
                  selfEl.classList.add(transitionDisabledClass);
              }
          });
          return Object.assign({ maxHeight: maxHeightRef, mergedClsPrefix: mergedClsPrefixRef, selfElRef,
              headerInstRef,
              bodyInstRef, bodyStyle: bodyStyleRef, flexHeight: flexHeightRef, handleBodyResize }, exposedMethods);
      },
      render() {
          const { mergedClsPrefix, maxHeight, flexHeight } = this;
          const headerInBody = maxHeight === undefined && !flexHeight;
          return (h("div", { class: `${mergedClsPrefix}-data-table-base-table`, ref: "selfElRef" },
              headerInBody ? null : h(TableHeader, { ref: "headerInstRef" }),
              h(TableBody, { ref: "bodyInstRef", bodyStyle: this.bodyStyle, showHeader: headerInBody, flexHeight: flexHeight, onResize: this.handleBodyResize })));
      }
  });

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useCheck(props, data) {
      const { paginatedDataRef, treeMateRef, selectionColumnRef } = data;
      const uncontrolledCheckedRowKeysRef = ref(props.defaultCheckedRowKeys);
      const mergedCheckState = computed(() => {
          var _a;
          const { checkedRowKeys } = props;
          const sourceKeys = checkedRowKeys === undefined
              ? uncontrolledCheckedRowKeysRef.value
              : checkedRowKeys;
          if (((_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.multiple) === false) {
              return {
                  checkedKeys: sourceKeys.slice(0, 1),
                  indeterminateKeys: []
              };
          }
          return treeMateRef.value.getCheckedKeys(sourceKeys, {
              cascade: props.cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
          });
      });
      const mergedCheckedRowKeysRef = computed(() => mergedCheckState.value.checkedKeys);
      const mergedInderminateRowKeysRef = computed(() => mergedCheckState.value.indeterminateKeys);
      const mergedCheckedRowKeySetRef = computed(() => {
          return new Set(mergedCheckedRowKeysRef.value);
      });
      const mergedInderminateRowKeySetRef = computed(() => {
          return new Set(mergedInderminateRowKeysRef.value);
      });
      const countOfCurrentPageCheckedRowsRef = computed(() => {
          const { value: mergedCheckedRowKeySet } = mergedCheckedRowKeySetRef;
          return paginatedDataRef.value.reduce((total, tmNode) => {
              const { key, disabled } = tmNode;
              return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
          }, 0);
      });
      const countOfCurrentPageDisabledRowsRef = computed(() => {
          return paginatedDataRef.value.filter((item) => item.disabled).length;
      });
      const someRowsCheckedRef = computed(() => {
          const { length } = paginatedDataRef.value;
          const { value: mergedInderminateRowKeySet } = mergedInderminateRowKeySetRef;
          return ((countOfCurrentPageCheckedRowsRef.value > 0 &&
              countOfCurrentPageCheckedRowsRef.value <
                  length - countOfCurrentPageDisabledRowsRef.value) ||
              paginatedDataRef.value.some((rowData) => mergedInderminateRowKeySet.has(rowData.key)));
      });
      const allRowsCheckedRef = computed(() => {
          const { length } = paginatedDataRef.value;
          return (countOfCurrentPageCheckedRowsRef.value !== 0 &&
              countOfCurrentPageCheckedRowsRef.value ===
                  length - countOfCurrentPageDisabledRowsRef.value);
      });
      const headerCheckboxDisabledRef = computed(() => {
          return paginatedDataRef.value.length === 0;
      });
      function doUpdateCheckedRowKeys(keys, row, action) {
          const { 'onUpdate:checkedRowKeys': _onUpdateCheckedRowKeys, onUpdateCheckedRowKeys, onCheckedRowKeysChange } = props;
          const rows = [];
          const { value: { getNode } } = treeMateRef;
          keys.forEach((key) => {
              var _a;
              const row = (_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              rows.push(row);
          });
          if (_onUpdateCheckedRowKeys) {
              call(_onUpdateCheckedRowKeys, keys, rows, { row, action });
          }
          if (onUpdateCheckedRowKeys) {
              call(onUpdateCheckedRowKeys, keys, rows, { row, action });
          }
          if (onCheckedRowKeysChange) {
              call(onCheckedRowKeysChange, keys, rows, { row, action });
          }
          uncontrolledCheckedRowKeysRef.value = keys;
      }
      function doCheck(rowKey, single = false, rowInfo) {
          if (props.loading)
              return;
          if (single) {
              doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey], rowInfo, 'check');
              return;
          }
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
              cascade: props.cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, 'check');
      }
      function doUncheck(rowKey, rowInfo) {
          if (props.loading)
              return;
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
              cascade: props.cascade,
              allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, 'uncheck');
      }
      function doCheckAll(checkWholeTable = false) {
          const { value: column } = selectionColumnRef;
          if (!column || props.loading)
              return;
          const rowKeysToCheck = [];
          (checkWholeTable
              ? treeMateRef.value.treeNodes
              : paginatedDataRef.value).forEach((tmNode) => {
              if (!tmNode.disabled) {
                  rowKeysToCheck.push(tmNode.key);
              }
          });
          // alway cascade, to emit correct row keys
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
              cascade: true,
              allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, undefined, 'checkAll');
      }
      function doUncheckAll(checkWholeTable = false) {
          const { value: column } = selectionColumnRef;
          if (!column || props.loading)
              return;
          const rowKeysToUncheck = [];
          (checkWholeTable
              ? treeMateRef.value.treeNodes
              : paginatedDataRef.value).forEach((tmNode) => {
              if (!tmNode.disabled) {
                  rowKeysToUncheck.push(tmNode.key);
              }
          });
          // alway cascade, to emit correct row keys
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
              cascade: true,
              allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, undefined, 'uncheckAll');
      }
      return {
          mergedCheckedRowKeySetRef,
          mergedCheckedRowKeysRef,
          mergedInderminateRowKeySetRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          headerCheckboxDisabledRef,
          doUpdateCheckedRowKeys,
          doCheckAll,
          doUncheckAll,
          doCheck,
          doUncheck
      };
  }

  function getMultiplePriority(sorter) {
      if (typeof sorter === 'object' && typeof sorter.multiple === 'number') {
          return sorter.multiple;
      }
      return false;
  }
  function getSortFunction(sorter, columnKey) {
      if (columnKey &&
          (sorter === undefined ||
              sorter === 'default' ||
              (typeof sorter === 'object' && sorter.compare === 'default'))) {
          return getDefaultSorterFn(columnKey);
      }
      if (typeof sorter === 'function') {
          return sorter;
      }
      if (sorter &&
          typeof sorter === 'object' &&
          sorter.compare &&
          sorter.compare !== 'default') {
          return sorter.compare;
      }
      return false;
  }
  function getDefaultSorterFn(columnKey) {
      return (row1, row2) => {
          const value1 = row1[columnKey];
          const value2 = row2[columnKey];
          if (typeof value1 === 'number' && typeof value2 === 'number') {
              return value1 - value2;
          }
          else if (typeof value1 === 'string' && typeof value2 === 'string') {
              return value1.localeCompare(value2);
          }
          return 0;
      };
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useSorter(props, { dataRelatedColsRef, filteredDataRef }) {
      const defaultSortState = [];
      // initialize
      dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.sorter !== undefined) {
              updateSortStatesByNewSortState(defaultSortState, {
                  columnKey: column.key,
                  sorter: column.sorter,
                  order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false
              });
          }
      });
      const uncontrolledSortStateRef = ref(defaultSortState);
      const mergedSortStateRef = computed(() => {
          // If one of the columns's sort order is false or 'ascend' or 'descend',
          // the table's controll functionality should work in controlled manner.
          const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== 'selection' &&
              column.sorter !== undefined &&
              (column.sortOrder === 'ascend' ||
                  column.sortOrder === 'descend' ||
                  column.sortOrder === false));
          // if multiple columns are controlled sortable, then we need to find columns with active sortOrder
          const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);
          if (columnToSort.length) {
              return columnToSort.map((column) => {
                  return {
                      columnKey: column.key,
                      // column to sort has controlled sorter
                      // sorter && sort order won't be undefined
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      order: column.sortOrder,
                      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                      sorter: column.sorter
                  };
              });
          }
          // If any column is in controlled mode, the sorting state of the table is
          // in controlled mode
          if (columnsWithControlledSortOrder.length)
              return [];
          const { value: uncontrolledSortState } = uncontrolledSortStateRef;
          if (Array.isArray(uncontrolledSortState)) {
              return uncontrolledSortState;
          }
          else if (uncontrolledSortState) {
              return [uncontrolledSortState];
          }
          else {
              return [];
          }
      });
      const sortedDataRef = computed(() => {
          const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {
              const item1Priority = getMultiplePriority(a.sorter) || 0;
              const item2Priority = getMultiplePriority(b.sorter) || 0;
              return item2Priority - item1Priority;
          });
          if (activeSorters.length) {
              const filteredData = filteredDataRef.value.slice();
              return filteredData.sort((tmNode1, tmNode2) => {
                  let compareResult = 0;
                  activeSorters.some((sorterState) => {
                      const { columnKey, sorter, order } = sorterState;
                      const compareFn = getSortFunction(sorter, columnKey);
                      if (compareFn && order) {
                          compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);
                          if (compareResult !== 0) {
                              compareResult = compareResult * getFlagOfOrder(order);
                              return true;
                          }
                      }
                      return false;
                  });
                  return compareResult;
              });
          }
          return filteredDataRef.value;
      });
      function getUpdatedSorterState(sortState) {
          let currentSortState = mergedSortStateRef.value.slice();
          // Multiple sorter (if you clicked on a multiple sort column)
          if (sortState && getMultiplePriority(sortState.sorter) !== false) {
              // clear column is not multiple sort
              currentSortState = currentSortState.filter((sortState) => getMultiplePriority(sortState.sorter) !== false);
              updateSortStatesByNewSortState(currentSortState, sortState);
              return currentSortState;
          }
          else if (sortState) {
              // single sorter
              return sortState;
          }
          // no sorter
          return null;
      }
      function deriveNextSorter(sortState) {
          const nextSorterState = getUpdatedSorterState(sortState);
          doUpdateSorter(nextSorterState);
      }
      function doUpdateSorter(sortState) {
          const { 'onUpdate:sorter': _onUpdateSorter, onUpdateSorter, onSorterChange } = props;
          if (_onUpdateSorter) {
              call(_onUpdateSorter, sortState);
          }
          if (onUpdateSorter) {
              call(onUpdateSorter, sortState);
          }
          if (onSorterChange) {
              call(onSorterChange, sortState);
          }
          uncontrolledSortStateRef.value = sortState;
      }
      function sort(columnKey, order = 'ascend') {
          if (!columnKey) {
              clearSorter();
          }
          else {
              const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== 'selection' &&
                  column.type !== 'expand' &&
                  column.key === columnKey);
              if (!(columnToSort === null || columnToSort === void 0 ? void 0 : columnToSort.sorter))
                  return;
              const sorter = columnToSort.sorter;
              deriveNextSorter({
                  columnKey,
                  sorter,
                  order
              });
          }
      }
      function clearSorter() {
          doUpdateSorter(null);
      }
      function updateSortStatesByNewSortState(sortStates, sortState) {
          const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);
          if (index !== undefined && index >= 0) {
              sortStates[index] = sortState;
          }
          else {
              sortStates.push(sortState);
          }
      }
      return {
          clearSorter,
          sort,
          sortedDataRef,
          mergedSortStateRef,
          deriveNextSorter
      };
  }

  // useTableData combines filter, sorter and pagination
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useTableData(props, { dataRelatedColsRef }) {
      const selectionColumnRef = computed(() => {
          const getSelectionColumn = (cols) => {
              for (let i = 0; i < cols.length; ++i) {
                  const col = cols[i];
                  if ('children' in col) {
                      return getSelectionColumn(col.children);
                  }
                  else if (col.type === 'selection') {
                      return col;
                  }
              }
              return null;
          };
          return getSelectionColumn(props.columns);
      });
      const treeMateRef = computed(() => {
          const { childrenKey } = props;
          return createTreeMate(props.data, {
              ignoreEmptyChildren: true,
              getKey: props.rowKey,
              getChildren: (rowData) => rowData[childrenKey],
              getDisabled: (rowData) => {
                  var _a, _b;
                  if ((_b = (_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.disabled) === null || _b === void 0 ? void 0 : _b.call(_a, rowData)) {
                      return true;
                  }
                  return false;
              }
          });
      });
      const childTriggerColIndexRef = useMemo(() => {
          const { columns } = props;
          const { length } = columns;
          let firstContentfulColIndex = null;
          for (let i = 0; i < length; ++i) {
              const col = columns[i];
              if (!col.type && firstContentfulColIndex === null) {
                  firstContentfulColIndex = i;
              }
              if ('tree' in col && col.tree) {
                  return i;
              }
          }
          return firstContentfulColIndex || 0;
      });
      const uncontrolledFilterStateRef = ref({});
      const uncontrolledCurrentPageRef = ref(1);
      const uncontrolledPageSizeRef = ref(10);
      const mergedFilterStateRef = computed(() => {
          const columnsWithControlledFilter = dataRelatedColsRef.value.filter((column) => {
              return (column.filterOptionValues !== undefined ||
                  column.filterOptionValue !== undefined);
          });
          const controlledFilterState = {};
          columnsWithControlledFilter.forEach((column) => {
              var _a;
              if (column.type === 'selection' || column.type === 'expand')
                  return;
              if (column.filterOptionValues === undefined) {
                  controlledFilterState[column.key] = (_a = column.filterOptionValue) !== null && _a !== void 0 ? _a : null;
              }
              else {
                  controlledFilterState[column.key] = column.filterOptionValues;
              }
          });
          const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
          return activeFilters;
      });
      const filteredDataRef = computed(() => {
          const mergedFilterState = mergedFilterStateRef.value;
          const { columns } = props;
          function createDefaultFilter(columnKey) {
              return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
          }
          const { value: { treeNodes: data } } = treeMateRef;
          const columnEntries = [];
          columns.forEach((column) => {
              if (column.type === 'selection' ||
                  column.type === 'expand' ||
                  'children' in column) {
                  return;
              }
              columnEntries.push([column.key, column]);
          });
          return data
              ? data.filter((tmNode) => {
                  const { rawNode: row } = tmNode;
                  // traverse all filters
                  for (const [columnKey, column] of columnEntries) {
                      let activeFilterOptionValues = mergedFilterState[columnKey];
                      if (activeFilterOptionValues == null)
                          continue;
                      if (!Array.isArray(activeFilterOptionValues)) {
                          activeFilterOptionValues = [activeFilterOptionValues];
                      }
                      if (!activeFilterOptionValues.length)
                          continue;
                      // When async, filter won't be set, so data won't be filtered
                      const filter = column.filter === 'default'
                          ? createDefaultFilter(columnKey)
                          : column.filter;
                      if (column && typeof filter === 'function') {
                          if (column.filterMode === 'and') {
                              if (activeFilterOptionValues.some((filterOptionValue) => !filter(filterOptionValue, row))) {
                                  return false;
                              }
                          }
                          else {
                              if (activeFilterOptionValues.some((filterOptionValue) => filter(filterOptionValue, row))) {
                                  continue;
                              }
                              else {
                                  return false;
                              }
                          }
                      }
                  }
                  return true;
              })
              : [];
      });
      const { sortedDataRef, deriveNextSorter, mergedSortStateRef, sort, clearSorter } = useSorter(props, {
          dataRelatedColsRef,
          filteredDataRef
      });
      // initialize
      dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.filter) {
              const defaultFilterOptionValues = column.defaultFilterOptionValues;
              if (column.filterMultiple) {
                  uncontrolledFilterStateRef.value[column.key] =
                      defaultFilterOptionValues || [];
              }
              else if (defaultFilterOptionValues !== undefined) {
                  // this branch is for compatibility, someone may use `values` in single filter mode
                  uncontrolledFilterStateRef.value[column.key] =
                      defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
              }
              else {
                  uncontrolledFilterStateRef.value[column.key] =
                      (_a = column.defaultFilterOptionValue) !== null && _a !== void 0 ? _a : null;
              }
          }
      });
      const controlledCurrentPageRef = computed(() => {
          const { pagination } = props;
          if (pagination === false)
              return undefined;
          return pagination.page;
      });
      const controlledPageSizeRef = computed(() => {
          const { pagination } = props;
          if (pagination === false)
              return undefined;
          return pagination.pageSize;
      });
      const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);
      const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
      const boundedMergedCurrentPageRef = useMemo(() => {
          const page = _mergedCurrentPageRef.value;
          return props.remote
              ? page
              : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page));
      });
      const mergedPageCountRef = computed(() => {
          const { pagination } = props;
          if (pagination) {
              const { pageCount } = pagination;
              if (pageCount !== undefined)
                  return pageCount;
          }
          return undefined;
      });
      const paginatedDataRef = computed(() => {
          if (props.remote)
              return treeMateRef.value.treeNodes;
          if (!props.pagination)
              return sortedDataRef.value;
          const pageSize = mergedPageSizeRef.value;
          const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
          return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
      });
      const rawPaginatedDataRef = computed(() => {
          return paginatedDataRef.value.map((tmNode) => tmNode.rawNode);
      });
      function mergedOnUpdatePage(page) {
          const { pagination } = props;
          if (pagination) {
              const { onChange, 'onUpdate:page': _onUpdatePage, onUpdatePage } = pagination;
              if (onChange)
                  call(onChange, page);
              if (onUpdatePage)
                  call(onUpdatePage, page);
              if (_onUpdatePage)
                  call(_onUpdatePage, page);
              doUpdatePage(page);
          }
      }
      function mergedOnUpdatePageSize(pageSize) {
          const { pagination } = props;
          if (pagination) {
              const { onPageSizeChange, 'onUpdate:pageSize': _onUpdatePageSize, onUpdatePageSize } = pagination;
              if (onPageSizeChange)
                  call(onPageSizeChange, pageSize);
              if (onUpdatePageSize)
                  call(onUpdatePageSize, pageSize);
              if (_onUpdatePageSize)
                  call(_onUpdatePageSize, pageSize);
              doUpdatePageSize(pageSize);
          }
      }
      const mergedItemCountRef = computed(() => {
          if (props.remote) {
              const { pagination } = props;
              if (pagination) {
                  const { itemCount } = pagination;
                  if (itemCount !== undefined)
                      return itemCount;
              }
              return undefined;
          }
          return filteredDataRef.value.length;
      });
      const mergedPaginationRef = computed(() => {
          return Object.assign(Object.assign({}, props.pagination), { 
              // reset deprecated methods
              onChange: undefined, onUpdatePage: undefined, onUpdatePageSize: undefined, onPageSizeChange: undefined, 'onUpdate:page': mergedOnUpdatePage, 'onUpdate:pageSize': mergedOnUpdatePageSize, 
              // writing merged props after pagination to avoid
              // pagination[key] === undefined
              // key still exists but value is undefined
              page: boundedMergedCurrentPageRef.value, pageSize: mergedPageSizeRef.value, pageCount: mergedItemCountRef.value === undefined
                  ? mergedPageCountRef.value
                  : undefined, itemCount: mergedItemCountRef.value });
      });
      function doUpdatePage(page) {
          const { 'onUpdate:page': _onUpdatePage, onPageChange, onUpdatePage } = props;
          if (onUpdatePage)
              call(onUpdatePage, page);
          if (_onUpdatePage)
              call(_onUpdatePage, page);
          if (onPageChange)
              call(onPageChange, page);
          uncontrolledCurrentPageRef.value = page;
      }
      function doUpdatePageSize(pageSize) {
          const { 'onUpdate:pageSize': _onUpdatePageSize, onPageSizeChange, onUpdatePageSize } = props;
          if (onPageSizeChange)
              call(onPageSizeChange, pageSize);
          if (onUpdatePageSize)
              call(onUpdatePageSize, pageSize);
          if (_onUpdatePageSize)
              call(_onUpdatePageSize, pageSize);
          uncontrolledPageSizeRef.value = pageSize;
      }
      function doUpdateFilters(filters, sourceColumn) {
          const { onUpdateFilters, 'onUpdate:filters': _onUpdateFilters, onFiltersChange } = props;
          if (onUpdateFilters)
              call(onUpdateFilters, filters, sourceColumn);
          if (_onUpdateFilters)
              call(_onUpdateFilters, filters, sourceColumn);
          if (onFiltersChange)
              call(onFiltersChange, filters, sourceColumn);
          uncontrolledFilterStateRef.value = filters;
      }
      function onUnstableColumnResize(resizedWidth, limitedWidth, column, getColumnWidth) {
          var _a;
          (_a = props.onUnstableColumnResize) === null || _a === void 0 ? void 0 : _a.call(props, resizedWidth, limitedWidth, column, getColumnWidth);
      }
      function page(page) {
          doUpdatePage(page);
      }
      function clearFilter() {
          clearFilters();
      }
      function clearFilters() {
          filters({});
      }
      function filters(filters) {
          filter(filters);
      }
      function filter(filters) {
          if (!filters) {
              uncontrolledFilterStateRef.value = {};
          }
          else if (filters) {
              uncontrolledFilterStateRef.value = createShallowClonedObject(filters);
          }
          else ;
      }
      return {
          treeMateRef,
          mergedCurrentPageRef: boundedMergedCurrentPageRef,
          mergedPaginationRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          mergedFilterStateRef,
          mergedSortStateRef,
          hoverKeyRef: ref(null),
          selectionColumnRef,
          childTriggerColIndexRef,
          doUpdateFilters,
          deriveNextSorter,
          doUpdatePageSize,
          doUpdatePage,
          onUnstableColumnResize,
          // exported methods
          filter,
          filters,
          clearFilter,
          clearFilters,
          clearSorter,
          page,
          sort
      };
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useScroll(props, { mainTableInstRef, mergedCurrentPageRef, bodyWidthRef }) {
      let lastScrollLeft = 0;
      const scrollPartRef = ref();
      const leftActiveFixedColKeyRef = ref(null);
      const leftActiveFixedChildrenColKeysRef = ref([]);
      const rightActiveFixedColKeyRef = ref(null);
      const rightActiveFixedChildrenColKeysRef = ref([]);
      const styleScrollXRef = computed(() => {
          return formatLength(props.scrollX);
      });
      const leftFixedColumnsRef = computed(() => {
          return props.columns.filter((column) => column.fixed === 'left');
      });
      const rightFixedColumnsRef = computed(() => {
          return props.columns.filter((column) => column.fixed === 'right');
      });
      const fixedColumnLeftMapRef = computed(() => {
          const columns = {};
          let left = 0;
          function traverse(cols) {
              cols.forEach((col) => {
                  const positionInfo = { start: left, end: 0 };
                  columns[getColKey(col)] = positionInfo;
                  if ('children' in col) {
                      traverse(col.children);
                      positionInfo.end = left;
                  }
                  else {
                      left += getNumberColWidth(col) || 0;
                      positionInfo.end = left;
                  }
              });
          }
          traverse(leftFixedColumnsRef.value);
          return columns;
      });
      const fixedColumnRightMapRef = computed(() => {
          const columns = {};
          let right = 0;
          function traverse(cols) {
              for (let i = cols.length - 1; i >= 0; --i) {
                  const col = cols[i];
                  const positionInfo = { start: right, end: 0 };
                  columns[getColKey(col)] = positionInfo;
                  if ('children' in col) {
                      traverse(col.children);
                      positionInfo.end = right;
                  }
                  else {
                      right += getNumberColWidth(col) || 0;
                      positionInfo.end = right;
                  }
              }
          }
          traverse(rightFixedColumnsRef.value);
          return columns;
      });
      function deriveActiveLeftFixedColumn() {
          var _a, _b;
          // target is header element
          const { value: leftFixedColumns } = leftFixedColumnsRef;
          let leftWidth = 0;
          const { value: fixedColumnLeftMap } = fixedColumnLeftMapRef;
          let leftActiveFixedColKey = null;
          for (let i = 0; i < leftFixedColumns.length; ++i) {
              const key = getColKey(leftFixedColumns[i]);
              if (lastScrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {
                  leftActiveFixedColKey = key;
                  leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
              }
              else {
                  break;
              }
          }
          leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
      }
      function deriveActiveLeftFixedChildrenColumns() {
          leftActiveFixedChildrenColKeysRef.value = [];
          let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);
          while (activeLeftFixedColumn && 'children' in activeLeftFixedColumn) {
              const length = activeLeftFixedColumn.children.length;
              if (length === 0)
                  break;
              const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
              leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
              activeLeftFixedColumn = nextActiveLeftFixedColumn;
          }
      }
      function deriveActiveRightFixedColumn() {
          var _a, _b;
          // target is header element
          const { value: rightFixedColumns } = rightFixedColumnsRef;
          const scrollWidth = Number(props.scrollX);
          const { value: tableWidth } = bodyWidthRef;
          if (tableWidth === null)
              return;
          let rightWidth = 0;
          let rightActiveFixedColKey = null;
          const { value: fixedColumnRightMap } = fixedColumnRightMapRef;
          for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
              const key = getColKey(rightFixedColumns[i]);
              if (Math.round(lastScrollLeft +
                  (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) +
                  tableWidth -
                  rightWidth) < scrollWidth) {
                  rightActiveFixedColKey = key;
                  rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
              }
              else {
                  break;
              }
          }
          rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
      }
      function deriveActiveRightFixedChildrenColumns() {
          rightActiveFixedChildrenColKeysRef.value = [];
          let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);
          while (activeRightFixedColumn &&
              'children' in activeRightFixedColumn &&
              activeRightFixedColumn.children.length) {
              const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
              rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
              activeRightFixedColumn = nextActiveRightFixedColumn;
          }
      }
      function getScrollElements() {
          const header = mainTableInstRef.value
              ? mainTableInstRef.value.getHeaderElement()
              : null;
          const body = mainTableInstRef.value
              ? mainTableInstRef.value.getBodyElement()
              : null;
          return {
              header,
              body
          };
      }
      function scrollMainTableBodyToTop() {
          const { body } = getScrollElements();
          if (body) {
              body.scrollTop = 0;
          }
      }
      function handleTableHeaderScroll() {
          if (scrollPartRef.value !== 'body') {
              beforeNextFrameOnce(syncScrollState);
          }
          else {
              scrollPartRef.value = undefined;
          }
      }
      function handleTableBodyScroll(e) {
          var _a;
          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (scrollPartRef.value !== 'head') {
              beforeNextFrameOnce(syncScrollState);
          }
          else {
              scrollPartRef.value = undefined;
          }
      }
      function syncScrollState() {
          // We can't simply use props.scrollX to determine whether the table has
          // need to be sync since user may set column width for each column.
          // Just let it be, the scroll listener won't be triggered for a basic table.
          const { header, body } = getScrollElements();
          if (!body)
              return;
          const { value: tableWidth } = bodyWidthRef;
          if (tableWidth === null)
              return;
          if (props.maxHeight || props.flexHeight) {
              if (!header)
                  return;
              // we need to deal with overscroll
              const directionHead = lastScrollLeft - header.scrollLeft;
              scrollPartRef.value = directionHead !== 0 ? 'head' : 'body';
              if (scrollPartRef.value === 'head') {
                  lastScrollLeft = header.scrollLeft;
                  body.scrollLeft = lastScrollLeft;
              }
              else {
                  lastScrollLeft = body.scrollLeft;
                  header.scrollLeft = lastScrollLeft;
              }
          }
          else {
              lastScrollLeft = body.scrollLeft;
          }
          deriveActiveLeftFixedColumn();
          deriveActiveLeftFixedChildrenColumns();
          deriveActiveRightFixedColumn();
          deriveActiveRightFixedChildrenColumns();
      }
      function setHeaderScrollLeft(left) {
          const { header } = getScrollElements();
          if (!header)
              return;
          header.scrollLeft = left;
          syncScrollState();
      }
      watch(mergedCurrentPageRef, () => {
          scrollMainTableBodyToTop();
      });
      return {
          styleScrollXRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          syncScrollState,
          handleTableBodyScroll,
          handleTableHeaderScroll,
          setHeaderScrollLeft
      };
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useResizable() {
      const resizableWidthsRef = ref({});
      function getResizableWidth(key) {
          return resizableWidthsRef.value[key];
      }
      function doUpdateResizableWidth(column, width) {
          if (isColumnResizable(column) && 'key' in column) {
              resizableWidthsRef.value[column.key] = width;
          }
      }
      function clearResizableWidth() {
          resizableWidthsRef.value = {};
      }
      return {
          getResizableWidth,
          doUpdateResizableWidth,
          clearResizableWidth
      };
  }

  function getRowsAndCols(columns, getResizableWidth) {
      const rows = [];
      const cols = [];
      const dataRelatedCols = [];
      const rowItemMap = new WeakMap();
      let maxDepth = -1;
      let totalRowSpan = 0;
      let hasEllipsis = false;
      function ensureMaxDepth(columns, currentDepth) {
          if (currentDepth > maxDepth) {
              rows[currentDepth] = [];
              maxDepth = currentDepth;
          }
          for (const column of columns) {
              if ('children' in column) {
                  ensureMaxDepth(column.children, currentDepth + 1);
              }
              else {
                  const key = 'key' in column ? column.key : undefined;
                  cols.push({
                      key: getColKey(column),
                      style: createCustomWidthStyle(column, key !== undefined ? formatLength(getResizableWidth(key)) : undefined),
                      column
                  });
                  totalRowSpan += 1;
                  if (!hasEllipsis) {
                      hasEllipsis = !!column.ellipsis;
                  }
                  dataRelatedCols.push(column);
              }
          }
      }
      ensureMaxDepth(columns, 0);
      let currentLeafIndex = 0;
      function ensureColLayout(columns, currentDepth) {
          let hideUntilIndex = 0;
          columns.forEach((column, index) => {
              var _a;
              if ('children' in column) {
                  // do not allow colSpan > 1 for non-leaf th
                  // we will execute the calculation logic
                  const cachedCurrentLeafIndex = currentLeafIndex;
                  const rowItem = {
                      column,
                      colSpan: 0,
                      rowSpan: 1,
                      isLast: false
                  };
                  ensureColLayout(column.children, currentDepth + 1);
                  column.children.forEach((childColumn) => {
                      var _a, _b;
                      rowItem.colSpan += (_b = (_a = rowItemMap.get(childColumn)) === null || _a === void 0 ? void 0 : _a.colSpan) !== null && _b !== void 0 ? _b : 0;
                  });
                  if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
                      rowItem.isLast = true;
                  }
                  rowItemMap.set(column, rowItem);
                  rows[currentDepth].push(rowItem);
              }
              else {
                  if (currentLeafIndex < hideUntilIndex) {
                      currentLeafIndex += 1;
                      return;
                  }
                  let colSpan = 1;
                  if ('titleColSpan' in column) {
                      colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
                  }
                  if (colSpan > 1) {
                      hideUntilIndex = currentLeafIndex + colSpan;
                  }
                  const isLast = currentLeafIndex + colSpan === totalRowSpan;
                  const rowItem = {
                      column,
                      colSpan,
                      rowSpan: maxDepth - currentDepth + 1,
                      isLast
                  };
                  rowItemMap.set(column, rowItem);
                  rows[currentDepth].push(rowItem);
                  currentLeafIndex += 1;
              }
          });
      }
      ensureColLayout(columns, 0);
      return {
          hasEllipsis,
          rows,
          cols,
          dataRelatedCols
      };
  }
  function useGroupHeader(props, getResizableWidth) {
      const rowsAndCols = computed(() => getRowsAndCols(props.columns, getResizableWidth));
      return {
          rowsRef: computed(() => rowsAndCols.value.rows),
          colsRef: computed(() => rowsAndCols.value.cols),
          hasEllipsisRef: computed(() => rowsAndCols.value.hasEllipsis),
          dataRelatedColsRef: computed(() => rowsAndCols.value.dataRelatedCols)
      };
  }

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useExpand(props, treeMateRef) {
      const renderExpandRef = useMemo(() => {
          for (const col of props.columns) {
              if (col.type === 'expand') {
                  return col.renderExpand;
              }
          }
      });
      const expandableRef = useMemo(() => {
          // It's not reactive
          let expandable;
          for (const col of props.columns) {
              if (col.type === 'expand') {
                  expandable = col.expandable;
                  break;
              }
          }
          return expandable;
      });
      const uncontrolledExpandedRowKeysRef = ref(props.defaultExpandAll
          ? (renderExpandRef === null || renderExpandRef === void 0 ? void 0 : renderExpandRef.value)
              ? (() => {
                  const expandedKeys = [];
                  treeMateRef.value.treeNodes.forEach((tmNode) => {
                      var _a;
                      if ((_a = expandableRef.value) === null || _a === void 0 ? void 0 : _a.call(expandableRef, tmNode.rawNode)) {
                          expandedKeys.push(tmNode.key);
                      }
                  });
                  return expandedKeys;
              })()
              : treeMateRef.value.getNonLeafKeys()
          : props.defaultExpandedRowKeys);
      const controlledExpandedRowKeysRef = toRef(props, 'expandedRowKeys');
      const stickyExpandedRowsRef = toRef(props, 'stickyExpandedRows');
      const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);
      function doUpdateExpandedRowKeys(expandedKeys) {
          const { onUpdateExpandedRowKeys, 'onUpdate:expandedRowKeys': _onUpdateExpandedRowKeys } = props;
          if (onUpdateExpandedRowKeys) {
              call(onUpdateExpandedRowKeys, expandedKeys);
          }
          if (_onUpdateExpandedRowKeys) {
              call(_onUpdateExpandedRowKeys, expandedKeys);
          }
          uncontrolledExpandedRowKeysRef.value = expandedKeys;
      }
      return {
          stickyExpandedRowsRef,
          mergedExpandedRowKeysRef,
          renderExpandRef,
          expandableRef,
          doUpdateExpandedRowKeys
      };
  }

  const fixedColumnStyle = createFixedColumnStyle();
  // vars:
  // --n-font-size
  // --n-th-padding
  // --n-td-padding
  // --n-bezier
  // --n-border-radius
  // --n-line-height
  // --n-border-color
  // --n-border-color-modal
  // --n-border-color-popover
  // --n-th-color
  // --n-th-color-hover
  // --n-th-color-modal
  // --n-th-color-hover-modal
  // --n-th-color-popover
  // --n-th-color-hover-popover
  // --n-td-color
  // --n-td-color-hover
  // --n-td-color-modal
  // --n-td-color-hover-modal
  // --n-td-color-popover
  // --n-td-color-hover-popover
  // --n-th-text-color
  // --n-td-text-color
  // --n-th-font-weight
  // --n-th-button-color-hover
  // --n-th-icon-color
  // --n-th-icon-color-active
  // --n-filter-size
  // --n-action-divider-color
  // --n-action-padding
  // --n-action-button-margin
  // --n-pagination-margin
  // --n-empty-padding
  // --n-sorter-size
  // --n-resizable-container-size
  // --n-resizable-size
  // --n-loading-size
  // --n-loading-color
  // --n-opacity-loading
  // --n-box-shadow-before used in Body.tsx
  // --n-box-shadow-after used in Body.tsx
  // --indent-offset for ellipsis & expand trigger
  var style$V = c$1([cB('data-table', `
 width: 100%;
 font-size: var(--n-font-size);
 display: flex;
 flex-direction: column;
 position: relative;
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 --n-merged-th-color-hover: var(--n-th-color-hover);
 --n-merged-td-color-hover: var(--n-td-color-hover);
 --n-merged-td-color-striped: var(--n-td-color-striped);
 `, [cB('data-table-wrapper', `
 flex-grow: 1;
 display: flex;
 flex-direction: column;
 `), cM('flex-height', [c$1('>', [cB('data-table-wrapper', [c$1('>', [cB('data-table-base-table', `
 display: flex;
 flex-direction: column;
 flex-grow: 1;
 `, [c$1('>', [cB('data-table-base-table-body', 'flex-basis: 0;', [
  // last-child means there is no empty icon
  // body is a scrollbar, we need to override height 100%
  c$1('&:last-child', 'flex-grow: 1;')])])])])])])]), c$1('>', [cB('data-table-loading-wrapper', `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [fadeInScaleUpTransition({
    originalTransform: 'translateX(-50%) translateY(-50%)'
  })])]), cB('data-table-expand-placeholder', `
 margin-right: 8px;
 display: inline-block;
 width: 16px;
 height: 1px;
 `), cB('data-table-indent', `
 display: inline-block;
 height: 1px;
 `), cB('data-table-expand-trigger', `
 display: inline-flex;
 margin-right: 8px;
 cursor: pointer;
 font-size: 16px;
 vertical-align: -0.2em;
 position: relative;
 width: 16px;
 height: 16px;
 color: var(--n-td-text-color);
 transition: color .3s var(--n-bezier);
 `, [cM('expanded', [cB('icon', 'transform: rotate(90deg);', [iconSwitchTransition({
    originalTransform: 'rotate(90deg)'
  })]), cB('base-icon', 'transform: rotate(90deg);', [iconSwitchTransition({
    originalTransform: 'rotate(90deg)'
  })])]), cB('base-loading', `
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB('icon', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB('base-icon', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cB('data-table-thead', `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-merged-th-color);
 `), cB('data-table-tr', `
 box-sizing: border-box;
 background-clip: padding-box;
 transition: background-color .3s var(--n-bezier);
 `, [cB('data-table-expand', `
 position: sticky;
 left: 0;
 overflow: hidden;
 margin: calc(var(--n-th-padding) * -1);
 padding: var(--n-th-padding);
 box-sizing: border-box;
 `), cM('striped', 'background-color: var(--n-merged-td-color-striped);', [cB('data-table-td', 'background-color: var(--n-merged-td-color-striped);')]), cNotM('summary', [c$1('&:hover', 'background-color: var(--n-merged-td-color-hover);', [c$1('>', [cB('data-table-td', 'background-color: var(--n-merged-td-color-hover);')])])])]), cB('data-table-th', `
 padding: var(--n-th-padding);
 position: relative;
 text-align: start;
 box-sizing: border-box;
 background-color: var(--n-merged-th-color);
 border-color: var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 color: var(--n-th-text-color);
 transition:
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 font-weight: var(--n-th-font-weight);
 `, [cM('filterable', `
 padding-right: 36px;
 `, [cM('sortable', `
 padding-right: calc(var(--n-th-padding) + 36px);
 `)]), fixedColumnStyle, cM('selection', `
 padding: 0;
 text-align: center;
 line-height: 0;
 z-index: 3;
 `), cE('title-wrapper', `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 max-width: 100%;
 `, [cE('title', `
 flex: 1;
 min-width: 0;
 `)]), cE('ellipsis', `
 display: inline-block;
 vertical-align: bottom;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 `), cM('hover', `
 background-color: var(--n-merged-th-color-hover);
 `), cM('sortable', `
 cursor: pointer;
 `, [cE('ellipsis', `
 max-width: calc(100% - 18px);
 `), c$1('&:hover', `
 background-color: var(--n-merged-th-color-hover);
 `)]), cB('data-table-sorter', `
 height: var(--n-sorter-size);
 width: var(--n-sorter-size);
 margin-left: 4px;
 position: relative;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 vertical-align: -0.2em;
 color: var(--n-th-icon-color);
 transition: color .3s var(--n-bezier);
 `, [cB('base-icon', 'transition: transform .3s var(--n-bezier)'), cM('desc', [cB('base-icon', `
 transform: rotate(0deg);
 `)]), cM('asc', [cB('base-icon', `
 transform: rotate(-180deg);
 `)]), cM('asc, desc', `
 color: var(--n-th-icon-color-active);
 `)]), cB('data-table-resize-button', `
 width: var(--n-resizable-container-size);
 position: absolute;
 top: 0;
 right: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 cursor: col-resize;
 user-select: none;
 `, [c$1('&::after', `
 width: var(--n-resizable-size);
 height: 50%;
 position: absolute;
 top: 50%;
 left: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 background-color: var(--n-merged-border-color);
 transform: translateY(-50%);
 transition: background-color .3s var(--n-bezier);
 z-index: 1;
 content: '';
 `), cM('active', [c$1('&::after', ` 
 background-color: var(--n-th-icon-color-active);
 `)]), c$1('&:hover::after', `
 background-color: var(--n-th-icon-color-active);
 `)]), cB('data-table-filter', `
 position: absolute;
 z-index: auto;
 right: 0;
 width: 36px;
 top: 0;
 bottom: 0;
 cursor: pointer;
 display: flex;
 justify-content: center;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: var(--n-filter-size);
 color: var(--n-th-icon-color);
 `, [c$1('&:hover', `
 background-color: var(--n-th-button-color-hover);
 `), cM('show', `
 background-color: var(--n-th-button-color-hover);
 `), cM('active', `
 background-color: var(--n-th-button-color-hover);
 color: var(--n-th-icon-color-active);
 `)])]), cB('data-table-td', `
 padding: var(--n-td-padding);
 text-align: start;
 box-sizing: border-box;
 border: none;
 background-color: var(--n-merged-td-color);
 color: var(--n-td-text-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cM('expand', [cB('data-table-expand-trigger', `
 margin-right: 0;
 `)]), cM('last-row', `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [
  // make sure there is no overlap between bottom border and
  // fixed column box shadow
  c$1('&::after', `
 bottom: 0 !important;
 `), c$1('&::before', `
 bottom: 0 !important;
 `)]), cM('summary', `
 background-color: var(--n-merged-th-color);
 `), cM('hover', `
 background-color: var(--n-merged-td-color-hover);
 `), cE('ellipsis', `
 display: inline-block;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 vertical-align: bottom;
 max-width: calc(100% - var(--indent-offset, -1.5) * 16px - 24px);
 `), cM('selection, expand', `
 text-align: center;
 padding: 0;
 line-height: 0;
 `), fixedColumnStyle]), cB('data-table-empty', `
 box-sizing: border-box;
 padding: var(--n-empty-padding);
 flex-grow: 1;
 flex-shrink: 0;
 opacity: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: opacity .3s var(--n-bezier);
 `, [cM('hide', `
 opacity: 0;
 `)]), cE('pagination', `
 margin: var(--n-pagination-margin);
 display: flex;
 justify-content: flex-end;
 `), cB('data-table-wrapper', `
 position: relative;
 opacity: 1;
 transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 line-height: var(--n-line-height);
 `), cM('loading', [cB('data-table-wrapper', `
 opacity: var(--n-opacity-loading);
 pointer-events: none;
 `)]), cM('single-column', [cB('data-table-td', `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [c$1('&::after, &::before', `
 bottom: 0 !important;
 `)])]), cNotM('single-line', [cB('data-table-th', `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM('last', `
 border-right: 0 solid var(--n-merged-border-color);
 `)]), cB('data-table-td', `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM('last-col', `
 border-right: 0 solid var(--n-merged-border-color);
 `)])]), cM('bordered', [cB('data-table-wrapper', `
 border: 1px solid var(--n-merged-border-color);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 overflow: hidden;
 `)]), cB('data-table-base-table', [cM('transition-disabled', [cB('data-table-th', [c$1('&::after, &::before', 'transition: none;')]), cB('data-table-td', [c$1('&::after, &::before', 'transition: none;')])])]), cM('bottom-bordered', [cB('data-table-td', [cM('last-row', `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)])]), cB('data-table-table', `
 font-variant-numeric: tabular-nums;
 width: 100%;
 word-break: break-word;
 transition: background-color .3s var(--n-bezier);
 border-collapse: separate;
 border-spacing: 0;
 background-color: var(--n-merged-td-color);
 `), cB('data-table-base-table-header', `
 border-top-left-radius: calc(var(--n-border-radius) - 1px);
 border-top-right-radius: calc(var(--n-border-radius) - 1px);
 z-index: 3;
 overflow: scroll;
 flex-shrink: 0;
 transition: border-color .3s var(--n-bezier);
 scrollbar-width: none;
 `, [c$1('&::-webkit-scrollbar', `
 width: 0;
 height: 0;
 `)]), cB('data-table-check-extra', `
 transition: color .3s var(--n-bezier);
 color: var(--n-th-icon-color);
 position: absolute;
 font-size: 14px;
 right: -4px;
 top: 50%;
 transform: translateY(-50%);
 z-index: 1;
 `)]), cB('data-table-filter-menu', [cB('scrollbar', `
 max-height: 240px;
 `), cE('group', `
 display: flex;
 flex-direction: column;
 padding: 12px 12px 0 12px;
 `, [cB('checkbox', `
 margin-bottom: 12px;
 margin-right: 0;
 `), cB('radio', `
 margin-bottom: 12px;
 margin-right: 0;
 `)]), cE('action', `
 padding: var(--n-action-padding);
 display: flex;
 flex-wrap: nowrap;
 justify-content: space-evenly;
 border-top: 1px solid var(--n-action-divider-color);
 `, [cB('button', [c$1('&:not(:last-child)', `
 margin: var(--n-action-button-margin);
 `), c$1('&:last-child', `
 margin-right: 0;
 `)])]), cB('divider', `
 margin: 0 !important;
 `)]), insideModal(cB('data-table', `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 --n-merged-th-color-hover: var(--n-th-color-hover-modal);
 --n-merged-td-color-hover: var(--n-td-color-hover-modal);
 --n-merged-td-color-striped: var(--n-td-color-striped-modal);
 `)), insidePopover(cB('data-table', `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 --n-merged-th-color-hover: var(--n-th-color-hover-popover);
 --n-merged-td-color-hover: var(--n-td-color-hover-popover);
 --n-merged-td-color-striped: var(--n-td-color-striped-popover);
 `))]);
  function createFixedColumnStyle() {
    return [cM('fixed-left', `
 left: 0;
 position: sticky;
 z-index: 2;
 `, [c$1('&::after', `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 right: -36px;
 `)]), cM('fixed-right', `
 right: 0;
 position: sticky;
 z-index: 1;
 `, [c$1('&::before', `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 left: -36px;
 `)])];
  }

  var DataTable = defineComponent({
      name: 'DataTable',
      alias: ['AdvancedTable'],
      props: dataTableProps,
      setup(props, { slots }) {
          const { mergedBorderedRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const mergedBottomBorderedRef = computed(() => {
              const { bottomBordered } = props;
              // do not add bottom bordered class if bordered is true
              // since border is displayed on wrapper
              if (mergedBorderedRef.value)
                  return false;
              if (bottomBordered !== undefined)
                  return bottomBordered;
              return true;
          });
          const themeRef = useTheme('DataTable', '-data-table', style$V, dataTableLight$1, props, mergedClsPrefixRef);
          const bodyWidthRef = ref(null);
          const mainTableInstRef = ref(null);
          const { getResizableWidth, clearResizableWidth, doUpdateResizableWidth } = useResizable();
          const { rowsRef, colsRef, dataRelatedColsRef, hasEllipsisRef } = useGroupHeader(props, getResizableWidth);
          const { treeMateRef, mergedCurrentPageRef, paginatedDataRef, rawPaginatedDataRef, selectionColumnRef, hoverKeyRef, mergedPaginationRef, mergedFilterStateRef, mergedSortStateRef, childTriggerColIndexRef, doUpdatePage, doUpdateFilters, onUnstableColumnResize, deriveNextSorter, filter, filters, clearFilter, clearFilters, clearSorter, page, sort } = useTableData(props, { dataRelatedColsRef });
          const { doCheckAll, doUncheckAll, doCheck, doUncheck, headerCheckboxDisabledRef, someRowsCheckedRef, allRowsCheckedRef, mergedCheckedRowKeySetRef, mergedInderminateRowKeySetRef } = useCheck(props, {
              selectionColumnRef,
              treeMateRef,
              paginatedDataRef
          });
          const { stickyExpandedRowsRef, mergedExpandedRowKeysRef, renderExpandRef, expandableRef, doUpdateExpandedRowKeys } = useExpand(props, treeMateRef);
          const { handleTableBodyScroll, handleTableHeaderScroll, syncScrollState, setHeaderScrollLeft, leftActiveFixedColKeyRef, leftActiveFixedChildrenColKeysRef, rightActiveFixedColKeyRef, rightActiveFixedChildrenColKeysRef, leftFixedColumnsRef, rightFixedColumnsRef, fixedColumnLeftMapRef, fixedColumnRightMapRef } = useScroll(props, {
              bodyWidthRef,
              mainTableInstRef,
              mergedCurrentPageRef
          });
          const { localeRef } = useLocale('DataTable');
          const mergedTableLayoutRef = computed(() => {
              // Layout
              // virtual |descrete header | ellpisis => fixed
              //    = virtual | maxHeight | ellpisis => fixed
              if (props.virtualScroll ||
                  props.flexHeight ||
                  props.maxHeight !== undefined ||
                  hasEllipsisRef.value) {
                  return 'fixed';
              }
              return props.tableLayout;
          });
          provide(dataTableInjectionKey, {
              props,
              treeMateRef,
              renderExpandIconRef: toRef(props, 'renderExpandIcon'),
              loadingKeySetRef: ref(new Set()),
              slots,
              indentRef: toRef(props, 'indent'),
              childTriggerColIndexRef,
              bodyWidthRef,
              componentId: createId(),
              hoverKeyRef,
              mergedClsPrefixRef,
              mergedThemeRef: themeRef,
              scrollXRef: computed(() => props.scrollX),
              rowsRef,
              colsRef,
              paginatedDataRef,
              leftActiveFixedColKeyRef,
              leftActiveFixedChildrenColKeysRef,
              rightActiveFixedColKeyRef,
              rightActiveFixedChildrenColKeysRef,
              leftFixedColumnsRef,
              rightFixedColumnsRef,
              fixedColumnLeftMapRef,
              fixedColumnRightMapRef,
              mergedCurrentPageRef,
              someRowsCheckedRef,
              allRowsCheckedRef,
              mergedSortStateRef,
              mergedFilterStateRef,
              loadingRef: toRef(props, 'loading'),
              rowClassNameRef: toRef(props, 'rowClassName'),
              mergedCheckedRowKeySetRef,
              mergedExpandedRowKeysRef,
              mergedInderminateRowKeySetRef,
              localeRef,
              expandableRef,
              stickyExpandedRowsRef,
              rowKeyRef: toRef(props, 'rowKey'),
              renderExpandRef,
              summaryRef: toRef(props, 'summary'),
              virtualScrollRef: toRef(props, 'virtualScroll'),
              rowPropsRef: toRef(props, 'rowProps'),
              stripedRef: toRef(props, 'striped'),
              checkOptionsRef: computed(() => {
                  const { value: selectionColumn } = selectionColumnRef;
                  return selectionColumn === null || selectionColumn === void 0 ? void 0 : selectionColumn.options;
              }),
              rawPaginatedDataRef,
              filterMenuCssVarsRef: computed(() => {
                  const { self: { actionDividerColor, actionPadding, actionButtonMargin } } = themeRef.value;
                  // eslint-disable-next-line @typescript-eslint/consistent-type-assertions
                  return {
                      '--n-action-padding': actionPadding,
                      '--n-action-button-margin': actionButtonMargin,
                      '--n-action-divider-color': actionDividerColor
                  };
              }),
              onLoadRef: toRef(props, 'onLoad'),
              mergedTableLayoutRef,
              maxHeightRef: toRef(props, 'maxHeight'),
              minHeightRef: toRef(props, 'minHeight'),
              flexHeightRef: toRef(props, 'flexHeight'),
              headerCheckboxDisabledRef,
              paginationBehaviorOnFilterRef: toRef(props, 'paginationBehaviorOnFilter'),
              summaryPlacementRef: toRef(props, 'summaryPlacement'),
              scrollbarPropsRef: toRef(props, 'scrollbarProps'),
              syncScrollState,
              doUpdatePage,
              doUpdateFilters,
              getResizableWidth,
              onUnstableColumnResize,
              clearResizableWidth,
              doUpdateResizableWidth,
              deriveNextSorter,
              doCheck,
              doUncheck,
              doCheckAll,
              doUncheckAll,
              doUpdateExpandedRowKeys,
              handleTableHeaderScroll,
              handleTableBodyScroll,
              setHeaderScrollLeft,
              renderCell: toRef(props, 'renderCell')
          });
          const exposedMethods = {
              filter,
              filters,
              clearFilters,
              clearSorter,
              page,
              sort,
              clearFilter,
              scrollTo: (arg0, arg1) => {
                  var _a;
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  (_a = mainTableInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
              }
          };
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { common: { cubicBezierEaseInOut }, self: { borderColor, tdColorHover, thColor, thColorHover, tdColor, tdTextColor, thTextColor, thFontWeight, thButtonColorHover, thIconColor, thIconColorActive, filterSize, borderRadius, lineHeight, tdColorModal, thColorModal, borderColorModal, thColorHoverModal, tdColorHoverModal, borderColorPopover, thColorPopover, tdColorPopover, tdColorHoverPopover, thColorHoverPopover, paginationMargin, emptyPadding, boxShadowAfter, boxShadowBefore, sorterSize, resizableContainerSize, resizableSize, loadingColor, loadingSize, opacityLoading, tdColorStriped, tdColorStripedModal, tdColorStripedPopover, [createKey('fontSize', size)]: fontSize, [createKey('thPadding', size)]: thPadding, [createKey('tdPadding', size)]: tdPadding } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-th-padding': thPadding,
                  '--n-td-padding': tdPadding,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-line-height': lineHeight,
                  '--n-border-color': borderColor,
                  '--n-border-color-modal': borderColorModal,
                  '--n-border-color-popover': borderColorPopover,
                  '--n-th-color': thColor,
                  '--n-th-color-hover': thColorHover,
                  '--n-th-color-modal': thColorModal,
                  '--n-th-color-hover-modal': thColorHoverModal,
                  '--n-th-color-popover': thColorPopover,
                  '--n-th-color-hover-popover': thColorHoverPopover,
                  '--n-td-color': tdColor,
                  '--n-td-color-hover': tdColorHover,
                  '--n-td-color-modal': tdColorModal,
                  '--n-td-color-hover-modal': tdColorHoverModal,
                  '--n-td-color-popover': tdColorPopover,
                  '--n-td-color-hover-popover': tdColorHoverPopover,
                  '--n-th-text-color': thTextColor,
                  '--n-td-text-color': tdTextColor,
                  '--n-th-font-weight': thFontWeight,
                  '--n-th-button-color-hover': thButtonColorHover,
                  '--n-th-icon-color': thIconColor,
                  '--n-th-icon-color-active': thIconColorActive,
                  '--n-filter-size': filterSize,
                  '--n-pagination-margin': paginationMargin,
                  '--n-empty-padding': emptyPadding,
                  '--n-box-shadow-before': boxShadowBefore,
                  '--n-box-shadow-after': boxShadowAfter,
                  '--n-sorter-size': sorterSize,
                  '--n-resizable-container-size': resizableContainerSize,
                  '--n-resizable-size': resizableSize,
                  '--n-loading-size': loadingSize,
                  '--n-loading-color': loadingColor,
                  '--n-opacity-loading': opacityLoading,
                  '--n-td-color-striped': tdColorStriped,
                  '--n-td-color-striped-modal': tdColorStripedModal,
                  '--n-td-color-striped-popover': tdColorStripedPopover
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('data-table', computed(() => props.size[0]), cssVarsRef, props)
              : undefined;
          const mergedShowPaginationRef = computed(() => {
              if (!props.pagination)
                  return false;
              if (props.paginateSinglePage)
                  return true;
              const mergedPagination = mergedPaginationRef.value;
              const { pageCount } = mergedPagination;
              if (pageCount !== undefined)
                  return pageCount > 1;
              return (mergedPagination.itemCount &&
                  mergedPagination.pageSize &&
                  mergedPagination.itemCount > mergedPagination.pageSize);
          });
          return Object.assign({ mainTableInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, paginatedData: paginatedDataRef, mergedBordered: mergedBorderedRef, mergedBottomBordered: mergedBottomBorderedRef, mergedPagination: mergedPaginationRef, mergedShowPagination: mergedShowPaginationRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
      },
      render() {
          const { mergedClsPrefix, themeClass, onRender, $slots, spinProps } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-data-table`,
                  themeClass,
                  {
                      [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
                      [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
                      [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
                      [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
                      [`${mergedClsPrefix}-data-table--loading`]: this.loading,
                      [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
                  }
              ], style: this.cssVars },
              h("div", { class: `${mergedClsPrefix}-data-table-wrapper` },
                  h(MainTable, { ref: "mainTableInstRef" })),
              this.mergedShowPagination ? (h("div", { class: `${mergedClsPrefix}-data-table__pagination` },
                  h(NPagination, Object.assign({ theme: this.mergedTheme.peers.Pagination, themeOverrides: this.mergedTheme.peerOverrides.Pagination, disabled: this.loading }, this.mergedPagination)))) : null,
              h(Transition, { name: "fade-in-scale-up-transition" }, {
                  default: () => {
                      return this.loading ? (h("div", { class: `${mergedClsPrefix}-data-table-loading-wrapper` }, resolveSlot($slots.loading, () => [
                          h(NBaseLoading, Object.assign({ clsPrefix: mergedClsPrefix, strokeWidth: 20 }, spinProps))
                      ]))) : null;
                  }
              })));
      }
  });

  var commonVars$7 = {
      itemFontSize: '12px',
      itemHeight: '36px',
      itemWidth: '52px',
      panelActionPadding: '8px 0'
  };

  const self$J = (vars) => {
      const { popoverColor, textColor2, primaryColor, hoverColor, dividerColor, opacityDisabled, boxShadow2, borderRadius, iconColor, iconColorDisabled } = vars;
      return Object.assign(Object.assign({}, commonVars$7), { panelColor: popoverColor, panelBoxShadow: boxShadow2, panelDividerColor: dividerColor, itemTextColor: textColor2, itemTextColorActive: primaryColor, itemColorHover: hoverColor, itemOpacityDisabled: opacityDisabled, itemBorderRadius: borderRadius, borderRadius,
          iconColor,
          iconColorDisabled });
  };
  const timePickerLight = createTheme({
      name: 'TimePicker',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1,
          Button: buttonLight$1,
          Input: inputLight$1
      },
      self: self$J
  });
  var timePickerLight$1 = timePickerLight;

  var commonVars$6 = {
      itemSize: '24px',
      itemCellWidth: '38px',
      itemCellHeight: '32px',
      scrollItemWidth: '80px',
      scrollItemHeight: '40px',
      panelExtraFooterPadding: '8px 12px',
      panelActionPadding: '8px 12px',
      calendarTitlePadding: '0',
      calendarTitleHeight: '28px',
      arrowSize: '14px',
      panelHeaderPadding: '8px 12px',
      calendarDaysHeight: '32px',
      calendarTitleGridTempateColumns: '28px 28px 1fr 28px 28px',
      // type
      calendarLeftPaddingDate: '6px 12px 4px 12px',
      calendarLeftPaddingDatetime: '4px 12px',
      calendarLeftPaddingDaterange: '6px 12px 4px 12px',
      calendarLeftPaddingDatetimerange: '4px 12px',
      calendarLeftPaddingMonth: '0', // TODO: make it actually effective
      calendarLeftPaddingYear: '0',
      calendarLeftPaddingQuarter: '0',
      calendarLeftPaddingMonthrange: '0',
      calendarLeftPaddingQuarterrange: '0',
      calendarLeftPaddingYearrange: '0',
      calendarRightPaddingDate: '6px 12px 4px 12px',
      calendarRightPaddingDatetime: '4px 12px',
      calendarRightPaddingDaterange: '6px 12px 4px 12px',
      calendarRightPaddingDatetimerange: '4px 12px',
      calendarRightPaddingMonth: '0',
      calendarRightPaddingYear: '0',
      calendarRightPaddingQuarter: '0',
      calendarRightPaddingMonthrange: '0',
      calendarRightPaddingQuarterrange: '0',
      calendarRightPaddingYearrange: '0'
  };

  const self$I = (vars) => {
      const { hoverColor, fontSize, textColor2, textColorDisabled, popoverColor, primaryColor, borderRadiusSmall, iconColor, iconColorDisabled, textColor1, dividerColor, boxShadow2, borderRadius, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVars$6), { itemFontSize: fontSize, calendarDaysFontSize: fontSize, calendarTitleFontSize: fontSize, itemTextColor: textColor2, itemTextColorDisabled: textColorDisabled, itemTextColorActive: popoverColor, itemTextColorCurrent: primaryColor, itemColorIncluded: changeColor(primaryColor, { alpha: 0.1 }), itemColorHover: hoverColor, itemColorDisabled: hoverColor, itemColorActive: primaryColor, itemBorderRadius: borderRadiusSmall, panelColor: popoverColor, panelTextColor: textColor2, arrowColor: iconColor, calendarTitleTextColor: textColor1, calendarTitleColorHover: hoverColor, calendarDaysTextColor: textColor2, panelHeaderDividerColor: dividerColor, calendarDaysDividerColor: dividerColor, calendarDividerColor: dividerColor, panelActionDividerColor: dividerColor, panelBoxShadow: boxShadow2, panelBorderRadius: borderRadius, calendarTitleFontWeight: fontWeightStrong, scrollItemBorderRadius: borderRadius, iconColor,
          iconColorDisabled });
  };
  const datePickerLight = createTheme({
      name: 'DatePicker',
      common: commonLight,
      peers: {
          Input: inputLight$1,
          Button: buttonLight$1,
          TimePicker: timePickerLight$1,
          Scrollbar: scrollbarLight$1
      },
      self: self$I
  });
  var datePickerLight$1 = datePickerLight;

  /* eslint-disable @typescript-eslint/explicit-function-return-type */
  function uniCalendarValidation(props, mergedValueRef) {
      // date, datetime
      const timePickerValidatorRef = computed(() => {
          const { isTimeDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null || Array.isArray(value))
              return undefined;
          return isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value);
      });
      const isHourDisabledRef = computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isHourDisabled;
      });
      const isMinuteDisabledRef = computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled;
      });
      const isSecondDisabledRef = computed(() => {
          var _a;
          return (_a = timePickerValidatorRef.value) === null || _a === void 0 ? void 0 : _a.isSecondDisabled;
      });
      const isDateInvalidRef = computed(() => {
          const { type, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null ||
              Array.isArray(value) ||
              !['date', 'datetime'].includes(type) ||
              !isDateDisabled) {
              return false;
          }
          return isDateDisabled(value);
      });
      const isTimeInvalidRef = computed(() => {
          const { type } = props;
          const { value } = mergedValueRef;
          if (value === null || !(type !== 'datetime') || Array.isArray(value)) {
              return false;
          }
          const time = new Date(value);
          const hour = time.getHours();
          const minute = time.getMinutes();
          const second = time.getMinutes();
          return ((isHourDisabledRef.value ? isHourDisabledRef.value(hour) : false) ||
              (isMinuteDisabledRef.value
                  ? isMinuteDisabledRef.value(minute, hour)
                  : false) ||
              (isSecondDisabledRef.value
                  ? isSecondDisabledRef.value(second, minute, hour)
                  : false));
      });
      const isDateTimeInvalidRef = computed(() => {
          return isDateInvalidRef.value || isTimeInvalidRef.value;
      });
      const isValueInvalidRef = computed(() => {
          const { type } = props;
          if (type === 'date')
              return isDateInvalidRef.value;
          if (type === 'datetime')
              return isDateTimeInvalidRef.value;
          return false;
      });
      return {
          // date & datetime
          isValueInvalidRef,
          isDateInvalidRef,
          // datetime only
          isTimeInvalidRef,
          isDateTimeInvalidRef,
          isHourDisabledRef,
          isMinuteDisabledRef,
          isSecondDisabledRef
      };
  }
  function dualCalendarValidation(props, mergedValueRef) {
      // daterange, datetimerange
      const timePickerValidatorRef = computed(() => {
          const { isTimeDisabled } = props;
          const { value } = mergedValueRef;
          if (!Array.isArray(value) || !isTimeDisabled) {
              return [undefined, undefined];
          }
          return [
              isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[0], 'start', value),
              isTimeDisabled === null || isTimeDisabled === void 0 ? void 0 : isTimeDisabled(value[1], 'end', value)
          ];
      });
      const timeValidator = {
          isStartHourDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isHourDisabled; }),
          isEndHourDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isHourDisabled; }),
          isStartMinuteDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled; }),
          isEndMinuteDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isMinuteDisabled; }),
          isStartSecondDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[0]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled; }),
          isEndSecondDisabledRef: computed(() => { var _a; return (_a = timePickerValidatorRef.value[1]) === null || _a === void 0 ? void 0 : _a.isSecondDisabled; })
      };
      const isStartDateInvalidRef = computed(() => {
          const { type, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null ||
              !Array.isArray(value) ||
              !['daterange', 'datetimerange'].includes(type) ||
              !isDateDisabled) {
              return false;
          }
          return isDateDisabled(value[0], 'start', value);
      });
      const isEndDateInvalidRef = computed(() => {
          const { type, isDateDisabled } = props;
          const { value } = mergedValueRef;
          if (value === null ||
              !Array.isArray(value) ||
              !['daterange', 'datetimerange'].includes(type) ||
              !isDateDisabled) {
              return false;
          }
          return isDateDisabled(value[1], 'end', value);
      });
      const isStartTimeInvalidRef = computed(() => {
          const { type } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || type !== 'datetimerange') {
              return false;
          }
          const startHours = getHours(value[0]);
          const startMinutes = getMinutes(value[0]);
          const startSeconds = getSeconds(value[0]);
          const { isStartHourDisabledRef, isStartMinuteDisabledRef, isStartSecondDisabledRef } = timeValidator;
          const startTimeInvalid = (isStartHourDisabledRef.value
              ? isStartHourDisabledRef.value(startHours)
              : false) ||
              (isStartMinuteDisabledRef.value
                  ? isStartMinuteDisabledRef.value(startMinutes, startHours)
                  : false) ||
              (isStartSecondDisabledRef.value
                  ? isStartSecondDisabledRef.value(startSeconds, startMinutes, startHours)
                  : false);
          return startTimeInvalid;
      });
      const isEndTimeInvalidRef = computed(() => {
          const { type } = props;
          const { value } = mergedValueRef;
          if (value === null || !Array.isArray(value) || type !== 'datetimerange') {
              return false;
          }
          const endHours = getHours(value[1]);
          const endMinutes = getMinutes(value[1]);
          const endSeconds = getSeconds(value[1]);
          const { isEndHourDisabledRef, isEndMinuteDisabledRef, isEndSecondDisabledRef } = timeValidator;
          const endTimeInvalid = (isEndHourDisabledRef.value
              ? isEndHourDisabledRef.value(endHours)
              : false) ||
              (isEndMinuteDisabledRef.value
                  ? isEndMinuteDisabledRef.value(endMinutes, endHours)
                  : false) ||
              (isEndSecondDisabledRef.value
                  ? isEndSecondDisabledRef.value(endSeconds, endMinutes, endHours)
                  : false);
          return endTimeInvalid;
      });
      const isStartValueInvalidRef = computed(() => {
          return isStartDateInvalidRef.value || isStartTimeInvalidRef.value;
      });
      const isEndValueInvalidRef = computed(() => {
          return isEndDateInvalidRef.value || isEndTimeInvalidRef.value;
      });
      const isRangeInvalidRef = computed(() => {
          return isStartValueInvalidRef.value || isEndValueInvalidRef.value;
      });
      return Object.assign(Object.assign({}, timeValidator), { isStartDateInvalidRef,
          isEndDateInvalidRef,
          isStartTimeInvalidRef,
          isEndTimeInvalidRef,
          isStartValueInvalidRef,
          isEndValueInvalidRef,
          isRangeInvalidRef });
  }

  const datePickerInjectionKey = createInjectionKey('n-date-picker');

  var cloneObject$1 = {exports: {}};

  var interopRequireDefault = {exports: {}};

  (function (module) {
  	function _interopRequireDefault(obj) {
  	  return obj && obj.__esModule ? obj : {
  	    "default": obj
  	  };
  	}
  	module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports; 
  } (interopRequireDefault));

  var interopRequireDefaultExports = interopRequireDefault.exports;

  var assign = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = assign;
  	function assign(target, object) {
  	  if (target == null) {
  	    throw new TypeError('assign requires that input parameter not be null or undefined');
  	  }
  	  for (var property in object) {
  	    if (Object.prototype.hasOwnProperty.call(object, property)) {
  	      target[property] = object[property];
  	    }
  	  }
  	  return target;
  	}
  	module.exports = exports.default; 
  } (assign, assign.exports));

  var assignExports = assign.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = cloneObject;
  	var _index = _interopRequireDefault(assignExports);
  	function cloneObject(object) {
  	  return (0, _index.default)({}, object);
  	}
  	module.exports = exports.default; 
  } (cloneObject$1, cloneObject$1.exports));

  var cloneObjectExports = cloneObject$1.exports;
  var cloneObject = /*@__PURE__*/getDefaultExportFromCjs(cloneObjectExports);

  var format$3 = {exports: {}};

  var isValid = {exports: {}};

  var isDate = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
  	function _typeof(o) {
  	  "@babel/helpers - typeof";

  	  return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
  	    return typeof o;
  	  } : function (o) {
  	    return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  	  }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
  	}
  	module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports; 
  } (_typeof));

  var _typeofExports = _typeof.exports;

  var requiredArgs = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = requiredArgs;
  	function requiredArgs(required, args) {
  	  if (args.length < required) {
  	    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  	  }
  	}
  	module.exports = exports.default; 
  } (requiredArgs, requiredArgs.exports));

  var requiredArgsExports = requiredArgs.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isDate;
  	var _typeof2 = _interopRequireDefault(_typeofExports);
  	var _index = _interopRequireDefault(requiredArgsExports);
  	/**
  	 * @name isDate
  	 * @category Common Helpers
  	 * @summary Is the given value a date?
  	 *
  	 * @description
  	 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
  	 *
  	 * @param {*} value - the value to check
  	 * @returns {boolean} true if the given value is a date
  	 * @throws {TypeError} 1 arguments required
  	 *
  	 * @example
  	 * // For a valid date:
  	 * const result = isDate(new Date())
  	 * //=> true
  	 *
  	 * @example
  	 * // For an invalid date:
  	 * const result = isDate(new Date(NaN))
  	 * //=> true
  	 *
  	 * @example
  	 * // For some value:
  	 * const result = isDate('2014-02-31')
  	 * //=> false
  	 *
  	 * @example
  	 * // For an object:
  	 * const result = isDate({})
  	 * //=> false
  	 */
  	function isDate(value) {
  	  (0, _index.default)(1, arguments);
  	  return value instanceof Date || (0, _typeof2.default)(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
  	}
  	module.exports = exports.default; 
  } (isDate, isDate.exports));

  var isDateExports = isDate.exports;

  var toDate$1 = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = toDate;
  	var _typeof2 = _interopRequireDefault(_typeofExports);
  	var _index = _interopRequireDefault(requiredArgsExports);
  	/**
  	 * @name toDate
  	 * @category Common Helpers
  	 * @summary Convert the given argument to an instance of Date.
  	 *
  	 * @description
  	 * Convert the given argument to an instance of Date.
  	 *
  	 * If the argument is an instance of Date, the function returns its clone.
  	 *
  	 * If the argument is a number, it is treated as a timestamp.
  	 *
  	 * If the argument is none of the above, the function returns Invalid Date.
  	 *
  	 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
  	 *
  	 * @param {Date|Number} argument - the value to convert
  	 * @returns {Date} the parsed date in the local time zone
  	 * @throws {TypeError} 1 argument required
  	 *
  	 * @example
  	 * // Clone the date:
  	 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
  	 * //=> Tue Feb 11 2014 11:30:30
  	 *
  	 * @example
  	 * // Convert the timestamp to date:
  	 * const result = toDate(1392098430000)
  	 * //=> Tue Feb 11 2014 11:30:30
  	 */
  	function toDate(argument) {
  	  (0, _index.default)(1, arguments);
  	  var argStr = Object.prototype.toString.call(argument);

  	  // Clone the date
  	  if (argument instanceof Date || (0, _typeof2.default)(argument) === 'object' && argStr === '[object Date]') {
  	    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
  	    return new Date(argument.getTime());
  	  } else if (typeof argument === 'number' || argStr === '[object Number]') {
  	    return new Date(argument);
  	  } else {
  	    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
  	      // eslint-disable-next-line no-console
  	      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
  	      // eslint-disable-next-line no-console
  	      console.warn(new Error().stack);
  	    }
  	    return new Date(NaN);
  	  }
  	}
  	module.exports = exports.default; 
  } (toDate$1, toDate$1.exports));

  var toDateExports = toDate$1.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = isValid;
  	var _index = _interopRequireDefault(isDateExports);
  	var _index2 = _interopRequireDefault(toDateExports);
  	var _index3 = _interopRequireDefault(requiredArgsExports);
  	/**
  	 * @name isValid
  	 * @category Common Helpers
  	 * @summary Is the given date valid?
  	 *
  	 * @description
  	 * Returns false if argument is Invalid Date and true otherwise.
  	 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
  	 * Invalid Date is a Date, whose time value is NaN.
  	 *
  	 * Time value of Date: http://es5.github.io/#x15.9.1.1
  	 *
  	 * @param {*} date - the date to check
  	 * @returns {Boolean} the date is valid
  	 * @throws {TypeError} 1 argument required
  	 *
  	 * @example
  	 * // For the valid date:
  	 * const result = isValid(new Date(2014, 1, 31))
  	 * //=> true
  	 *
  	 * @example
  	 * // For the value, convertable into a date:
  	 * const result = isValid(1393804800000)
  	 * //=> true
  	 *
  	 * @example
  	 * // For the invalid date:
  	 * const result = isValid(new Date(''))
  	 * //=> false
  	 */
  	function isValid(dirtyDate) {
  	  (0, _index3.default)(1, arguments);
  	  if (!(0, _index.default)(dirtyDate) && typeof dirtyDate !== 'number') {
  	    return false;
  	  }
  	  var date = (0, _index2.default)(dirtyDate);
  	  return !isNaN(Number(date));
  	}
  	module.exports = exports.default; 
  } (isValid, isValid.exports));

  var isValidExports = isValid.exports;

  var subMilliseconds = {exports: {}};

  var addMilliseconds = {exports: {}};

  var toInteger$1 = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = toInteger;
  	function toInteger(dirtyNumber) {
  	  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
  	    return NaN;
  	  }
  	  var number = Number(dirtyNumber);
  	  if (isNaN(number)) {
  	    return number;
  	  }
  	  return number < 0 ? Math.ceil(number) : Math.floor(number);
  	}
  	module.exports = exports.default; 
  } (toInteger$1, toInteger$1.exports));

  var toIntegerExports = toInteger$1.exports;
  var toInteger = /*@__PURE__*/getDefaultExportFromCjs(toIntegerExports);

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = addMilliseconds;
  	var _index = _interopRequireDefault(toIntegerExports);
  	var _index2 = _interopRequireDefault(toDateExports);
  	var _index3 = _interopRequireDefault(requiredArgsExports);
  	/**
  	 * @name addMilliseconds
  	 * @category Millisecond Helpers
  	 * @summary Add the specified number of milliseconds to the given date.
  	 *
  	 * @description
  	 * Add the specified number of milliseconds to the given date.
  	 *
  	 * @param {Date|Number} date - the date to be changed
  	 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
  	 * @returns {Date} the new date with the milliseconds added
  	 * @throws {TypeError} 2 arguments required
  	 *
  	 * @example
  	 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
  	 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
  	 * //=> Thu Jul 10 2014 12:45:30.750
  	 */
  	function addMilliseconds(dirtyDate, dirtyAmount) {
  	  (0, _index3.default)(2, arguments);
  	  var timestamp = (0, _index2.default)(dirtyDate).getTime();
  	  var amount = (0, _index.default)(dirtyAmount);
  	  return new Date(timestamp + amount);
  	}
  	module.exports = exports.default; 
  } (addMilliseconds, addMilliseconds.exports));

  var addMillisecondsExports = addMilliseconds.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = subMilliseconds;
  	var _index = _interopRequireDefault(addMillisecondsExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var _index3 = _interopRequireDefault(toIntegerExports);
  	/**
  	 * @name subMilliseconds
  	 * @category Millisecond Helpers
  	 * @summary Subtract the specified number of milliseconds from the given date.
  	 *
  	 * @description
  	 * Subtract the specified number of milliseconds from the given date.
  	 *
  	 * @param {Date|Number} date - the date to be changed
  	 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
  	 * @returns {Date} the new date with the milliseconds subtracted
  	 * @throws {TypeError} 2 arguments required
  	 *
  	 * @example
  	 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
  	 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
  	 * //=> Thu Jul 10 2014 12:45:29.250
  	 */
  	function subMilliseconds(dirtyDate, dirtyAmount) {
  	  (0, _index2.default)(2, arguments);
  	  var amount = (0, _index3.default)(dirtyAmount);
  	  return (0, _index.default)(dirtyDate, -amount);
  	}
  	module.exports = exports.default; 
  } (subMilliseconds, subMilliseconds.exports));

  var subMillisecondsExports = subMilliseconds.exports;

  var formatters$2 = {exports: {}};

  var getUTCDayOfYear = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getUTCDayOfYear;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var MILLISECONDS_IN_DAY = 86400000;
  	function getUTCDayOfYear(dirtyDate) {
  	  (0, _index2.default)(1, arguments);
  	  var date = (0, _index.default)(dirtyDate);
  	  var timestamp = date.getTime();
  	  date.setUTCMonth(0, 1);
  	  date.setUTCHours(0, 0, 0, 0);
  	  var startOfYearTimestamp = date.getTime();
  	  var difference = timestamp - startOfYearTimestamp;
  	  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
  	}
  	module.exports = exports.default; 
  } (getUTCDayOfYear, getUTCDayOfYear.exports));

  var getUTCDayOfYearExports = getUTCDayOfYear.exports;

  var getUTCISOWeek = {exports: {}};

  var startOfUTCISOWeek = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = startOfUTCISOWeek;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	function startOfUTCISOWeek(dirtyDate) {
  	  (0, _index2.default)(1, arguments);
  	  var weekStartsOn = 1;
  	  var date = (0, _index.default)(dirtyDate);
  	  var day = date.getUTCDay();
  	  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  	  date.setUTCDate(date.getUTCDate() - diff);
  	  date.setUTCHours(0, 0, 0, 0);
  	  return date;
  	}
  	module.exports = exports.default; 
  } (startOfUTCISOWeek, startOfUTCISOWeek.exports));

  var startOfUTCISOWeekExports = startOfUTCISOWeek.exports;

  var startOfUTCISOWeekYear = {exports: {}};

  var getUTCISOWeekYear = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getUTCISOWeekYear;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var _index3 = _interopRequireDefault(startOfUTCISOWeekExports);
  	function getUTCISOWeekYear(dirtyDate) {
  	  (0, _index2.default)(1, arguments);
  	  var date = (0, _index.default)(dirtyDate);
  	  var year = date.getUTCFullYear();
  	  var fourthOfJanuaryOfNextYear = new Date(0);
  	  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  	  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  	  var startOfNextYear = (0, _index3.default)(fourthOfJanuaryOfNextYear);
  	  var fourthOfJanuaryOfThisYear = new Date(0);
  	  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  	  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  	  var startOfThisYear = (0, _index3.default)(fourthOfJanuaryOfThisYear);
  	  if (date.getTime() >= startOfNextYear.getTime()) {
  	    return year + 1;
  	  } else if (date.getTime() >= startOfThisYear.getTime()) {
  	    return year;
  	  } else {
  	    return year - 1;
  	  }
  	}
  	module.exports = exports.default; 
  } (getUTCISOWeekYear, getUTCISOWeekYear.exports));

  var getUTCISOWeekYearExports = getUTCISOWeekYear.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = startOfUTCISOWeekYear;
  	var _index = _interopRequireDefault(getUTCISOWeekYearExports);
  	var _index2 = _interopRequireDefault(startOfUTCISOWeekExports);
  	var _index3 = _interopRequireDefault(requiredArgsExports);
  	function startOfUTCISOWeekYear(dirtyDate) {
  	  (0, _index3.default)(1, arguments);
  	  var year = (0, _index.default)(dirtyDate);
  	  var fourthOfJanuary = new Date(0);
  	  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  	  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  	  var date = (0, _index2.default)(fourthOfJanuary);
  	  return date;
  	}
  	module.exports = exports.default; 
  } (startOfUTCISOWeekYear, startOfUTCISOWeekYear.exports));

  var startOfUTCISOWeekYearExports = startOfUTCISOWeekYear.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getUTCISOWeek;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(startOfUTCISOWeekExports);
  	var _index3 = _interopRequireDefault(startOfUTCISOWeekYearExports);
  	var _index4 = _interopRequireDefault(requiredArgsExports);
  	var MILLISECONDS_IN_WEEK = 604800000;
  	function getUTCISOWeek(dirtyDate) {
  	  (0, _index4.default)(1, arguments);
  	  var date = (0, _index.default)(dirtyDate);
  	  var diff = (0, _index2.default)(date).getTime() - (0, _index3.default)(date).getTime();

  	  // Round the number of days to the nearest integer
  	  // because the number of milliseconds in a week is not constant
  	  // (e.g. it's different in the week of the daylight saving time clock shift)
  	  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  	}
  	module.exports = exports.default; 
  } (getUTCISOWeek, getUTCISOWeek.exports));

  var getUTCISOWeekExports = getUTCISOWeek.exports;

  var getUTCWeek = {exports: {}};

  var startOfUTCWeek = {exports: {}};

  var defaultOptions$1 = {};

  Object.defineProperty(defaultOptions$1, "__esModule", {
    value: true
  });
  defaultOptions$1.getDefaultOptions = getDefaultOptions;
  defaultOptions$1.setDefaultOptions = setDefaultOptions;
  var defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }
  function setDefaultOptions(newOptions) {
    defaultOptions = newOptions;
  }

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = startOfUTCWeek;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var _index3 = _interopRequireDefault(toIntegerExports);
  	var _index4 = defaultOptions$1;
  	function startOfUTCWeek(dirtyDate, options) {
  	  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  	  (0, _index2.default)(1, arguments);
  	  var defaultOptions = (0, _index4.getDefaultOptions)();
  	  var weekStartsOn = (0, _index3.default)((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);

  	  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  	  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
  	    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  	  }
  	  var date = (0, _index.default)(dirtyDate);
  	  var day = date.getUTCDay();
  	  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  	  date.setUTCDate(date.getUTCDate() - diff);
  	  date.setUTCHours(0, 0, 0, 0);
  	  return date;
  	}
  	module.exports = exports.default; 
  } (startOfUTCWeek, startOfUTCWeek.exports));

  var startOfUTCWeekExports = startOfUTCWeek.exports;

  var startOfUTCWeekYear = {exports: {}};

  var getUTCWeekYear = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getUTCWeekYear;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var _index3 = _interopRequireDefault(startOfUTCWeekExports);
  	var _index4 = _interopRequireDefault(toIntegerExports);
  	var _index5 = defaultOptions$1;
  	function getUTCWeekYear(dirtyDate, options) {
  	  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  	  (0, _index2.default)(1, arguments);
  	  var date = (0, _index.default)(dirtyDate);
  	  var year = date.getUTCFullYear();
  	  var defaultOptions = (0, _index5.getDefaultOptions)();
  	  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);

  	  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  	  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
  	    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  	  }
  	  var firstWeekOfNextYear = new Date(0);
  	  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  	  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  	  var startOfNextYear = (0, _index3.default)(firstWeekOfNextYear, options);
  	  var firstWeekOfThisYear = new Date(0);
  	  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  	  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  	  var startOfThisYear = (0, _index3.default)(firstWeekOfThisYear, options);
  	  if (date.getTime() >= startOfNextYear.getTime()) {
  	    return year + 1;
  	  } else if (date.getTime() >= startOfThisYear.getTime()) {
  	    return year;
  	  } else {
  	    return year - 1;
  	  }
  	}
  	module.exports = exports.default; 
  } (getUTCWeekYear, getUTCWeekYear.exports));

  var getUTCWeekYearExports = getUTCWeekYear.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = startOfUTCWeekYear;
  	var _index = _interopRequireDefault(getUTCWeekYearExports);
  	var _index2 = _interopRequireDefault(requiredArgsExports);
  	var _index3 = _interopRequireDefault(startOfUTCWeekExports);
  	var _index4 = _interopRequireDefault(toIntegerExports);
  	var _index5 = defaultOptions$1;
  	function startOfUTCWeekYear(dirtyDate, options) {
  	  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  	  (0, _index2.default)(1, arguments);
  	  var defaultOptions = (0, _index5.getDefaultOptions)();
  	  var firstWeekContainsDate = (0, _index4.default)((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  	  var year = (0, _index.default)(dirtyDate, options);
  	  var firstWeek = new Date(0);
  	  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  	  firstWeek.setUTCHours(0, 0, 0, 0);
  	  var date = (0, _index3.default)(firstWeek, options);
  	  return date;
  	}
  	module.exports = exports.default; 
  } (startOfUTCWeekYear, startOfUTCWeekYear.exports));

  var startOfUTCWeekYearExports = startOfUTCWeekYear.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getUTCWeek;
  	var _index = _interopRequireDefault(toDateExports);
  	var _index2 = _interopRequireDefault(startOfUTCWeekExports);
  	var _index3 = _interopRequireDefault(startOfUTCWeekYearExports);
  	var _index4 = _interopRequireDefault(requiredArgsExports);
  	var MILLISECONDS_IN_WEEK = 604800000;
  	function getUTCWeek(dirtyDate, options) {
  	  (0, _index4.default)(1, arguments);
  	  var date = (0, _index.default)(dirtyDate);
  	  var diff = (0, _index2.default)(date, options).getTime() - (0, _index3.default)(date, options).getTime();

  	  // Round the number of days to the nearest integer
  	  // because the number of milliseconds in a week is not constant
  	  // (e.g. it's different in the week of the daylight saving time clock shift)
  	  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
  	}
  	module.exports = exports.default; 
  } (getUTCWeek, getUTCWeek.exports));

  var getUTCWeekExports = getUTCWeek.exports;

  var addLeadingZeros$1 = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = addLeadingZeros;
  	function addLeadingZeros(number, targetLength) {
  	  var sign = number < 0 ? '-' : '';
  	  var output = Math.abs(number).toString();
  	  while (output.length < targetLength) {
  	    output = '0' + output;
  	  }
  	  return sign + output;
  	}
  	module.exports = exports.default; 
  } (addLeadingZeros$1, addLeadingZeros$1.exports));

  var addLeadingZerosExports = addLeadingZeros$1.exports;

  var lightFormatters = {exports: {}};

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(addLeadingZerosExports);
  	/*
  	 * |     | Unit                           |     | Unit                           |
  	 * |-----|--------------------------------|-----|--------------------------------|
  	 * |  a  | AM, PM                         |  A* |                                |
  	 * |  d  | Day of month                   |  D  |                                |
  	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
  	 * |  m  | Minute                         |  M  | Month                          |
  	 * |  s  | Second                         |  S  | Fraction of second             |
  	 * |  y  | Year (abs)                     |  Y  |                                |
  	 *
  	 * Letters marked by * are not implemented but reserved by Unicode standard.
  	 */

  	var formatters = {
  	  // Year
  	  y: function y(date, token) {
  	    // From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_tokens
  	    // | Year     |     y | yy |   yyy |  yyyy | yyyyy |
  	    // |----------|-------|----|-------|-------|-------|
  	    // | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
  	    // | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
  	    // | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
  	    // | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
  	    // | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |

  	    var signedYear = date.getUTCFullYear();
  	    // Returns 1 for 1 BC (which is year 0 in JavaScript)
  	    var year = signedYear > 0 ? signedYear : 1 - signedYear;
  	    return (0, _index.default)(token === 'yy' ? year % 100 : year, token.length);
  	  },
  	  // Month
  	  M: function M(date, token) {
  	    var month = date.getUTCMonth();
  	    return token === 'M' ? String(month + 1) : (0, _index.default)(month + 1, 2);
  	  },
  	  // Day of the month
  	  d: function d(date, token) {
  	    return (0, _index.default)(date.getUTCDate(), token.length);
  	  },
  	  // AM or PM
  	  a: function a(date, token) {
  	    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? 'pm' : 'am';
  	    switch (token) {
  	      case 'a':
  	      case 'aa':
  	        return dayPeriodEnumValue.toUpperCase();
  	      case 'aaa':
  	        return dayPeriodEnumValue;
  	      case 'aaaaa':
  	        return dayPeriodEnumValue[0];
  	      case 'aaaa':
  	      default:
  	        return dayPeriodEnumValue === 'am' ? 'a.m.' : 'p.m.';
  	    }
  	  },
  	  // Hour [1-12]
  	  h: function h(date, token) {
  	    return (0, _index.default)(date.getUTCHours() % 12 || 12, token.length);
  	  },
  	  // Hour [0-23]
  	  H: function H(date, token) {
  	    return (0, _index.default)(date.getUTCHours(), token.length);
  	  },
  	  // Minute
  	  m: function m(date, token) {
  	    return (0, _index.default)(date.getUTCMinutes(), token.length);
  	  },
  	  // Second
  	  s: function s(date, token) {
  	    return (0, _index.default)(date.getUTCSeconds(), token.length);
  	  },
  	  // Fraction of second
  	  S: function S(date, token) {
  	    var numberOfDigits = token.length;
  	    var milliseconds = date.getUTCMilliseconds();
  	    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
  	    return (0, _index.default)(fractionalSeconds, token.length);
  	  }
  	};
  	var _default = formatters;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (lightFormatters, lightFormatters.exports));

  var lightFormattersExports = lightFormatters.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(getUTCDayOfYearExports);
  	var _index2 = _interopRequireDefault(getUTCISOWeekExports);
  	var _index3 = _interopRequireDefault(getUTCISOWeekYearExports);
  	var _index4 = _interopRequireDefault(getUTCWeekExports);
  	var _index5 = _interopRequireDefault(getUTCWeekYearExports);
  	var _index6 = _interopRequireDefault(addLeadingZerosExports);
  	var _index7 = _interopRequireDefault(lightFormattersExports);
  	var dayPeriodEnum = {
  	  am: 'am',
  	  pm: 'pm',
  	  midnight: 'midnight',
  	  noon: 'noon',
  	  morning: 'morning',
  	  afternoon: 'afternoon',
  	  evening: 'evening',
  	  night: 'night'
  	};
  	/*
  	 * |     | Unit                           |     | Unit                           |
  	 * |-----|--------------------------------|-----|--------------------------------|
  	 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
  	 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
  	 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
  	 * |  d  | Day of month                   |  D  | Day of year                    |
  	 * |  e  | Local day of week              |  E  | Day of week                    |
  	 * |  f  |                                |  F* | Day of week in month           |
  	 * |  g* | Modified Julian day            |  G  | Era                            |
  	 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
  	 * |  i! | ISO day of week                |  I! | ISO week of year               |
  	 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
  	 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
  	 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
  	 * |  m  | Minute                         |  M  | Month                          |
  	 * |  n  |                                |  N  |                                |
  	 * |  o! | Ordinal number modifier        |  O  | Timezone (GMT)                 |
  	 * |  p! | Long localized time            |  P! | Long localized date            |
  	 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
  	 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
  	 * |  s  | Second                         |  S  | Fraction of second             |
  	 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
  	 * |  u  | Extended year                  |  U* | Cyclic year                    |
  	 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
  	 * |  w  | Local week of year             |  W* | Week of month                  |
  	 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
  	 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
  	 * |  z  | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
  	 *
  	 * Letters marked by * are not implemented but reserved by Unicode standard.
  	 *
  	 * Letters marked by ! are non-standard, but implemented by date-fns:
  	 * - `o` modifies the previous token to turn it into an ordinal (see `format` docs)
  	 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
  	 *   i.e. 7 for Sunday, 1 for Monday, etc.
  	 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
  	 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
  	 *   `R` is supposed to be used in conjunction with `I` and `i`
  	 *   for universal ISO week-numbering date, whereas
  	 *   `Y` is supposed to be used in conjunction with `w` and `e`
  	 *   for week-numbering date specific to the locale.
  	 * - `P` is long localized date format
  	 * - `p` is long localized time format
  	 */

  	var formatters = {
  	  // Era
  	  G: function G(date, token, localize) {
  	    var era = date.getUTCFullYear() > 0 ? 1 : 0;
  	    switch (token) {
  	      // AD, BC
  	      case 'G':
  	      case 'GG':
  	      case 'GGG':
  	        return localize.era(era, {
  	          width: 'abbreviated'
  	        });
  	      // A, B
  	      case 'GGGGG':
  	        return localize.era(era, {
  	          width: 'narrow'
  	        });
  	      // Anno Domini, Before Christ
  	      case 'GGGG':
  	      default:
  	        return localize.era(era, {
  	          width: 'wide'
  	        });
  	    }
  	  },
  	  // Year
  	  y: function y(date, token, localize) {
  	    // Ordinal number
  	    if (token === 'yo') {
  	      var signedYear = date.getUTCFullYear();
  	      // Returns 1 for 1 BC (which is year 0 in JavaScript)
  	      var year = signedYear > 0 ? signedYear : 1 - signedYear;
  	      return localize.ordinalNumber(year, {
  	        unit: 'year'
  	      });
  	    }
  	    return _index7.default.y(date, token);
  	  },
  	  // Local week-numbering year
  	  Y: function Y(date, token, localize, options) {
  	    var signedWeekYear = (0, _index5.default)(date, options);
  	    // Returns 1 for 1 BC (which is year 0 in JavaScript)
  	    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;

  	    // Two digit year
  	    if (token === 'YY') {
  	      var twoDigitYear = weekYear % 100;
  	      return (0, _index6.default)(twoDigitYear, 2);
  	    }

  	    // Ordinal number
  	    if (token === 'Yo') {
  	      return localize.ordinalNumber(weekYear, {
  	        unit: 'year'
  	      });
  	    }

  	    // Padding
  	    return (0, _index6.default)(weekYear, token.length);
  	  },
  	  // ISO week-numbering year
  	  R: function R(date, token) {
  	    var isoWeekYear = (0, _index3.default)(date);

  	    // Padding
  	    return (0, _index6.default)(isoWeekYear, token.length);
  	  },
  	  // Extended year. This is a single number designating the year of this calendar system.
  	  // The main difference between `y` and `u` localizers are B.C. years:
  	  // | Year | `y` | `u` |
  	  // |------|-----|-----|
  	  // | AC 1 |   1 |   1 |
  	  // | BC 1 |   1 |   0 |
  	  // | BC 2 |   2 |  -1 |
  	  // Also `yy` always returns the last two digits of a year,
  	  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  	  u: function u(date, token) {
  	    var year = date.getUTCFullYear();
  	    return (0, _index6.default)(year, token.length);
  	  },
  	  // Quarter
  	  Q: function Q(date, token, localize) {
  	    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
  	    switch (token) {
  	      // 1, 2, 3, 4
  	      case 'Q':
  	        return String(quarter);
  	      // 01, 02, 03, 04
  	      case 'QQ':
  	        return (0, _index6.default)(quarter, 2);
  	      // 1st, 2nd, 3rd, 4th
  	      case 'Qo':
  	        return localize.ordinalNumber(quarter, {
  	          unit: 'quarter'
  	        });
  	      // Q1, Q2, Q3, Q4
  	      case 'QQQ':
  	        return localize.quarter(quarter, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
  	      case 'QQQQQ':
  	        return localize.quarter(quarter, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      // 1st quarter, 2nd quarter, ...
  	      case 'QQQQ':
  	      default:
  	        return localize.quarter(quarter, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // Stand-alone quarter
  	  q: function q(date, token, localize) {
  	    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
  	    switch (token) {
  	      // 1, 2, 3, 4
  	      case 'q':
  	        return String(quarter);
  	      // 01, 02, 03, 04
  	      case 'qq':
  	        return (0, _index6.default)(quarter, 2);
  	      // 1st, 2nd, 3rd, 4th
  	      case 'qo':
  	        return localize.ordinalNumber(quarter, {
  	          unit: 'quarter'
  	        });
  	      // Q1, Q2, Q3, Q4
  	      case 'qqq':
  	        return localize.quarter(quarter, {
  	          width: 'abbreviated',
  	          context: 'standalone'
  	        });
  	      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
  	      case 'qqqqq':
  	        return localize.quarter(quarter, {
  	          width: 'narrow',
  	          context: 'standalone'
  	        });
  	      // 1st quarter, 2nd quarter, ...
  	      case 'qqqq':
  	      default:
  	        return localize.quarter(quarter, {
  	          width: 'wide',
  	          context: 'standalone'
  	        });
  	    }
  	  },
  	  // Month
  	  M: function M(date, token, localize) {
  	    var month = date.getUTCMonth();
  	    switch (token) {
  	      case 'M':
  	      case 'MM':
  	        return _index7.default.M(date, token);
  	      // 1st, 2nd, ..., 12th
  	      case 'Mo':
  	        return localize.ordinalNumber(month + 1, {
  	          unit: 'month'
  	        });
  	      // Jan, Feb, ..., Dec
  	      case 'MMM':
  	        return localize.month(month, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      // J, F, ..., D
  	      case 'MMMMM':
  	        return localize.month(month, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      // January, February, ..., December
  	      case 'MMMM':
  	      default:
  	        return localize.month(month, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // Stand-alone month
  	  L: function L(date, token, localize) {
  	    var month = date.getUTCMonth();
  	    switch (token) {
  	      // 1, 2, ..., 12
  	      case 'L':
  	        return String(month + 1);
  	      // 01, 02, ..., 12
  	      case 'LL':
  	        return (0, _index6.default)(month + 1, 2);
  	      // 1st, 2nd, ..., 12th
  	      case 'Lo':
  	        return localize.ordinalNumber(month + 1, {
  	          unit: 'month'
  	        });
  	      // Jan, Feb, ..., Dec
  	      case 'LLL':
  	        return localize.month(month, {
  	          width: 'abbreviated',
  	          context: 'standalone'
  	        });
  	      // J, F, ..., D
  	      case 'LLLLL':
  	        return localize.month(month, {
  	          width: 'narrow',
  	          context: 'standalone'
  	        });
  	      // January, February, ..., December
  	      case 'LLLL':
  	      default:
  	        return localize.month(month, {
  	          width: 'wide',
  	          context: 'standalone'
  	        });
  	    }
  	  },
  	  // Local week of year
  	  w: function w(date, token, localize, options) {
  	    var week = (0, _index4.default)(date, options);
  	    if (token === 'wo') {
  	      return localize.ordinalNumber(week, {
  	        unit: 'week'
  	      });
  	    }
  	    return (0, _index6.default)(week, token.length);
  	  },
  	  // ISO week of year
  	  I: function I(date, token, localize) {
  	    var isoWeek = (0, _index2.default)(date);
  	    if (token === 'Io') {
  	      return localize.ordinalNumber(isoWeek, {
  	        unit: 'week'
  	      });
  	    }
  	    return (0, _index6.default)(isoWeek, token.length);
  	  },
  	  // Day of the month
  	  d: function d(date, token, localize) {
  	    if (token === 'do') {
  	      return localize.ordinalNumber(date.getUTCDate(), {
  	        unit: 'date'
  	      });
  	    }
  	    return _index7.default.d(date, token);
  	  },
  	  // Day of year
  	  D: function D(date, token, localize) {
  	    var dayOfYear = (0, _index.default)(date);
  	    if (token === 'Do') {
  	      return localize.ordinalNumber(dayOfYear, {
  	        unit: 'dayOfYear'
  	      });
  	    }
  	    return (0, _index6.default)(dayOfYear, token.length);
  	  },
  	  // Day of week
  	  E: function E(date, token, localize) {
  	    var dayOfWeek = date.getUTCDay();
  	    switch (token) {
  	      // Tue
  	      case 'E':
  	      case 'EE':
  	      case 'EEE':
  	        return localize.day(dayOfWeek, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      // T
  	      case 'EEEEE':
  	        return localize.day(dayOfWeek, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      // Tu
  	      case 'EEEEEE':
  	        return localize.day(dayOfWeek, {
  	          width: 'short',
  	          context: 'formatting'
  	        });
  	      // Tuesday
  	      case 'EEEE':
  	      default:
  	        return localize.day(dayOfWeek, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // Local day of week
  	  e: function e(date, token, localize, options) {
  	    var dayOfWeek = date.getUTCDay();
  	    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
  	    switch (token) {
  	      // Numerical value (Nth day of week with current locale or weekStartsOn)
  	      case 'e':
  	        return String(localDayOfWeek);
  	      // Padded numerical value
  	      case 'ee':
  	        return (0, _index6.default)(localDayOfWeek, 2);
  	      // 1st, 2nd, ..., 7th
  	      case 'eo':
  	        return localize.ordinalNumber(localDayOfWeek, {
  	          unit: 'day'
  	        });
  	      case 'eee':
  	        return localize.day(dayOfWeek, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      // T
  	      case 'eeeee':
  	        return localize.day(dayOfWeek, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      // Tu
  	      case 'eeeeee':
  	        return localize.day(dayOfWeek, {
  	          width: 'short',
  	          context: 'formatting'
  	        });
  	      // Tuesday
  	      case 'eeee':
  	      default:
  	        return localize.day(dayOfWeek, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // Stand-alone local day of week
  	  c: function c(date, token, localize, options) {
  	    var dayOfWeek = date.getUTCDay();
  	    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
  	    switch (token) {
  	      // Numerical value (same as in `e`)
  	      case 'c':
  	        return String(localDayOfWeek);
  	      // Padded numerical value
  	      case 'cc':
  	        return (0, _index6.default)(localDayOfWeek, token.length);
  	      // 1st, 2nd, ..., 7th
  	      case 'co':
  	        return localize.ordinalNumber(localDayOfWeek, {
  	          unit: 'day'
  	        });
  	      case 'ccc':
  	        return localize.day(dayOfWeek, {
  	          width: 'abbreviated',
  	          context: 'standalone'
  	        });
  	      // T
  	      case 'ccccc':
  	        return localize.day(dayOfWeek, {
  	          width: 'narrow',
  	          context: 'standalone'
  	        });
  	      // Tu
  	      case 'cccccc':
  	        return localize.day(dayOfWeek, {
  	          width: 'short',
  	          context: 'standalone'
  	        });
  	      // Tuesday
  	      case 'cccc':
  	      default:
  	        return localize.day(dayOfWeek, {
  	          width: 'wide',
  	          context: 'standalone'
  	        });
  	    }
  	  },
  	  // ISO day of week
  	  i: function i(date, token, localize) {
  	    var dayOfWeek = date.getUTCDay();
  	    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
  	    switch (token) {
  	      // 2
  	      case 'i':
  	        return String(isoDayOfWeek);
  	      // 02
  	      case 'ii':
  	        return (0, _index6.default)(isoDayOfWeek, token.length);
  	      // 2nd
  	      case 'io':
  	        return localize.ordinalNumber(isoDayOfWeek, {
  	          unit: 'day'
  	        });
  	      // Tue
  	      case 'iii':
  	        return localize.day(dayOfWeek, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      // T
  	      case 'iiiii':
  	        return localize.day(dayOfWeek, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      // Tu
  	      case 'iiiiii':
  	        return localize.day(dayOfWeek, {
  	          width: 'short',
  	          context: 'formatting'
  	        });
  	      // Tuesday
  	      case 'iiii':
  	      default:
  	        return localize.day(dayOfWeek, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // AM or PM
  	  a: function a(date, token, localize) {
  	    var hours = date.getUTCHours();
  	    var dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
  	    switch (token) {
  	      case 'a':
  	      case 'aa':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      case 'aaa':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        }).toLowerCase();
  	      case 'aaaaa':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      case 'aaaa':
  	      default:
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // AM, PM, midnight, noon
  	  b: function b(date, token, localize) {
  	    var hours = date.getUTCHours();
  	    var dayPeriodEnumValue;
  	    if (hours === 12) {
  	      dayPeriodEnumValue = dayPeriodEnum.noon;
  	    } else if (hours === 0) {
  	      dayPeriodEnumValue = dayPeriodEnum.midnight;
  	    } else {
  	      dayPeriodEnumValue = hours / 12 >= 1 ? 'pm' : 'am';
  	    }
  	    switch (token) {
  	      case 'b':
  	      case 'bb':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      case 'bbb':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        }).toLowerCase();
  	      case 'bbbbb':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      case 'bbbb':
  	      default:
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // in the morning, in the afternoon, in the evening, at night
  	  B: function B(date, token, localize) {
  	    var hours = date.getUTCHours();
  	    var dayPeriodEnumValue;
  	    if (hours >= 17) {
  	      dayPeriodEnumValue = dayPeriodEnum.evening;
  	    } else if (hours >= 12) {
  	      dayPeriodEnumValue = dayPeriodEnum.afternoon;
  	    } else if (hours >= 4) {
  	      dayPeriodEnumValue = dayPeriodEnum.morning;
  	    } else {
  	      dayPeriodEnumValue = dayPeriodEnum.night;
  	    }
  	    switch (token) {
  	      case 'B':
  	      case 'BB':
  	      case 'BBB':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'abbreviated',
  	          context: 'formatting'
  	        });
  	      case 'BBBBB':
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'narrow',
  	          context: 'formatting'
  	        });
  	      case 'BBBB':
  	      default:
  	        return localize.dayPeriod(dayPeriodEnumValue, {
  	          width: 'wide',
  	          context: 'formatting'
  	        });
  	    }
  	  },
  	  // Hour [1-12]
  	  h: function h(date, token, localize) {
  	    if (token === 'ho') {
  	      var hours = date.getUTCHours() % 12;
  	      if (hours === 0) hours = 12;
  	      return localize.ordinalNumber(hours, {
  	        unit: 'hour'
  	      });
  	    }
  	    return _index7.default.h(date, token);
  	  },
  	  // Hour [0-23]
  	  H: function H(date, token, localize) {
  	    if (token === 'Ho') {
  	      return localize.ordinalNumber(date.getUTCHours(), {
  	        unit: 'hour'
  	      });
  	    }
  	    return _index7.default.H(date, token);
  	  },
  	  // Hour [0-11]
  	  K: function K(date, token, localize) {
  	    var hours = date.getUTCHours() % 12;
  	    if (token === 'Ko') {
  	      return localize.ordinalNumber(hours, {
  	        unit: 'hour'
  	      });
  	    }
  	    return (0, _index6.default)(hours, token.length);
  	  },
  	  // Hour [1-24]
  	  k: function k(date, token, localize) {
  	    var hours = date.getUTCHours();
  	    if (hours === 0) hours = 24;
  	    if (token === 'ko') {
  	      return localize.ordinalNumber(hours, {
  	        unit: 'hour'
  	      });
  	    }
  	    return (0, _index6.default)(hours, token.length);
  	  },
  	  // Minute
  	  m: function m(date, token, localize) {
  	    if (token === 'mo') {
  	      return localize.ordinalNumber(date.getUTCMinutes(), {
  	        unit: 'minute'
  	      });
  	    }
  	    return _index7.default.m(date, token);
  	  },
  	  // Second
  	  s: function s(date, token, localize) {
  	    if (token === 'so') {
  	      return localize.ordinalNumber(date.getUTCSeconds(), {
  	        unit: 'second'
  	      });
  	    }
  	    return _index7.default.s(date, token);
  	  },
  	  // Fraction of second
  	  S: function S(date, token) {
  	    return _index7.default.S(date, token);
  	  },
  	  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  	  X: function X(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timezoneOffset = originalDate.getTimezoneOffset();
  	    if (timezoneOffset === 0) {
  	      return 'Z';
  	    }
  	    switch (token) {
  	      // Hours and optional minutes
  	      case 'X':
  	        return formatTimezoneWithOptionalMinutes(timezoneOffset);

  	      // Hours, minutes and optional seconds without `:` delimiter
  	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
  	      // so this token always has the same output as `XX`
  	      case 'XXXX':
  	      case 'XX':
  	        // Hours and minutes without `:` delimiter
  	        return formatTimezone(timezoneOffset);

  	      // Hours, minutes and optional seconds with `:` delimiter
  	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
  	      // so this token always has the same output as `XXX`
  	      case 'XXXXX':
  	      case 'XXX': // Hours and minutes with `:` delimiter
  	      default:
  	        return formatTimezone(timezoneOffset, ':');
  	    }
  	  },
  	  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  	  x: function x(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timezoneOffset = originalDate.getTimezoneOffset();
  	    switch (token) {
  	      // Hours and optional minutes
  	      case 'x':
  	        return formatTimezoneWithOptionalMinutes(timezoneOffset);

  	      // Hours, minutes and optional seconds without `:` delimiter
  	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
  	      // so this token always has the same output as `xx`
  	      case 'xxxx':
  	      case 'xx':
  	        // Hours and minutes without `:` delimiter
  	        return formatTimezone(timezoneOffset);

  	      // Hours, minutes and optional seconds with `:` delimiter
  	      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
  	      // so this token always has the same output as `xxx`
  	      case 'xxxxx':
  	      case 'xxx': // Hours and minutes with `:` delimiter
  	      default:
  	        return formatTimezone(timezoneOffset, ':');
  	    }
  	  },
  	  // Timezone (GMT)
  	  O: function O(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timezoneOffset = originalDate.getTimezoneOffset();
  	    switch (token) {
  	      // Short
  	      case 'O':
  	      case 'OO':
  	      case 'OOO':
  	        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
  	      // Long
  	      case 'OOOO':
  	      default:
  	        return 'GMT' + formatTimezone(timezoneOffset, ':');
  	    }
  	  },
  	  // Timezone (specific non-location)
  	  z: function z(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timezoneOffset = originalDate.getTimezoneOffset();
  	    switch (token) {
  	      // Short
  	      case 'z':
  	      case 'zz':
  	      case 'zzz':
  	        return 'GMT' + formatTimezoneShort(timezoneOffset, ':');
  	      // Long
  	      case 'zzzz':
  	      default:
  	        return 'GMT' + formatTimezone(timezoneOffset, ':');
  	    }
  	  },
  	  // Seconds timestamp
  	  t: function t(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timestamp = Math.floor(originalDate.getTime() / 1000);
  	    return (0, _index6.default)(timestamp, token.length);
  	  },
  	  // Milliseconds timestamp
  	  T: function T(date, token, _localize, options) {
  	    var originalDate = options._originalDate || date;
  	    var timestamp = originalDate.getTime();
  	    return (0, _index6.default)(timestamp, token.length);
  	  }
  	};
  	function formatTimezoneShort(offset, dirtyDelimiter) {
  	  var sign = offset > 0 ? '-' : '+';
  	  var absOffset = Math.abs(offset);
  	  var hours = Math.floor(absOffset / 60);
  	  var minutes = absOffset % 60;
  	  if (minutes === 0) {
  	    return sign + String(hours);
  	  }
  	  var delimiter = dirtyDelimiter || '';
  	  return sign + String(hours) + delimiter + (0, _index6.default)(minutes, 2);
  	}
  	function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  	  if (offset % 60 === 0) {
  	    var sign = offset > 0 ? '-' : '+';
  	    return sign + (0, _index6.default)(Math.abs(offset) / 60, 2);
  	  }
  	  return formatTimezone(offset, dirtyDelimiter);
  	}
  	function formatTimezone(offset, dirtyDelimiter) {
  	  var delimiter = dirtyDelimiter || '';
  	  var sign = offset > 0 ? '-' : '+';
  	  var absOffset = Math.abs(offset);
  	  var hours = (0, _index6.default)(Math.floor(absOffset / 60), 2);
  	  var minutes = (0, _index6.default)(absOffset % 60, 2);
  	  return sign + hours + delimiter + minutes;
  	}
  	var _default = formatters;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (formatters$2, formatters$2.exports));

  var formattersExports = formatters$2.exports;

  var longFormatters = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  	  switch (pattern) {
  	    case 'P':
  	      return formatLong.date({
  	        width: 'short'
  	      });
  	    case 'PP':
  	      return formatLong.date({
  	        width: 'medium'
  	      });
  	    case 'PPP':
  	      return formatLong.date({
  	        width: 'long'
  	      });
  	    case 'PPPP':
  	    default:
  	      return formatLong.date({
  	        width: 'full'
  	      });
  	  }
  	};
  	var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  	  switch (pattern) {
  	    case 'p':
  	      return formatLong.time({
  	        width: 'short'
  	      });
  	    case 'pp':
  	      return formatLong.time({
  	        width: 'medium'
  	      });
  	    case 'ppp':
  	      return formatLong.time({
  	        width: 'long'
  	      });
  	    case 'pppp':
  	    default:
  	      return formatLong.time({
  	        width: 'full'
  	      });
  	  }
  	};
  	var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  	  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  	  var datePattern = matchResult[1];
  	  var timePattern = matchResult[2];
  	  if (!timePattern) {
  	    return dateLongFormatter(pattern, formatLong);
  	  }
  	  var dateTimeFormat;
  	  switch (datePattern) {
  	    case 'P':
  	      dateTimeFormat = formatLong.dateTime({
  	        width: 'short'
  	      });
  	      break;
  	    case 'PP':
  	      dateTimeFormat = formatLong.dateTime({
  	        width: 'medium'
  	      });
  	      break;
  	    case 'PPP':
  	      dateTimeFormat = formatLong.dateTime({
  	        width: 'long'
  	      });
  	      break;
  	    case 'PPPP':
  	    default:
  	      dateTimeFormat = formatLong.dateTime({
  	        width: 'full'
  	      });
  	      break;
  	  }
  	  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
  	};
  	var longFormatters = {
  	  p: timeLongFormatter,
  	  P: dateTimeLongFormatter
  	};
  	var _default = longFormatters;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (longFormatters, longFormatters.exports));

  var longFormattersExports = longFormatters.exports;

  var getTimezoneOffsetInMilliseconds$1 = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = getTimezoneOffsetInMilliseconds;
  	/**
  	 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
  	 * They usually appear for dates that denote time before the timezones were introduced
  	 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
  	 * and GMT+01:00:00 after that date)
  	 *
  	 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
  	 * which would lead to incorrect calculations.
  	 *
  	 * This function returns the timezone offset in milliseconds that takes seconds in account.
  	 */
  	function getTimezoneOffsetInMilliseconds(date) {
  	  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  	  utcDate.setUTCFullYear(date.getFullYear());
  	  return date.getTime() - utcDate.getTime();
  	}
  	module.exports = exports.default; 
  } (getTimezoneOffsetInMilliseconds$1, getTimezoneOffsetInMilliseconds$1.exports));

  var getTimezoneOffsetInMillisecondsExports = getTimezoneOffsetInMilliseconds$1.exports;
  var getTimezoneOffsetInMilliseconds = /*@__PURE__*/getDefaultExportFromCjs(getTimezoneOffsetInMillisecondsExports);

  var protectedTokens = {};

  Object.defineProperty(protectedTokens, "__esModule", {
    value: true
  });
  protectedTokens.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
  protectedTokens.isProtectedWeekYearToken = isProtectedWeekYearToken;
  protectedTokens.throwProtectedError = throwProtectedError;
  var protectedDayOfYearTokens = ['D', 'DD'];
  var protectedWeekYearTokens = ['YY', 'YYYY'];
  function isProtectedDayOfYearToken(token) {
    return protectedDayOfYearTokens.indexOf(token) !== -1;
  }
  function isProtectedWeekYearToken(token) {
    return protectedWeekYearTokens.indexOf(token) !== -1;
  }
  function throwProtectedError(token, format, input) {
    if (token === 'YYYY') {
      throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'YY') {
      throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'D') {
      throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    } else if (token === 'DD') {
      throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
    }
  }

  var defaultLocale = {exports: {}};

  var enUS = {exports: {}};

  var formatDistance = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var formatDistanceLocale = {
  	  lessThanXSeconds: {
  	    one: 'less than a second',
  	    other: 'less than {{count}} seconds'
  	  },
  	  xSeconds: {
  	    one: '1 second',
  	    other: '{{count}} seconds'
  	  },
  	  halfAMinute: 'half a minute',
  	  lessThanXMinutes: {
  	    one: 'less than a minute',
  	    other: 'less than {{count}} minutes'
  	  },
  	  xMinutes: {
  	    one: '1 minute',
  	    other: '{{count}} minutes'
  	  },
  	  aboutXHours: {
  	    one: 'about 1 hour',
  	    other: 'about {{count}} hours'
  	  },
  	  xHours: {
  	    one: '1 hour',
  	    other: '{{count}} hours'
  	  },
  	  xDays: {
  	    one: '1 day',
  	    other: '{{count}} days'
  	  },
  	  aboutXWeeks: {
  	    one: 'about 1 week',
  	    other: 'about {{count}} weeks'
  	  },
  	  xWeeks: {
  	    one: '1 week',
  	    other: '{{count}} weeks'
  	  },
  	  aboutXMonths: {
  	    one: 'about 1 month',
  	    other: 'about {{count}} months'
  	  },
  	  xMonths: {
  	    one: '1 month',
  	    other: '{{count}} months'
  	  },
  	  aboutXYears: {
  	    one: 'about 1 year',
  	    other: 'about {{count}} years'
  	  },
  	  xYears: {
  	    one: '1 year',
  	    other: '{{count}} years'
  	  },
  	  overXYears: {
  	    one: 'over 1 year',
  	    other: 'over {{count}} years'
  	  },
  	  almostXYears: {
  	    one: 'almost 1 year',
  	    other: 'almost {{count}} years'
  	  }
  	};
  	var formatDistance = function formatDistance(token, count, options) {
  	  var result;
  	  var tokenValue = formatDistanceLocale[token];
  	  if (typeof tokenValue === 'string') {
  	    result = tokenValue;
  	  } else if (count === 1) {
  	    result = tokenValue.one;
  	  } else {
  	    result = tokenValue.other.replace('{{count}}', count.toString());
  	  }
  	  if (options !== null && options !== void 0 && options.addSuffix) {
  	    if (options.comparison && options.comparison > 0) {
  	      return 'in ' + result;
  	    } else {
  	      return result + ' ago';
  	    }
  	  }
  	  return result;
  	};
  	var _default = formatDistance;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (formatDistance, formatDistance.exports));

  var formatDistanceExports = formatDistance.exports;

  var formatLong = {exports: {}};

  var buildFormatLongFn = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = buildFormatLongFn;
  	function buildFormatLongFn(args) {
  	  return function () {
  	    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  	    // TODO: Remove String()
  	    var width = options.width ? String(options.width) : args.defaultWidth;
  	    var format = args.formats[width] || args.formats[args.defaultWidth];
  	    return format;
  	  };
  	}
  	module.exports = exports.default; 
  } (buildFormatLongFn, buildFormatLongFn.exports));

  var buildFormatLongFnExports = buildFormatLongFn.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(buildFormatLongFnExports);
  	var dateFormats = {
  	  full: 'EEEE, MMMM do, y',
  	  long: 'MMMM do, y',
  	  medium: 'MMM d, y',
  	  short: 'MM/dd/yyyy'
  	};
  	var timeFormats = {
  	  full: 'h:mm:ss a zzzz',
  	  long: 'h:mm:ss a z',
  	  medium: 'h:mm:ss a',
  	  short: 'h:mm a'
  	};
  	var dateTimeFormats = {
  	  full: "{{date}} 'at' {{time}}",
  	  long: "{{date}} 'at' {{time}}",
  	  medium: '{{date}}, {{time}}',
  	  short: '{{date}}, {{time}}'
  	};
  	var formatLong = {
  	  date: (0, _index.default)({
  	    formats: dateFormats,
  	    defaultWidth: 'full'
  	  }),
  	  time: (0, _index.default)({
  	    formats: timeFormats,
  	    defaultWidth: 'full'
  	  }),
  	  dateTime: (0, _index.default)({
  	    formats: dateTimeFormats,
  	    defaultWidth: 'full'
  	  })
  	};
  	var _default = formatLong;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (formatLong, formatLong.exports));

  var formatLongExports = formatLong.exports;

  var formatRelative = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var formatRelativeLocale = {
  	  lastWeek: "'last' eeee 'at' p",
  	  yesterday: "'yesterday at' p",
  	  today: "'today at' p",
  	  tomorrow: "'tomorrow at' p",
  	  nextWeek: "eeee 'at' p",
  	  other: 'P'
  	};
  	var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  	  return formatRelativeLocale[token];
  	};
  	var _default = formatRelative;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (formatRelative, formatRelative.exports));

  var formatRelativeExports = formatRelative.exports;

  var localize = {exports: {}};

  var buildLocalizeFn = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = buildLocalizeFn;
  	function buildLocalizeFn(args) {
  	  return function (dirtyIndex, options) {
  	    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
  	    var valuesArray;
  	    if (context === 'formatting' && args.formattingValues) {
  	      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
  	      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
  	      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
  	    } else {
  	      var _defaultWidth = args.defaultWidth;
  	      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
  	      valuesArray = args.values[_width] || args.values[_defaultWidth];
  	    }
  	    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
  	    // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!
  	    return valuesArray[index];
  	  };
  	}
  	module.exports = exports.default; 
  } (buildLocalizeFn, buildLocalizeFn.exports));

  var buildLocalizeFnExports = buildLocalizeFn.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(buildLocalizeFnExports);
  	var eraValues = {
  	  narrow: ['B', 'A'],
  	  abbreviated: ['BC', 'AD'],
  	  wide: ['Before Christ', 'Anno Domini']
  	};
  	var quarterValues = {
  	  narrow: ['1', '2', '3', '4'],
  	  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  	  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
  	};

  	// Note: in English, the names of days of the week and months are capitalized.
  	// If you are making a new locale based on this one, check if the same is true for the language you're working on.
  	// Generally, formatted dates should look like they are in the middle of a sentence,
  	// e.g. in Spanish language the weekdays and months should be in the lowercase.
  	var monthValues = {
  	  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  	  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  	  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
  	};
  	var dayValues = {
  	  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  	  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  	  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  	  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
  	};
  	var dayPeriodValues = {
  	  narrow: {
  	    am: 'a',
  	    pm: 'p',
  	    midnight: 'mi',
  	    noon: 'n',
  	    morning: 'morning',
  	    afternoon: 'afternoon',
  	    evening: 'evening',
  	    night: 'night'
  	  },
  	  abbreviated: {
  	    am: 'AM',
  	    pm: 'PM',
  	    midnight: 'midnight',
  	    noon: 'noon',
  	    morning: 'morning',
  	    afternoon: 'afternoon',
  	    evening: 'evening',
  	    night: 'night'
  	  },
  	  wide: {
  	    am: 'a.m.',
  	    pm: 'p.m.',
  	    midnight: 'midnight',
  	    noon: 'noon',
  	    morning: 'morning',
  	    afternoon: 'afternoon',
  	    evening: 'evening',
  	    night: 'night'
  	  }
  	};
  	var formattingDayPeriodValues = {
  	  narrow: {
  	    am: 'a',
  	    pm: 'p',
  	    midnight: 'mi',
  	    noon: 'n',
  	    morning: 'in the morning',
  	    afternoon: 'in the afternoon',
  	    evening: 'in the evening',
  	    night: 'at night'
  	  },
  	  abbreviated: {
  	    am: 'AM',
  	    pm: 'PM',
  	    midnight: 'midnight',
  	    noon: 'noon',
  	    morning: 'in the morning',
  	    afternoon: 'in the afternoon',
  	    evening: 'in the evening',
  	    night: 'at night'
  	  },
  	  wide: {
  	    am: 'a.m.',
  	    pm: 'p.m.',
  	    midnight: 'midnight',
  	    noon: 'noon',
  	    morning: 'in the morning',
  	    afternoon: 'in the afternoon',
  	    evening: 'in the evening',
  	    night: 'at night'
  	  }
  	};
  	var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  	  var number = Number(dirtyNumber);

  	  // If ordinal numbers depend on context, for example,
  	  // if they are different for different grammatical genders,
  	  // use `options.unit`.
  	  //
  	  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  	  // 'day', 'hour', 'minute', 'second'.

  	  var rem100 = number % 100;
  	  if (rem100 > 20 || rem100 < 10) {
  	    switch (rem100 % 10) {
  	      case 1:
  	        return number + 'st';
  	      case 2:
  	        return number + 'nd';
  	      case 3:
  	        return number + 'rd';
  	    }
  	  }
  	  return number + 'th';
  	};
  	var localize = {
  	  ordinalNumber: ordinalNumber,
  	  era: (0, _index.default)({
  	    values: eraValues,
  	    defaultWidth: 'wide'
  	  }),
  	  quarter: (0, _index.default)({
  	    values: quarterValues,
  	    defaultWidth: 'wide',
  	    argumentCallback: function argumentCallback(quarter) {
  	      return quarter - 1;
  	    }
  	  }),
  	  month: (0, _index.default)({
  	    values: monthValues,
  	    defaultWidth: 'wide'
  	  }),
  	  day: (0, _index.default)({
  	    values: dayValues,
  	    defaultWidth: 'wide'
  	  }),
  	  dayPeriod: (0, _index.default)({
  	    values: dayPeriodValues,
  	    defaultWidth: 'wide',
  	    formattingValues: formattingDayPeriodValues,
  	    defaultFormattingWidth: 'wide'
  	  })
  	};
  	var _default = localize;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (localize, localize.exports));

  var localizeExports = localize.exports;

  var match = {exports: {}};

  var buildMatchFn = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = buildMatchFn;
  	function buildMatchFn(args) {
  	  return function (string) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    var width = options.width;
  	    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
  	    var matchResult = string.match(matchPattern);
  	    if (!matchResult) {
  	      return null;
  	    }
  	    var matchedString = matchResult[0];
  	    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
  	    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
  	      return pattern.test(matchedString);
  	    }) : findKey(parsePatterns, function (pattern) {
  	      return pattern.test(matchedString);
  	    });
  	    var value;
  	    value = args.valueCallback ? args.valueCallback(key) : key;
  	    value = options.valueCallback ? options.valueCallback(value) : value;
  	    var rest = string.slice(matchedString.length);
  	    return {
  	      value: value,
  	      rest: rest
  	    };
  	  };
  	}
  	function findKey(object, predicate) {
  	  for (var key in object) {
  	    if (object.hasOwnProperty(key) && predicate(object[key])) {
  	      return key;
  	    }
  	  }
  	  return undefined;
  	}
  	function findIndex(array, predicate) {
  	  for (var key = 0; key < array.length; key++) {
  	    if (predicate(array[key])) {
  	      return key;
  	    }
  	  }
  	  return undefined;
  	}
  	module.exports = exports.default; 
  } (buildMatchFn, buildMatchFn.exports));

  var buildMatchFnExports = buildMatchFn.exports;

  var buildMatchPatternFn = {exports: {}};

  (function (module, exports) {

  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = buildMatchPatternFn;
  	function buildMatchPatternFn(args) {
  	  return function (string) {
  	    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  	    var matchResult = string.match(args.matchPattern);
  	    if (!matchResult) return null;
  	    var matchedString = matchResult[0];
  	    var parseResult = string.match(args.parsePattern);
  	    if (!parseResult) return null;
  	    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
  	    value = options.valueCallback ? options.valueCallback(value) : value;
  	    var rest = string.slice(matchedString.length);
  	    return {
  	      value: value,
  	      rest: rest
  	    };
  	  };
  	}
  	module.exports = exports.default; 
  } (buildMatchPatternFn, buildMatchPatternFn.exports));

  var buildMatchPatternFnExports = buildMatchPatternFn.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(buildMatchFnExports);
  	var _index2 = _interopRequireDefault(buildMatchPatternFnExports);
  	var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  	var parseOrdinalNumberPattern = /\d+/i;
  	var matchEraPatterns = {
  	  narrow: /^(b|a)/i,
  	  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  	  wide: /^(before christ|before common era|anno domini|common era)/i
  	};
  	var parseEraPatterns = {
  	  any: [/^b/i, /^(a|c)/i]
  	};
  	var matchQuarterPatterns = {
  	  narrow: /^[1234]/i,
  	  abbreviated: /^q[1234]/i,
  	  wide: /^[1234](th|st|nd|rd)? quarter/i
  	};
  	var parseQuarterPatterns = {
  	  any: [/1/i, /2/i, /3/i, /4/i]
  	};
  	var matchMonthPatterns = {
  	  narrow: /^[jfmasond]/i,
  	  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  	  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  	};
  	var parseMonthPatterns = {
  	  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  	  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  	};
  	var matchDayPatterns = {
  	  narrow: /^[smtwf]/i,
  	  short: /^(su|mo|tu|we|th|fr|sa)/i,
  	  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  	  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  	};
  	var parseDayPatterns = {
  	  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  	  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  	};
  	var matchDayPeriodPatterns = {
  	  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  	  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  	};
  	var parseDayPeriodPatterns = {
  	  any: {
  	    am: /^a/i,
  	    pm: /^p/i,
  	    midnight: /^mi/i,
  	    noon: /^no/i,
  	    morning: /morning/i,
  	    afternoon: /afternoon/i,
  	    evening: /evening/i,
  	    night: /night/i
  	  }
  	};
  	var match = {
  	  ordinalNumber: (0, _index2.default)({
  	    matchPattern: matchOrdinalNumberPattern,
  	    parsePattern: parseOrdinalNumberPattern,
  	    valueCallback: function valueCallback(value) {
  	      return parseInt(value, 10);
  	    }
  	  }),
  	  era: (0, _index.default)({
  	    matchPatterns: matchEraPatterns,
  	    defaultMatchWidth: 'wide',
  	    parsePatterns: parseEraPatterns,
  	    defaultParseWidth: 'any'
  	  }),
  	  quarter: (0, _index.default)({
  	    matchPatterns: matchQuarterPatterns,
  	    defaultMatchWidth: 'wide',
  	    parsePatterns: parseQuarterPatterns,
  	    defaultParseWidth: 'any',
  	    valueCallback: function valueCallback(index) {
  	      return index + 1;
  	    }
  	  }),
  	  month: (0, _index.default)({
  	    matchPatterns: matchMonthPatterns,
  	    defaultMatchWidth: 'wide',
  	    parsePatterns: parseMonthPatterns,
  	    defaultParseWidth: 'any'
  	  }),
  	  day: (0, _index.default)({
  	    matchPatterns: matchDayPatterns,
  	    defaultMatchWidth: 'wide',
  	    parsePatterns: parseDayPatterns,
  	    defaultParseWidth: 'any'
  	  }),
  	  dayPeriod: (0, _index.default)({
  	    matchPatterns: matchDayPeriodPatterns,
  	    defaultMatchWidth: 'any',
  	    parsePatterns: parseDayPeriodPatterns,
  	    defaultParseWidth: 'any'
  	  })
  	};
  	var _default = match;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (match, match.exports));

  var matchExports = match.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(formatDistanceExports);
  	var _index2 = _interopRequireDefault(formatLongExports);
  	var _index3 = _interopRequireDefault(formatRelativeExports);
  	var _index4 = _interopRequireDefault(localizeExports);
  	var _index5 = _interopRequireDefault(matchExports);
  	/**
  	 * @type {Locale}
  	 * @category Locales
  	 * @summary English locale (United States).
  	 * @language English
  	 * @iso-639-2 eng
  	 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
  	 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
  	 */
  	var locale = {
  	  code: 'en-US',
  	  formatDistance: _index.default,
  	  formatLong: _index2.default,
  	  formatRelative: _index3.default,
  	  localize: _index4.default,
  	  match: _index5.default,
  	  options: {
  	    weekStartsOn: 0 /* Sunday */,
  	    firstWeekContainsDate: 1
  	  }
  	};
  	var _default = locale;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (enUS, enUS.exports));

  var enUSExports = enUS.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = void 0;
  	var _index = _interopRequireDefault(enUSExports);
  	var _default = _index.default;
  	exports.default = _default;
  	module.exports = exports.default; 
  } (defaultLocale, defaultLocale.exports));

  var defaultLocaleExports = defaultLocale.exports;

  (function (module, exports) {

  	var _interopRequireDefault = interopRequireDefaultExports.default;
  	Object.defineProperty(exports, "__esModule", {
  	  value: true
  	});
  	exports.default = format;
  	var _index = _interopRequireDefault(isValidExports);
  	var _index2 = _interopRequireDefault(subMillisecondsExports);
  	var _index3 = _interopRequireDefault(toDateExports);
  	var _index4 = _interopRequireDefault(formattersExports);
  	var _index5 = _interopRequireDefault(longFormattersExports);
  	var _index6 = _interopRequireDefault(getTimezoneOffsetInMillisecondsExports);
  	var _index7 = protectedTokens;
  	var _index8 = _interopRequireDefault(toIntegerExports);
  	var _index9 = _interopRequireDefault(requiredArgsExports);
  	var _index10 = defaultOptions$1;
  	var _index11 = _interopRequireDefault(defaultLocaleExports);
  	// This RegExp consists of three parts separated by `|`:
  	// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
  	//   (one of the certain letters followed by `o`)
  	// - (\w)\1* matches any sequences of the same letter
  	// - '' matches two quote characters in a row
  	// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
  	//   except a single quote symbol, which ends the sequence.
  	//   Two quote characters do not end the sequence.
  	//   If there is no matching single quote
  	//   then the sequence will continue until the end of the string.
  	// - . matches any single character unmatched by previous parts of the RegExps
  	var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;

  	// This RegExp catches symbols escaped by quotes, and also
  	// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`
  	var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  	var escapedStringRegExp = /^'([^]*?)'?$/;
  	var doubleQuoteRegExp = /''/g;
  	var unescapedLatinCharacterRegExp = /[a-zA-Z]/;

  	/**
  	 * @name format
  	 * @category Common Helpers
  	 * @summary Format the date.
  	 *
  	 * @description
  	 * Return the formatted date string in the given format. The result may vary by locale.
  	 *
  	 * >  Please note that the `format` tokens differ from Moment.js and other libraries.
  	 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 *
  	 * The characters wrapped between two single quotes characters (') are escaped.
  	 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
  	 * (see the last example)
  	 *
  	 * Format of the string is based on Unicode Technical Standard #35:
  	 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
  	 * with a few additions (see note 7 below the table).
  	 *
  	 * Accepted patterns:
  	 * | Unit                            | Pattern | Result examples                   | Notes |
  	 * |---------------------------------|---------|-----------------------------------|-------|
  	 * | Era                             | G..GGG  | AD, BC                            |       |
  	 * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
  	 * |                                 | GGGGG   | A, B                              |       |
  	 * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
  	 * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
  	 * |                                 | yy      | 44, 01, 00, 17                    | 5     |
  	 * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
  	 * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
  	 * |                                 | yyyyy   | ...                               | 3,5   |
  	 * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
  	 * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
  	 * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
  	 * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
  	 * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
  	 * |                                 | YYYYY   | ...                               | 3,5   |
  	 * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
  	 * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
  	 * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
  	 * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
  	 * |                                 | RRRRR   | ...                               | 3,5,7 |
  	 * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
  	 * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
  	 * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
  	 * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
  	 * |                                 | uuuuu   | ...                               | 3,5   |
  	 * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
  	 * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
  	 * |                                 | QQ      | 01, 02, 03, 04                    |       |
  	 * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
  	 * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
  	 * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
  	 * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
  	 * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
  	 * |                                 | qq      | 01, 02, 03, 04                    |       |
  	 * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
  	 * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
  	 * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
  	 * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
  	 * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
  	 * |                                 | MM      | 01, 02, ..., 12                   |       |
  	 * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
  	 * |                                 | MMMM    | January, February, ..., December  | 2     |
  	 * |                                 | MMMMM   | J, F, ..., D                      |       |
  	 * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
  	 * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
  	 * |                                 | LL      | 01, 02, ..., 12                   |       |
  	 * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
  	 * |                                 | LLLL    | January, February, ..., December  | 2     |
  	 * |                                 | LLLLL   | J, F, ..., D                      |       |
  	 * | Local week of year              | w       | 1, 2, ..., 53                     |       |
  	 * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
  	 * |                                 | ww      | 01, 02, ..., 53                   |       |
  	 * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
  	 * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
  	 * |                                 | II      | 01, 02, ..., 53                   | 7     |
  	 * | Day of month                    | d       | 1, 2, ..., 31                     |       |
  	 * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
  	 * |                                 | dd      | 01, 02, ..., 31                   |       |
  	 * | Day of year                     | D       | 1, 2, ..., 365, 366               | 9     |
  	 * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
  	 * |                                 | DD      | 01, 02, ..., 365, 366             | 9     |
  	 * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
  	 * |                                 | DDDD    | ...                               | 3     |
  	 * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
  	 * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
  	 * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
  	 * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
  	 * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
  	 * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
  	 * |                                 | ii      | 01, 02, ..., 07                   | 7     |
  	 * |                                 | iii     | Mon, Tue, Wed, ..., Sun           | 7     |
  	 * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
  	 * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
  	 * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 7     |
  	 * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
  	 * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
  	 * |                                 | ee      | 02, 03, ..., 01                   |       |
  	 * |                                 | eee     | Mon, Tue, Wed, ..., Sun           |       |
  	 * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
  	 * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
  	 * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
  	 * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
  	 * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
  	 * |                                 | cc      | 02, 03, ..., 01                   |       |
  	 * |                                 | ccc     | Mon, Tue, Wed, ..., Sun           |       |
  	 * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
  	 * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
  	 * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
  	 * | AM, PM                          | a..aa   | AM, PM                            |       |
  	 * |                                 | aaa     | am, pm                            |       |
  	 * |                                 | aaaa    | a.m., p.m.                        | 2     |
  	 * |                                 | aaaaa   | a, p                              |       |
  	 * | AM, PM, noon, midnight          | b..bb   | AM, PM, noon, midnight            |       |
  	 * |                                 | bbb     | am, pm, noon, midnight            |       |
  	 * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
  	 * |                                 | bbbbb   | a, p, n, mi                       |       |
  	 * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
  	 * |                                 | BBBB    | at night, in the morning, ...     | 2     |
  	 * |                                 | BBBBB   | at night, in the morning, ...     |       |
  	 * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
  	 * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
  	 * |                                 | hh      | 01, 02, ..., 11, 12               |       |
  	 * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
  	 * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
  	 * |                                 | HH      | 00, 01, 02, ..., 23               |       |
  	 * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
  	 * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
  	 * |                                 | KK      | 01, 02, ..., 11, 00               |       |
  	 * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
  	 * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
  	 * |                                 | kk      | 24, 01, 02, ..., 23               |       |
  	 * | Minute                          | m       | 0, 1, ..., 59                     |       |
  	 * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
  	 * |                                 | mm      | 00, 01, ..., 59                   |       |
  	 * | Second                          | s       | 0, 1, ..., 59                     |       |
  	 * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
  	 * |                                 | ss      | 00, 01, ..., 59                   |       |
  	 * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
  	 * |                                 | SS      | 00, 01, ..., 99                   |       |
  	 * |                                 | SSS     | 000, 001, ..., 999                |       |
  	 * |                                 | SSSS    | ...                               | 3     |
  	 * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
  	 * |                                 | XX      | -0800, +0530, Z                   |       |
  	 * |                                 | XXX     | -08:00, +05:30, Z                 |       |
  	 * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
  	 * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
  	 * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
  	 * |                                 | xx      | -0800, +0530, +0000               |       |
  	 * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
  	 * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
  	 * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
  	 * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
  	 * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
  	 * | Timezone (specific non-locat.)  | z...zzz | GMT-8, GMT+5:30, GMT+0            | 6     |
  	 * |                                 | zzzz    | GMT-08:00, GMT+05:30, GMT+00:00   | 2,6   |
  	 * | Seconds timestamp               | t       | 512969520                         | 7     |
  	 * |                                 | tt      | ...                               | 3,7   |
  	 * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
  	 * |                                 | TT      | ...                               | 3,7   |
  	 * | Long localized date             | P       | 04/29/1453                        | 7     |
  	 * |                                 | PP      | Apr 29, 1453                      | 7     |
  	 * |                                 | PPP     | April 29th, 1453                  | 7     |
  	 * |                                 | PPPP    | Friday, April 29th, 1453          | 2,7   |
  	 * | Long localized time             | p       | 12:00 AM                          | 7     |
  	 * |                                 | pp      | 12:00:00 AM                       | 7     |
  	 * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
  	 * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
  	 * | Combination of date and time    | Pp      | 04/29/1453, 12:00 AM              | 7     |
  	 * |                                 | PPpp    | Apr 29, 1453, 12:00:00 AM         | 7     |
  	 * |                                 | PPPppp  | April 29th, 1453 at ...           | 7     |
  	 * |                                 | PPPPpppp| Friday, April 29th, 1453 at ...   | 2,7   |
  	 * Notes:
  	 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
  	 *    are the same as "stand-alone" units, but are different in some languages.
  	 *    "Formatting" units are declined according to the rules of the language
  	 *    in the context of a date. "Stand-alone" units are always nominative singular:
  	 *
  	 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
  	 *
  	 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
  	 *
  	 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
  	 *    the single quote characters (see below).
  	 *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
  	 *    the output will be the same as default pattern for this unit, usually
  	 *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
  	 *    are marked with "2" in the last column of the table.
  	 *
  	 *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
  	 *
  	 *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
  	 *
  	 *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
  	 *
  	 *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
  	 *
  	 *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
  	 *
  	 * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
  	 *    The output will be padded with zeros to match the length of the pattern.
  	 *
  	 *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
  	 *
  	 * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
  	 *    These tokens represent the shortest form of the quarter.
  	 *
  	 * 5. The main difference between `y` and `u` patterns are B.C. years:
  	 *
  	 *    | Year | `y` | `u` |
  	 *    |------|-----|-----|
  	 *    | AC 1 |   1 |   1 |
  	 *    | BC 1 |   1 |   0 |
  	 *    | BC 2 |   2 |  -1 |
  	 *
  	 *    Also `yy` always returns the last two digits of a year,
  	 *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
  	 *
  	 *    | Year | `yy` | `uu` |
  	 *    |------|------|------|
  	 *    | 1    |   01 |   01 |
  	 *    | 14   |   14 |   14 |
  	 *    | 376  |   76 |  376 |
  	 *    | 1453 |   53 | 1453 |
  	 *
  	 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
  	 *    except local week-numbering years are dependent on `options.weekStartsOn`
  	 *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
  	 *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
  	 *
  	 * 6. Specific non-location timezones are currently unavailable in `date-fns`,
  	 *    so right now these tokens fall back to GMT timezones.
  	 *
  	 * 7. These patterns are not in the Unicode Technical Standard #35:
  	 *    - `i`: ISO day of week
  	 *    - `I`: ISO week of year
  	 *    - `R`: ISO week-numbering year
  	 *    - `t`: seconds timestamp
  	 *    - `T`: milliseconds timestamp
  	 *    - `o`: ordinal number modifier
  	 *    - `P`: long localized date
  	 *    - `p`: long localized time
  	 *
  	 * 8. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
  	 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 *
  	 * 9. `D` and `DD` tokens represent days of the year but they are often confused with days of the month.
  	 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 *
  	 * @param {Date|Number} date - the original date
  	 * @param {String} format - the string of tokens
  	 * @param {Object} [options] - an object with options.
  	 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
  	 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
  	 * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
  	 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
  	 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
  	 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @returns {String} the formatted date string
  	 * @throws {TypeError} 2 arguments required
  	 * @throws {RangeError} `date` must not be Invalid Date
  	 * @throws {RangeError} `options.locale` must contain `localize` property
  	 * @throws {RangeError} `options.locale` must contain `formatLong` property
  	 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
  	 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
  	 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
  	 * @throws {RangeError} format string contains an unescaped latin alphabet character
  	 *
  	 * @example
  	 * // Represent 11 February 2014 in middle-endian format:
  	 * const result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
  	 * //=> '02/11/2014'
  	 *
  	 * @example
  	 * // Represent 2 July 2014 in Esperanto:
  	 * import { eoLocale } from 'date-fns/locale/eo'
  	 * const result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
  	 *   locale: eoLocale
  	 * })
  	 * //=> '2-a de julio 2014'
  	 *
  	 * @example
  	 * // Escape string by single quote characters:
  	 * const result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
  	 * //=> "3 o'clock"
  	 */

  	function format(dirtyDate, dirtyFormatStr, options) {
  	  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  	  (0, _index9.default)(2, arguments);
  	  var formatStr = String(dirtyFormatStr);
  	  var defaultOptions = (0, _index10.getDefaultOptions)();
  	  var locale = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : _index11.default;
  	  var firstWeekContainsDate = (0, _index8.default)((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);

  	  // Test if weekStartsOn is between 1 and 7 _and_ is not NaN
  	  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
  	    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  	  }
  	  var weekStartsOn = (0, _index8.default)((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);

  	  // Test if weekStartsOn is between 0 and 6 _and_ is not NaN
  	  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
  	    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  	  }
  	  if (!locale.localize) {
  	    throw new RangeError('locale must contain localize property');
  	  }
  	  if (!locale.formatLong) {
  	    throw new RangeError('locale must contain formatLong property');
  	  }
  	  var originalDate = (0, _index3.default)(dirtyDate);
  	  if (!(0, _index.default)(originalDate)) {
  	    throw new RangeError('Invalid time value');
  	  }

  	  // Convert the date in system timezone to the same date in UTC+00:00 timezone.
  	  // This ensures that when UTC functions will be implemented, locales will be compatible with them.
  	  // See an issue about UTC functions: https://github.com/date-fns/date-fns/issues/376
  	  var timezoneOffset = (0, _index6.default)(originalDate);
  	  var utcDate = (0, _index2.default)(originalDate, timezoneOffset);
  	  var formatterOptions = {
  	    firstWeekContainsDate: firstWeekContainsDate,
  	    weekStartsOn: weekStartsOn,
  	    locale: locale,
  	    _originalDate: originalDate
  	  };
  	  var result = formatStr.match(longFormattingTokensRegExp).map(function (substring) {
  	    var firstCharacter = substring[0];
  	    if (firstCharacter === 'p' || firstCharacter === 'P') {
  	      var longFormatter = _index5.default[firstCharacter];
  	      return longFormatter(substring, locale.formatLong);
  	    }
  	    return substring;
  	  }).join('').match(formattingTokensRegExp).map(function (substring) {
  	    // Replace two single quote characters with one single quote character
  	    if (substring === "''") {
  	      return "'";
  	    }
  	    var firstCharacter = substring[0];
  	    if (firstCharacter === "'") {
  	      return cleanEscapedString(substring);
  	    }
  	    var formatter = _index4.default[firstCharacter];
  	    if (formatter) {
  	      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && (0, _index7.isProtectedWeekYearToken)(substring)) {
  	        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
  	      }
  	      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && (0, _index7.isProtectedDayOfYearToken)(substring)) {
  	        (0, _index7.throwProtectedError)(substring, dirtyFormatStr, String(dirtyDate));
  	      }
  	      return formatter(utcDate, substring, locale.localize, formatterOptions);
  	    }
  	    if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
  	      throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
  	    }
  	    return substring;
  	  }).join('');
  	  return result;
  	}
  	function cleanEscapedString(input) {
  	  var matched = input.match(escapedStringRegExp);
  	  if (!matched) {
  	    return input;
  	  }
  	  return matched[1].replace(doubleQuoteRegExp, "'");
  	}
  	module.exports = exports.default; 
  } (format$3, format$3.exports));

  var formatExports = format$3.exports;
  var dateFnsFormat = /*@__PURE__*/getDefaultExportFromCjs(formatExports);

  /**
   * Returns the formatted time zone name of the provided `timeZone` or the current
   * system time zone if omitted, accounting for DST according to the UTC value of
   * the date.
   */
  function tzIntlTimeZoneName(length, date, options) {
    var dtf = getDTF(length, options.timeZone, options.locale);
    return dtf.formatToParts ? partsTimeZone(dtf, date) : hackyTimeZone(dtf, date)
  }

  function partsTimeZone(dtf, date) {
    var formatted = dtf.formatToParts(date);

    for (var i = formatted.length - 1; i >= 0; --i) {
      if (formatted[i].type === 'timeZoneName') {
        return formatted[i].value
      }
    }
  }

  function hackyTimeZone(dtf, date) {
    var formatted = dtf.format(date).replace(/\u200E/g, '');
    var tzNameMatch = / [\w-+ ]+$/.exec(formatted);
    return tzNameMatch ? tzNameMatch[0].substr(1) : ''
  }

  // If a locale has been provided `en-US` is used as a fallback in case it is an
  // invalid locale, otherwise the locale is left undefined to use the system locale.
  function getDTF(length, timeZone, locale) {
    if (locale && !locale.code) {
      throw new Error(
        "date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`"
      )
    }
    return new Intl.DateTimeFormat(locale ? [locale.code, 'en-US'] : undefined, {
      timeZone: timeZone,
      timeZoneName: length,
    })
  }

  /**
   * Returns the [year, month, day, hour, minute, seconds] tokens of the provided
   * `date` as it will be rendered in the `timeZone`.
   */
  function tzTokenizeDate(date, timeZone) {
    var dtf = getDateTimeFormat(timeZone);
    return dtf.formatToParts ? partsOffset(dtf, date) : hackyOffset(dtf, date)
  }

  var typeToPos = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5,
  };

  function partsOffset(dtf, date) {
    try {
      var formatted = dtf.formatToParts(date);
      var filled = [];
      for (var i = 0; i < formatted.length; i++) {
        var pos = typeToPos[formatted[i].type];

        if (pos >= 0) {
          filled[pos] = parseInt(formatted[i].value, 10);
        }
      }
      return filled
    } catch (error) {
      if (error instanceof RangeError) {
        return [NaN]
      }
      throw error
    }
  }

  function hackyOffset(dtf, date) {
    var formatted = dtf.format(date).replace(/\u200E/g, '');
    var parsed = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(formatted);
    // var [, fMonth, fDay, fYear, fHour, fMinute, fSecond] = parsed
    // return [fYear, fMonth, fDay, fHour, fMinute, fSecond]
    return [parsed[3], parsed[1], parsed[2], parsed[4], parsed[5], parsed[6]]
  }

  // Get a cached Intl.DateTimeFormat instance for the IANA `timeZone`. This can be used
  // to get deterministic local date/time output according to the `en-US` locale which
  // can be used to extract local time parts as necessary.
  var dtfCache = {};
  function getDateTimeFormat(timeZone) {
    if (!dtfCache[timeZone]) {
      // New browsers use `hourCycle`, IE and Chrome <73 does not support it and uses `hour12`
      var testDateFormatted = new Intl.DateTimeFormat('en-US', {
        hour12: false,
        timeZone: 'America/New_York',
        year: 'numeric',
        month: 'numeric',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
      }).format(new Date('2014-06-25T04:00:00.123Z'));
      var hourCycleSupported =
        testDateFormatted === '06/25/2014, 00:00:00' ||
        testDateFormatted === '06/25/2014 00:00:00';

      dtfCache[timeZone] = hourCycleSupported
        ? new Intl.DateTimeFormat('en-US', {
            hour12: false,
            timeZone: timeZone,
            year: 'numeric',
            month: 'numeric',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          })
        : new Intl.DateTimeFormat('en-US', {
            hourCycle: 'h23',
            timeZone: timeZone,
            year: 'numeric',
            month: 'numeric',
            day: '2-digit',
            hour: '2-digit',
            minute: '2-digit',
            second: '2-digit',
          });
    }
    return dtfCache[timeZone]
  }

  /**
   * Use instead of `new Date(Date.UTC(...))` to support years below 100 which doesn't work
   * otherwise due to the nature of the
   * [`Date` constructor](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date#interpretation_of_two-digit_years.
   *
   * For `Date.UTC(...)`, use `newDateUTC(...).getTime()`.
   */
  function newDateUTC(fullYear, month, day, hour, minute, second, millisecond) {
    var utcDate = new Date(0);
    utcDate.setUTCFullYear(fullYear, month, day);
    utcDate.setUTCHours(hour, minute, second, millisecond);
    return utcDate
  }

  var MILLISECONDS_IN_HOUR$1 = 3600000;
  var MILLISECONDS_IN_MINUTE$2 = 60000;

  var patterns$1 = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/,
  };

  // Parse various time zone offset formats to an offset in milliseconds
  function tzParseTimezone(timezoneString, date, isUtcDate) {
    var token;
    var absoluteOffset;

    // Empty string
    if (!timezoneString) {
      return 0
    }

    // Z
    token = patterns$1.timezoneZ.exec(timezoneString);
    if (token) {
      return 0
    }

    var hours;

    // hh
    token = patterns$1.timezoneHH.exec(timezoneString);
    if (token) {
      hours = parseInt(token[1], 10);

      if (!validateTimezone(hours)) {
        return NaN
      }

      return -(hours * MILLISECONDS_IN_HOUR$1)
    }

    // hh:mm or hhmm
    token = patterns$1.timezoneHHMM.exec(timezoneString);
    if (token) {
      hours = parseInt(token[1], 10);
      var minutes = parseInt(token[2], 10);

      if (!validateTimezone(hours, minutes)) {
        return NaN
      }

      absoluteOffset = Math.abs(hours) * MILLISECONDS_IN_HOUR$1 + minutes * MILLISECONDS_IN_MINUTE$2;
      return hours > 0 ? -absoluteOffset : absoluteOffset
    }

    // IANA time zone
    if (isValidTimezoneIANAString(timezoneString)) {
      date = new Date(date || Date.now());
      var utcDate = isUtcDate ? date : toUtcDate(date);

      var offset = calcOffset(utcDate, timezoneString);

      var fixedOffset = isUtcDate ? offset : fixOffset(date, offset, timezoneString);

      return -fixedOffset
    }

    return NaN
  }

  function toUtcDate(date) {
    return newDateUTC(
      date.getFullYear(),
      date.getMonth(),
      date.getDate(),
      date.getHours(),
      date.getMinutes(),
      date.getSeconds(),
      date.getMilliseconds()
    )
  }

  function calcOffset(date, timezoneString) {
    var tokens = tzTokenizeDate(date, timezoneString);

    // ms dropped because it's not provided by tzTokenizeDate
    var asUTC = newDateUTC(
      tokens[0],
      tokens[1] - 1,
      tokens[2],
      tokens[3] % 24,
      tokens[4],
      tokens[5],
      0
    ).getTime();

    var asTS = date.getTime();
    var over = asTS % 1000;
    asTS -= over >= 0 ? over : 1000 + over;
    return asUTC - asTS
  }

  function fixOffset(date, offset, timezoneString) {
    var localTS = date.getTime();

    // Our UTC time is just a guess because our offset is just a guess
    var utcGuess = localTS - offset;

    // Test whether the zone matches the offset for this ts
    var o2 = calcOffset(new Date(utcGuess), timezoneString);

    // If so, offset didn't change, and we're done
    if (offset === o2) {
      return offset
    }

    // If not, change the ts by the difference in the offset
    utcGuess -= o2 - offset;

    // If that gives us the local time we want, we're done
    var o3 = calcOffset(new Date(utcGuess), timezoneString);
    if (o2 === o3) {
      return o2
    }

    // If it's different, we're in a hole time. The offset has changed, but we don't adjust the time
    return Math.max(o2, o3)
  }

  function validateTimezone(hours, minutes) {
    return -23 <= hours && hours <= 23 && (minutes == null || (0 <= minutes && minutes <= 59))
  }

  var validIANATimezoneCache = {};
  function isValidTimezoneIANAString(timeZoneString) {
    if (validIANATimezoneCache[timeZoneString]) return true
    try {
      new Intl.DateTimeFormat(undefined, { timeZone: timeZoneString });
      validIANATimezoneCache[timeZoneString] = true;
      return true
    } catch (error) {
      return false
    }
  }

  var MILLISECONDS_IN_MINUTE$1 = 60 * 1000;

  var formatters = {
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function (date, token, localize, options) {
      var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

      if (timezoneOffset === 0) {
        return 'Z'
      }

      switch (token) {
        // Hours and optional minutes
        case 'X':
          return formatTimezoneWithOptionalMinutes(timezoneOffset)

        // Hours, minutes and optional seconds without `:` delimeter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case 'XXXX':
        case 'XX': // Hours and minutes without `:` delimeter
          return formatTimezone(timezoneOffset)

        // Hours, minutes and optional seconds with `:` delimeter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case 'XXXXX':
        case 'XXX': // Hours and minutes with `:` delimeter
        default:
          return formatTimezone(timezoneOffset, ':')
      }
    },

    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function (date, token, localize, options) {
      var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

      switch (token) {
        // Hours and optional minutes
        case 'x':
          return formatTimezoneWithOptionalMinutes(timezoneOffset)

        // Hours, minutes and optional seconds without `:` delimeter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case 'xxxx':
        case 'xx': // Hours and minutes without `:` delimeter
          return formatTimezone(timezoneOffset)

        // Hours, minutes and optional seconds with `:` delimeter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case 'xxxxx':
        case 'xxx': // Hours and minutes with `:` delimeter
        default:
          return formatTimezone(timezoneOffset, ':')
      }
    },

    // Timezone (GMT)
    O: function (date, token, localize, options) {
      var timezoneOffset = getTimeZoneOffset(options.timeZone, options._originalDate || date);

      switch (token) {
        // Short
        case 'O':
        case 'OO':
        case 'OOO':
          return 'GMT' + formatTimezoneShort(timezoneOffset, ':')
        // Long
        case 'OOOO':
        default:
          return 'GMT' + formatTimezone(timezoneOffset, ':')
      }
    },

    // Timezone (specific non-location)
    z: function (date, token, localize, options) {
      var originalDate = options._originalDate || date;

      switch (token) {
        // Short
        case 'z':
        case 'zz':
        case 'zzz':
          return tzIntlTimeZoneName('short', originalDate, options)
        // Long
        case 'zzzz':
        default:
          return tzIntlTimeZoneName('long', originalDate, options)
      }
    },
  };

  function getTimeZoneOffset(timeZone, originalDate) {
    var timeZoneOffset = timeZone
      ? tzParseTimezone(timeZone, originalDate, true) / MILLISECONDS_IN_MINUTE$1
      : originalDate.getTimezoneOffset();
    if (Number.isNaN(timeZoneOffset)) {
      throw new RangeError('Invalid time zone specified: ' + timeZone)
    }
    return timeZoneOffset
  }

  function addLeadingZeros(number, targetLength) {
    var sign = number < 0 ? '-' : '';
    var output = Math.abs(number).toString();
    while (output.length < targetLength) {
      output = '0' + output;
    }
    return sign + output
  }

  function formatTimezone(offset, dirtyDelimeter) {
    var delimeter = dirtyDelimeter || '';
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
    var minutes = addLeadingZeros(Math.floor(absOffset % 60), 2);
    return sign + hours + delimeter + minutes
  }

  function formatTimezoneWithOptionalMinutes(offset, dirtyDelimeter) {
    if (offset % 60 === 0) {
      var sign = offset > 0 ? '-' : '+';
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2)
    }
    return formatTimezone(offset, dirtyDelimeter)
  }

  function formatTimezoneShort(offset, dirtyDelimeter) {
    var sign = offset > 0 ? '-' : '+';
    var absOffset = Math.abs(offset);
    var hours = Math.floor(absOffset / 60);
    var minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours)
    }
    var delimeter = dirtyDelimeter || '';
    return sign + String(hours) + delimeter + addLeadingZeros(minutes, 2)
  }

  var formatters$1 = formatters;

  /** Regex to identify the presence of a time zone specifier in a date string */
  var tzPattern = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;

  var MILLISECONDS_IN_HOUR = 3600000;
  var MILLISECONDS_IN_MINUTE = 60000;
  var DEFAULT_ADDITIONAL_DIGITS = 2;

  var patterns = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,

    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/, // 0 additional digits
      /^([+-]\d{3})$/, // 1 additional digit
      /^([+-]\d{4})$/, // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/, // 0 additional digits
      /^([+-]\d{5})/, // 1 additional digit
      /^([+-]\d{6})/, // 2 additional digits
    ],

    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,

    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,

    // time zone tokens (to identify the presence of a tz)
    timeZone: tzPattern,
  };

  /**
   * @name toDate
   * @category Common Helpers
   * @summary Convert the given argument to an instance of Date.
   *
   * @description
   * Convert the given argument to an instance of Date.
   *
   * If the argument is an instance of Date, the function returns its clone.
   *
   * If the argument is a number, it is treated as a timestamp.
   *
   * If an argument is a string, the function tries to parse it.
   * Function accepts complete ISO 8601 formats as well as partial implementations.
   * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
   * If the function cannot parse the string or the values are invalid, it returns Invalid Date.
   *
   * If the argument is none of the above, the function returns Invalid Date.
   *
   * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
   * All *date-fns* functions will throw `RangeError` if `options.additionalDigits` is not 0, 1, 2 or undefined.
   *
   * @param {Date|String|Number} argument - the value to convert
   * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
   * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
   * @returns {Date} the parsed date in the local time zone
   * @throws {TypeError} 1 argument required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // Convert string '2014-02-11T11:30:30' to date:
   * var result = toDate('2014-02-11T11:30:30')
   * //=> Tue Feb 11 2014 11:30:30
   *
   * @example
   * // Convert string '+02014101' to date,
   * // if the additional number of digits in the extended year format is 1:
   * var result = toDate('+02014101', {additionalDigits: 1})
   * //=> Fri Apr 11 2014 00:00:00
   */
  function toDate(argument, dirtyOptions) {
    if (arguments.length < 1) {
      throw new TypeError('1 argument required, but only ' + arguments.length + ' present')
    }

    if (argument === null) {
      return new Date(NaN)
    }

    var options = dirtyOptions || {};

    var additionalDigits =
      options.additionalDigits == null
        ? DEFAULT_ADDITIONAL_DIGITS
        : toInteger(options.additionalDigits);
    if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
      throw new RangeError('additionalDigits must be 0, 1 or 2')
    }

    // Clone the date
    if (
      argument instanceof Date ||
      (typeof argument === 'object' && Object.prototype.toString.call(argument) === '[object Date]')
    ) {
      // Prevent the date to lose the milliseconds when passed to new Date() in IE10
      return new Date(argument.getTime())
    } else if (
      typeof argument === 'number' ||
      Object.prototype.toString.call(argument) === '[object Number]'
    ) {
      return new Date(argument)
    } else if (
      !(
        typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]'
      )
    ) {
      return new Date(NaN)
    }

    var dateStrings = splitDateString(argument);

    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    var year = parseYearResult.year;
    var restDateString = parseYearResult.restDateString;

    var date = parseDate(restDateString, year);

    if (isNaN(date)) {
      return new Date(NaN)
    }

    if (date) {
      var timestamp = date.getTime();
      var time = 0;
      var offset;

      if (dateStrings.time) {
        time = parseTime(dateStrings.time);

        if (isNaN(time)) {
          return new Date(NaN)
        }
      }

      if (dateStrings.timeZone || options.timeZone) {
        offset = tzParseTimezone(dateStrings.timeZone || options.timeZone, new Date(timestamp + time));
        if (isNaN(offset)) {
          return new Date(NaN)
        }
      } else {
        // get offset accurate to hour in time zones that change offset
        offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time));
        offset = getTimezoneOffsetInMilliseconds(new Date(timestamp + time + offset));
      }

      return new Date(timestamp + time + offset)
    } else {
      return new Date(NaN)
    }
  }

  function splitDateString(dateString) {
    var dateStrings = {};
    var parts = patterns.dateTimePattern.exec(dateString);
    var timeString;

    if (!parts) {
      parts = patterns.datePattern.exec(dateString);
      if (parts) {
        dateStrings.date = parts[1];
        timeString = parts[2];
      } else {
        dateStrings.date = null;
        timeString = dateString;
      }
    } else {
      dateStrings.date = parts[1];
      timeString = parts[3];
    }

    if (timeString) {
      var token = patterns.timeZone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], '');
        dateStrings.timeZone = token[1].trim();
      } else {
        dateStrings.time = timeString;
      }
    }

    return dateStrings
  }

  function parseYear(dateString, additionalDigits) {
    var patternYYY = patterns.YYY[additionalDigits];
    var patternYYYYY = patterns.YYYYY[additionalDigits];

    var token;

    // YYYY or YYYYY
    token = patterns.YYYY.exec(dateString) || patternYYYYY.exec(dateString);
    if (token) {
      var yearString = token[1];
      return {
        year: parseInt(yearString, 10),
        restDateString: dateString.slice(yearString.length),
      }
    }

    // YY or YYY
    token = patterns.YY.exec(dateString) || patternYYY.exec(dateString);
    if (token) {
      var centuryString = token[1];
      return {
        year: parseInt(centuryString, 10) * 100,
        restDateString: dateString.slice(centuryString.length),
      }
    }

    // Invalid ISO-formatted year
    return {
      year: null,
    }
  }

  function parseDate(dateString, year) {
    // Invalid ISO-formatted year
    if (year === null) {
      return null
    }

    var token;
    var date;
    var month;
    var week;

    // YYYY
    if (dateString.length === 0) {
      date = new Date(0);
      date.setUTCFullYear(year);
      return date
    }

    // YYYY-MM
    token = patterns.MM.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;

      if (!validateDate(year, month)) {
        return new Date(NaN)
      }

      date.setUTCFullYear(year, month);
      return date
    }

    // YYYY-DDD or YYYYDDD
    token = patterns.DDD.exec(dateString);
    if (token) {
      date = new Date(0);
      var dayOfYear = parseInt(token[1], 10);

      if (!validateDayOfYearDate(year, dayOfYear)) {
        return new Date(NaN)
      }

      date.setUTCFullYear(year, 0, dayOfYear);
      return date
    }

    // yyyy-MM-dd or YYYYMMDD
    token = patterns.MMDD.exec(dateString);
    if (token) {
      date = new Date(0);
      month = parseInt(token[1], 10) - 1;
      var day = parseInt(token[2], 10);

      if (!validateDate(year, month, day)) {
        return new Date(NaN)
      }

      date.setUTCFullYear(year, month, day);
      return date
    }

    // YYYY-Www or YYYYWww
    token = patterns.Www.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;

      if (!validateWeekDate(year, week)) {
        return new Date(NaN)
      }

      return dayOfISOWeekYear(year, week)
    }

    // YYYY-Www-D or YYYYWwwD
    token = patterns.WwwD.exec(dateString);
    if (token) {
      week = parseInt(token[1], 10) - 1;
      var dayOfWeek = parseInt(token[2], 10) - 1;

      if (!validateWeekDate(year, week, dayOfWeek)) {
        return new Date(NaN)
      }

      return dayOfISOWeekYear(year, week, dayOfWeek)
    }

    // Invalid ISO-formatted date
    return null
  }

  function parseTime(timeString) {
    var token;
    var hours;
    var minutes;

    // hh
    token = patterns.HH.exec(timeString);
    if (token) {
      hours = parseFloat(token[1].replace(',', '.'));

      if (!validateTime(hours)) {
        return NaN
      }

      return (hours % 24) * MILLISECONDS_IN_HOUR
    }

    // hh:mm or hhmm
    token = patterns.HHMM.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseFloat(token[2].replace(',', '.'));

      if (!validateTime(hours, minutes)) {
        return NaN
      }

      return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE
    }

    // hh:mm:ss or hhmmss
    token = patterns.HHMMSS.exec(timeString);
    if (token) {
      hours = parseInt(token[1], 10);
      minutes = parseInt(token[2], 10);
      var seconds = parseFloat(token[3].replace(',', '.'));

      if (!validateTime(hours, minutes, seconds)) {
        return NaN
      }

      return (hours % 24) * MILLISECONDS_IN_HOUR + minutes * MILLISECONDS_IN_MINUTE + seconds * 1000
    }

    // Invalid ISO-formatted time
    return null
  }

  function dayOfISOWeekYear(isoWeekYear, week, day) {
    week = week || 0;
    day = day || 0;
    var date = new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    var fourthOfJanuaryDay = date.getUTCDay() || 7;
    var diff = week * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date
  }

  // Validation functions

  var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

  function isLeapYearIndex(year) {
    return year % 400 === 0 || (year % 4 === 0 && year % 100 !== 0)
  }

  function validateDate(year, month, date) {
    if (month < 0 || month > 11) {
      return false
    }

    if (date != null) {
      if (date < 1) {
        return false
      }

      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear && date > DAYS_IN_MONTH_LEAP_YEAR[month]) {
        return false
      }
      if (!isLeapYear && date > DAYS_IN_MONTH[month]) {
        return false
      }
    }

    return true
  }

  function validateDayOfYearDate(year, dayOfYear) {
    if (dayOfYear < 1) {
      return false
    }

    var isLeapYear = isLeapYearIndex(year);
    if (isLeapYear && dayOfYear > 366) {
      return false
    }
    if (!isLeapYear && dayOfYear > 365) {
      return false
    }

    return true
  }

  function validateWeekDate(year, week, day) {
    if (week < 0 || week > 52) {
      return false
    }

    if (day != null && (day < 0 || day > 6)) {
      return false
    }

    return true
  }

  function validateTime(hours, minutes, seconds) {
    if (hours != null && (hours < 0 || hours >= 25)) {
      return false
    }

    if (minutes != null && (minutes < 0 || minutes >= 60)) {
      return false
    }

    if (seconds != null && (seconds < 0 || seconds >= 60)) {
      return false
    }

    return true
  }

  var tzFormattingTokensRegExp = /([xXOz]+)|''|'(''|[^'])+('|$)/g;

  /**
   * @name format
   * @category Common Helpers
   * @summary Format the date.
   *
   * @description
   * Return the formatted date string in the given format. The result may vary by locale.
   *
   * >  Please note that the `format` tokens differ from Moment.js and other libraries.
   * > See: https://git.io/fxCyr
   *
   * The characters wrapped between two single quotes characters (') are escaped.
   * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
   * (see the last example)
   *
   * Format of the string is based on Unicode Technical Standard #35:
   * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
   * with a few additions (see note 7 below the table).
   *
   * Accepted patterns:
   * | Unit                            | Pattern | Result examples                   | Notes |
   * |---------------------------------|---------|-----------------------------------|-------|
   * | Era                             | G..GGG  | AD, BC                            |       |
   * |                                 | GGGG    | Anno Domini, Before Christ        | 2     |
   * |                                 | GGGGG   | A, B                              |       |
   * | Calendar year                   | y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | yo      | 44th, 1st, 0th, 17th              | 5,7   |
   * |                                 | yy      | 44, 01, 00, 17                    | 5     |
   * |                                 | yyy     | 044, 001, 1900, 2017              | 5     |
   * |                                 | yyyy    | 0044, 0001, 1900, 2017            | 5     |
   * |                                 | yyyyy   | ...                               | 3,5   |
   * | Local week-numbering year       | Y       | 44, 1, 1900, 2017                 | 5     |
   * |                                 | Yo      | 44th, 1st, 1900th, 2017th         | 5,7   |
   * |                                 | YY      | 44, 01, 00, 17                    | 5,8   |
   * |                                 | YYY     | 044, 001, 1900, 2017              | 5     |
   * |                                 | YYYY    | 0044, 0001, 1900, 2017            | 5,8   |
   * |                                 | YYYYY   | ...                               | 3,5   |
   * | ISO week-numbering year         | R       | -43, 0, 1, 1900, 2017             | 5,7   |
   * |                                 | RR      | -43, 00, 01, 1900, 2017           | 5,7   |
   * |                                 | RRR     | -043, 000, 001, 1900, 2017        | 5,7   |
   * |                                 | RRRR    | -0043, 0000, 0001, 1900, 2017     | 5,7   |
   * |                                 | RRRRR   | ...                               | 3,5,7 |
   * | Extended year                   | u       | -43, 0, 1, 1900, 2017             | 5     |
   * |                                 | uu      | -43, 01, 1900, 2017               | 5     |
   * |                                 | uuu     | -043, 001, 1900, 2017             | 5     |
   * |                                 | uuuu    | -0043, 0001, 1900, 2017           | 5     |
   * |                                 | uuuuu   | ...                               | 3,5   |
   * | Quarter (formatting)            | Q       | 1, 2, 3, 4                        |       |
   * |                                 | Qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | QQ      | 01, 02, 03, 04                    |       |
   * |                                 | QQQ     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | QQQQQ   | 1, 2, 3, 4                        | 4     |
   * | Quarter (stand-alone)           | q       | 1, 2, 3, 4                        |       |
   * |                                 | qo      | 1st, 2nd, 3rd, 4th                | 7     |
   * |                                 | qq      | 01, 02, 03, 04                    |       |
   * |                                 | qqq     | Q1, Q2, Q3, Q4                    |       |
   * |                                 | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
   * |                                 | qqqqq   | 1, 2, 3, 4                        | 4     |
   * | Month (formatting)              | M       | 1, 2, ..., 12                     |       |
   * |                                 | Mo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | MM      | 01, 02, ..., 12                   |       |
   * |                                 | MMM     | Jan, Feb, ..., Dec                |       |
   * |                                 | MMMM    | January, February, ..., December  | 2     |
   * |                                 | MMMMM   | J, F, ..., D                      |       |
   * | Month (stand-alone)             | L       | 1, 2, ..., 12                     |       |
   * |                                 | Lo      | 1st, 2nd, ..., 12th               | 7     |
   * |                                 | LL      | 01, 02, ..., 12                   |       |
   * |                                 | LLL     | Jan, Feb, ..., Dec                |       |
   * |                                 | LLLL    | January, February, ..., December  | 2     |
   * |                                 | LLLLL   | J, F, ..., D                      |       |
   * | Local week of year              | w       | 1, 2, ..., 53                     |       |
   * |                                 | wo      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | ww      | 01, 02, ..., 53                   |       |
   * | ISO week of year                | I       | 1, 2, ..., 53                     | 7     |
   * |                                 | Io      | 1st, 2nd, ..., 53th               | 7     |
   * |                                 | II      | 01, 02, ..., 53                   | 7     |
   * | Day of month                    | d       | 1, 2, ..., 31                     |       |
   * |                                 | do      | 1st, 2nd, ..., 31st               | 7     |
   * |                                 | dd      | 01, 02, ..., 31                   |       |
   * | Day of year                     | D       | 1, 2, ..., 365, 366               | 8     |
   * |                                 | Do      | 1st, 2nd, ..., 365th, 366th       | 7     |
   * |                                 | DD      | 01, 02, ..., 365, 366             | 8     |
   * |                                 | DDD     | 001, 002, ..., 365, 366           |       |
   * |                                 | DDDD    | ...                               | 3     |
   * | Day of week (formatting)        | E..EEE  | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | EEEEE   | M, T, W, T, F, S, S               |       |
   * |                                 | EEEEEE  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | ISO day of week (formatting)    | i       | 1, 2, 3, ..., 7                   | 7     |
   * |                                 | io      | 1st, 2nd, ..., 7th                | 7     |
   * |                                 | ii      | 01, 02, ..., 07                   | 7     |
   * |                                 | iii     | Mon, Tue, Wed, ..., Su            | 7     |
   * |                                 | iiii    | Monday, Tuesday, ..., Sunday      | 2,7   |
   * |                                 | iiiii   | M, T, W, T, F, S, S               | 7     |
   * |                                 | iiiiii  | Mo, Tu, We, Th, Fr, Su, Sa        | 7     |
   * | Local day of week (formatting)  | e       | 2, 3, 4, ..., 1                   |       |
   * |                                 | eo      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | ee      | 02, 03, ..., 01                   |       |
   * |                                 | eee     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | eeeee   | M, T, W, T, F, S, S               |       |
   * |                                 | eeeeee  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | Local day of week (stand-alone) | c       | 2, 3, 4, ..., 1                   |       |
   * |                                 | co      | 2nd, 3rd, ..., 1st                | 7     |
   * |                                 | cc      | 02, 03, ..., 01                   |       |
   * |                                 | ccc     | Mon, Tue, Wed, ..., Su            |       |
   * |                                 | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
   * |                                 | ccccc   | M, T, W, T, F, S, S               |       |
   * |                                 | cccccc  | Mo, Tu, We, Th, Fr, Su, Sa        |       |
   * | AM, PM                          | a..aaa  | AM, PM                            |       |
   * |                                 | aaaa    | a.m., p.m.                        | 2     |
   * |                                 | aaaaa   | a, p                              |       |
   * | AM, PM, noon, midnight          | b..bbb  | AM, PM, noon, midnight            |       |
   * |                                 | bbbb    | a.m., p.m., noon, midnight        | 2     |
   * |                                 | bbbbb   | a, p, n, mi                       |       |
   * | Flexible day period             | B..BBB  | at night, in the morning, ...     |       |
   * |                                 | BBBB    | at night, in the morning, ...     | 2     |
   * |                                 | BBBBB   | at night, in the morning, ...     |       |
   * | Hour [1-12]                     | h       | 1, 2, ..., 11, 12                 |       |
   * |                                 | ho      | 1st, 2nd, ..., 11th, 12th         | 7     |
   * |                                 | hh      | 01, 02, ..., 11, 12               |       |
   * | Hour [0-23]                     | H       | 0, 1, 2, ..., 23                  |       |
   * |                                 | Ho      | 0th, 1st, 2nd, ..., 23rd          | 7     |
   * |                                 | HH      | 00, 01, 02, ..., 23               |       |
   * | Hour [0-11]                     | K       | 1, 2, ..., 11, 0                  |       |
   * |                                 | Ko      | 1st, 2nd, ..., 11th, 0th          | 7     |
   * |                                 | KK      | 1, 2, ..., 11, 0                  |       |
   * | Hour [1-24]                     | k       | 24, 1, 2, ..., 23                 |       |
   * |                                 | ko      | 24th, 1st, 2nd, ..., 23rd         | 7     |
   * |                                 | kk      | 24, 01, 02, ..., 23               |       |
   * | Minute                          | m       | 0, 1, ..., 59                     |       |
   * |                                 | mo      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | mm      | 00, 01, ..., 59                   |       |
   * | Second                          | s       | 0, 1, ..., 59                     |       |
   * |                                 | so      | 0th, 1st, ..., 59th               | 7     |
   * |                                 | ss      | 00, 01, ..., 59                   |       |
   * | Fraction of second              | S       | 0, 1, ..., 9                      |       |
   * |                                 | SS      | 00, 01, ..., 99                   |       |
   * |                                 | SSS     | 000, 0001, ..., 999               |       |
   * |                                 | SSSS    | ...                               | 3     |
   * | Timezone (ISO-8601 w/ Z)        | X       | -08, +0530, Z                     |       |
   * |                                 | XX      | -0800, +0530, Z                   |       |
   * |                                 | XXX     | -08:00, +05:30, Z                 |       |
   * |                                 | XXXX    | -0800, +0530, Z, +123456          | 2     |
   * |                                 | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
   * | Timezone (ISO-8601 w/o Z)       | x       | -08, +0530, +00                   |       |
   * |                                 | xx      | -0800, +0530, +0000               |       |
   * |                                 | xxx     | -08:00, +05:30, +00:00            | 2     |
   * |                                 | xxxx    | -0800, +0530, +0000, +123456      |       |
   * |                                 | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
   * | Timezone (GMT)                  | O...OOO | GMT-8, GMT+5:30, GMT+0            |       |
   * |                                 | OOOO    | GMT-08:00, GMT+05:30, GMT+00:00   | 2     |
   * | Timezone (specific non-locat.)  | z...zzz | PDT, EST, CEST                    | 6     |
   * |                                 | zzzz    | Pacific Daylight Time             | 2,6   |
   * | Seconds timestamp               | t       | 512969520                         | 7     |
   * |                                 | tt      | ...                               | 3,7   |
   * | Milliseconds timestamp          | T       | 512969520900                      | 7     |
   * |                                 | TT      | ...                               | 3,7   |
   * | Long localized date             | P       | 05/29/1453                        | 7     |
   * |                                 | PP      | May 29, 1453                      | 7     |
   * |                                 | PPP     | May 29th, 1453                    | 7     |
   * |                                 | PPPP    | Sunday, May 29th, 1453            | 2,7   |
   * | Long localized time             | p       | 12:00 AM                          | 7     |
   * |                                 | pp      | 12:00:00 AM                       | 7     |
   * |                                 | ppp     | 12:00:00 AM GMT+2                 | 7     |
   * |                                 | pppp    | 12:00:00 AM GMT+02:00             | 2,7   |
   * | Combination of date and time    | Pp      | 05/29/1453, 12:00 AM              | 7     |
   * |                                 | PPpp    | May 29, 1453, 12:00:00 AM         | 7     |
   * |                                 | PPPppp  | May 29th, 1453 at ...             | 7     |
   * |                                 | PPPPpppp| Sunday, May 29th, 1453 at ...     | 2,7   |
   * Notes:
   * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
   *    are the same as "stand-alone" units, but are different in some languages.
   *    "Formatting" units are declined according to the rules of the language
   *    in the context of a date. "Stand-alone" units are always nominative singular:
   *
   *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
   *
   *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
   *
   * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
   *    the single quote characters (see below).
   *    If the sequence is longer than listed in table (e.g. `EEEEEEEEEEE`)
   *    the output will be the same as default pattern for this unit, usually
   *    the longest one (in case of ISO weekdays, `EEEE`). Default patterns for units
   *    are marked with "2" in the last column of the table.
   *
   *    `format(new Date(2017, 10, 6), 'MMM') //=> 'Nov'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMM') //=> 'N'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMM') //=> 'November'`
   *
   *    `format(new Date(2017, 10, 6), 'MMMMMMM') //=> 'November'`
   *
   * 3. Some patterns could be unlimited length (such as `yyyyyyyy`).
   *    The output will be padded with zeros to match the length of the pattern.
   *
   *    `format(new Date(2017, 10, 6), 'yyyyyyyy') //=> '00002017'`
   *
   * 4. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
   *    These tokens represent the shortest form of the quarter.
   *
   * 5. The main difference between `y` and `u` patterns are B.C. years:
   *
   *    | Year | `y` | `u` |
   *    |------|-----|-----|
   *    | AC 1 |   1 |   1 |
   *    | BC 1 |   1 |   0 |
   *    | BC 2 |   2 |  -1 |
   *
   *    Also `yy` always returns the last two digits of a year,
   *    while `uu` pads single digit years to 2 characters and returns other years unchanged:
   *
   *    | Year | `yy` | `uu` |
   *    |------|------|------|
   *    | 1    |   01 |   01 |
   *    | 14   |   14 |   14 |
   *    | 376  |   76 |  376 |
   *    | 1453 |   53 | 1453 |
   *
   *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
   *    except local week-numbering years are dependent on `options.weekStartsOn`
   *    and `options.firstWeekContainsDate` (compare [getISOWeekYear]{@link https://date-fns.org/docs/getISOWeekYear}
   *    and [getWeekYear]{@link https://date-fns.org/docs/getWeekYear}).
   *
   * 6. Specific non-location timezones are created using the Intl browser API. The output is determined by the
   *    preferred standard of the current locale (en-US by default) which may not always give the expected result.
   *    For this reason it is recommended to supply a `locale` in the format options when formatting a time zone name.
   *
   * 7. These patterns are not in the Unicode Technical Standard #35:
   *    - `i`: ISO day of week
   *    - `I`: ISO week of year
   *    - `R`: ISO week-numbering year
   *    - `t`: seconds timestamp
   *    - `T`: milliseconds timestamp
   *    - `o`: ordinal number modifier
   *    - `P`: long localized date
   *    - `p`: long localized time
   *
   * 8. These tokens are often confused with others. See: https://git.io/fxCyr
   *
   *
   * ### v2.0.0 breaking changes:
   *
   * - [Changes that are common for the whole
   *   library](https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#Common-Changes).
   *
   * - The second argument is now required for the sake of explicitness.
   *
   *   ```javascript
   *   // Before v2.0.0
   *   format(new Date(2016, 0, 1))
   *
   *   // v2.0.0 onward
   *   format(new Date(2016, 0, 1), "yyyy-MM-dd'T'HH:mm:ss.SSSxxx")
   *   ```
   *
   * - New format string API for `format` function
   *   which is based on [Unicode Technical Standard
   *   #35](https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table). See [this
   *   post](https://blog.date-fns.org/post/unicode-tokens-in-date-fns-v2-sreatyki91jg) for more details.
   *
   * - Characters are now escaped using single quote symbols (`'`) instead of square brackets.
   *
   * @param {Date|Number} date - the original date
   * @param {String} format - the string of tokens
   * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
   *   https://date-fns.org/docs/toDate}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See
   *   [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
   *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
   *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
   *   (`yy`, `yyyy`). See: https://git.io/fxCyr
   * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
   * @returns {String} the formatted date string
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   * @throws {RangeError} `options.locale` must contain `localize` property
   * @throws {RangeError} `options.locale` must contain `formatLong` property
   * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
   * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
   * @throws {RangeError} `options.awareOfUnicodeTokens` must be set to `true` to use `XX` token; see:
   *   https://git.io/fxCyr
   *
   * @example
   * // Represent 11 February 2014 in middle-endian format:
   * var result = format(new Date(2014, 1, 11), 'MM/dd/yyyy')
   * //=> '02/11/2014'
   *
   * @example
   * // Represent 2 July 2014 in Esperanto:
   * import { eoLocale } from 'date-fns/locale/eo'
   * var result = format(new Date(2014, 6, 2), "do 'de' MMMM yyyy", {
   *   locale: eoLocale
   * })
   * //=> '2-a de julio 2014'
   *
   * @example
   * // Escape string by single quote characters:
   * var result = format(new Date(2014, 6, 2, 15), "h 'o''clock'")
   * //=> "3 o'clock"
   */
  function format$2(dirtyDate, dirtyFormatStr, dirtyOptions) {
    var formatStr = String(dirtyFormatStr);
    var options = dirtyOptions || {};

    var matches = formatStr.match(tzFormattingTokensRegExp);
    if (matches) {
      var date = toDate(dirtyDate, options);
      // Work through each match and replace the tz token in the format string with the quoted
      // formatted time zone so the remaining tokens can be filled in by date-fns#format.
      formatStr = matches.reduce(function (result, token) {
        if (token[0] === "'") {
          return result // This is a quoted portion, matched only to ensure we don't match inside it
        }
        var pos = result.indexOf(token);
        var precededByQuotedSection = result[pos - 1] === "'";
        var replaced = result.replace(
          token,
          "'" + formatters$1[token[0]](date, token, null, options) + "'"
        );
        // If the replacement results in two adjoining quoted strings, the back to back quotes
        // are removed, so it doesn't look like an escaped quote.
        return precededByQuotedSection
          ? replaced.substring(0, pos - 1) + replaced.substring(pos + 1)
          : replaced
      }, formatStr);
    }

    return dateFnsFormat(dirtyDate, formatStr, options)
  }

  /**
   * @name utcToZonedTime
   * @category Time Zone Helpers
   * @summary Get a date/time representing local time in a given time zone from the UTC date
   *
   * @description
   * Returns a date instance with values representing the local time in the time zone
   * specified of the UTC time from the date provided. In other words, when the new date
   * is formatted it will show the equivalent hours in the target time zone regardless
   * of the current system time zone.
   *
   * @param {Date|String|Number} date - the date with the relevant UTC time
   * @param {String} timeZone - the time zone to get local time for, can be an offset or IANA time zone
   * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
   * @returns {Date} the new date with the equivalent time in the time zone
   * @throws {TypeError} 2 arguments required
   * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
   *
   * @example
   * // In June 10am UTC is 6am in New York (-04:00)
   * const result = utcToZonedTime('2014-06-25T10:00:00.000Z', 'America/New_York')
   * //=> Jun 25 2014 06:00:00
   */
  function utcToZonedTime(dirtyDate, timeZone, options) {
    var date = toDate(dirtyDate, options);

    var offsetMilliseconds = tzParseTimezone(timeZone, date, true);

    var d = new Date(date.getTime() - offsetMilliseconds);

    var resultDate = new Date(0);

    resultDate.setFullYear(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());

    resultDate.setHours(d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());

    return resultDate
  }

  /**
   * @name formatInTimeZone
   * @category Time Zone Helpers
   * @summary Gets the offset in milliseconds between the time zone and Universal Coordinated Time (UTC)
   *
   * @param {Date|String|Number} date - the date representing the local time / real UTC time
   * @param {String} timeZone - the time zone this date should be formatted for; can be an offset or IANA time zone
   * @param {String} formatStr - the string of tokens
   * @param {OptionsWithTZ} [options] - the object with options. See [Options]{@link https://date-fns.org/docs/Options}
   * @param {0|1|2} [options.additionalDigits=2] - passed to `toDate`. See [toDate]{@link
   *   https://date-fns.org/docs/toDate}
   * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
   * @param {Number} [options.firstWeekContainsDate=1] - the day of January, which is
   * @param {Locale} [options.locale=defaultLocale] - the locale object. See
   *   [Locale]{@link https://date-fns.org/docs/Locale}
   * @param {Boolean} [options.awareOfUnicodeTokens=false] - if true, allows usage of Unicode tokens causes confusion:
   *   - Some of the day of year tokens (`D`, `DD`) that are confused with the day of month tokens (`d`, `dd`).
   *   - Some of the local week-numbering year tokens (`YY`, `YYYY`) that are confused with the calendar year tokens
   *   (`yy`, `yyyy`). See: https://git.io/fxCyr
   * @param {String} [options.timeZone=''] - used to specify the IANA time zone offset of a date String.
   * @returns {String} the formatted date string
   */
  function formatInTimeZone(date, timeZone, formatStr, options) {
    var extendedOptions = cloneObject(options);
    extendedOptions.timeZone = timeZone;
    return format$2(utcToZonedTime(date, timeZone), formatStr, extendedOptions)
  }

  const time = {
      amHours: [
          '00',
          '01',
          '02',
          '03',
          '04',
          '05',
          '06',
          '07',
          '08',
          '09',
          '10',
          '11'
      ],
      pmHours: [
          '12',
          '01',
          '02',
          '03',
          '04',
          '05',
          '06',
          '07',
          '08',
          '09',
          '10',
          '11'
      ],
      hours: [
          '00',
          '01',
          '02',
          '03',
          '04',
          '05',
          '06',
          '07',
          '08',
          '09',
          '10',
          '11',
          '12',
          '13',
          '14',
          '15',
          '16',
          '17',
          '18',
          '19',
          '20',
          '21',
          '22',
          '23'
      ],
      minutes: [
          '00',
          '01',
          '02',
          '03',
          '04',
          '05',
          '06',
          '07',
          '08',
          '09',
          '10',
          '11',
          '12',
          '13',
          '14',
          '15',
          '16',
          '17',
          '18',
          '19',
          '20',
          '21',
          '22',
          '23',
          '24',
          '25',
          '26',
          '27',
          '28',
          '29',
          '30',
          '31',
          '32',
          '33',
          '34',
          '35',
          '36',
          '37',
          '38',
          '39',
          '40',
          '41',
          '42',
          '43',
          '44',
          '45',
          '46',
          '47',
          '48',
          '49',
          '50',
          '51',
          '52',
          '53',
          '54',
          '55',
          '56',
          '57',
          '58',
          '59'
      ],
      seconds: [
          '00',
          '01',
          '02',
          '03',
          '04',
          '05',
          '06',
          '07',
          '08',
          '09',
          '10',
          '11',
          '12',
          '13',
          '14',
          '15',
          '16',
          '17',
          '18',
          '19',
          '20',
          '21',
          '22',
          '23',
          '24',
          '25',
          '26',
          '27',
          '28',
          '29',
          '30',
          '31',
          '32',
          '33',
          '34',
          '35',
          '36',
          '37',
          '38',
          '39',
          '40',
          '41',
          '42',
          '43',
          '44',
          '45',
          '46',
          '47',
          '48',
          '49',
          '50',
          '51',
          '52',
          '53',
          '54',
          '55',
          '56',
          '57',
          '58',
          '59'
      ],
      period: ['AM', 'PM']
  };
  function getFixValue(value) {
      return `00${value}`.slice(-2);
  }
  // TODO: refactor the logic, it's somehow a patch logic
  function getTimeUnits(defaultValue, stepOrList, isHourWithAmPm) {
      if (Array.isArray(stepOrList)) {
          return (isHourWithAmPm === 'am'
              ? stepOrList.filter((v) => v < 12)
              : isHourWithAmPm === 'pm'
                  ? stepOrList.filter((v) => v >= 12).map((v) => (v === 12 ? 12 : v - 12))
                  : stepOrList).map((v) => getFixValue(v));
      }
      else if (typeof stepOrList === 'number') {
          if (isHourWithAmPm === 'am') {
              return defaultValue.filter((hour) => {
                  const hourAsNumber = Number(hour);
                  return hourAsNumber < 12 && hourAsNumber % stepOrList === 0;
              });
          }
          else if (isHourWithAmPm === 'pm') {
              return defaultValue
                  .filter((hour) => {
                  const hourAsNumber = Number(hour);
                  return hourAsNumber >= 12 && hourAsNumber % stepOrList === 0;
              })
                  .map((hour) => {
                  const hourAsNumber = Number(hour);
                  return getFixValue(hourAsNumber === 12 ? 12 : hourAsNumber - 12);
              });
          }
          return defaultValue.filter((hour) => {
              return Number(hour) % stepOrList === 0;
          });
      }
      else {
          return isHourWithAmPm === 'am'
              ? defaultValue.filter((hour) => Number(hour) < 12)
              : isHourWithAmPm === 'pm'
                  ? defaultValue
                      .map((hour) => Number(hour))
                      .filter((hour) => Number(hour) >= 12)
                      .map((v) => getFixValue(v === 12 ? 12 : v - 12))
                  : defaultValue;
      }
  }
  function isTimeInStep(value, type, stepOrList) {
      if (!stepOrList) {
          return true;
      }
      else if (typeof stepOrList === 'number') {
          return value % stepOrList === 0;
      }
      else {
          return stepOrList.includes(value);
      }
  }
  function findSimilarTime(value, type, stepOrList) {
      const list = getTimeUnits(time[type], stepOrList).map(Number);
      let lowerBound, upperBound;
      for (let i = 0; i < list.length; ++i) {
          const v = list[i];
          if (v === value)
              return v;
          else if (v > value) {
              upperBound = v;
              break;
          }
          lowerBound = v;
      }
      if (lowerBound === undefined) {
          if (!upperBound) {
              throwError('time-picker', "Please set 'hours' or 'minutes' or 'seconds' props");
          }
          return upperBound;
      }
      if (upperBound === undefined) {
          return lowerBound;
      }
      return upperBound - value > value - lowerBound ? lowerBound : upperBound;
  }
  function getAmPm(value) {
      return getHours(value) < 12 ? 'am' : 'pm';
  }

  const timePickerInjectionKey = createInjectionKey('n-time-picker');

  var PanelCol = defineComponent({
      name: 'TimePickerPanelCol',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          data: {
              type: Array,
              required: true
          },
          activeValue: {
              type: Number,
              default: null
          },
          // It should be required but vue's type seems to have bugs
          onItemClick: Function
      },
      render() {
          const { activeValue, onItemClick, clsPrefix } = this;
          return this.data.map((item) => {
              const { label, disabled, value } = item;
              const active = activeValue === value;
              return (h("div", { key: label, "data-active": active ? '' : null, class: [
                      `${clsPrefix}-time-picker-col__item`,
                      active && `${clsPrefix}-time-picker-col__item--active`,
                      disabled && `${clsPrefix}-time-picker-col__item--disabled`
                  ], onClick: onItemClick && !disabled
                      ? () => {
                          onItemClick(value);
                      }
                      : undefined }, label));
          });
      }
  });

  const timePickerPanelProps = {
      actions: {
          type: Array,
          default: () => ['now', 'confirm']
      },
      showHour: {
          type: Boolean,
          default: true
      },
      showMinute: {
          type: Boolean,
          default: true
      },
      showSecond: {
          type: Boolean,
          default: true
      },
      showPeriod: {
          type: Boolean,
          default: true
      },
      isHourInvalid: Boolean,
      isMinuteInvalid: Boolean,
      isSecondInvalid: Boolean,
      isAmPmInvalid: Boolean,
      isValueInvalid: Boolean,
      hourValue: {
          type: Number,
          default: null
      },
      minuteValue: {
          type: Number,
          default: null
      },
      secondValue: {
          type: Number,
          default: null
      },
      amPmValue: {
          type: String,
          default: null
      },
      isHourDisabled: Function,
      isMinuteDisabled: Function,
      isSecondDisabled: Function,
      onHourClick: {
          type: Function,
          required: true
      },
      onMinuteClick: {
          type: Function,
          required: true
      },
      onSecondClick: {
          type: Function,
          required: true
      },
      onAmPmClick: {
          type: Function,
          required: true
      },
      onNowClick: Function,
      nowText: String,
      confirmText: String,
      transitionDisabled: Boolean,
      onConfirmClick: Function,
      onFocusin: Function,
      onFocusout: Function,
      onFocusDetectorFocus: Function,
      onKeydown: Function,
      hours: [Number, Array],
      minutes: [Number, Array],
      seconds: [Number, Array],
      use12Hours: Boolean
  };
  var Panel = defineComponent({
      name: 'TimePickerPanel',
      props: timePickerPanelProps,
      setup(props) {
          const { mergedThemeRef, mergedClsPrefixRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(timePickerInjectionKey);
          const hoursRef = computed(() => {
              const { isHourDisabled, hours, use12Hours, amPmValue } = props;
              if (!use12Hours) {
                  return getTimeUnits(time.hours, hours).map((hour) => {
                      return {
                          label: hour,
                          value: Number(hour),
                          disabled: isHourDisabled ? isHourDisabled(Number(hour)) : false
                      };
                  });
              }
              else {
                  const mergedAmPmValue = amPmValue !== null && amPmValue !== void 0 ? amPmValue : getAmPm(Date.now());
                  return getTimeUnits(time.hours, hours, mergedAmPmValue).map((hour) => {
                      const hourAs12FormattedNumber = Number(hour);
                      const hourAs24FormattedNumber = mergedAmPmValue === 'pm' && hourAs12FormattedNumber !== 12
                          ? hourAs12FormattedNumber + 12
                          : hourAs12FormattedNumber;
                      return {
                          label: hour,
                          value: hourAs24FormattedNumber,
                          disabled: isHourDisabled
                              ? isHourDisabled(hourAs24FormattedNumber)
                              : false
                      };
                  });
              }
          });
          const minutesRef = computed(() => {
              const { isMinuteDisabled, minutes } = props;
              return getTimeUnits(time.minutes, minutes).map((minute) => {
                  return {
                      label: minute,
                      value: Number(minute),
                      disabled: isMinuteDisabled
                          ? isMinuteDisabled(Number(minute), props.hourValue)
                          : false
                  };
              });
          });
          const secondsRef = computed(() => {
              const { isSecondDisabled, seconds } = props;
              return getTimeUnits(time.seconds, seconds).map((second) => {
                  return {
                      label: second,
                      value: Number(second),
                      disabled: isSecondDisabled
                          ? isSecondDisabled(Number(second), props.minuteValue, props.hourValue)
                          : false
                  };
              });
          });
          const amPmRef = computed(() => {
              const { isHourDisabled } = props;
              let amDisabled = true;
              let pmDisabled = true;
              for (let i = 0; i < 12; ++i) {
                  if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
                      amDisabled = false;
                      break;
                  }
              }
              for (let i = 12; i < 24; ++i) {
                  if (!(isHourDisabled === null || isHourDisabled === void 0 ? void 0 : isHourDisabled(i))) {
                      pmDisabled = false;
                      break;
                  }
              }
              return [
                  {
                      label: 'AM',
                      value: 'am',
                      disabled: amDisabled
                  },
                  {
                      label: 'PM',
                      value: 'pm',
                      disabled: pmDisabled
                  }
              ];
          });
          return {
              mergedTheme: mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              hours: hoursRef,
              minutes: minutesRef,
              seconds: secondsRef,
              amPm: amPmRef,
              hourScrollRef: ref(null),
              minuteScrollRef: ref(null),
              secondScrollRef: ref(null),
              amPmScrollRef: ref(null)
          };
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme } = this;
          return (h("div", { tabindex: 0, class: `${mergedClsPrefix}-time-picker-panel`, onFocusin: this.onFocusin, onFocusout: this.onFocusout, onKeydown: this.onKeydown },
              h("div", { class: `${mergedClsPrefix}-time-picker-cols` },
                  this.showHour ? (h("div", { class: [
                          `${mergedClsPrefix}-time-picker-col`,
                          this.isHourInvalid &&
                              `${mergedClsPrefix}-time-picker-col--invalid`,
                          this.transitionDisabled &&
                              `${mergedClsPrefix}-time-picker-col--transition-disabled`
                      ] },
                      h(NScrollbar, { ref: "hourScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => [
                              h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.hours, activeValue: this.hourValue, onItemClick: this.onHourClick }),
                              h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                          ]
                      }))) : null,
                  this.showMinute ? (h("div", { class: [
                          `${mergedClsPrefix}-time-picker-col`,
                          this.transitionDisabled &&
                              `${mergedClsPrefix}-time-picker-col--transition-disabled`,
                          this.isMinuteInvalid &&
                              `${mergedClsPrefix}-time-picker-col--invalid`
                      ] },
                      h(NScrollbar, { ref: "minuteScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => [
                              h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.minutes, activeValue: this.minuteValue, onItemClick: this.onMinuteClick }),
                              h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                          ]
                      }))) : null,
                  this.showSecond ? (h("div", { class: [
                          `${mergedClsPrefix}-time-picker-col`,
                          this.isSecondInvalid &&
                              `${mergedClsPrefix}-time-picker-col--invalid`,
                          this.transitionDisabled &&
                              `${mergedClsPrefix}-time-picker-col--transition-disabled`
                      ] },
                      h(NScrollbar, { ref: "secondScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => [
                              h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.seconds, activeValue: this.secondValue, onItemClick: this.onSecondClick }),
                              h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                          ]
                      }))) : null,
                  this.use12Hours ? (h("div", { class: [
                          `${mergedClsPrefix}-time-picker-col`,
                          this.isAmPmInvalid &&
                              `${mergedClsPrefix}-time-picker-col--invalid`,
                          this.transitionDisabled &&
                              `${mergedClsPrefix}-time-picker-col--transition-disabled`
                      ] },
                      h(NScrollbar, { ref: "amPmScrollRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => [
                              h(PanelCol, { clsPrefix: mergedClsPrefix, data: this.amPm, activeValue: this.amPmValue, onItemClick: this.onAmPmClick }),
                              h("div", { class: `${mergedClsPrefix}-time-picker-col__padding` })
                          ]
                      }))) : null),
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) ? (h("div", { class: `${mergedClsPrefix}-time-picker-actions` },
                  ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('now')) ? (h(NButton, { size: "tiny", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.onNowClick }, { default: () => this.nowText })) : null,
                  ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('confirm')) ? (h(NButton, { size: "tiny", type: "primary", class: `${mergedClsPrefix}-time-picker-actions__confirm`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, disabled: this.isValueInvalid, onClick: this.onConfirmClick }, { default: () => this.confirmText })) : null)) : null,
              h(FocusDetector, { onFocus: this.onFocusDetectorFocus })));
      }
  });

  // vars:
  // --n-icon-color-override
  // --n-icon-color-disabled-override
  // --n-bezier
  // --n-border-radius
  // --n-item-color-hover
  // --n-item-font-size
  // --n-item-height
  // --n-item-opacity-disabled
  // --n-item-text-color
  // --n-item-text-color-active
  // --n-item-width
  // --n-panel-action-padding
  // --n-panel-box-shadow
  // --n-panel-color
  // --n-panel-divider-color
  // --n-item-border-radius
  var style$U = c$1([cB('time-picker', `
 z-index: auto;
 position: relative;
 `, [cB('time-picker-icon', `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM('disabled', [cB('time-picker-icon', `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB('time-picker-panel', `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 outline: none;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-border-radius);
 margin: 4px 0;
 min-width: 104px;
 overflow: hidden;
 background-color: var(--n-panel-color);
 box-shadow: var(--n-panel-box-shadow);
 `, [fadeInScaleUpTransition(), cB('time-picker-actions', `
 padding: var(--n-panel-action-padding);
 align-items: center;
 display: flex;
 justify-content: space-evenly;
 `), cB('time-picker-cols', `
 height: calc(var(--n-item-height) * 6);
 display: flex;
 position: relative;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-panel-divider-color);
 `), cB('time-picker-col', `
 flex-grow: 1;
 min-width: var(--n-item-width);
 height: calc(var(--n-item-height) * 6);
 flex-direction: column;
 transition: box-shadow .3s var(--n-bezier);
 `, [cM('transition-disabled', [cE('item', 'transition: none;', [c$1('&::before', 'transition: none;')])]), cE('padding', `
 height: calc(var(--n-item-height) * 5);
 `), c$1('&:first-child', 'min-width: calc(var(--n-item-width) + 4px);', [cE('item', [c$1('&::before', 'left: 4px;')])]), cE('item', `
 cursor: pointer;
 height: var(--n-item-height);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 background: #0000;
 text-decoration-color: #0000;
 color: var(--n-item-text-color);
 z-index: 0;
 box-sizing: border-box;
 padding-top: 4px;
 position: relative;
 `, [c$1('&::before', `
 content: "";
 transition: background-color .3s var(--n-bezier);
 z-index: -1;
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-item-border-radius);
 `), cNotM('disabled', [c$1('&:hover::before', `
 background-color: var(--n-item-color-hover);
 `)]), cM('active', `
 color: var(--n-item-text-color-active);
 `, [c$1('&::before', `
 background-color: var(--n-item-color-hover);
 `)]), cM('disabled', `
 opacity: var(--n-item-opacity-disabled);
 cursor: not-allowed;
 `)]), cM('invalid', [cE('item', [cM('active', `
 text-decoration: line-through;
 text-decoration-color: var(--n-item-text-color-active);
 `)])])])])]);

  // validate hours, minutes, seconds prop
  function validateUnits(value, max) {
      if (value === undefined) {
          return true;
      }
      if (Array.isArray(value)) {
          return value.every((v) => v >= 0 && v <= max);
      }
      else {
          return value >= 0 && value <= max;
      }
  }
  const timePickerProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, bordered: {
          type: Boolean,
          default: undefined
      }, actions: Array, defaultValue: {
          type: Number,
          default: null
      }, defaultFormattedValue: String, placeholder: String, placement: {
          type: String,
          default: 'bottom-start'
      }, value: Number, format: {
          type: String,
          default: 'HH:mm:ss'
      }, valueFormat: String, formattedValue: String, isHourDisabled: Function, size: String, isMinuteDisabled: Function, isSecondDisabled: Function, inputReadonly: Boolean, clearable: Boolean, status: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], onUpdateFormattedValue: [Function, Array], 'onUpdate:formattedValue': [Function, Array], onBlur: [Function, Array], onConfirm: [Function, Array], onClear: Function, onFocus: [Function, Array], 
      // https://www.iana.org/time-zones
      timeZone: String, showIcon: {
          type: Boolean,
          default: true
      }, disabled: {
          type: Boolean,
          default: undefined
      }, show: {
          type: Boolean,
          default: undefined
      }, hours: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 23)
      }, minutes: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 59)
      }, seconds: {
          type: [Number, Array],
          validator: (value) => validateUnits(value, 59)
      }, use12Hours: Boolean, 
      // private
      stateful: {
          type: Boolean,
          default: true
      }, 
      // deprecated
      onChange: [Function, Array] });
  var NTimePicker = defineComponent({
      name: 'TimePicker',
      props: timePickerProps,
      setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef, dateLocaleRef } = useLocale('TimePicker');
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const themeRef = useTheme('TimePicker', '-time-picker', style$U, timePickerLight$1, props, mergedClsPrefixRef);
          const keyboardState = useKeyboard$1();
          const inputInstRef = ref(null);
          const panelInstRef = ref(null);
          const dateFnsOptionsRef = computed(() => {
              return {
                  locale: dateLocaleRef.value.locale
              };
          });
          function getTimestampFromFormattedValue(value) {
              if (value === null)
                  return null;
              return strictParse(value, props.valueFormat || props.format, new Date(), dateFnsOptionsRef.value).getTime();
          }
          const { defaultValue, defaultFormattedValue } = props;
          const uncontrolledValueRef = ref(defaultFormattedValue !== undefined
              ? getTimestampFromFormattedValue(defaultFormattedValue)
              : defaultValue);
          const mergedValueRef = computed(() => {
              const { formattedValue } = props;
              if (formattedValue !== undefined) {
                  return getTimestampFromFormattedValue(formattedValue);
              }
              const { value } = props;
              if (value !== undefined) {
                  return value;
              }
              return uncontrolledValueRef.value;
          });
          const mergedFormatRef = computed(() => {
              const { timeZone } = props;
              if (timeZone) {
                  return (date, format, options) => {
                      return formatInTimeZone(date, timeZone, format, options);
                  };
              }
              else {
                  return (date, _format, options) => {
                      return format$4(date, _format, options);
                  };
              }
          });
          const displayTimeStringRef = ref('');
          watch(() => props.timeZone, () => {
              const mergedValue = mergedValueRef.value;
              displayTimeStringRef.value =
                  mergedValue === null
                      ? ''
                      : mergedFormatRef.value(mergedValue, props.format, dateFnsOptionsRef.value);
          }, {
              immediate: true
          });
          const uncontrolledShowRef = ref(false);
          const controlledShowRef = toRef(props, 'show');
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const memorizedValueRef = ref(mergedValueRef.value);
          const transitionDisabledRef = ref(false);
          const localizedNowRef = computed(() => {
              return localeRef.value.now;
          });
          const localizedPlaceholderRef = computed(() => {
              if (props.placeholder !== undefined)
                  return props.placeholder;
              return localeRef.value.placeholder;
          });
          const localizedNegativeTextRef = computed(() => {
              return localeRef.value.negativeText;
          });
          const localizedPositiveTextRef = computed(() => {
              return localeRef.value.positiveText;
          });
          const hourInFormatRef = computed(() => {
              return /H|h|K|k/.test(props.format);
          });
          const minuteInFormatRef = computed(() => {
              return props.format.includes('m');
          });
          const secondInFormatRef = computed(() => {
              return props.format.includes('s');
          });
          const isHourInvalidRef = computed(() => {
              const { isHourDisabled } = props;
              if (hourValueRef.value === null)
                  return false;
              if (!isTimeInStep(hourValueRef.value, 'hours', props.hours))
                  return true;
              if (!isHourDisabled)
                  return false;
              return isHourDisabled(hourValueRef.value);
          });
          const isMinuteInvalidRef = computed(() => {
              const { value: minuteValue } = minuteValueRef;
              const { value: hourValue } = hourValueRef;
              if (minuteValue === null || hourValue === null)
                  return false;
              if (!isTimeInStep(minuteValue, 'minutes', props.minutes))
                  return true;
              const { isMinuteDisabled } = props;
              if (!isMinuteDisabled)
                  return false;
              return isMinuteDisabled(minuteValue, hourValue);
          });
          const isSecondInvalidRef = computed(() => {
              const { value: minuteValue } = minuteValueRef;
              const { value: hourValue } = hourValueRef;
              const { value: secondValue } = secondValueRef;
              if (secondValue === null || minuteValue === null || hourValue === null) {
                  return false;
              }
              if (!isTimeInStep(secondValue, 'seconds', props.seconds))
                  return true;
              const { isSecondDisabled } = props;
              if (!isSecondDisabled)
                  return false;
              return isSecondDisabled(secondValue, minuteValue, hourValue);
          });
          const isValueInvalidRef = computed(() => {
              return (isHourInvalidRef.value ||
                  isMinuteInvalidRef.value ||
                  isSecondInvalidRef.value);
          });
          const mergedAttrSizeRef = computed(() => {
              return props.format.length + 4;
          });
          const amPmValueRef = computed(() => {
              const { value } = mergedValueRef;
              if (value === null)
                  return null;
              return getHours(value) < 12 ? 'am' : 'pm';
          });
          const hourValueRef = computed(() => {
              const { value } = mergedValueRef;
              if (value === null)
                  return null;
              return Number(mergedFormatRef.value(value, 'HH', dateFnsOptionsRef.value));
          });
          const minuteValueRef = computed(() => {
              const { value } = mergedValueRef;
              if (value === null)
                  return null;
              return Number(mergedFormatRef.value(value, 'mm', dateFnsOptionsRef.value));
          });
          const secondValueRef = computed(() => {
              const { value } = mergedValueRef;
              if (value === null)
                  return null;
              return Number(mergedFormatRef.value(value, 'ss', dateFnsOptionsRef.value));
          });
          function doUpdateFormattedValue(value, timestampValue) {
              const { onUpdateFormattedValue, 'onUpdate:formattedValue': _onUpdateFormattedValue } = props;
              if (onUpdateFormattedValue) {
                  call(onUpdateFormattedValue, value, timestampValue);
              }
              if (_onUpdateFormattedValue) {
                  call(_onUpdateFormattedValue, value, timestampValue);
              }
          }
          function createFormattedValue(value) {
              return value === null
                  ? null
                  : mergedFormatRef.value(value, props.valueFormat || props.format);
          }
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              const formattedValue = createFormattedValue(value);
              if (onUpdateValue) {
                  call(onUpdateValue, value, formattedValue);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, formattedValue);
              }
              if (onChange)
                  call(onChange, value, formattedValue);
              doUpdateFormattedValue(formattedValue, value);
              uncontrolledValueRef.value = value;
              nTriggerFormChange();
              nTriggerFormInput();
          }
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doConfirm() {
              const { onConfirm } = props;
              if (onConfirm) {
                  call(onConfirm, mergedValueRef.value, createFormattedValue(mergedValueRef.value));
              }
          }
          function handleTimeInputClear(e) {
              var _a;
              e.stopPropagation();
              doUpdateValue(null);
              deriveInputValue(null);
              (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function handleFocusDetectorFocus() {
              closePanel({
                  returnFocus: true
              });
          }
          function handleInputKeydown(e) {
              if (e.key === 'Escape' && mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  // closePanel will be called in onDeactivated
              }
          }
          function handleMenuKeydown(e) {
              var _a;
              switch (e.key) {
                  case 'Escape':
                      if (mergedShowRef.value) {
                          markEventEffectPerformed(e);
                          closePanel({
                              returnFocus: true
                          });
                      }
                      break;
                  case 'Tab':
                      if (keyboardState.shift && e.target === ((_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el)) {
                          e.preventDefault();
                          closePanel({
                              returnFocus: true
                          });
                      }
                      break;
              }
          }
          function disableTransitionOneTick() {
              transitionDisabledRef.value = true;
              void nextTick(() => {
                  transitionDisabledRef.value = false;
              });
          }
          function handleTriggerClick(e) {
              if (mergedDisabledRef.value || happensIn(e, 'clear'))
                  return;
              if (!mergedShowRef.value) {
                  openPanel();
              }
          }
          function handleHourClick(hour) {
              if (typeof hour === 'string')
                  return;
              if (mergedValueRef.value === null) {
                  doUpdateValue(getTime(setHours(startOfHour(new Date()), hour)));
              }
              else {
                  doUpdateValue(getTime(setHours(mergedValueRef.value, hour)));
              }
          }
          function handleMinuteClick(minute) {
              if (typeof minute === 'string')
                  return;
              if (mergedValueRef.value === null) {
                  doUpdateValue(getTime(setMinutes(startOfMinute(new Date()), minute)));
              }
              else {
                  doUpdateValue(getTime(setMinutes(mergedValueRef.value, minute)));
              }
          }
          function handleSecondClick(second) {
              if (typeof second === 'string')
                  return;
              if (mergedValueRef.value === null) {
                  doUpdateValue(getTime(setSeconds(startOfSecond(new Date()), second)));
              }
              else {
                  doUpdateValue(getTime(setSeconds(mergedValueRef.value, second)));
              }
          }
          function handleAmPmClick(amPm) {
              const { value: mergedValue } = mergedValueRef;
              if (mergedValue === null) {
                  const now = new Date();
                  const hours = getHours(now);
                  if (amPm === 'pm' && hours < 12) {
                      doUpdateValue(getTime(setHours(now, hours + 12)));
                  }
                  else if (amPm === 'am' && hours >= 12) {
                      doUpdateValue(getTime(setHours(now, hours - 12)));
                  }
                  doUpdateValue(getTime(now));
              }
              else {
                  const hours = getHours(mergedValue);
                  if (amPm === 'pm' && hours < 12) {
                      doUpdateValue(getTime(setHours(mergedValue, hours + 12)));
                  }
                  else if (amPm === 'am' && hours >= 12) {
                      doUpdateValue(getTime(setHours(mergedValue, hours - 12)));
                  }
              }
          }
          function deriveInputValue(time) {
              if (time === undefined)
                  time = mergedValueRef.value;
              if (time === null)
                  displayTimeStringRef.value = '';
              else {
                  displayTimeStringRef.value = mergedFormatRef.value(time, props.format, dateFnsOptionsRef.value);
              }
          }
          function handleTimeInputFocus(e) {
              if (isInternalFocusSwitch(e))
                  return;
              doFocus(e);
          }
          function handleTimeInputBlur(e) {
              var _a;
              if (isInternalFocusSwitch(e))
                  return;
              if (mergedShowRef.value) {
                  const panelEl = (_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;
                  if (!(panelEl === null || panelEl === void 0 ? void 0 : panelEl.contains(e.relatedTarget))) {
                      deriveInputValue();
                      doBlur(e);
                      closePanel({
                          returnFocus: false
                      });
                  }
              }
              else {
                  deriveInputValue();
                  doBlur(e);
              }
          }
          function handleTimeInputActivate() {
              if (mergedDisabledRef.value)
                  return;
              if (!mergedShowRef.value) {
                  openPanel();
              }
          }
          function handleTimeInputDeactivate() {
              if (mergedDisabledRef.value)
                  return;
              deriveInputValue();
              closePanel({
                  returnFocus: false
              });
          }
          function scrollTimer() {
              if (!panelInstRef.value)
                  return;
              const { hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef } = panelInstRef.value;
              [hourScrollRef, minuteScrollRef, secondScrollRef, amPmScrollRef].forEach((itemScrollRef) => {
                  var _a;
                  if (!itemScrollRef)
                      return;
                  const activeItemEl = (_a = itemScrollRef.contentRef) === null || _a === void 0 ? void 0 : _a.querySelector('[data-active]');
                  if (activeItemEl) {
                      itemScrollRef.scrollTo({
                          top: activeItemEl.offsetTop
                      });
                  }
              });
          }
          function doUpdateShow(value) {
              uncontrolledShowRef.value = value;
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, value);
              if (_onUpdateShow)
                  call(_onUpdateShow, value);
          }
          function isInternalFocusSwitch(e) {
              var _a, _b, _c;
              return !!(((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) ||
                  ((_c = panelInstRef.value) === null || _c === void 0 ? void 0 : _c.$el.contains(e.relatedTarget)));
          }
          function openPanel() {
              memorizedValueRef.value = mergedValueRef.value;
              doUpdateShow(true);
              void nextTick(scrollTimer);
          }
          function handleClickOutside(e) {
              var _a, _b;
              if (mergedShowRef.value &&
                  !((_b = (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef) === null || _b === void 0 ? void 0 : _b.contains(getPreciseEventTarget(e)))) {
                  closePanel({
                      returnFocus: false
                  });
              }
          }
          function closePanel({ returnFocus }) {
              var _a;
              if (mergedShowRef.value) {
                  doUpdateShow(false);
                  if (returnFocus) {
                      (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                  }
              }
          }
          function handleTimeInputUpdateValue(v) {
              if (v === '') {
                  doUpdateValue(null);
                  return;
              }
              const time = strictParse(v, props.format, new Date(), dateFnsOptionsRef.value);
              displayTimeStringRef.value = v;
              if (isValid$1(time)) {
                  const { value: mergedValue } = mergedValueRef;
                  if (mergedValue !== null) {
                      const newTime = set(mergedValue, {
                          hours: getHours(time),
                          minutes: getMinutes(time),
                          seconds: getSeconds(time)
                      });
                      doUpdateValue(getTime(newTime));
                  }
                  else {
                      doUpdateValue(getTime(time));
                  }
              }
          }
          function handleCancelClick() {
              doUpdateValue(memorizedValueRef.value);
              doUpdateShow(false);
          }
          function handleNowClick() {
              const now = new Date();
              const getNowTime = {
                  hours: getHours,
                  minutes: getMinutes,
                  seconds: getSeconds
              };
              const [mergeHours, mergeMinutes, mergeSeconds] = ['hours', 'minutes', 'seconds'].map((i) => !props[i] || isTimeInStep(getNowTime[i](now), i, props[i])
                  ? getNowTime[i](now)
                  : findSimilarTime(getNowTime[i](now), i, props[i]));
              const newValue = setSeconds(setMinutes(setHours(mergedValueRef.value ? mergedValueRef.value : getTime(now), mergeHours), mergeMinutes), mergeSeconds);
              doUpdateValue(getTime(newValue));
          }
          function handleConfirmClick() {
              deriveInputValue();
              doConfirm();
              closePanel({
                  returnFocus: true
              });
          }
          function handleMenuFocusOut(e) {
              if (isInternalFocusSwitch(e))
                  return;
              deriveInputValue();
              doBlur(e);
              closePanel({
                  returnFocus: false
              });
          }
          watch(mergedValueRef, (value) => {
              deriveInputValue(value);
              disableTransitionOneTick();
              void nextTick(scrollTimer);
          });
          watch(mergedShowRef, () => {
              if (isValueInvalidRef.value) {
                  doUpdateValue(memorizedValueRef.value);
              }
          });
          provide(timePickerInjectionKey, {
              mergedThemeRef: themeRef,
              mergedClsPrefixRef
          });
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              }
          };
          const triggerCssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { iconColor, iconColorDisabled } } = themeRef.value;
              return {
                  '--n-icon-color-override': iconColor,
                  '--n-icon-color-disabled-override': iconColorDisabled,
                  '--n-bezier': cubicBezierEaseInOut
              };
          });
          const triggerThemeClassHandle = inlineThemeDisabled
              ? useThemeClass('time-picker-trigger', undefined, triggerCssVarsRef, props)
              : undefined;
          const cssVarsRef = computed(() => {
              const { self: { panelColor, itemTextColor, itemTextColorActive, itemColorHover, panelDividerColor, panelBoxShadow, itemOpacityDisabled, borderRadius, itemFontSize, itemWidth, itemHeight, panelActionPadding, itemBorderRadius }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-item-color-hover': itemColorHover,
                  '--n-item-font-size': itemFontSize,
                  '--n-item-height': itemHeight,
                  '--n-item-opacity-disabled': itemOpacityDisabled,
                  '--n-item-text-color': itemTextColor,
                  '--n-item-text-color-active': itemTextColorActive,
                  '--n-item-width': itemWidth,
                  '--n-panel-action-padding': panelActionPadding,
                  '--n-panel-box-shadow': panelBoxShadow,
                  '--n-panel-color': panelColor,
                  '--n-panel-divider-color': panelDividerColor,
                  '--n-item-border-radius': itemBorderRadius
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('time-picker', undefined, cssVarsRef, props)
              : undefined;
          return {
              focus: exposedMethods.focus,
              blur: exposedMethods.blur,
              mergedStatus: mergedStatusRef,
              mergedBordered: mergedBorderedRef,
              mergedClsPrefix: mergedClsPrefixRef,
              namespace: namespaceRef,
              uncontrolledValue: uncontrolledValueRef,
              mergedValue: mergedValueRef,
              isMounted: isMounted(),
              inputInstRef,
              panelInstRef,
              adjustedTo: useAdjustedTo(props),
              mergedShow: mergedShowRef,
              localizedNow: localizedNowRef,
              localizedPlaceholder: localizedPlaceholderRef,
              localizedNegativeText: localizedNegativeTextRef,
              localizedPositiveText: localizedPositiveTextRef,
              hourInFormat: hourInFormatRef,
              minuteInFormat: minuteInFormatRef,
              secondInFormat: secondInFormatRef,
              mergedAttrSize: mergedAttrSizeRef,
              displayTimeString: displayTimeStringRef,
              mergedSize: mergedSizeRef,
              mergedDisabled: mergedDisabledRef,
              isValueInvalid: isValueInvalidRef,
              isHourInvalid: isHourInvalidRef,
              isMinuteInvalid: isMinuteInvalidRef,
              isSecondInvalid: isSecondInvalidRef,
              transitionDisabled: transitionDisabledRef,
              hourValue: hourValueRef,
              minuteValue: minuteValueRef,
              secondValue: secondValueRef,
              amPmValue: amPmValueRef,
              handleInputKeydown,
              handleTimeInputFocus,
              handleTimeInputBlur,
              handleNowClick,
              handleConfirmClick,
              handleTimeInputUpdateValue,
              handleMenuFocusOut,
              handleCancelClick,
              handleClickOutside,
              handleTimeInputActivate,
              handleTimeInputDeactivate,
              handleHourClick,
              handleMinuteClick,
              handleSecondClick,
              handleAmPmClick,
              handleTimeInputClear,
              handleFocusDetectorFocus,
              handleMenuKeydown,
              handleTriggerClick,
              mergedTheme: themeRef,
              triggerCssVars: inlineThemeDisabled ? undefined : triggerCssVarsRef,
              triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass,
              triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, $slots, triggerOnRender } = this;
          triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
          return (h("div", { class: [`${mergedClsPrefix}-time-picker`, this.triggerThemeClass], style: this.triggerCssVars },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h(NInput, { ref: "inputInstRef", status: this.mergedStatus, value: this.displayTimeString, bordered: this.mergedBordered, passivelyActivated: true, attrSize: this.mergedAttrSize, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, stateful: this.stateful, size: this.mergedSize, placeholder: this.localizedPlaceholder, clearable: this.clearable, disabled: this.mergedDisabled, textDecoration: this.isValueInvalid ? 'line-through' : undefined, onFocus: this.handleTimeInputFocus, onBlur: this.handleTimeInputBlur, onActivate: this.handleTimeInputActivate, onDeactivate: this.handleTimeInputDeactivate, onUpdateValue: this.handleTimeInputUpdateValue, onClear: this.handleTimeInputClear, internalDeactivateOnEnter: true, internalForceFocus: this.mergedShow, readonly: this.inputReadonly || this.mergedDisabled, onClick: this.handleTriggerClick, onKeydown: this.handleInputKeydown }, this.showIcon
                              ? {
                                  [this.clearable
                                      ? 'clear-icon-placeholder'
                                      : 'suffix']: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-time-picker-icon` }, {
                                      default: () => $slots.icon ? $slots.icon() : h(TimeIcon, null)
                                  }))
                              }
                              : null))
                      }),
                      h(VFollower, { teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, show: this.mergedShow, to: this.adjustedTo, containerClass: this.namespace, placement: this.placement }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                              default: () => {
                                  var _a;
                                  if (this.mergedShow) {
                                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                                      return withDirectives(h(Panel, { ref: "panelInstRef", actions: this.actions, class: this.themeClass, style: this.cssVars, seconds: this.seconds, minutes: this.minutes, hours: this.hours, transitionDisabled: this.transitionDisabled, hourValue: this.hourValue, showHour: this.hourInFormat, isHourInvalid: this.isHourInvalid, isHourDisabled: this.isHourDisabled, minuteValue: this.minuteValue, showMinute: this.minuteInFormat, isMinuteInvalid: this.isMinuteInvalid, isMinuteDisabled: this.isMinuteDisabled, secondValue: this.secondValue, amPmValue: this.amPmValue, showSecond: this.secondInFormat, isSecondInvalid: this.isSecondInvalid, isSecondDisabled: this.isSecondDisabled, isValueInvalid: this.isValueInvalid, nowText: this.localizedNow, confirmText: this.localizedPositiveText, use12Hours: this.use12Hours, onFocusout: this.handleMenuFocusOut, onKeydown: this.handleMenuKeydown, onHourClick: this.handleHourClick, onMinuteClick: this.handleMinuteClick, onSecondClick: this.handleSecondClick, onAmPmClick: this.handleAmPmClick, onNowClick: this.handleNowClick, onConfirmClick: this.handleConfirmClick, onFocusDetectorFocus: this.handleFocusDetectorFocus }), [
                                          [
                                              clickoutside$1,
                                              this.handleClickOutside,
                                              undefined,
                                              { capture: true }
                                          ]
                                      ]);
                                  }
                                  return null;
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  const TIME_FORMAT = 'HH:mm:ss';
  const usePanelCommonProps = {
      active: Boolean,
      dateFormat: String,
      timeFormat: {
          type: String,
          value: TIME_FORMAT
      },
      value: {
          type: [Array, Number],
          default: null
      },
      shortcuts: Object,
      defaultTime: [Number, String, Array],
      onClear: Function,
      onConfirm: Function,
      onClose: Function,
      onTabOut: Function,
      onUpdateValue: {
          type: Function,
          required: true
      },
      themeClass: String,
      onRender: Function,
      panel: Boolean
  };
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function usePanelCommon(props) {
      const { dateLocaleRef, timePickerSizeRef, timePickerPropsRef, localeRef, mergedClsPrefixRef, mergedThemeRef
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
       } = inject(datePickerInjectionKey);
      const dateFnsOptionsRef = computed(() => {
          return {
              locale: dateLocaleRef.value.locale
          };
      });
      const selfRef = ref(null);
      const keyboardState = useKeyboard$1();
      function doClear() {
          const { onClear } = props;
          if (onClear)
              onClear();
      }
      function doConfirm() {
          const { onConfirm, value } = props;
          if (onConfirm)
              onConfirm(value);
      }
      function doUpdateValue(value, doUpdate) {
          const { onUpdateValue } = props;
          onUpdateValue(value, doUpdate);
      }
      function doClose(disableUpdateOnClose = false) {
          const { onClose } = props;
          if (onClose)
              onClose(disableUpdateOnClose);
      }
      function doTabOut() {
          const { onTabOut } = props;
          if (onTabOut)
              onTabOut();
      }
      function handleClearClick() {
          doUpdateValue(null, true);
          doClose(true);
          doClear();
      }
      function handleFocusDetectorFocus() {
          doTabOut();
      }
      function disableTransitionOneTick() {
          if (props.active || props.panel) {
              void nextTick(() => {
                  const { value: selfEl } = selfRef;
                  if (!selfEl)
                      return;
                  const dateEls = selfEl.querySelectorAll('[data-n-date]');
                  dateEls.forEach((el) => {
                      el.classList.add('transition-disabled');
                  });
                  void selfEl.offsetWidth;
                  dateEls.forEach((el) => {
                      el.classList.remove('transition-disabled');
                  });
              });
          }
      }
      function handlePanelKeyDown(e) {
          if (e.key === 'Tab' && e.target === selfRef.value && keyboardState.shift) {
              e.preventDefault();
              doTabOut();
          }
      }
      function handlePanelFocus(e) {
          const { value: el } = selfRef;
          if (keyboardState.tab &&
              e.target === el &&
              (el === null || el === void 0 ? void 0 : el.contains(e.relatedTarget))) {
              doTabOut();
          }
      }
      let cachedValue = null;
      let cached = false;
      function cachePendingValue() {
          cachedValue = props.value;
          cached = true;
      }
      function clearPendingValue() {
          cached = false;
      }
      function restorePendingValue() {
          if (cached) {
              doUpdateValue(cachedValue, false);
              cached = false;
          }
      }
      function getShortcutValue(shortcut) {
          if (typeof shortcut === 'function') {
              return shortcut();
          }
          return shortcut;
      }
      const showMonthYearPanel = ref(false);
      function handleOpenQuickSelectMonthPanel() {
          showMonthYearPanel.value = !showMonthYearPanel.value;
      }
      return {
          mergedTheme: mergedThemeRef,
          mergedClsPrefix: mergedClsPrefixRef,
          dateFnsOptions: dateFnsOptionsRef,
          timePickerSize: timePickerSizeRef,
          timePickerProps: timePickerPropsRef,
          selfRef,
          locale: localeRef,
          doConfirm,
          doClose,
          doUpdateValue,
          doTabOut,
          handleClearClick,
          handleFocusDetectorFocus,
          disableTransitionOneTick,
          handlePanelKeyDown,
          handlePanelFocus,
          cachePendingValue,
          clearPendingValue,
          restorePendingValue,
          getShortcutValue,
          handleShortcutMouseleave: restorePendingValue,
          showMonthYearPanel,
          handleOpenQuickSelectMonthPanel
      };
  }

  const useCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), { actions: {
          type: Array,
          default: () => ['now', 'clear', 'confirm']
      } });
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useCalendar(props, type) {
      const panelCommon = usePanelCommon(props);
      const { isValueInvalidRef, isDateDisabledRef, isDateInvalidRef, isTimeInvalidRef, isDateTimeInvalidRef, isHourDisabledRef, isMinuteDisabledRef, isSecondDisabledRef, localeRef, firstDayOfWeekRef, datePickerSlots
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
       } = inject(datePickerInjectionKey);
      const validation = {
          isValueInvalid: isValueInvalidRef,
          isDateDisabled: isDateDisabledRef,
          isDateInvalid: isDateInvalidRef,
          isTimeInvalid: isTimeInvalidRef,
          isDateTimeInvalid: isDateTimeInvalidRef,
          isHourDisabled: isHourDisabledRef,
          isMinuteDisabled: isMinuteDisabledRef,
          isSecondDisabled: isSecondDisabledRef
      };
      const mergedDateFormatRef = computed(() => props.dateFormat || localeRef.value.dateFormat);
      const dateInputValueRef = ref(props.value === null || Array.isArray(props.value)
          ? ''
          : format$4(props.value, mergedDateFormatRef.value));
      const calendarValueRef = ref(props.value === null || Array.isArray(props.value)
          ? Date.now()
          : props.value);
      const yearVlRef = ref(null);
      const yearScrollbarRef = ref(null);
      const monthScrollbarRef = ref(null);
      const nowRef = ref(Date.now());
      const dateArrayRef = computed(() => {
          var _a;
          return dateArray(calendarValueRef.value, props.value, nowRef.value, (_a = firstDayOfWeekRef.value) !== null && _a !== void 0 ? _a : localeRef.value.firstDayOfWeek);
      });
      const monthArrayRef = computed(() => {
          const { value } = props;
          return monthArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
      });
      const yearArrayRef = computed(() => {
          const { value } = props;
          return yearArray(Array.isArray(value) ? null : value, nowRef.value);
      });
      const quarterArrayRef = computed(() => {
          const { value } = props;
          return quarterArray(calendarValueRef.value, Array.isArray(value) ? null : value, nowRef.value);
      });
      const weekdaysRef = computed(() => {
          return dateArrayRef.value.slice(0, 7).map((dateItem) => {
              const { ts } = dateItem;
              return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
          });
      });
      const calendarMonthRef = computed(() => {
          return format$4(calendarValueRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const calendarYearRef = computed(() => {
          return format$4(calendarValueRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      watch(calendarValueRef, (value, oldValue) => {
          if (type === 'date' || type === 'datetime') {
              if (!isSameMonth(value, oldValue)) {
                  panelCommon.disableTransitionOneTick();
              }
          }
      });
      watch(computed(() => props.value), (value) => {
          if (value !== null && !Array.isArray(value)) {
              dateInputValueRef.value = format$4(value, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
              calendarValueRef.value = value;
          }
          else {
              dateInputValueRef.value = '';
          }
      });
      function sanitizeValue(value) {
          if (type === 'datetime')
              return getTime(startOfSecond(value));
          if (type === 'month')
              return getTime(startOfMonth(value));
          if (type === 'year')
              return getTime(startOfYear(value));
          if (type === 'quarter')
              return getTime(startOfQuarter(value));
          return getTime(startOfDay(value));
      }
      function mergedIsDateDisabled(ts) {
          const { isDateDisabled: { value: isDateDisabled } } = validation;
          if (!isDateDisabled)
              return false;
          return isDateDisabled(ts);
      }
      function handleDateInput(value) {
          const date = strictParse(value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date)) {
              if (props.value === null) {
                  panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), props.panel);
              }
              else if (!Array.isArray(props.value)) {
                  const newDateTime = set(props.value, {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), props.panel);
              }
          }
          else {
              dateInputValueRef.value = value;
          }
      }
      function handleDateInputBlur() {
          const date = strictParse(dateInputValueRef.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date)) {
              if (props.value === null) {
                  panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), false);
              }
              else if (!Array.isArray(props.value)) {
                  const newDateTime = set(props.value, {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  panelCommon.doUpdateValue(getTime(sanitizeValue(getTime(newDateTime))), false);
              }
          }
          else {
              deriveDateInputValue();
          }
      }
      function clearSelectedDateTime() {
          panelCommon.doUpdateValue(null, true);
          dateInputValueRef.value = '';
          panelCommon.doClose(true);
          panelCommon.handleClearClick();
      }
      function handleNowClick() {
          panelCommon.doUpdateValue(getTime(sanitizeValue(Date.now())), true);
          const now = Date.now();
          calendarValueRef.value = now;
          panelCommon.doClose(true);
          if (props.panel &&
              (type === 'month' || type === 'quarter' || type === 'year')) {
              panelCommon.disableTransitionOneTick();
              justifyColumnsScrollState(now);
          }
      }
      function handleDateClick(dateItem) {
          if (mergedIsDateDisabled(dateItem.ts)) {
              return;
          }
          let newValue;
          if (props.value !== null && !Array.isArray(props.value)) {
              newValue = props.value;
          }
          else {
              newValue = Date.now();
          }
          if (type === 'datetime' &&
              props.defaultTime !== null &&
              !Array.isArray(props.defaultTime)) {
              const time = getDefaultTime(props.defaultTime);
              if (time) {
                  newValue = getTime(set(newValue, time)); // setDate getTime(addMilliseconds(startOfDay(newValue), time))
              }
          }
          newValue = getTime(dateItem.type === 'quarter' && dateItem.dateObject.quarter
              ? setQuarter(setYear(newValue, dateItem.dateObject.year), dateItem.dateObject.quarter)
              : set(newValue, dateItem.dateObject));
          panelCommon.doUpdateValue(sanitizeValue(newValue), props.panel || type === 'date' || type === 'year');
          switch (type) {
              case 'date':
                  panelCommon.doClose();
                  break;
              case 'year':
                  if (props.panel) {
                      panelCommon.disableTransitionOneTick();
                  }
                  panelCommon.doClose();
                  break;
              case 'month':
                  panelCommon.disableTransitionOneTick();
                  justifyColumnsScrollState(newValue);
                  break;
              case 'quarter':
                  panelCommon.disableTransitionOneTick();
                  justifyColumnsScrollState(newValue);
                  break;
          }
      }
      function handleQuickMonthClick(dateItem, updatePanelValue) {
          let newValue;
          if (props.value !== null && !Array.isArray(props.value)) {
              newValue = props.value;
          }
          else {
              newValue = Date.now();
          }
          newValue = getTime(dateItem.type === 'month'
              ? setMonth(newValue, dateItem.dateObject.month)
              : setYear(newValue, dateItem.dateObject.year));
          updatePanelValue(newValue);
          justifyColumnsScrollState(newValue);
      }
      function onUpdateCalendarValue(value) {
          calendarValueRef.value = value;
      }
      function deriveDateInputValue(time) {
          // If not selected, display nothing,
          // else update datetime related string
          if (props.value === null || Array.isArray(props.value)) {
              dateInputValueRef.value = '';
              return;
          }
          if (time === undefined) {
              time = props.value;
          }
          dateInputValueRef.value = format$4(time, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
      }
      function handleConfirmClick() {
          if (validation.isDateInvalid.value || validation.isTimeInvalid.value) {
              return;
          }
          panelCommon.doConfirm();
          closeCalendar();
      }
      function closeCalendar() {
          if (props.active) {
              panelCommon.doClose();
          }
      }
      function nextYear() {
          calendarValueRef.value = getTime(addYears(calendarValueRef.value, 1));
      }
      function prevYear() {
          calendarValueRef.value = getTime(addYears(calendarValueRef.value, -1));
      }
      function nextMonth() {
          calendarValueRef.value = getTime(addMonths(calendarValueRef.value, 1));
      }
      function prevMonth() {
          calendarValueRef.value = getTime(addMonths(calendarValueRef.value, -1));
      }
      // For month type
      function virtualListContainer() {
          const { value } = yearVlRef;
          return (value === null || value === void 0 ? void 0 : value.listElRef) || null;
      }
      // For month type
      function virtualListContent() {
          const { value } = yearVlRef;
          return (value === null || value === void 0 ? void 0 : value.itemsElRef) || null;
      }
      // For month type
      function handleVirtualListScroll(e) {
          var _a;
          (_a = yearScrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function handleTimePickerChange(value) {
          if (value === null)
              return;
          panelCommon.doUpdateValue(value, props.panel);
      }
      function handleSingleShortcutMouseenter(shortcut) {
          panelCommon.cachePendingValue();
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (typeof shortcutValue !== 'number')
              return;
          panelCommon.doUpdateValue(shortcutValue, false);
      }
      function handleSingleShortcutClick(shortcut) {
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (typeof shortcutValue !== 'number')
              return;
          panelCommon.doUpdateValue(shortcutValue, props.panel);
          panelCommon.clearPendingValue();
          handleConfirmClick();
      }
      function justifyColumnsScrollState(value) {
          const { value: mergedValue } = props;
          if (monthScrollbarRef.value) {
              const monthIndex = value === undefined
                  ? mergedValue === null
                      ? getMonth(Date.now())
                      : getMonth(mergedValue)
                  : getMonth(value);
              monthScrollbarRef.value.scrollTo({ top: monthIndex * MONTH_ITEM_HEIGHT });
          }
          if (yearVlRef.value) {
              const yearIndex = (value === undefined
                  ? mergedValue === null
                      ? getYear(Date.now())
                      : getYear(mergedValue)
                  : getYear(value)) - START_YEAR;
              yearVlRef.value.scrollTo({ top: yearIndex * MONTH_ITEM_HEIGHT });
          }
      }
      const childComponentRefs = {
          monthScrollbarRef,
          yearScrollbarRef,
          yearVlRef
      };
      return Object.assign(Object.assign(Object.assign(Object.assign({ dateArray: dateArrayRef, monthArray: monthArrayRef, yearArray: yearArrayRef, quarterArray: quarterArrayRef, calendarYear: calendarYearRef, calendarMonth: calendarMonthRef, weekdays: weekdaysRef, mergedIsDateDisabled,
          nextYear,
          prevYear,
          nextMonth,
          prevMonth,
          handleNowClick,
          handleConfirmClick,
          handleSingleShortcutMouseenter,
          handleSingleShortcutClick }, validation), panelCommon), childComponentRefs), { 
          // datetime only
          handleDateClick,
          handleDateInputBlur,
          handleDateInput,
          handleTimePickerChange,
          clearSelectedDateTime,
          virtualListContainer,
          virtualListContent,
          handleVirtualListScroll, timePickerSize: panelCommon.timePickerSize, dateInputValue: dateInputValueRef, datePickerSlots,
          handleQuickMonthClick,
          justifyColumnsScrollState, calendarValue: calendarValueRef, onUpdateCalendarValue });
  }

  /**
   * Month Panel
   * Update picker value on:
   * 1. item click
   * 2. clear click
   */
  var MonthPanel = defineComponent({
      name: 'MonthPanel',
      props: Object.assign(Object.assign({}, useCalendarProps), { type: {
              type: String,
              required: true
          }, 
          // panelHeader prop
          useAsQuickJump: Boolean }),
      setup(props) {
          const useCalendarRef = useCalendar(props, props.type);
          const getRenderContent = (item) => {
              switch (item.type) {
                  case 'year':
                      return item.dateObject.year;
                  case 'month':
                      return item.dateObject.month + 1;
                  case 'quarter':
                      return `Q${item.dateObject.quarter}`;
              }
          };
          const { useAsQuickJump } = props;
          const renderItem = (item, i, mergedClsPrefix) => {
              const { mergedIsDateDisabled, handleDateClick, handleQuickMonthClick } = useCalendarRef;
              return (h("div", { "data-n-date": true, key: i, class: [
                      `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
                      {
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: !useAsQuickJump && mergedIsDateDisabled(item.ts)
                      }
                  ], onClick: () => {
                      useAsQuickJump
                          ? handleQuickMonthClick(item, (value) => {
                              props.onUpdateValue(value, false);
                          })
                          : handleDateClick(item);
                  } }, getRenderContent(item)));
          };
          onMounted(() => {
              useCalendarRef.justifyColumnsScrollState();
          });
          return Object.assign(Object.assign({}, useCalendarRef), { renderItem });
      },
      render() {
          const { mergedClsPrefix, mergedTheme, shortcuts, actions, renderItem, type, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--month`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onFocus: this.handlePanelFocus, onKeydown: this.handlePanelKeyDown },
              h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar` },
                  h(NScrollbar, { ref: "yearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: this.virtualListContainer, content: this.virtualListContent, horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                      default: () => (h(VVirtualList, { ref: "yearVlRef", items: this.yearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleVirtualListScroll, paddingBottom: 4 }, {
                          default: ({ item, index }) => {
                              return renderItem(item, index, mergedClsPrefix);
                          }
                      }))
                  }),
                  type === 'month' || type === 'quarter' ? (h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                      h(NScrollbar, { ref: "monthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => [
                              (type === 'month'
                                  ? this.monthArray
                                  : this.quarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix)),
                              h("div", { class: `${mergedClsPrefix}-date-panel-${type}-calendar__padding` })
                          ]
                      }))) : null),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, {
                  default: this.datePickerSlots.footer
              })) : null,
              (actions === null || actions === void 0 ? void 0 : actions.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ? null : (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleSingleShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleSingleShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key }));
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      (actions === null || actions === void 0 ? void 0 : actions.includes('clear')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear })) : null,
                      (actions === null || actions === void 0 ? void 0 : actions.includes('now')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now })) : null,
                      (actions === null || actions === void 0 ? void 0 : actions.includes('confirm')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isDateInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  var PanelHeader = defineComponent({
      props: {
          mergedClsPrefix: {
              type: String,
              required: true
          },
          value: Number,
          monthBeforeYear: {
              type: Boolean,
              required: true
          },
          calendarMonth: {
              type: String,
              required: true
          },
          calendarYear: {
              type: String,
              required: true
          },
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup() {
          const triggerRef = ref(null);
          const monthPanelRef = ref(null);
          const showRef = ref(false);
          function handleClickOutside(e) {
              var _a;
              if (showRef.value &&
                  !((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
                  showRef.value = false;
              }
          }
          function handleHeaderClick() {
              showRef.value = !showRef.value;
          }
          return {
              show: showRef,
              triggerRef,
              monthPanelRef,
              handleHeaderClick,
              handleClickOutside
          };
      },
      render() {
          const { handleClickOutside, mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-date-panel-month__month-year`, ref: "triggerRef" },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h("div", { class: [
                                  `${mergedClsPrefix}-date-panel-month__text`,
                                  this.show &&
                                      `${mergedClsPrefix}-date-panel-month__text--active`
                              ], onClick: this.handleHeaderClick }, this.monthBeforeYear
                              ? [this.calendarMonth, ' ', this.calendarYear]
                              : [this.calendarYear, ' ', this.calendarMonth]))
                      }),
                      h(VFollower, { show: this.show, teleportDisabled: true }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: true }, {
                              default: () => this.show
                                  ? withDirectives(h(MonthPanel, { ref: "monthPanelRef", onUpdateValue: this.onUpdateValue, actions: [], 
                                      // month and year click show month type
                                      type: "month", key: "month", useAsQuickJump: true, value: this.value }), [
                                      [
                                          clickoutside$1,
                                          handleClickOutside,
                                          undefined,
                                          { capture: true }
                                      ]
                                  ])
                                  : null
                          }))
                      })
                  ]
              })));
      }
  });

  /**
   * DateTime Panel
   * Update picker value on:
   * 1. confirm click
   * 2. clear click
   */
  var DatetimePanel = defineComponent({
      name: 'DateTimePanel',
      props: useCalendarProps,
      setup(props) {
          return useCalendar(props, 'datetime');
      },
      render() {
          var _a, _b, _c, _d;
          const { mergedClsPrefix, mergedTheme, shortcuts, timePickerProps, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--datetime`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
              h("div", { class: `${mergedClsPrefix}-date-panel-header` },
                  h(NInput, { value: this.dateInputValue, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, stateful: false, size: this.timePickerSize, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isDateInvalid ? 'line-through' : '', placeholder: this.locale.selectDate, onBlur: this.handleDateInputBlur, onUpdateValue: this.handleDateInput }),
                  h(NTimePicker, Object.assign({ size: this.timePickerSize, placeholder: this.locale.selectTime, format: this.timeFormat }, (Array.isArray(timePickerProps) ? undefined : timePickerProps), { showIcon: false, to: false, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, value: Array.isArray(this.value) ? null : this.value, isHourDisabled: this.isHourDisabled, isMinuteDisabled: this.isMinuteDisabled, isSecondDisabled: this.isSecondDisabled, onUpdateValue: this.handleTimePickerChange, stateful: false }))),
              h("div", { class: `${mergedClsPrefix}-date-panel-calendar` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.prevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.prevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.calendarValue, onUpdateValue: this.onUpdateCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.calendarMonth, calendarYear: this.calendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.nextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.nextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.dateArray.map((dateItem, i) => (h("div", { "data-n-date": true, key: i, class: [
                          `${mergedClsPrefix}-date-panel-date`,
                          {
                              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
                          }
                      ], onClick: () => {
                          this.handleDateClick(dateItem);
                      } },
                      h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                      dateItem.dateObject.date,
                      dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null))))),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer())) : null,
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ? null : (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleSingleShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleSingleShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key }));
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('clear')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.clearSelectedDateTime }, { default: () => this.locale.clear })) : null,
                      ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('now')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now })) : null,
                      ((_d = this.actions) === null || _d === void 0 ? void 0 : _d.includes('confirm')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isDateInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  const useDualCalendarProps = Object.assign(Object.assign({}, usePanelCommonProps), { defaultCalendarStartTime: Number, defaultCalendarEndTime: Number, bindCalendarMonths: Boolean, actions: {
          type: Array,
          default: () => ['clear', 'confirm']
      } });
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useDualCalendar(props, type) {
      var _a, _b;
      const { isDateDisabledRef, isStartHourDisabledRef, isEndHourDisabledRef, isStartMinuteDisabledRef, isEndMinuteDisabledRef, isStartSecondDisabledRef, isEndSecondDisabledRef, isStartDateInvalidRef, isEndDateInvalidRef, isStartTimeInvalidRef, isEndTimeInvalidRef, isStartValueInvalidRef, isEndValueInvalidRef, isRangeInvalidRef, localeRef, rangesRef, closeOnSelectRef, updateValueOnCloseRef, firstDayOfWeekRef, datePickerSlots
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
       } = inject(datePickerInjectionKey);
      const validation = {
          isDateDisabled: isDateDisabledRef,
          isStartHourDisabled: isStartHourDisabledRef,
          isEndHourDisabled: isEndHourDisabledRef,
          isStartMinuteDisabled: isStartMinuteDisabledRef,
          isEndMinuteDisabled: isEndMinuteDisabledRef,
          isStartSecondDisabled: isStartSecondDisabledRef,
          isEndSecondDisabled: isEndSecondDisabledRef,
          isStartDateInvalid: isStartDateInvalidRef,
          isEndDateInvalid: isEndDateInvalidRef,
          isStartTimeInvalid: isStartTimeInvalidRef,
          isEndTimeInvalid: isEndTimeInvalidRef,
          isStartValueInvalid: isStartValueInvalidRef,
          isEndValueInvalid: isEndValueInvalidRef,
          isRangeInvalid: isRangeInvalidRef
      };
      const panelCommon = usePanelCommon(props);
      const startDatesElRef = ref(null);
      const endDatesElRef = ref(null);
      const startYearScrollbarRef = ref(null);
      const endYearScrollbarRef = ref(null);
      const startYearVlRef = ref(null);
      const endYearVlRef = ref(null);
      const startMonthScrollbarRef = ref(null);
      const endMonthScrollbarRef = ref(null);
      const { value } = props;
      const defaultCalendarStartTime = (_a = props.defaultCalendarStartTime) !== null && _a !== void 0 ? _a : (Array.isArray(value) && typeof value[0] === 'number'
          ? value[0]
          : Date.now());
      const startCalendarDateTimeRef = ref(defaultCalendarStartTime);
      const endCalendarDateTimeRef = ref((_b = props.defaultCalendarEndTime) !== null && _b !== void 0 ? _b : (Array.isArray(value) && typeof value[1] === 'number'
          ? value[1]
          : getTime(addMonths(defaultCalendarStartTime, 1))));
      adjustCalendarTimes(true);
      const nowRef = ref(Date.now());
      const isSelectingRef = ref(false);
      const memorizedStartDateTimeRef = ref(0);
      const mergedDateFormatRef = computed(() => props.dateFormat || localeRef.value.dateFormat);
      const startDateInput = ref(Array.isArray(value)
          ? format$4(value[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value)
          : '');
      const endDateInputRef = ref(Array.isArray(value)
          ? format$4(value[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value)
          : '');
      // derived computed
      const selectingPhaseRef = computed(() => {
          if (isSelectingRef.value)
              return 'end';
          else
              return 'start';
      });
      const startDateArrayRef = computed(() => {
          var _a;
          return dateArray(startCalendarDateTimeRef.value, props.value, nowRef.value, (_a = firstDayOfWeekRef.value) !== null && _a !== void 0 ? _a : localeRef.value.firstDayOfWeek);
      });
      const endDateArrayRef = computed(() => {
          var _a;
          return dateArray(endCalendarDateTimeRef.value, props.value, nowRef.value, (_a = firstDayOfWeekRef.value) !== null && _a !== void 0 ? _a : localeRef.value.firstDayOfWeek);
      });
      const weekdaysRef = computed(() => {
          return startDateArrayRef.value.slice(0, 7).map((dateItem) => {
              const { ts } = dateItem;
              return format$4(ts, localeRef.value.dayFormat, panelCommon.dateFnsOptions.value);
          });
      });
      const startCalendarMonthRef = computed(() => {
          return format$4(startCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const endCalendarMonthRef = computed(() => {
          return format$4(endCalendarDateTimeRef.value, localeRef.value.monthFormat, panelCommon.dateFnsOptions.value);
      });
      const startCalendarYearRef = computed(() => {
          return format$4(startCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      const endCalendarYearRef = computed(() => {
          return format$4(endCalendarDateTimeRef.value, localeRef.value.yearFormat, panelCommon.dateFnsOptions.value);
      });
      const startTimeValueRef = computed(() => {
          const { value } = props;
          if (Array.isArray(value))
              return value[0];
          return null;
      });
      const endTimeValueRef = computed(() => {
          const { value } = props;
          if (Array.isArray(value))
              return value[1];
          return null;
      });
      const shortcutsRef = computed(() => {
          const { shortcuts } = props;
          return shortcuts || rangesRef.value;
      });
      const startYearArrayRef = computed(() => {
          return yearArray(pluckValueFromRange(props.value, 'start'), nowRef.value);
      });
      const endYearArrayRef = computed(() => {
          return yearArray(pluckValueFromRange(props.value, 'end'), nowRef.value);
      });
      const startQuarterArrayRef = computed(() => {
          const startValue = pluckValueFromRange(props.value, 'start');
          return quarterArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value);
      });
      const endQuarterArrayRef = computed(() => {
          const endValue = pluckValueFromRange(props.value, 'end');
          return quarterArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value);
      });
      const startMonthArrayRef = computed(() => {
          const startValue = pluckValueFromRange(props.value, 'start');
          return monthArray(startValue !== null && startValue !== void 0 ? startValue : Date.now(), startValue, nowRef.value);
      });
      const endMonthArrayRef = computed(() => {
          const endValue = pluckValueFromRange(props.value, 'end');
          return monthArray(endValue !== null && endValue !== void 0 ? endValue : Date.now(), endValue, nowRef.value);
      });
      watch(computed(() => props.value), (value) => {
          if (value !== null && Array.isArray(value)) {
              const [startMoment, endMoment] = value;
              startDateInput.value = format$4(startMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
              endDateInputRef.value = format$4(endMoment, mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
              if (!isSelectingRef.value) {
                  syncCalendarTimeWithValue(value);
              }
          }
          else {
              startDateInput.value = '';
              endDateInputRef.value = '';
          }
      });
      function handleCalendarChange(value, oldValue) {
          if (type === 'daterange' || type === 'datetimerange') {
              if (getYear(value) !== getYear(oldValue) ||
                  getMonth(value) !== getMonth(oldValue)) {
                  panelCommon.disableTransitionOneTick();
              }
          }
      }
      watch(startCalendarDateTimeRef, handleCalendarChange);
      watch(endCalendarDateTimeRef, handleCalendarChange);
      // change calendar
      function adjustCalendarTimes(byStartCalendarTime) {
          const startTime = startOfMonth(startCalendarDateTimeRef.value);
          const endTime = startOfMonth(endCalendarDateTimeRef.value);
          if (props.bindCalendarMonths || startTime >= endTime) {
              if (byStartCalendarTime) {
                  endCalendarDateTimeRef.value = getTime(addMonths(startTime, 1));
              }
              else {
                  startCalendarDateTimeRef.value = getTime(addMonths(endTime, -1));
              }
          }
      }
      function startCalendarNextYear() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 12));
          adjustCalendarTimes(true);
      }
      function startCalendarPrevYear() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -12));
          adjustCalendarTimes(true);
      }
      function startCalendarNextMonth() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, 1));
          adjustCalendarTimes(true);
      }
      function startCalendarPrevMonth() {
          startCalendarDateTimeRef.value = getTime(addMonths(startCalendarDateTimeRef.value, -1));
          adjustCalendarTimes(true);
      }
      function endCalendarNextYear() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 12));
          adjustCalendarTimes(false);
      }
      function endCalendarPrevYear() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -12));
          adjustCalendarTimes(false);
      }
      function endCalendarNextMonth() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, 1));
          adjustCalendarTimes(false);
      }
      function endCalendarPrevMonth() {
          endCalendarDateTimeRef.value = getTime(addMonths(endCalendarDateTimeRef.value, -1));
          adjustCalendarTimes(false);
      }
      function onUpdateStartCalendarValue(value) {
          startCalendarDateTimeRef.value = value;
          adjustCalendarTimes(true);
      }
      function onUpdateEndCalendarValue(value) {
          endCalendarDateTimeRef.value = value;
          adjustCalendarTimes(false);
      }
      // The function is used on date panel, not the date-picker value validation
      function mergedIsDateDisabled(ts) {
          const isDateDisabled = isDateDisabledRef.value;
          if (!isDateDisabled)
              return false;
          if (!Array.isArray(props.value))
              return isDateDisabled(ts, 'start', null);
          if (selectingPhaseRef.value === 'start') {
              // before you really start to select
              return isDateDisabled(ts, 'start', null);
          }
          else {
              const { value: memorizedStartDateTime } = memorizedStartDateTimeRef;
              // after you starting to select
              if (ts < memorizedStartDateTimeRef.value) {
                  return isDateDisabled(ts, 'start', [
                      memorizedStartDateTime,
                      memorizedStartDateTime
                  ]);
              }
              else {
                  return isDateDisabled(ts, 'end', [
                      memorizedStartDateTime,
                      memorizedStartDateTime
                  ]);
              }
          }
      }
      function syncCalendarTimeWithValue(value) {
          if (value === null)
              return;
          const [startMoment, endMoment] = value;
          startCalendarDateTimeRef.value = startMoment;
          if (startOfMonth(endMoment) <= startOfMonth(startMoment)) {
              endCalendarDateTimeRef.value = getTime(startOfMonth(addMonths(startMoment, 1)));
          }
          else {
              endCalendarDateTimeRef.value = getTime(startOfMonth(endMoment));
          }
      }
      // for daterange & datetimerange
      function handleDateClick(dateItem) {
          if (!isSelectingRef.value) {
              isSelectingRef.value = true;
              memorizedStartDateTimeRef.value = dateItem.ts;
              changeStartEndTime(dateItem.ts, dateItem.ts, 'done');
          }
          else {
              isSelectingRef.value = false;
              const { value } = props;
              if (props.panel && Array.isArray(value)) {
                  changeStartEndTime(value[0], value[1], 'done');
              }
              else {
                  if (closeOnSelectRef.value && type === 'daterange') {
                      if (updateValueOnCloseRef.value) {
                          closeCalendar();
                      }
                      else {
                          handleConfirmClick();
                      }
                  }
              }
          }
      }
      function handleDateMouseEnter(dateItem) {
          if (isSelectingRef.value) {
              if (mergedIsDateDisabled(dateItem.ts))
                  return;
              if (dateItem.ts >= memorizedStartDateTimeRef.value) {
                  changeStartEndTime(memorizedStartDateTimeRef.value, dateItem.ts, 'wipPreview');
              }
              else {
                  changeStartEndTime(dateItem.ts, memorizedStartDateTimeRef.value, 'wipPreview');
              }
          }
      }
      function handleConfirmClick() {
          if (isRangeInvalidRef.value) {
              return;
          }
          panelCommon.doConfirm();
          closeCalendar();
      }
      function closeCalendar() {
          isSelectingRef.value = false;
          if (props.active) {
              panelCommon.doClose();
          }
      }
      function changeStartDateTime(time) {
          if (typeof time !== 'number') {
              time = getTime(time);
          }
          if (props.value === null) {
              panelCommon.doUpdateValue([time, time], props.panel);
          }
          else if (Array.isArray(props.value)) {
              panelCommon.doUpdateValue([time, Math.max(props.value[1], time)], props.panel);
          }
      }
      function changeEndDateTime(time) {
          if (typeof time !== 'number') {
              time = getTime(time);
          }
          if (props.value === null) {
              panelCommon.doUpdateValue([time, time], props.panel);
          }
          else if (Array.isArray(props.value)) {
              panelCommon.doUpdateValue([Math.min(props.value[0], time), time], props.panel);
          }
      }
      function changeStartEndTime(startTime, endTime, source) {
          if (typeof startTime !== 'number') {
              startTime = getTime(startTime);
          }
          if (source !== 'shortcutPreview') {
              let startDefaultTime;
              let endDefaultTime;
              if (type === 'datetimerange') {
                  const { defaultTime } = props;
                  if (Array.isArray(defaultTime)) {
                      startDefaultTime = getDefaultTime(defaultTime[0]);
                      endDefaultTime = getDefaultTime(defaultTime[1]);
                  }
                  else {
                      startDefaultTime = getDefaultTime(defaultTime);
                      endDefaultTime = startDefaultTime;
                  }
              }
              if (startDefaultTime) {
                  startTime = getTime(set(startTime, startDefaultTime));
              }
              if (endDefaultTime) {
                  endTime = getTime(set(endTime, endDefaultTime));
              }
          }
          panelCommon.doUpdateValue([startTime, endTime], props.panel && source === 'done');
      }
      function sanitizeValue(datetime) {
          if (type === 'datetimerange') {
              return getTime(startOfSecond(datetime));
          }
          else if (type === 'monthrange') {
              return getTime(startOfMonth(datetime));
          }
          else {
              // daterange
              return getTime(startOfDay(datetime));
          }
      }
      function handleStartDateInput(value) {
          const date = strictParse(value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date)) {
              if (!props.value) {
                  const newValue = set(new Date(), {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeStartDateTime(sanitizeValue(getTime(newValue)));
              }
              else if (Array.isArray(props.value)) {
                  const newValue = set(props.value[0], {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeStartDateTime(sanitizeValue(getTime(newValue)));
              }
          }
          else {
              startDateInput.value = value;
          }
      }
      function handleEndDateInput(value) {
          /** strict check when input */
          const date = strictParse(value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          if (isValid$1(date)) {
              if (props.value === null) {
                  const newValue = set(new Date(), {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeEndDateTime(sanitizeValue(getTime(newValue)));
              }
              else if (Array.isArray(props.value)) {
                  const newValue = set(props.value[1], {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeEndDateTime(sanitizeValue(getTime(newValue)));
              }
          }
          else {
              endDateInputRef.value = value;
          }
      }
      function handleStartDateInputBlur() {
          const date = strictParse(startDateInput.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          const { value } = props;
          if (isValid$1(date)) {
              if (value === null) {
                  const newValue = set(new Date(), {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeStartDateTime(sanitizeValue(getTime(newValue)));
              }
              else if (Array.isArray(value)) {
                  const newValue = set(value[0], {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeStartDateTime(sanitizeValue(getTime(newValue)));
              }
          }
          else {
              refreshDisplayDateString();
          }
      }
      function handleEndDateInputBlur() {
          const date = strictParse(endDateInputRef.value, mergedDateFormatRef.value, new Date(), panelCommon.dateFnsOptions.value);
          const { value } = props;
          if (isValid$1(date)) {
              if (value === null) {
                  const newValue = set(new Date(), {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeEndDateTime(sanitizeValue(getTime(newValue)));
              }
              else if (Array.isArray(value)) {
                  const newValue = set(value[1], {
                      year: getYear(date),
                      month: getMonth(date),
                      date: getDate(date)
                  });
                  changeEndDateTime(sanitizeValue(getTime(newValue)));
              }
          }
          else {
              refreshDisplayDateString();
          }
      }
      function refreshDisplayDateString(times) {
          // If not selected, display nothing,
          // else update datetime related string
          const { value } = props;
          if (value === null || !Array.isArray(value)) {
              startDateInput.value = '';
              endDateInputRef.value = '';
              return;
          }
          if (times === undefined) {
              times = value;
          }
          startDateInput.value = format$4(times[0], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
          endDateInputRef.value = format$4(times[1], mergedDateFormatRef.value, panelCommon.dateFnsOptions.value);
      }
      function handleStartTimePickerChange(value) {
          if (value === null)
              return;
          changeStartDateTime(value);
      }
      function handleEndTimePickerChange(value) {
          if (value === null)
              return;
          changeEndDateTime(value);
      }
      function handleRangeShortcutMouseenter(shortcut) {
          panelCommon.cachePendingValue();
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (!Array.isArray(shortcutValue))
              return;
          changeStartEndTime(shortcutValue[0], shortcutValue[1], 'shortcutPreview');
      }
      function handleRangeShortcutClick(shortcut) {
          const shortcutValue = panelCommon.getShortcutValue(shortcut);
          if (!Array.isArray(shortcutValue))
              return;
          changeStartEndTime(shortcutValue[0], shortcutValue[1], 'done');
          panelCommon.clearPendingValue();
          handleConfirmClick();
      }
      function justifyColumnsScrollState(value, type) {
          const mergedValue = value === undefined ? props.value : value;
          if (value === undefined || type === 'start') {
              if (startMonthScrollbarRef.value) {
                  const monthIndex = !Array.isArray(mergedValue)
                      ? getMonth(Date.now())
                      : getMonth(mergedValue[0]);
                  startMonthScrollbarRef.value.scrollTo({
                      debounce: false,
                      index: monthIndex,
                      elSize: MONTH_ITEM_HEIGHT
                  });
              }
              if (startYearVlRef.value) {
                  const yearIndex = (!Array.isArray(mergedValue)
                      ? getYear(Date.now())
                      : getYear(mergedValue[0])) - START_YEAR;
                  startYearVlRef.value.scrollTo({ index: yearIndex, debounce: false });
              }
          }
          if (value === undefined || type === 'end') {
              if (endMonthScrollbarRef.value) {
                  const monthIndex = !Array.isArray(mergedValue)
                      ? getMonth(Date.now())
                      : getMonth(mergedValue[1]);
                  endMonthScrollbarRef.value.scrollTo({
                      debounce: false,
                      index: monthIndex,
                      elSize: MONTH_ITEM_HEIGHT
                  });
              }
              if (endYearVlRef.value) {
                  const yearIndex = (!Array.isArray(mergedValue)
                      ? getYear(Date.now())
                      : getYear(mergedValue[1])) - START_YEAR;
                  endYearVlRef.value.scrollTo({ index: yearIndex, debounce: false });
              }
          }
      }
      // only for monthrange
      function handleColItemClick(dateItem, clickType) {
          const { value } = props;
          const noCurrentValue = !Array.isArray(value);
          const itemTs = dateItem.type === 'year' && type !== 'yearrange'
              ? noCurrentValue
                  ? set(dateItem.ts, {
                      month: getMonth(type === 'quarterrange'
                          ? startOfQuarter(new Date())
                          : new Date())
                  }).valueOf()
                  : set(dateItem.ts, {
                      month: getMonth(type === 'quarterrange'
                          ? startOfQuarter(value[clickType === 'start' ? 0 : 1])
                          : value[clickType === 'start' ? 0 : 1])
                  }).valueOf()
              : dateItem.ts;
          if (noCurrentValue) {
              const partialValue = sanitizeValue(itemTs);
              const nextValue = [partialValue, partialValue];
              panelCommon.doUpdateValue(nextValue, props.panel);
              justifyColumnsScrollState(nextValue, 'start');
              justifyColumnsScrollState(nextValue, 'end');
              panelCommon.disableTransitionOneTick();
              return;
          }
          const nextValue = [value[0], value[1]];
          let otherPartsChanged = false;
          if (clickType === 'start') {
              nextValue[0] = sanitizeValue(itemTs);
              if (nextValue[0] > nextValue[1]) {
                  nextValue[1] = nextValue[0];
                  otherPartsChanged = true;
              }
          }
          else {
              nextValue[1] = sanitizeValue(itemTs);
              if (nextValue[0] > nextValue[1]) {
                  nextValue[0] = nextValue[1];
                  otherPartsChanged = true;
              }
          }
          panelCommon.doUpdateValue(nextValue, props.panel);
          switch (type) {
              case 'monthrange':
              case 'quarterrange':
                  panelCommon.disableTransitionOneTick();
                  if (otherPartsChanged) {
                      justifyColumnsScrollState(nextValue, 'start');
                      justifyColumnsScrollState(nextValue, 'end');
                  }
                  else {
                      justifyColumnsScrollState(nextValue, clickType);
                  }
                  break;
              case 'yearrange':
                  panelCommon.disableTransitionOneTick();
                  justifyColumnsScrollState(nextValue, 'start');
                  justifyColumnsScrollState(nextValue, 'end');
          }
      }
      function handleStartYearVlScroll() {
          var _a;
          (_a = startYearScrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function handleEndYearVlScroll() {
          var _a;
          (_a = endYearScrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
      }
      function virtualListContainer(type) {
          var _a, _b;
          if (type === 'start') {
              return ((_a = startYearVlRef.value) === null || _a === void 0 ? void 0 : _a.listElRef) || null;
          }
          else {
              return ((_b = endYearVlRef.value) === null || _b === void 0 ? void 0 : _b.listElRef) || null;
          }
      }
      function virtualListContent(type) {
          var _a, _b;
          if (type === 'start') {
              return ((_a = startYearVlRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef) || null;
          }
          else {
              return ((_b = endYearVlRef.value) === null || _b === void 0 ? void 0 : _b.itemsElRef) || null;
          }
      }
      const childComponentRefs = {
          startYearVlRef,
          endYearVlRef,
          startMonthScrollbarRef,
          endMonthScrollbarRef,
          startYearScrollbarRef,
          endYearScrollbarRef
      };
      return Object.assign(Object.assign(Object.assign(Object.assign({ startDatesElRef,
          endDatesElRef,
          handleDateClick,
          handleColItemClick,
          handleDateMouseEnter,
          handleConfirmClick,
          startCalendarPrevYear,
          startCalendarPrevMonth,
          startCalendarNextYear,
          startCalendarNextMonth,
          endCalendarPrevYear,
          endCalendarPrevMonth,
          endCalendarNextMonth,
          endCalendarNextYear,
          mergedIsDateDisabled,
          changeStartEndTime, ranges: rangesRef, startCalendarMonth: startCalendarMonthRef, startCalendarYear: startCalendarYearRef, endCalendarMonth: endCalendarMonthRef, endCalendarYear: endCalendarYearRef, weekdays: weekdaysRef, startDateArray: startDateArrayRef, endDateArray: endDateArrayRef, startYearArray: startYearArrayRef, startMonthArray: startMonthArrayRef, startQuarterArray: startQuarterArrayRef, endYearArray: endYearArrayRef, endMonthArray: endMonthArrayRef, endQuarterArray: endQuarterArrayRef, isSelecting: isSelectingRef, handleRangeShortcutMouseenter,
          handleRangeShortcutClick }, panelCommon), validation), childComponentRefs), { 
          // datetimerangeonly
          startDateDisplayString: startDateInput, endDateInput: endDateInputRef, timePickerSize: panelCommon.timePickerSize, startTimeValue: startTimeValueRef, endTimeValue: endTimeValueRef, datePickerSlots, shortcuts: shortcutsRef, startCalendarDateTime: startCalendarDateTimeRef, endCalendarDateTime: endCalendarDateTimeRef, justifyColumnsScrollState, handleFocusDetectorFocus: panelCommon.handleFocusDetectorFocus, handleStartTimePickerChange,
          handleEndTimePickerChange,
          handleStartDateInput,
          handleStartDateInputBlur,
          handleEndDateInput,
          handleEndDateInputBlur,
          handleStartYearVlScroll,
          handleEndYearVlScroll,
          virtualListContainer,
          virtualListContent,
          onUpdateStartCalendarValue,
          onUpdateEndCalendarValue });
  }

  var DatetimerangePanel = defineComponent({
      name: 'DateTimeRangePanel',
      props: useDualCalendarProps,
      setup(props) {
          return useDualCalendar(props, 'datetimerange');
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, timePickerProps, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--datetimerange`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
              h("div", { class: `${mergedClsPrefix}-date-panel-header` },
                  h(NInput, { value: this.startDateDisplayString, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, size: this.timePickerSize, stateful: false, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isStartValueInvalid ? 'line-through' : '', placeholder: this.locale.selectDate, onBlur: this.handleStartDateInputBlur, onUpdateValue: this.handleStartDateInput }),
                  h(NTimePicker, Object.assign({ placeholder: this.locale.selectTime, format: this.timeFormat, size: this.timePickerSize }, (Array.isArray(timePickerProps)
                      ? timePickerProps[0]
                      : timePickerProps), { value: this.startTimeValue, to: false, showIcon: false, disabled: this.isSelecting, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, stateful: false, isHourDisabled: this.isStartHourDisabled, isMinuteDisabled: this.isStartMinuteDisabled, isSecondDisabled: this.isStartSecondDisabled, onUpdateValue: this.handleStartTimePickerChange })),
                  h(NInput, { value: this.endDateInput, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, stateful: false, size: this.timePickerSize, class: `${mergedClsPrefix}-date-panel-date-input`, textDecoration: this.isEndValueInvalid ? 'line-through' : '', placeholder: this.locale.selectDate, onBlur: this.handleEndDateInputBlur, onUpdateValue: this.handleEndDateInput }),
                  h(NTimePicker, Object.assign({ placeholder: this.locale.selectTime, format: this.timeFormat, size: this.timePickerSize }, (Array.isArray(timePickerProps)
                      ? timePickerProps[1]
                      : timePickerProps), { disabled: this.isSelecting, showIcon: false, theme: mergedTheme.peers.TimePicker, themeOverrides: mergedTheme.peerOverrides.TimePicker, to: false, stateful: false, value: this.endTimeValue, isHourDisabled: this.isEndHourDisabled, isMinuteDisabled: this.isEndMinuteDisabled, isSecondDisabled: this.isEndSecondDisabled, onUpdateValue: this.handleEndTimePickerChange }))),
              h("div", { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.startCalendarPrevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.startCalendarPrevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.startCalendarDateTime, onUpdateValue: this.onUpdateStartCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.startCalendarMonth, calendarYear: this.startCalendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.startCalendarNextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.startCalendarNextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.startDateArray.map((dateItem, i) => {
                      const disabled = this.mergedIsDateDisabled(dateItem.ts);
                      return (h("div", { "data-n-date": true, key: i, class: [
                              `${mergedClsPrefix}-date-panel-date`,
                              {
                                  [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                                  [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                                  [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                                  [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                                  [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                                  [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                                  [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
                              }
                          ], onClick: disabled
                              ? undefined
                              : () => {
                                  this.handleDateClick(dateItem);
                              }, onMouseenter: disabled
                              ? undefined
                              : () => {
                                  this.handleDateMouseEnter(dateItem);
                              } },
                          h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                          dateItem.dateObject.date,
                          dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null));
                  }))),
              h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
              h("div", { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.endCalendarPrevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.endCalendarPrevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.endCalendarDateTime, onUpdateValue: this.onUpdateEndCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.endCalendarMonth, calendarYear: this.endCalendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.endCalendarNextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.endCalendarNextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.endDateArray.map((dateItem, i) => {
                      const disabled = this.mergedIsDateDisabled(dateItem.ts);
                      return (h("div", { "data-n-date": true, key: i, class: [
                              `${mergedClsPrefix}-date-panel-date`,
                              {
                                  [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                                  [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                                  [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                                  [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                                  [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                                  [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                                  [`${mergedClsPrefix}-date-panel-date--disabled`]: disabled
                              }
                          ], onClick: disabled
                              ? undefined
                              : () => {
                                  this.handleDateClick(dateItem);
                              }, onMouseenter: disabled
                              ? undefined
                              : () => {
                                  this.handleDateMouseEnter(dateItem);
                              } },
                          h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                          dateItem.dateObject.date,
                          dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null));
                  }))),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer())) : null,
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ||
                              typeof shortcut === 'function' ? (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleRangeShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleRangeShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key })) : null;
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('clear')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear })) : null,
                      ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('confirm')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid || this.isSelecting, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  /**
   * Date Panel
   * Update picker value on:
   * 1. item click
   * 2. clear click
   */
  var DatePanel = defineComponent({
      name: 'DatePanel',
      props: useCalendarProps,
      setup(props) {
          return useCalendar(props, 'date');
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--date`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onFocus: this.handlePanelFocus, onKeydown: this.handlePanelKeyDown },
              h("div", { class: `${mergedClsPrefix}-date-panel-calendar` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.prevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.prevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.calendarValue, onUpdateValue: this.onUpdateCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.calendarMonth, calendarYear: this.calendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.nextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.nextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.dateArray.map((dateItem, i) => (h("div", { "data-n-date": true, key: i, class: [
                          `${mergedClsPrefix}-date-panel-date`,
                          {
                              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
                          }
                      ], onClick: () => {
                          this.handleDateClick(dateItem);
                      } },
                      h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                      dateItem.dateObject.date,
                      dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null))))),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer())) : null,
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ? null : (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleSingleShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleSingleShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key }));
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('clear')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear })) : null,
                      ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('now')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleNowClick }, { default: () => this.locale.now })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  var DaterangePanel = defineComponent({
      name: 'DateRangePanel',
      props: useDualCalendarProps,
      setup(props) {
          return useDualCalendar(props, 'daterange');
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--daterange`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
              h("div", { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.startCalendarPrevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.startCalendarPrevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.startCalendarDateTime, onUpdateValue: this.onUpdateStartCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.startCalendarMonth, calendarYear: this.startCalendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.startCalendarNextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.startCalendarNextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.startDateArray.map((dateItem, i) => (h("div", { "data-n-date": true, key: i, class: [
                          `${mergedClsPrefix}-date-panel-date`,
                          {
                              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                              [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                              [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                              [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
                          }
                      ], onClick: () => {
                          this.handleDateClick(dateItem);
                      }, onMouseenter: () => {
                          this.handleDateMouseEnter(dateItem);
                      } },
                      h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                      dateItem.dateObject.date,
                      dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null))))),
              h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
              h("div", { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month` },
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-prev`, onClick: this.endCalendarPrevYear }, resolveSlot($slots['prev-year'], () => [h(FastBackwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__prev`, onClick: this.endCalendarPrevMonth }, resolveSlot($slots['prev-month'], () => [h(BackwardIcon, null)])),
                      h(PanelHeader, { monthBeforeYear: this.locale.monthBeforeYear, value: this.endCalendarDateTime, onUpdateValue: this.onUpdateEndCalendarValue, mergedClsPrefix: mergedClsPrefix, calendarMonth: this.endCalendarMonth, calendarYear: this.endCalendarYear }),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__next`, onClick: this.endCalendarNextMonth }, resolveSlot($slots['next-month'], () => [h(ForwardIcon, null)])),
                      h("div", { class: `${mergedClsPrefix}-date-panel-month__fast-next`, onClick: this.endCalendarNextYear }, resolveSlot($slots['next-year'], () => [h(FastForwardIcon, null)]))),
                  h("div", { class: `${mergedClsPrefix}-date-panel-weekdays` }, this.weekdays.map((weekday) => (h("div", { key: weekday, class: `${mergedClsPrefix}-date-panel-weekdays__day` }, weekday)))),
                  h("div", { class: `${mergedClsPrefix}-date-panel__divider` }),
                  h("div", { class: `${mergedClsPrefix}-date-panel-dates` }, this.endDateArray.map((dateItem, i) => (h("div", { "data-n-date": true, key: i, class: [
                          `${mergedClsPrefix}-date-panel-date`,
                          {
                              [`${mergedClsPrefix}-date-panel-date--excluded`]: !dateItem.inCurrentMonth,
                              [`${mergedClsPrefix}-date-panel-date--current`]: dateItem.isCurrentDate,
                              [`${mergedClsPrefix}-date-panel-date--selected`]: dateItem.selected,
                              [`${mergedClsPrefix}-date-panel-date--covered`]: dateItem.inSpan,
                              [`${mergedClsPrefix}-date-panel-date--start`]: dateItem.startOfSpan,
                              [`${mergedClsPrefix}-date-panel-date--end`]: dateItem.endOfSpan,
                              [`${mergedClsPrefix}-date-panel-date--disabled`]: this.mergedIsDateDisabled(dateItem.ts)
                          }
                      ], onClick: () => {
                          this.handleDateClick(dateItem);
                      }, onMouseenter: () => {
                          this.handleDateMouseEnter(dateItem);
                      } },
                      h("div", { class: `${mergedClsPrefix}-date-panel-date__trigger` }),
                      dateItem.dateObject.date,
                      dateItem.isCurrentDate ? (h("div", { class: `${mergedClsPrefix}-date-panel-date__sup` })) : null))))),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, this.datePickerSlots.footer())) : null,
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ||
                              typeof shortcut === 'function' ? (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleRangeShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleRangeShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key })) : null;
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('clear')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear })) : null,
                      ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('confirm')) ? (h(NButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid || this.isSelecting, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  var MonthRangePanel = defineComponent({
      name: 'MonthRangePanel',
      props: Object.assign(Object.assign({}, useDualCalendarProps), { type: {
              type: String,
              required: true
          } }),
      setup(props) {
          const useCalendarRef = useDualCalendar(props, props.type);
          const renderItem = (item, i, mergedClsPrefix, type) => {
              const { handleColItemClick } = useCalendarRef;
              // TODO
              const disabled = false;
              return (h("div", { "data-n-date": true, key: i, class: [
                      `${mergedClsPrefix}-date-panel-month-calendar__picker-col-item`,
                      {
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--current`]: item.isCurrent,
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--selected`]: item.selected,
                          [`${mergedClsPrefix}-date-panel-month-calendar__picker-col-item--disabled`]: disabled
                      }
                  ], onClick: () => {
                          handleColItemClick(item, type);
                      } }, item.type === 'month'
                  ? item.dateObject.month + 1
                  : item.type === 'quarter'
                      ? `Q${item.dateObject.quarter}`
                      : item.dateObject.year));
          };
          onMounted(() => {
              useCalendarRef.justifyColumnsScrollState();
          });
          return Object.assign(Object.assign({}, useCalendarRef), { renderItem });
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix, mergedTheme, shortcuts, type, renderItem, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { ref: "selfRef", tabindex: 0, class: [
                  `${mergedClsPrefix}-date-panel`,
                  `${mergedClsPrefix}-date-panel--daterange`,
                  !this.panel && `${mergedClsPrefix}-date-panel--shadow`,
                  this.themeClass
              ], onKeydown: this.handlePanelKeyDown, onFocus: this.handlePanelFocus },
              h("div", { ref: "startDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--start` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar` },
                      h(NScrollbar, { ref: "startYearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: () => this.virtualListContainer('start'), content: () => this.virtualListContent('start'), horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                          default: () => (h(VVirtualList, { ref: "startYearVlRef", items: this.startYearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleStartYearVlScroll, paddingBottom: 4 }, {
                              default: ({ item, index }) => {
                                  return renderItem(item, index, mergedClsPrefix, 'start');
                              }
                          }))
                      }),
                      type === 'monthrange' || type === 'quarterrange' ? (h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                          h(NScrollbar, { ref: "startMonthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                              default: () => [
                                  (type === 'monthrange'
                                      ? this.startMonthArray
                                      : this.startQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, 'start')),
                                  type === 'monthrange' && (h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__padding` }))
                              ]
                          }))) : null)),
              h("div", { class: `${mergedClsPrefix}-date-panel__vertical-divider` }),
              h("div", { ref: "endDatesElRef", class: `${mergedClsPrefix}-date-panel-calendar ${mergedClsPrefix}-date-panel-calendar--end` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar` },
                      h(NScrollbar, { ref: "endYearScrollbarRef", class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col`, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: () => this.virtualListContainer('end'), content: () => this.virtualListContent('end'), horizontalRailStyle: { zIndex: 1 }, verticalRailStyle: { zIndex: 1 } }, {
                          default: () => (h(VVirtualList, { ref: "endYearVlRef", items: this.endYearArray, itemSize: MONTH_ITEM_HEIGHT, showScrollbar: false, keyField: "ts", onScroll: this.handleEndYearVlScroll, paddingBottom: 4 }, {
                              default: ({ item, index }) => {
                                  return renderItem(item, index, mergedClsPrefix, 'end');
                              }
                          }))
                      }),
                      type === 'monthrange' || type === 'quarterrange' ? (h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__picker-col` },
                          h(NScrollbar, { ref: "endMonthScrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                              default: () => [
                                  (type === 'monthrange'
                                      ? this.endMonthArray
                                      : this.endQuarterArray).map((item, i) => renderItem(item, i, mergedClsPrefix, 'end')),
                                  type === 'monthrange' && (h("div", { class: `${mergedClsPrefix}-date-panel-month-calendar__padding` }))
                              ]
                          }))) : null)),
              this.datePickerSlots.footer ? (h("div", { class: `${mergedClsPrefix}-date-panel-footer` }, renderSlot(this.datePickerSlots, 'footer'))) : null,
              ((_a = this.actions) === null || _a === void 0 ? void 0 : _a.length) || shortcuts ? (h("div", { class: `${mergedClsPrefix}-date-panel-actions` },
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__prefix` }, shortcuts &&
                      Object.keys(shortcuts).map((key) => {
                          const shortcut = shortcuts[key];
                          return Array.isArray(shortcut) ||
                              typeof shortcut === 'function' ? (h(XButton, { size: "tiny", onMouseenter: () => {
                                  this.handleRangeShortcutMouseenter(shortcut);
                              }, onClick: () => {
                                  this.handleRangeShortcutClick(shortcut);
                              }, onMouseleave: () => {
                                  this.handleShortcutMouseleave();
                              } }, { default: () => key })) : null;
                      })),
                  h("div", { class: `${mergedClsPrefix}-date-panel-actions__suffix` },
                      ((_b = this.actions) === null || _b === void 0 ? void 0 : _b.includes('clear')) ? (h(XButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", onClick: this.handleClearClick }, { default: () => this.locale.clear })) : null,
                      ((_c = this.actions) === null || _c === void 0 ? void 0 : _c.includes('confirm')) ? (h(XButton, { theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "tiny", type: "primary", disabled: this.isRangeInvalid, onClick: this.handleConfirmClick }, { default: () => this.locale.confirm })) : null))) : null,
              h(FocusDetector, { onFocus: this.handleFocusDetectorFocus })));
      }
  });

  // vars:
  // --n-bezier
  // --n-icon-color-override
  // --n-icon-color-disabled-override
  // --n-panel-border-radius
  // --n-panel-color
  // --n-panel-box-shadow
  // --n-panel-text-color
  // panel header
  // --n-panel-header-padding
  // --n-panel-header-divider-color
  // panel calendar
  // --n-calendar-left-padding
  // --n-calendar-right-padding
  // --n-calendar-title-color-hover
  // --n-calendar-title-height
  // --n-calendar-title-padding
  // --n-calendar-title-font-size
  // --n-calendar-title-text-color
  // --n-calendar-title-font-weight
  // --n-calendar-title-grid-template-columns
  // --n-calendar-days-height
  // --n-calendar-days-divider-color
  // --n-calendar-days-font-size
  // --n-calendar-days-text-color
  // --n-calendar-divider-color
  // panel action
  // --n-panel-action-padding
  // --n-panel-action-divider-color
  // panel item
  // --n-item-border-radius
  // --n-item-size
  // --n-item-cell-width
  // --n-item-cell-height
  // --n-item-text-color
  // --n-item-color-included
  // --n-item-color-disabled
  // --n-item-color-hover
  // --n-item-color-active
  // --n-item-font-size
  // --n-item-text-color-disabled
  // --n-item-text-color-active
  // scroll item
  // --n-scroll-item-width
  // --n-scroll-item-height
  // --n-scroll-item-border-radius
  // panel arrow
  // --n-arrow-size
  // --n-arrow-color
  var style$T = c$1([cB('date-picker', `
 position: relative;
 z-index: auto;
 `, [cB('date-picker-icon', `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cB('icon', `
 color: var(--n-icon-color-override);
 transition: color .3s var(--n-bezier);
 `), cM('disabled', [cB('date-picker-icon', `
 color: var(--n-icon-color-disabled-override);
 `), cB('icon', `
 color: var(--n-icon-color-disabled-override);
 `)])]), cB('date-panel', `
 width: fit-content;
 outline: none;
 margin: 4px 0;
 display: grid;
 grid-template-columns: 0fr;
 border-radius: var(--n-panel-border-radius);
 background-color: var(--n-panel-color);
 color: var(--n-panel-text-color);
 user-select: none;
 `, [fadeInScaleUpTransition(), cM('shadow', `
 box-shadow: var(--n-panel-box-shadow);
 `), cB('date-panel-calendar', {
    padding: 'var(--n-calendar-left-padding)',
    display: 'grid',
    gridTemplateColumns: '1fr',
    gridArea: 'left-calendar'
  }, [cM('end', {
    padding: 'var(--n-calendar-right-padding)',
    gridArea: 'right-calendar'
  })]), cB('date-panel-month-calendar', {
    display: 'flex',
    gridArea: 'left-calendar'
  }, [cE('picker-col', `
 min-width: var(--n-scroll-item-width);
 height: calc(var(--n-scroll-item-height) * 6);
 user-select: none;
 -webkit-user-select: none;
 `, [c$1('&:first-child', `
 min-width: calc(var(--n-scroll-item-width) + 4px);
 `, [cE('picker-col-item', [c$1('&::before', 'left: 4px;')])]), cE('padding', `
 height: calc(var(--n-scroll-item-height) * 5)
 `)]), cE('picker-col-item', `
 z-index: 0;
 cursor: pointer;
 height: var(--n-scroll-item-height);
 box-sizing: border-box;
 padding-top: 4px;
 display: flex;
 align-items: center;
 justify-content: center;
 position: relative;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background: #0000;
 color: var(--n-item-text-color);
 `, [c$1('&::before', `
 z-index: -1;
 content: "";
 position: absolute;
 left: 0;
 right: 4px;
 top: 4px;
 bottom: 0;
 border-radius: var(--n-scroll-item-border-radius);
 transition: 
 background-color .3s var(--n-bezier);
 `), cNotM('disabled', [c$1('&:hover::before', `
 background-color: var(--n-item-color-hover);
 `), cM('selected', `
 color: var(--n-item-color-active);
 `, [c$1('&::before', 'background-color: var(--n-item-color-hover);')])]), cM('disabled', `
 color: var(--n-item-text-color-disabled);
 cursor: not-allowed;
 `, [cM('selected', [c$1('&::before', `
 background-color: var(--n-item-color-disabled);
 `)])])])]), cM('date', {
    gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
  }), cM('daterange', {
    gridTemplateAreas: `
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
  }), cM('datetime', {
    gridTemplateAreas: `
 "header"
 "left-calendar"
 "footer"
 "action"
 `
  }), cM('datetimerange', {
    gridTemplateAreas: `
 "header header header"
 "left-calendar divider right-calendar"
 "footer footer footer"
 "action action action"
 `
  }), cM('month', {
    gridTemplateAreas: `
 "left-calendar"
 "footer"
 "action"
 `
  }), cB('date-panel-footer', {
    gridArea: 'footer'
  }), cB('date-panel-actions', {
    gridArea: 'action'
  }), cB('date-panel-header', {
    gridArea: 'header'
  }), cB('date-panel-header', `
 box-sizing: border-box;
 width: 100%;
 align-items: center;
 padding: var(--n-panel-header-padding);
 display: flex;
 justify-content: space-between;
 border-bottom: 1px solid var(--n-panel-header-divider-color);
 `, [c$1('>', [c$1('*:not(:last-child)', {
    marginRight: '10px'
  }), c$1('*', {
    flex: 1,
    width: 0
  }), cB('time-picker', {
    zIndex: 1
  })])]), cB('date-panel-month', `
 box-sizing: border-box;
 display: grid;
 grid-template-columns: var(--n-calendar-title-grid-template-columns);
 align-items: center;
 justify-items: center;
 padding: var(--n-calendar-title-padding);
 height: var(--n-calendar-title-height);
 `, [cE('prev, next, fast-prev, fast-next', `
 line-height: 0;
 cursor: pointer;
 width: var(--n-arrow-size);
 height: var(--n-arrow-size);
 color: var(--n-arrow-color);
 `), cE('month-year', `
 user-select: none;
 -webkit-user-select: none;
 flex-grow: 1;
 position: relative;
 `, [cE('text', `
 font-size: var(--n-calendar-title-font-size);
 line-height: var(--n-calendar-title-font-size);
 font-weight: var(--n-calendar-title-font-weight);
 padding: 6px 8px;
 text-align: center;
 color: var(--n-calendar-title-text-color);
 cursor: pointer;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-panel-border-radius);
 `, [cM('active', `
 background-color: var(--n-calendar-title-color-hover);
 `), c$1('&:hover', `
 background-color: var(--n-calendar-title-color-hover);
 `)])])]), cB('date-panel-weekdays', `
 display: grid;
 margin: auto;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(1, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 margin-bottom: 4px;
 border-bottom: 1px solid var(--n-calendar-days-divider-color);
 `, [cE('day', `
 user-select: none;
 -webkit-user-select: none;
 line-height: 15px;
 width: var(--n-item-size);
 text-align: center;
 font-size: var(--n-calendar-days-font-size);
 color: var(--n-item-text-color);
 `)]), cB('date-panel-dates', `
 margin: auto;
 display: grid;
 grid-template-columns: repeat(7, var(--n-item-cell-width));
 grid-template-rows: repeat(6, var(--n-item-cell-height));
 align-items: center;
 justify-items: center;
 flex-wrap: wrap;
 `, [cB('date-panel-date', `
 user-select: none;
 -webkit-user-select: none;
 position: relative;
 width: var(--n-item-size);
 height: var(--n-item-size);
 line-height: var(--n-item-size);
 text-align: center;
 font-size: var(--n-item-font-size);
 border-radius: var(--n-item-border-radius);
 z-index: 0;
 cursor: pointer;
 transition:
 background-color .2s var(--n-bezier),
 color .2s var(--n-bezier);
 `, [cE('trigger', `
 position: absolute;
 left: calc(var(--n-item-size) / 2 - var(--n-item-cell-width) / 2);
 top: calc(var(--n-item-size) / 2 - var(--n-item-cell-height) / 2);
 width: var(--n-item-cell-width);
 height: var(--n-item-cell-height);
 `), cNotM('disabled', [cNotM('selected', [c$1('&:hover', {
    backgroundColor: 'var(--n-item-color-hover)'
  })])]), cM('current', [cE('sup', `
 position: absolute;
 top: 2px;
 right: 2px;
 content: "";
 height: 4px;
 width: 4px;
 border-radius: 2px;
 background-color: var(--n-item-color-active);
 transition:
 background-color .2s var(--n-bezier);
 `)]), c$1('&::after', `
 content: "";
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 transition: background-color .3s var(--n-bezier);
 `), cM('covered, start, end', [cNotM('excluded', [c$1('&::before', `
 content: "";
 z-index: -2;
 position: absolute;
 left: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 right: calc((var(--n-item-size) - var(--n-item-cell-width)) / 2);
 top: 0;
 bottom: 0;
 background-color: var(--n-item-color-included);
 `), c$1('&:nth-child(7n + 1)::before', {
    borderTopLeftRadius: 'var(--n-item-border-radius)',
    borderBottomLeftRadius: 'var(--n-item-border-radius)'
  }), c$1('&:nth-child(7n + 7)::before', {
    borderTopRightRadius: 'var(--n-item-border-radius)',
    borderBottomRightRadius: 'var(--n-item-border-radius)'
  })])]), cM('selected', {
    color: 'var(--n-item-text-color-active)'
  }, [c$1('&::after', {
    backgroundColor: 'var(--n-item-color-active)'
  }), cM('start', [c$1('&::before', {
    left: '50%'
  })]), cM('end', [c$1('&::before', {
    right: '50%'
  })]), cE('sup', {
    backgroundColor: 'var(--n-panel-color)'
  })]), cM('excluded', {
    color: 'var(--n-item-text-color-disabled)'
  }, [cM('selected', [c$1('&::after', {
    backgroundColor: 'var(--n-item-color-disabled)'
  })])]), cM('disabled', {
    cursor: 'not-allowed',
    color: 'var(--n-item-text-color-disabled)'
  }, [cM('covered', [c$1('&::before', {
    backgroundColor: 'var(--n-item-color-disabled)'
  })]), cM('selected', [c$1('&::before', {
    backgroundColor: 'var(--n-item-color-disabled)'
  }), c$1('&::after', {
    backgroundColor: 'var(--n-item-color-disabled)'
  })])])])]), cE('vertical-divider', `
 grid-area: divider;
 height: 100%;
 width: 1px;
 background-color: var(--n-calendar-divider-color);
 `), cB('date-panel-footer', {
    borderTop: '1px solid var(--n-panel-action-divider-color)',
    padding: 'var(--n-panel-extra-footer-padding)'
  }), cB('date-panel-actions', `
 flex: 1;
 padding: var(--n-panel-action-padding);
 display: flex;
 align-items: center;
 justify-content: space-between;
 border-top: 1px solid var(--n-panel-action-divider-color);
 `, [cE('prefix, suffix', `
 display: flex;
 margin-bottom: -8px;
 `), cE('suffix', `
 align-self: flex-end;
 `), cE('prefix', `
 flex-wrap: wrap;
 `), cB('button', `
 margin-bottom: 8px;
 `, [c$1('&:not(:last-child)', `
 margin-right: 8px;
 `)])])]), c$1('[data-n-date].transition-disabled', {
    transition: 'none !important'
  }, [c$1('&::before, &::after', {
    transition: 'none !important'
  })])]);

  const datePickerProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, bordered: {
          type: Boolean,
          default: undefined
      }, clearable: Boolean, updateValueOnClose: Boolean, defaultValue: [Number, Array], defaultFormattedValue: [String, Array], defaultTime: [Number, String, Array], disabled: {
          type: Boolean,
          default: undefined
      }, placement: {
          type: String,
          default: 'bottom-start'
      }, value: [Number, Array], formattedValue: [String, Array], size: String, type: {
          type: String,
          default: 'date'
      }, valueFormat: String, separator: String, placeholder: String, startPlaceholder: String, endPlaceholder: String, format: String, dateFormat: String, timeFormat: String, actions: Array, shortcuts: Object, isDateDisabled: Function, isTimeDisabled: Function, show: {
          type: Boolean,
          default: undefined
      }, panel: Boolean, ranges: Object, firstDayOfWeek: Number, inputReadonly: Boolean, closeOnSelect: Boolean, status: String, timePickerProps: [Object, Array], onClear: Function, onConfirm: Function, defaultCalendarStartTime: Number, defaultCalendarEndTime: Number, bindCalendarMonths: Boolean, 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], 'onUpdate:formattedValue': [Function, Array], onUpdateFormattedValue: [Function, Array], 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], 
      // deprecated
      onChange: [Function, Array] });
  var DatePicker = defineComponent({
      name: 'DatePicker',
      props: datePickerProps,
      setup(props, { slots }) {
          var _a;
          const { localeRef, dateLocaleRef } = useLocale('DatePicker');
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          const { mergedComponentPropsRef, mergedClsPrefixRef, mergedBorderedRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const panelInstRef = ref(null);
          const triggerElRef = ref(null);
          const inputInstRef = ref(null);
          const uncontrolledShowRef = ref(false);
          const controlledShowRef = toRef(props, 'show');
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const dateFnsOptionsRef = computed(() => {
              return {
                  locale: dateLocaleRef.value.locale
              };
          });
          const mergedFormatRef = computed(() => {
              const { format } = props;
              if (format)
                  return format;
              switch (props.type) {
                  case 'date':
                  case 'daterange':
                      return localeRef.value.dateFormat;
                  case 'datetime':
                  case 'datetimerange':
                      return localeRef.value.dateTimeFormat;
                  case 'year':
                  case 'yearrange':
                      return localeRef.value.yearTypeFormat;
                  case 'month':
                  case 'monthrange':
                      return localeRef.value.monthTypeFormat;
                  case 'quarter':
                  case 'quarterrange':
                      return localeRef.value.quarterFormat;
              }
          });
          const mergedValueFormatRef = computed(() => {
              var _a;
              return (_a = props.valueFormat) !== null && _a !== void 0 ? _a : mergedFormatRef.value;
          });
          function getTimestampValue(value) {
              if (value === null)
                  return null;
              const { value: mergedValueFormat } = mergedValueFormatRef;
              const { value: dateFnsOptions } = dateFnsOptionsRef;
              if (Array.isArray(value)) {
                  return [
                      strictParse(value[0], mergedValueFormat, new Date(), dateFnsOptions).getTime(),
                      strictParse(value[1], mergedValueFormat, new Date(), dateFnsOptions).getTime()
                  ];
              }
              return strictParse(value, mergedValueFormat, new Date(), dateFnsOptions).getTime();
          }
          const { defaultFormattedValue, defaultValue } = props;
          const uncontrolledValueRef = ref((_a = (defaultFormattedValue !== undefined
              ? getTimestampValue(defaultFormattedValue)
              : defaultValue)) !== null && _a !== void 0 ? _a : null);
          const controlledValueRef = computed(() => {
              const { formattedValue } = props;
              if (formattedValue !== undefined) {
                  return getTimestampValue(formattedValue);
              }
              return props.value;
          });
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          // We don't change value unless blur or confirm is called
          const pendingValueRef = ref(null);
          watchEffect(() => {
              pendingValueRef.value = mergedValueRef.value;
          });
          const singleInputValueRef = ref('');
          const rangeStartInputValueRef = ref('');
          const rangeEndInputValueRef = ref('');
          const themeRef = useTheme('DatePicker', '-date-picker', style$T, datePickerLight$1, props, mergedClsPrefixRef);
          const timePickerSizeRef = computed(() => {
              var _a, _b;
              return (((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DatePicker) === null || _b === void 0 ? void 0 : _b.timePickerSize) || 'small');
          });
          const isRangeRef = computed(() => {
              return [
                  'daterange',
                  'datetimerange',
                  'monthrange',
                  'quarterrange',
                  'yearrange'
              ].includes(props.type);
          });
          const localizedPlacehoderRef = computed(() => {
              const { placeholder } = props;
              if (placeholder === undefined) {
                  const { type } = props;
                  switch (type) {
                      case 'date':
                          return localeRef.value.datePlaceholder;
                      case 'datetime':
                          return localeRef.value.datetimePlaceholder;
                      case 'month':
                          return localeRef.value.monthPlaceholder;
                      case 'year':
                          return localeRef.value.yearPlaceholder;
                      case 'quarter':
                          return localeRef.value.quarterPlaceholder;
                      default:
                          return '';
                  }
              }
              else {
                  return placeholder;
              }
          });
          const localizedStartPlaceholderRef = computed(() => {
              if (props.startPlaceholder === undefined) {
                  if (props.type === 'daterange') {
                      return localeRef.value.startDatePlaceholder;
                  }
                  else if (props.type === 'datetimerange') {
                      return localeRef.value.startDatetimePlaceholder;
                  }
                  else if (props.type === 'monthrange') {
                      return localeRef.value.startMonthPlaceholder;
                  }
                  return '';
              }
              else {
                  return props.startPlaceholder;
              }
          });
          const localizedEndPlaceholderRef = computed(() => {
              if (props.endPlaceholder === undefined) {
                  if (props.type === 'daterange') {
                      return localeRef.value.endDatePlaceholder;
                  }
                  else if (props.type === 'datetimerange') {
                      return localeRef.value.endDatetimePlaceholder;
                  }
                  else if (props.type === 'monthrange') {
                      return localeRef.value.endMonthPlaceholder;
                  }
                  return '';
              }
              else {
                  return props.endPlaceholder;
              }
          });
          const mergedActionsRef = computed(() => {
              const { actions, type, clearable } = props;
              if (actions === null)
                  return [];
              if (actions !== undefined)
                  return actions;
              const result = clearable ? ['clear'] : [];
              switch (type) {
                  case 'date': {
                      result.push('now');
                      return result;
                  }
                  case 'datetime': {
                      result.push('now', 'confirm');
                      return result;
                  }
                  case 'daterange': {
                      result.push('confirm');
                      return result;
                  }
                  case 'datetimerange': {
                      result.push('confirm');
                      return result;
                  }
                  case 'month': {
                      result.push('now', 'confirm');
                      return result;
                  }
                  case 'year': {
                      result.push('now');
                      return result;
                  }
                  case 'quarter': {
                      result.push('now', 'confirm');
                      return result;
                  }
                  case 'monthrange':
                  case 'yearrange':
                  case 'quarterrange': {
                      result.push('confirm');
                      return result;
                  }
                  default: {
                      warn$2('date-picker', "The type is wrong, n-date-picker's type only supports `date`, `datetime`, `daterange` and `datetimerange`.");
                      break;
                  }
              }
          });
          function getFormattedValue(value) {
              if (value === null)
                  return null;
              if (Array.isArray(value)) {
                  const { value: mergedValueFormat } = mergedValueFormatRef;
                  const { value: dateFnsOptions } = dateFnsOptionsRef;
                  return [
                      format$4(value[0], mergedValueFormat, dateFnsOptions),
                      format$4(value[1], mergedValueFormat, dateFnsOptionsRef.value)
                  ];
              }
              else {
                  return format$4(value, mergedValueFormatRef.value, dateFnsOptionsRef.value);
              }
          }
          function doUpdatePendingValue(value) {
              pendingValueRef.value = value;
          }
          function doUpdateFormattedValue(value, timestampValue) {
              const { 'onUpdate:formattedValue': _onUpdateFormattedValue, onUpdateFormattedValue } = props;
              if (_onUpdateFormattedValue) {
                  call(_onUpdateFormattedValue, value, timestampValue);
              }
              if (onUpdateFormattedValue) {
                  call(onUpdateFormattedValue, value, timestampValue);
              }
          }
          function doUpdateValue(value, options) {
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue, onChange } = props;
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              const formattedValue = getFormattedValue(value);
              if (options.doConfirm) {
                  doConfirm(value, formattedValue);
              }
              if (onUpdateValue) {
                  call(onUpdateValue, value, formattedValue);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, formattedValue);
              }
              if (onChange)
                  call(onChange, value, formattedValue);
              uncontrolledValueRef.value = value;
              doUpdateFormattedValue(formattedValue, value);
              nTriggerFormChange();
              nTriggerFormInput();
          }
          function doClear() {
              const { onClear } = props;
              onClear === null || onClear === void 0 ? void 0 : onClear();
          }
          function doConfirm(value, formattedValue) {
              const { onConfirm } = props;
              if (onConfirm)
                  onConfirm(value, formattedValue);
          }
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function doBlur(e) {
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
          }
          function doUpdateShow(show) {
              const { 'onUpdate:show': _onUpdateShow, onUpdateShow } = props;
              if (_onUpdateShow)
                  call(_onUpdateShow, show);
              if (onUpdateShow)
                  call(onUpdateShow, show);
              uncontrolledShowRef.value = show;
          }
          function handleKeydown(e) {
              if (e.key === 'Escape') {
                  if (mergedShowRef.value) {
                      markEventEffectPerformed(e);
                      closeCalendar({
                          returnFocus: true
                      });
                  }
              }
              // We need to handle the conflict with normal date value input
              // const { value: mergedValue } = mergedValueRef
              // if (props.type === 'date' && !Array.isArray(mergedValue)) {
              //   const nextValue = getDerivedTimeFromKeyboardEvent(mergedValue, e)
              //   doUpdateValue(nextValue)
              // }
          }
          function handleInputKeydown(e) {
              if (e.key === 'Escape' && mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  // closeCalendar will be called in handleDeactivated
              }
          }
          function handleClear() {
              var _a;
              doUpdateShow(false);
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.deactivate();
              doClear();
          }
          function handlePanelClear() {
              var _a;
              // close will be called inside panel
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.deactivate();
              doClear();
          }
          function handlePanelTabOut() {
              closeCalendar({
                  returnFocus: true
              });
          }
          function handleClickOutside(e) {
              var _a;
              if (mergedShowRef.value &&
                  !((_a = triggerElRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)))) {
                  closeCalendar({
                      returnFocus: false
                  });
              }
          }
          function handlePanelClose(disableUpdateOnClose) {
              closeCalendar({
                  returnFocus: true,
                  disableUpdateOnClose
              });
          }
          // --- Panel update value
          function handlePanelUpdateValue(value, doUpdate) {
              if (doUpdate) {
                  doUpdateValue(value, { doConfirm: false });
              }
              else {
                  doUpdatePendingValue(value);
              }
          }
          function handlePanelConfirm() {
              const pendingValue = pendingValueRef.value;
              doUpdateValue(Array.isArray(pendingValue)
                  ? [pendingValue[0], pendingValue[1]]
                  : pendingValue, { doConfirm: true });
          }
          // --- Refresh
          function deriveInputState() {
              const { value } = pendingValueRef;
              if (isRangeRef.value) {
                  if (Array.isArray(value) || value === null) {
                      deriveRangeInputState(value);
                  }
              }
              else {
                  if (!Array.isArray(value)) {
                      deriveSingleInputState(value);
                  }
              }
          }
          function deriveSingleInputState(value) {
              if (value === null) {
                  singleInputValueRef.value = '';
              }
              else {
                  singleInputValueRef.value = format$4(value, mergedFormatRef.value, dateFnsOptionsRef.value);
              }
          }
          function deriveRangeInputState(values) {
              if (values === null) {
                  rangeStartInputValueRef.value = '';
                  rangeEndInputValueRef.value = '';
              }
              else {
                  const dateFnsOptions = dateFnsOptionsRef.value;
                  rangeStartInputValueRef.value = format$4(values[0], mergedFormatRef.value, dateFnsOptions);
                  rangeEndInputValueRef.value = format$4(values[1], mergedFormatRef.value, dateFnsOptions);
              }
          }
          // --- Input deactivate & blur
          function handleInputActivate() {
              if (!mergedShowRef.value) {
                  openCalendar();
              }
          }
          function handleInputBlur(e) {
              var _a;
              if (!((_a = panelInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget))) {
                  doBlur(e);
                  deriveInputState();
                  closeCalendar({
                      returnFocus: false
                  });
              }
          }
          function handleInputDeactivate() {
              if (mergedDisabledRef.value)
                  return;
              deriveInputState();
              closeCalendar({
                  returnFocus: false
              });
          }
          // --- Input
          function handleSingleUpdateValue(v) {
              // TODO, fix conflict with clear
              if (v === '') {
                  doUpdateValue(null, { doConfirm: false });
                  pendingValueRef.value = null;
                  singleInputValueRef.value = '';
                  return;
              }
              const newSelectedDateTime = strictParse(v, mergedFormatRef.value, new Date(), dateFnsOptionsRef.value);
              if (isValid$1(newSelectedDateTime)) {
                  doUpdateValue(getTime(newSelectedDateTime), { doConfirm: false });
                  deriveInputState();
              }
              else {
                  singleInputValueRef.value = v;
              }
          }
          function handleRangeUpdateValue(v) {
              if (v[0] === '' && v[1] === '') {
                  // clear or just delete all the inputs
                  doUpdateValue(null, { doConfirm: false });
                  pendingValueRef.value = null;
                  rangeStartInputValueRef.value = '';
                  rangeEndInputValueRef.value = '';
                  return;
              }
              const [startTime, endTime] = v;
              const newStartTime = strictParse(startTime, mergedFormatRef.value, new Date(), dateFnsOptionsRef.value);
              const newEndTime = strictParse(endTime, mergedFormatRef.value, new Date(), dateFnsOptionsRef.value);
              if (isValid$1(newStartTime) && isValid$1(newEndTime)) {
                  doUpdateValue([getTime(newStartTime), getTime(newEndTime)], {
                      doConfirm: false
                  });
                  deriveInputState();
              }
              else {
                  [rangeStartInputValueRef.value, rangeEndInputValueRef.value] = v;
              }
          }
          // --- Click
          function handleTriggerClick(e) {
              if (mergedDisabledRef.value)
                  return;
              if (happensIn(e, 'clear'))
                  return;
              if (!mergedShowRef.value) {
                  openCalendar();
              }
          }
          // --- Focus
          function handleInputFocus(e) {
              if (mergedDisabledRef.value)
                  return;
              doFocus(e);
          }
          // --- Calendar
          function openCalendar() {
              if (mergedDisabledRef.value || mergedShowRef.value)
                  return;
              doUpdateShow(true);
          }
          function closeCalendar({ returnFocus, disableUpdateOnClose }) {
              var _a;
              if (mergedShowRef.value) {
                  doUpdateShow(false);
                  if (props.type !== 'date' &&
                      props.updateValueOnClose &&
                      !disableUpdateOnClose) {
                      handlePanelConfirm();
                  }
                  if (returnFocus) {
                      (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                  }
              }
          }
          // If new value is valid, set calendarTime and refresh display strings.
          // If new value is invalid, do nothing.
          watch(pendingValueRef, () => {
              deriveInputState();
          });
          // init
          deriveInputState();
          watch(mergedShowRef, (value) => {
              if (!value) {
                  // close & restore original value
                  // it won't conflict with props.value change
                  // since when prop is passed, it is already
                  // up to date.
                  pendingValueRef.value = mergedValueRef.value;
              }
          });
          // use pending value to do validation
          const uniVaidation = uniCalendarValidation(props, pendingValueRef);
          const dualValidation = dualCalendarValidation(props, pendingValueRef);
          provide(datePickerInjectionKey, Object.assign(Object.assign(Object.assign({ mergedClsPrefixRef, mergedThemeRef: themeRef, timePickerSizeRef,
              localeRef,
              dateLocaleRef, firstDayOfWeekRef: toRef(props, 'firstDayOfWeek'), isDateDisabledRef: toRef(props, 'isDateDisabled'), rangesRef: toRef(props, 'ranges'), timePickerPropsRef: toRef(props, 'timePickerProps'), closeOnSelectRef: toRef(props, 'closeOnSelect'), updateValueOnCloseRef: toRef(props, 'updateValueOnClose') }, uniVaidation), dualValidation), { datePickerSlots: slots }));
          const exposedMethods = {
              focus: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              },
              blur: () => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              }
          };
          const triggerCssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { iconColor, iconColorDisabled } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-icon-color-override': iconColor,
                  '--n-icon-color-disabled-override': iconColorDisabled
              };
          });
          const triggerThemeClassHandle = inlineThemeDisabled
              ? useThemeClass('date-picker-trigger', undefined, triggerCssVarsRef, props)
              : undefined;
          const cssVarsRef = computed(() => {
              const { type } = props;
              const { common: { cubicBezierEaseInOut }, self: { calendarTitleFontSize, calendarDaysFontSize, itemFontSize, itemTextColor, itemColorDisabled, itemColorIncluded, itemColorHover, itemColorActive, itemBorderRadius, itemTextColorDisabled, itemTextColorActive, panelColor, panelTextColor, arrowColor, calendarTitleTextColor, panelActionDividerColor, panelHeaderDividerColor, calendarDaysDividerColor, panelBoxShadow, panelBorderRadius, calendarTitleFontWeight, panelExtraFooterPadding, panelActionPadding, itemSize, itemCellWidth, itemCellHeight, scrollItemWidth, scrollItemHeight, calendarTitlePadding, calendarTitleHeight, calendarDaysHeight, calendarDaysTextColor, arrowSize, panelHeaderPadding, calendarDividerColor, calendarTitleGridTempateColumns, iconColor, iconColorDisabled, scrollItemBorderRadius, calendarTitleColorHover, [createKey('calendarLeftPadding', type)]: calendarLeftPadding, [createKey('calendarRightPadding', type)]: calendarRightPadding } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-panel-border-radius': panelBorderRadius,
                  '--n-panel-color': panelColor,
                  '--n-panel-box-shadow': panelBoxShadow,
                  '--n-panel-text-color': panelTextColor,
                  // panel header
                  '--n-panel-header-padding': panelHeaderPadding,
                  '--n-panel-header-divider-color': panelHeaderDividerColor,
                  // panel calendar
                  '--n-calendar-left-padding': calendarLeftPadding,
                  '--n-calendar-right-padding': calendarRightPadding,
                  '--n-calendar-title-color-hover': calendarTitleColorHover,
                  '--n-calendar-title-height': calendarTitleHeight,
                  '--n-calendar-title-padding': calendarTitlePadding,
                  '--n-calendar-title-font-size': calendarTitleFontSize,
                  '--n-calendar-title-font-weight': calendarTitleFontWeight,
                  '--n-calendar-title-text-color': calendarTitleTextColor,
                  '--n-calendar-title-grid-template-columns': calendarTitleGridTempateColumns,
                  '--n-calendar-days-height': calendarDaysHeight,
                  '--n-calendar-days-divider-color': calendarDaysDividerColor,
                  '--n-calendar-days-font-size': calendarDaysFontSize,
                  '--n-calendar-days-text-color': calendarDaysTextColor,
                  '--n-calendar-divider-color': calendarDividerColor,
                  // panel action
                  '--n-panel-action-padding': panelActionPadding,
                  '--n-panel-extra-footer-padding': panelExtraFooterPadding,
                  '--n-panel-action-divider-color': panelActionDividerColor,
                  // panel item
                  '--n-item-font-size': itemFontSize,
                  '--n-item-border-radius': itemBorderRadius,
                  '--n-item-size': itemSize,
                  '--n-item-cell-width': itemCellWidth,
                  '--n-item-cell-height': itemCellHeight,
                  '--n-item-text-color': itemTextColor,
                  '--n-item-color-included': itemColorIncluded,
                  '--n-item-color-disabled': itemColorDisabled,
                  '--n-item-color-hover': itemColorHover,
                  '--n-item-color-active': itemColorActive,
                  '--n-item-text-color-disabled': itemTextColorDisabled,
                  '--n-item-text-color-active': itemTextColorActive,
                  // scroll item
                  '--n-scroll-item-width': scrollItemWidth,
                  '--n-scroll-item-height': scrollItemHeight,
                  '--n-scroll-item-border-radius': scrollItemBorderRadius,
                  // panel arrow
                  '--n-arrow-size': arrowSize,
                  '--n-arrow-color': arrowColor,
                  // icon in trigger
                  '--n-icon-color': iconColor,
                  '--n-icon-color-disabled': iconColorDisabled
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('date-picker', computed(() => {
                  return props.type;
              }), cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedMethods), { mergedStatus: mergedStatusRef, mergedClsPrefix: mergedClsPrefixRef, mergedBordered: mergedBorderedRef, namespace: namespaceRef, uncontrolledValue: uncontrolledValueRef, pendingValue: pendingValueRef, panelInstRef,
              triggerElRef,
              inputInstRef, isMounted: isMounted(), displayTime: singleInputValueRef, displayStartTime: rangeStartInputValueRef, displayEndTime: rangeEndInputValueRef, mergedShow: mergedShowRef, adjustedTo: useAdjustedTo(props), isRange: isRangeRef, localizedStartPlaceholder: localizedStartPlaceholderRef, localizedEndPlaceholder: localizedEndPlaceholderRef, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, localizedPlacehoder: localizedPlacehoderRef, isValueInvalid: uniVaidation.isValueInvalidRef, isStartValueInvalid: dualValidation.isStartValueInvalidRef, isEndValueInvalid: dualValidation.isEndValueInvalidRef, handleInputKeydown,
              handleClickOutside,
              handleKeydown,
              handleClear,
              handlePanelClear,
              handleTriggerClick,
              handleInputActivate,
              handleInputDeactivate,
              handleInputFocus,
              handleInputBlur,
              handlePanelTabOut,
              handlePanelClose,
              handleRangeUpdateValue,
              handleSingleUpdateValue,
              handlePanelUpdateValue,
              handlePanelConfirm, mergedTheme: themeRef, actions: mergedActionsRef, triggerCssVars: inlineThemeDisabled ? undefined : triggerCssVarsRef, triggerThemeClass: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.themeClass, triggerOnRender: triggerThemeClassHandle === null || triggerThemeClassHandle === void 0 ? void 0 : triggerThemeClassHandle.onRender, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          const { clearable, triggerOnRender, mergedClsPrefix, $slots } = this;
          const commonPanelProps = {
              onUpdateValue: this.handlePanelUpdateValue,
              onTabOut: this.handlePanelTabOut,
              onClose: this.handlePanelClose,
              onClear: this.handlePanelClear,
              onKeydown: this.handleKeydown,
              onConfirm: this.handlePanelConfirm,
              ref: 'panelInstRef',
              value: this.pendingValue,
              active: this.mergedShow,
              actions: this.actions,
              shortcuts: this.shortcuts,
              style: this.cssVars,
              defaultTime: this.defaultTime,
              themeClass: this.themeClass,
              panel: this.panel,
              onRender: this.onRender
          };
          const renderPanel = () => {
              const { type } = this;
              return type === 'datetime' ? (h(DatetimePanel, Object.assign({}, commonPanelProps), $slots)) : type === 'daterange' ? (h(DaterangePanel, Object.assign({}, commonPanelProps, { defaultCalendarStartTime: this.defaultCalendarStartTime, defaultCalendarEndTime: this.defaultCalendarEndTime, bindCalendarMonths: this.bindCalendarMonths }), $slots)) : type === 'datetimerange' ? (h(DatetimerangePanel, Object.assign({}, commonPanelProps, { defaultCalendarStartTime: this.defaultCalendarStartTime, defaultCalendarEndTime: this.defaultCalendarEndTime, bindCalendarMonths: this.bindCalendarMonths }), $slots)) : type === 'month' || type === 'year' || type === 'quarter' ? (h(MonthPanel, Object.assign({}, commonPanelProps, { type: type, key: type }))) : type === 'monthrange' ||
                  type === 'yearrange' ||
                  type === 'quarterrange' ? (h(MonthRangePanel, Object.assign({}, commonPanelProps, { type: type }))) : (h(DatePanel, Object.assign({}, commonPanelProps), $slots));
          };
          if (this.panel) {
              return renderPanel();
          }
          triggerOnRender === null || triggerOnRender === void 0 ? void 0 : triggerOnRender();
          const commonInputProps = {
              bordered: this.mergedBordered,
              size: this.mergedSize,
              passivelyActivated: true,
              disabled: this.mergedDisabled,
              readonly: this.inputReadonly || this.mergedDisabled,
              clearable,
              onClear: this.handleClear,
              onClick: this.handleTriggerClick,
              onKeydown: this.handleInputKeydown,
              onActivate: this.handleInputActivate,
              onDeactivate: this.handleInputDeactivate,
              onFocus: this.handleInputFocus,
              onBlur: this.handleInputBlur
          };
          return (h("div", { ref: "triggerElRef", class: [
                  `${mergedClsPrefix}-date-picker`,
                  this.mergedDisabled && `${mergedClsPrefix}-date-picker--disabled`,
                  this.isRange && `${mergedClsPrefix}-date-picker--range`,
                  this.triggerThemeClass
              ], style: this.triggerCssVars, onKeydown: this.handleKeydown },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => this.isRange ? (h(NInput, Object.assign({ ref: "inputInstRef", status: this.mergedStatus, value: [this.displayStartTime, this.displayEndTime], placeholder: [
                                  this.localizedStartPlaceholder,
                                  this.localizedEndPlaceholder
                              ], textDecoration: [
                                  this.isStartValueInvalid ? 'line-through' : '',
                                  this.isEndValueInvalid ? 'line-through' : ''
                              ], pair: true, onUpdateValue: this.handleRangeUpdateValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, internalForceFocus: this.mergedShow, internalDeactivateOnEnter: true }, commonInputProps), {
                              separator: () => this.separator === undefined
                                  ? resolveSlot($slots.separator, () => [
                                      h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                                          default: () => h(ToIcon, null)
                                      })
                                  ])
                                  : this.separator,
                              [clearable ? 'clear-icon-placeholder' : 'suffix']: () => resolveSlot($slots['date-icon'], () => [
                                  h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                                      default: () => h(DateIcon, null)
                                  })
                              ])
                          })) : (h(NInput, Object.assign({ ref: "inputInstRef", status: this.mergedStatus, value: this.displayTime, placeholder: this.localizedPlacehoder, textDecoration: this.isValueInvalid && !this.isRange
                                  ? 'line-through'
                                  : '', onUpdateValue: this.handleSingleUpdateValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, internalForceFocus: this.mergedShow, internalDeactivateOnEnter: true }, commonInputProps), {
                              [clearable ? 'clear-icon-placeholder' : 'suffix']: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-date-picker-icon` }, {
                                  default: () => resolveSlot($slots['date-icon'], () => [
                                      h(DateIcon, null)
                                  ])
                              }))
                          }))
                      }),
                      h(VFollower, { show: this.mergedShow, containerClass: this.namespace, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.placement }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                              default: () => {
                                  if (!this.mergedShow)
                                      return null;
                                  return withDirectives(renderPanel(), [
                                      [
                                          clickoutside$1,
                                          this.handleClickOutside,
                                          undefined,
                                          { capture: true }
                                      ]
                                  ]);
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  var commonVariables$7 = {
      thPaddingBorderedSmall: '8px 12px',
      thPaddingBorderedMedium: '12px 16px',
      thPaddingBorderedLarge: '16px 24px',
      thPaddingSmall: '0',
      thPaddingMedium: '0',
      thPaddingLarge: '0',
      tdPaddingBorderedSmall: '8px 12px',
      tdPaddingBorderedMedium: '12px 16px',
      tdPaddingBorderedLarge: '16px 24px',
      tdPaddingSmall: '0 0 8px 0',
      tdPaddingMedium: '0 0 12px 0',
      tdPaddingLarge: '0 0 16px 0'
  };

  const self$H = (vars) => {
      const { tableHeaderColor, textColor2, textColor1, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontWeightStrong, lineHeight, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
      return Object.assign(Object.assign({}, commonVariables$7), { lineHeight,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge, titleTextColor: textColor1, thColor: composite(cardColor, tableHeaderColor), thColorModal: composite(modalColor, tableHeaderColor), thColorPopover: composite(popoverColor, tableHeaderColor), thTextColor: textColor1, thFontWeight: fontWeightStrong, tdTextColor: textColor2, tdColor: cardColor, tdColorModal: modalColor, tdColorPopover: popoverColor, borderColor: composite(cardColor, dividerColor), borderColorModal: composite(modalColor, dividerColor), borderColorPopover: composite(popoverColor, dividerColor), borderRadius });
  };
  const descriptionsLight = {
      name: 'Descriptions',
      common: commonLight,
      self: self$H
  };
  var descriptionsLight$1 = descriptionsLight;

  const DESCRIPTION_ITEM_FLAG = 'DESCRIPTION_ITEM_FLAG';
  function isDescriptionsItem(vNode) {
      if (typeof vNode === 'object' && vNode && !Array.isArray(vNode)) {
          return vNode.type && vNode.type[DESCRIPTION_ITEM_FLAG];
      }
      return false;
  }

  // vars:
  // --n-th-padding
  // --n-td-padding
  // --n-font-size
  // --n-bezier
  // --n-th-font-weight
  // --n-line-height
  // --n-th-text-color
  // --n-td-text-color
  // --n-th-color
  // --n-th-color-modal
  // --n-th-color-popover
  // --n-td-color
  // --n-td-color-modal
  // --n-td-color-popover
  // --n-border-radius
  // --n-border-color
  // --n-border-color-modal
  // --n-border-color-popover
  // --n-title-text-color
  var style$S = c$1([cB('descriptions', {
    fontSize: 'var(--n-font-size)'
  }, [cB('descriptions-separator', `
 display: inline-block;
 margin: 0 8px 0 2px;
 `), cB('descriptions-table-wrapper', [cB('descriptions-table', [cB('descriptions-table-row', [cB('descriptions-table-header', {
    padding: 'var(--n-th-padding)'
  }), cB('descriptions-table-content', {
    padding: 'var(--n-td-padding)'
  })])])]), cNotM('bordered', [cB('descriptions-table-wrapper', [cB('descriptions-table', [cB('descriptions-table-row', [c$1('&:last-child', [cB('descriptions-table-content', {
    paddingBottom: 0
  })])])])])]), cM('left-label-placement', [cB('descriptions-table-content', [c$1('> *', {
    verticalAlign: 'top'
  })])]), cM('left-label-align', [c$1('th', {
    textAlign: 'left'
  })]), cM('center-label-align', [c$1('th', {
    textAlign: 'center'
  })]), cM('right-label-align', [c$1('th', {
    textAlign: 'right'
  })]), cM('bordered', [cB('descriptions-table-wrapper', `
 border-radius: var(--n-border-radius);
 overflow: hidden;
 background: var(--n-merged-td-color);
 border: 1px solid var(--n-merged-border-color);
 `, [cB('descriptions-table', [cB('descriptions-table-row', [c$1('&:not(:last-child)', [cB('descriptions-table-content', {
    borderBottom: '1px solid var(--n-merged-border-color)'
  }), cB('descriptions-table-header', {
    borderBottom: '1px solid var(--n-merged-border-color)'
  })]), cB('descriptions-table-header', `
 font-weight: 400;
 background-clip: padding-box;
 background-color: var(--n-merged-th-color);
 `, [c$1('&:not(:last-child)', {
    borderRight: '1px solid var(--n-merged-border-color)'
  })]), cB('descriptions-table-content', [c$1('&:not(:last-child)', {
    borderRight: '1px solid var(--n-merged-border-color)'
  })])])])])]), cB('descriptions-header', `
 font-weight: var(--n-th-font-weight);
 font-size: 18px;
 transition: color .3s var(--n-bezier);
 line-height: var(--n-line-height);
 margin-bottom: 16px;
 color: var(--n-title-text-color);
 `), cB('descriptions-table-wrapper', `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cB('descriptions-table', `
 width: 100%;
 border-collapse: separate;
 border-spacing: 0;
 box-sizing: border-box;
 `, [cB('descriptions-table-row', `
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [cB('descriptions-table-header', `
 font-weight: var(--n-th-font-weight);
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-th-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cB('descriptions-table-content', `
 vertical-align: top;
 line-height: var(--n-line-height);
 display: table-cell;
 box-sizing: border-box;
 color: var(--n-td-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE('content', `
 transition: color .3s var(--n-bezier);
 display: inline-block;
 color: var(--n-td-text-color);
 `)]), cE('label', `
 font-weight: var(--n-th-font-weight);
 transition: color .3s var(--n-bezier);
 display: inline-block;
 margin-right: 14px;
 color: var(--n-th-text-color);
 `)])])])]), cB('descriptions-table-wrapper', `
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 `), insideModal(cB('descriptions-table-wrapper', `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB('descriptions-table-wrapper', `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);

  const descriptionsProps = Object.assign(Object.assign({}, useTheme.props), { title: String, column: {
          type: Number,
          default: 3
      }, columns: Number, labelPlacement: {
          type: String,
          default: 'top'
      }, labelAlign: {
          type: String,
          default: 'left'
      }, separator: {
          type: String,
          default: ':'
      }, size: {
          type: String,
          default: 'medium'
      }, bordered: Boolean, labelClass: String, labelStyle: [Object, String], contentClass: String, contentStyle: [Object, String] });
  var Descriptions = defineComponent({
      name: 'Descriptions',
      props: descriptionsProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Descriptions', '-descriptions', style$S, descriptionsLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size, bordered } = props;
              const { common: { cubicBezierEaseInOut }, self: { titleTextColor, thColor, thColorModal, thColorPopover, thTextColor, thFontWeight, tdTextColor, tdColor, tdColorModal, tdColorPopover, borderColor, borderColorModal, borderColorPopover, borderRadius, lineHeight, [createKey('fontSize', size)]: fontSize, [createKey(bordered ? 'thPaddingBordered' : 'thPadding', size)]: thPadding, [createKey(bordered ? 'tdPaddingBordered' : 'tdPadding', size)]: tdPadding } } = themeRef.value;
              return {
                  '--n-title-text-color': titleTextColor,
                  '--n-th-padding': thPadding,
                  '--n-td-padding': tdPadding,
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-th-font-weight': thFontWeight,
                  '--n-line-height': lineHeight,
                  '--n-th-text-color': thTextColor,
                  '--n-td-text-color': tdTextColor,
                  '--n-th-color': thColor,
                  '--n-th-color-modal': thColorModal,
                  '--n-th-color-popover': thColorPopover,
                  '--n-td-color': tdColor,
                  '--n-td-color-modal': tdColorModal,
                  '--n-td-color-popover': tdColorPopover,
                  '--n-border-radius': borderRadius,
                  '--n-border-color': borderColor,
                  '--n-border-color-modal': borderColorModal,
                  '--n-border-color-popover': borderColorPopover
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('descriptions', computed(() => {
                  let hash = '';
                  const { size, bordered } = props;
                  if (bordered)
                      hash += 'a';
                  hash += size[0];
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              compitableColumn: useCompitable(props, ['columns', 'column']),
              inlineThemeDisabled
          };
      },
      render() {
          const defaultSlots = this.$slots.default;
          const children = defaultSlots ? flatten$3(defaultSlots()) : [];
          children.length;
          const { contentClass, labelClass, compitableColumn, labelPlacement, labelAlign, size, bordered, title, cssVars, mergedClsPrefix, separator, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const filteredChildren = children.filter((child) => isDescriptionsItem(child));
          const defaultState = {
              span: 0,
              row: [],
              secondRow: [],
              rows: []
          };
          const itemState = filteredChildren.reduce((state, vNode, index) => {
              const props = vNode.props || {};
              const isLastIteration = filteredChildren.length - 1 === index;
              const itemLabel = [
                  'label' in props ? props.label : getVNodeChildren(vNode, 'label')
              ];
              const itemChildren = [getVNodeChildren(vNode)];
              const itemSpan = props.span || 1;
              const memorizedSpan = state.span;
              state.span += itemSpan;
              const labelStyle = props.labelStyle || props['label-style'] || this.labelStyle;
              const contentStyle = props.contentStyle || props['content-style'] || this.contentStyle;
              if (labelPlacement === 'left') {
                  if (bordered) {
                      state.row.push(h("th", { class: [
                              `${mergedClsPrefix}-descriptions-table-header`,
                              labelClass
                          ], colspan: 1, style: labelStyle }, itemLabel), h("td", { class: [
                              `${mergedClsPrefix}-descriptions-table-content`,
                              contentClass
                          ], colspan: isLastIteration
                              ? (compitableColumn - memorizedSpan) * 2 + 1
                              : itemSpan * 2 - 1, style: contentStyle }, itemChildren));
                  }
                  else {
                      state.row.push(h("td", { class: `${mergedClsPrefix}-descriptions-table-content`, colspan: isLastIteration
                              ? (compitableColumn - memorizedSpan) * 2
                              : itemSpan * 2 },
                          h("span", { class: [
                                  `${mergedClsPrefix}-descriptions-table-content__label`,
                                  labelClass
                              ], style: labelStyle }, [
                              ...itemLabel,
                              separator && (h("span", { class: `${mergedClsPrefix}-descriptions-separator` }, separator))
                          ]),
                          h("span", { class: [
                                  `${mergedClsPrefix}-descriptions-table-content__content`,
                                  contentClass
                              ], style: contentStyle }, itemChildren)));
                  }
              }
              else {
                  const colspan = isLastIteration
                      ? (compitableColumn - memorizedSpan) * 2
                      : itemSpan * 2;
                  state.row.push(h("th", { class: [`${mergedClsPrefix}-descriptions-table-header`, labelClass], colspan: colspan, style: labelStyle }, itemLabel));
                  state.secondRow.push(h("td", { class: [
                          `${mergedClsPrefix}-descriptions-table-content`,
                          contentClass
                      ], colspan: colspan, style: contentStyle }, itemChildren));
              }
              if (state.span >= compitableColumn || isLastIteration) {
                  state.span = 0;
                  if (state.row.length) {
                      state.rows.push(state.row);
                      state.row = [];
                  }
                  if (labelPlacement !== 'left') {
                      if (state.secondRow.length) {
                          state.rows.push(state.secondRow);
                          state.secondRow = [];
                      }
                  }
              }
              return state;
          }, defaultState);
          const rows = itemState.rows.map((row) => (h("tr", { class: `${mergedClsPrefix}-descriptions-table-row` }, row)));
          return (h("div", { style: cssVars, class: [
                  `${mergedClsPrefix}-descriptions`,
                  this.themeClass,
                  `${mergedClsPrefix}-descriptions--${labelPlacement}-label-placement`,
                  `${mergedClsPrefix}-descriptions--${labelAlign}-label-align`,
                  `${mergedClsPrefix}-descriptions--${size}-size`,
                  bordered && `${mergedClsPrefix}-descriptions--bordered`
              ] },
              title || this.$slots.header ? (h("div", { class: `${mergedClsPrefix}-descriptions-header` }, title || getSlot$1(this, 'header'))) : null,
              h("div", { class: `${mergedClsPrefix}-descriptions-table-wrapper` },
                  h("table", { class: `${mergedClsPrefix}-descriptions-table` },
                      h("tbody", null,
                          labelPlacement === 'top' && (h("tr", { class: `${mergedClsPrefix}-descriptions-table-row`, style: {
                                  visibility: 'collapse'
                              } }, repeat(compitableColumn * 2, h("td", null)))),
                          rows)))));
      }
  });

  const descriptionsItemProps = {
      label: String,
      span: {
          type: Number,
          default: 1
      },
      labelClass: String,
      labelStyle: [Object, String],
      contentClass: String,
      contentStyle: [Object, String]
  };
  var DescriptionsItem = defineComponent({
      name: 'DescriptionsItem',
      [DESCRIPTION_ITEM_FLAG]: true,
      props: descriptionsItemProps,
      render() {
          return null;
      }
  });

  var commonVars$5 = {
      titleFontSize: '18px',
      padding: '16px 28px 20px 28px',
      iconSize: '28px',
      actionSpace: '12px',
      contentMargin: '8px 0 16px 0',
      iconMargin: '0 4px 0 0',
      iconMarginIconTop: '4px 0 8px 0',
      closeSize: '22px',
      closeIconSize: '18px',
      closeMargin: '20px 26px 0 0',
      closeMarginIconTop: '10px 16px 0 0'
  };

  const self$G = (vars) => {
      const { textColor1, textColor2, modalColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, infoColor, successColor, warningColor, errorColor, primaryColor, dividerColor, borderRadius, fontWeightStrong, lineHeight, fontSize } = vars;
      return Object.assign(Object.assign({}, commonVars$5), { fontSize,
          lineHeight, border: `1px solid ${dividerColor}`, titleTextColor: textColor1, textColor: textColor2, color: modalColor, closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed, closeBorderRadius: borderRadius, iconColor: primaryColor, iconColorInfo: infoColor, iconColorSuccess: successColor, iconColorWarning: warningColor, iconColorError: errorColor, borderRadius, titleFontWeight: fontWeightStrong });
  };
  const dialogLight = createTheme({
      name: 'Dialog',
      common: commonLight,
      peers: {
          Button: buttonLight$1
      },
      self: self$G
  });
  var dialogLight$1 = dialogLight;

  const dialogProps = {
      icon: Function,
      type: {
          type: String,
          default: 'default'
      },
      title: [String, Function],
      closable: {
          type: Boolean,
          default: true
      },
      negativeText: String,
      positiveText: String,
      positiveButtonProps: Object,
      negativeButtonProps: Object,
      content: [String, Function],
      action: Function,
      showIcon: {
          type: Boolean,
          default: true
      },
      loading: Boolean,
      bordered: Boolean,
      iconPlacement: String,
      onPositiveClick: Function,
      onNegativeClick: Function,
      onClose: Function
  };
  const dialogPropKeys = keysOf(dialogProps);

  // vars:
  // --n-icon-color
  // --n-bezier
  // --n-icon-margin
  // --n-icon-size
  // --n-close-border-radius
  // --n-close-margin
  // --n-close-size
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-color
  // --n-text-color
  // --n-border-radius
  // --n-padding
  // --n-line-height
  // --n-border
  // --n-content-margin
  // --n-title-font-size
  // --n-title-font-weight
  // --n-title-text-color
  // --n-action-space
  var style$R = c$1([cB('dialog', `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: relative;
 background: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--n-border-radius);
 padding: var(--n-padding);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cE('icon', {
    color: 'var(--n-icon-color)'
  }), cM('bordered', {
    border: 'var(--n-border)'
  }), cM('icon-top', [cE('close', {
    margin: 'var(--n-close-margin)'
  }), cE('icon', {
    margin: 'var(--n-icon-margin)'
  }), cE('content', {
    textAlign: 'center'
  }), cE('title', {
    justifyContent: 'center'
  }), cE('action', {
    justifyContent: 'center'
  })]), cM('icon-left', [cE('icon', {
    margin: 'var(--n-icon-margin)'
  }), cM('closable', [cE('title', `
 padding-right: calc(var(--n-close-size) + 6px);
 `)])]), cE('close', `
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 z-index: 1;
 `), cE('content', `
 font-size: var(--n-font-size);
 margin: var(--n-content-margin);
 position: relative;
 word-break: break-word;
 `, [cM('last', 'margin-bottom: 0;')]), cE('action', `
 display: flex;
 justify-content: flex-end;
 `, [c$1('> *:not(:last-child)', {
    marginRight: 'var(--n-action-space)'
  })]), cE('icon', {
    fontSize: 'var(--n-icon-size)',
    transition: 'color .3s var(--n-bezier)'
  }), cE('title', `
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cB('dialog-icon-container', {
    display: 'flex',
    justifyContent: 'center'
  })]), insideModal(cB('dialog', `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB('dialog', [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]);

  const iconRenderMap$2 = {
      default: () => h(InfoIcon, null),
      info: () => h(InfoIcon, null),
      success: () => h(SuccessIcon, null),
      warning: () => h(WarningIcon, null),
      error: () => h(ErrorIcon, null)
  };
  const NDialog = defineComponent({
      name: 'Dialog',
      alias: [
          'NimbusConfirmCard', // deprecated
          'Confirm' // deprecated
      ],
      props: Object.assign(Object.assign({}, useTheme.props), dialogProps),
      setup(props) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const mergedIconPlacementRef = computed(() => {
              var _a, _b;
              const { iconPlacement } = props;
              return (iconPlacement ||
                  ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) ||
                  'left');
          });
          function handlePositiveClick(e) {
              const { onPositiveClick } = props;
              if (onPositiveClick)
                  onPositiveClick(e);
          }
          function handleNegativeClick(e) {
              const { onNegativeClick } = props;
              if (onNegativeClick)
                  onNegativeClick(e);
          }
          function handleCloseClick() {
              const { onClose } = props;
              if (onClose)
                  onClose();
          }
          const themeRef = useTheme('Dialog', '-dialog', style$R, dialogLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type } = props;
              const iconPlacement = mergedIconPlacementRef.value;
              const { common: { cubicBezierEaseInOut }, self: { fontSize, lineHeight, border, titleTextColor, textColor, color, closeBorderRadius, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, closeIconSize, borderRadius, titleFontWeight, titleFontSize, padding, iconSize, actionSpace, contentMargin, closeSize, [iconPlacement === 'top' ? 'iconMarginIconTop' : 'iconMargin']: iconMargin, [iconPlacement === 'top' ? 'closeMarginIconTop' : 'closeMargin']: closeMargin, [createKey('iconColor', type)]: iconColor } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-icon-color': iconColor,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-close-margin': closeMargin,
                  '--n-icon-margin': iconMargin,
                  '--n-icon-size': iconSize,
                  '--n-close-size': closeSize,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-color': color,
                  '--n-text-color': textColor,
                  '--n-border-radius': borderRadius,
                  '--n-padding': padding,
                  '--n-line-height': lineHeight,
                  '--n-border': border,
                  '--n-content-margin': contentMargin,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-title-text-color': titleTextColor,
                  '--n-action-space': actionSpace
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('dialog', computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedIconPlacement: mergedIconPlacementRef,
              mergedTheme: themeRef,
              handlePositiveClick,
              handleNegativeClick,
              handleCloseClick,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { bordered, mergedIconPlacement, cssVars, closable, showIcon, title, content, action, negativeText, positiveText, positiveButtonProps, negativeButtonProps, handlePositiveClick, handleNegativeClick, mergedTheme, loading, type, mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const icon = showIcon ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__icon` }, {
              default: () => resolveWrappedSlot(this.$slots.icon, (children) => children ||
                  (this.icon ? render$1(this.icon) : iconRenderMap$2[this.type]()))
          })) : null;
          const actionNode = resolveWrappedSlot(this.$slots.action, (children) => children || positiveText || negativeText || action ? (h("div", { class: `${mergedClsPrefix}-dialog__action` }, children ||
              (action
                  ? [render$1(action)]
                  : [
                      this.negativeText && (h(NButton, Object.assign({ theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, ghost: true, size: "small", onClick: handleNegativeClick }, negativeButtonProps), {
                          default: () => render$1(this.negativeText)
                      })),
                      this.positiveText && (h(NButton, Object.assign({ theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: "small", type: type === 'default' ? 'primary' : type, disabled: loading, loading: loading, onClick: handlePositiveClick }, positiveButtonProps), {
                          default: () => render$1(this.positiveText)
                      }))
                  ]))) : null);
          return (h("div", { class: [
                  `${mergedClsPrefix}-dialog`,
                  this.themeClass,
                  this.closable && `${mergedClsPrefix}-dialog--closable`,
                  `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`,
                  bordered && `${mergedClsPrefix}-dialog--bordered`
              ], style: cssVars, role: "dialog" },
              closable
                  ? resolveWrappedSlot(this.$slots.close, (node) => {
                      return node ? (h("div", { class: `${mergedClsPrefix}-dialog__close` }, node)) : (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-dialog__close`, onClick: this.handleCloseClick }));
                  })
                  : null,
              showIcon && mergedIconPlacement === 'top' ? (h("div", { class: `${mergedClsPrefix}-dialog-icon-container` }, icon)) : null,
              h("div", { class: `${mergedClsPrefix}-dialog__title` },
                  showIcon && mergedIconPlacement === 'left' ? icon : null,
                  resolveSlot(this.$slots.header, () => [render$1(title)])),
              h("div", { class: [
                      `${mergedClsPrefix}-dialog__content`,
                      actionNode ? '' : `${mergedClsPrefix}-dialog__content--last`
                  ] }, resolveSlot(this.$slots.default, () => [render$1(content)])),
              actionNode));
      }
  });

  const dialogProviderInjectionKey = createInjectionKey('n-dialog-provider');
  const dialogApiInjectionKey = createInjectionKey('n-dialog-api');
  const dialogReactiveListInjectionKey = createInjectionKey('n-dialog-reactive-list');

  const self$F = (vars) => {
      const { modalColor, textColor2, boxShadow3 } = vars;
      return {
          color: modalColor,
          textColor: textColor2,
          boxShadow: boxShadow3
      };
  };
  const modalLight = createTheme({
      name: 'Modal',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1,
          Dialog: dialogLight$1,
          Card: cardLight$1
      },
      self: self$F
  });
  var modalLight$1 = modalLight;

  const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
  const presetPropsKeys = keysOf(presetProps);

  var NModalBodyWrapper = defineComponent({
      name: 'ModalBody',
      inheritAttrs: false,
      props: Object.assign(Object.assign({ show: {
              type: Boolean,
              required: true
          }, preset: String, displayDirective: {
              type: String,
              required: true
          }, trapFocus: {
              type: Boolean,
              default: true
          }, autoFocus: {
              type: Boolean,
              default: true
          }, blockScroll: Boolean }, presetProps), { renderMask: Function, 
          // events
          onClickoutside: Function, onBeforeLeave: {
              type: Function,
              required: true
          }, onAfterLeave: {
              type: Function,
              required: true
          }, onPositiveClick: {
              type: Function,
              required: true
          }, onNegativeClick: {
              type: Function,
              required: true
          }, onClose: {
              type: Function,
              required: true
          }, onAfterEnter: Function, onEsc: Function }),
      setup(props) {
          const bodyRef = ref(null);
          const scrollbarRef = ref(null);
          const displayedRef = ref(props.show);
          const transformOriginXRef = ref(null);
          const transformOriginYRef = ref(null);
          watch(toRef(props, 'show'), (value) => {
              if (value)
                  displayedRef.value = true;
          });
          useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NModal = inject(modalInjectionKey);
          function styleTransformOrigin() {
              if (NModal.transformOriginRef.value === 'center') {
                  return '';
              }
              const { value: transformOriginX } = transformOriginXRef;
              const { value: transformOriginY } = transformOriginYRef;
              if (transformOriginX === null || transformOriginY === null) {
                  return '';
              }
              else if (scrollbarRef.value) {
                  const scrollTop = scrollbarRef.value.containerScrollTop;
                  return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
              }
              return '';
          }
          function syncTransformOrigin(el) {
              if (NModal.transformOriginRef.value === 'center') {
                  return;
              }
              const mousePosition = NModal.getMousePosition();
              if (!mousePosition) {
                  return;
              }
              if (!scrollbarRef.value)
                  return;
              const scrollTop = scrollbarRef.value.containerScrollTop;
              const { offsetLeft, offsetTop } = el;
              if (mousePosition) {
                  const top = mousePosition.y;
                  const left = mousePosition.x;
                  transformOriginXRef.value = -(offsetLeft - left);
                  transformOriginYRef.value = -(offsetTop - top - scrollTop);
              }
              el.style.transformOrigin = styleTransformOrigin();
          }
          function handleEnter(el) {
              void nextTick(() => {
                  syncTransformOrigin(el);
              });
          }
          function handleBeforeLeave(el) {
              el.style.transformOrigin = styleTransformOrigin();
              props.onBeforeLeave();
          }
          function handleAfterLeave() {
              displayedRef.value = false;
              transformOriginXRef.value = null;
              transformOriginYRef.value = null;
              props.onAfterLeave();
          }
          function handleCloseClick() {
              const { onClose } = props;
              if (onClose) {
                  onClose();
              }
          }
          function handleNegativeClick() {
              props.onNegativeClick();
          }
          function handlePositiveClick() {
              props.onPositiveClick();
          }
          const childNodeRef = ref(null);
          watch(childNodeRef, (node) => {
              if (node) {
                  void nextTick(() => {
                      const el = node.el;
                      if (el && bodyRef.value !== el) {
                          bodyRef.value = el;
                      }
                  });
              }
          });
          provide(modalBodyInjectionKey, bodyRef);
          provide(drawerBodyInjectionKey, null);
          provide(popoverBodyInjectionKey, null);
          return {
              mergedTheme: NModal.mergedThemeRef,
              appear: NModal.appearRef,
              isMounted: NModal.isMountedRef,
              mergedClsPrefix: NModal.mergedClsPrefixRef,
              bodyRef,
              scrollbarRef,
              displayed: displayedRef,
              childNodeRef,
              handlePositiveClick,
              handleNegativeClick,
              handleCloseClick,
              handleAfterLeave,
              handleBeforeLeave,
              handleEnter
          };
      },
      render() {
          const { $slots, $attrs, handleEnter, handleAfterLeave, handleBeforeLeave, preset, mergedClsPrefix } = this;
          let childNode = null;
          if (!preset) {
              childNode = getFirstSlotVNode($slots);
              if (!childNode) {
                  warn$2('modal', 'default slot is empty');
                  return;
              }
              childNode = cloneVNode(childNode);
              childNode.props = mergeProps({
                  class: `${mergedClsPrefix}-modal`
              }, $attrs, childNode.props || {});
          }
          return this.displayDirective === 'show' || this.displayed || this.show
              ? withDirectives(h("div", { role: "none", class: `${mergedClsPrefix}-modal-body-wrapper` },
                  h(NScrollbar, { ref: "scrollbarRef", theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, contentClass: `${mergedClsPrefix}-modal-scroll-content` }, {
                      default: () => {
                          var _a;
                          return [
                              (_a = this.renderMask) === null || _a === void 0 ? void 0 : _a.call(this),
                              h(FocusTrap, { disabled: !this.trapFocus, active: this.show, onEsc: this.onEsc, autoFocus: this.autoFocus }, {
                                  default: () => {
                                      var _a;
                                      return (h(Transition, { name: "fade-in-scale-up-transition", appear: (_a = this.appear) !== null && _a !== void 0 ? _a : this.isMounted, onEnter: handleEnter, onAfterEnter: this.onAfterEnter, onAfterLeave: handleAfterLeave, onBeforeLeave: handleBeforeLeave }, {
                                          default: () => {
                                              const dirs = [
                                                  [vShow, this.show]
                                              ];
                                              const { onClickoutside } = this;
                                              if (onClickoutside) {
                                                  dirs.push([
                                                      clickoutside$1,
                                                      this.onClickoutside,
                                                      undefined,
                                                      { capture: true }
                                                  ]);
                                              }
                                              return withDirectives((this.preset === 'confirm' ||
                                                  this.preset === 'dialog' ? (h(NDialog, Object.assign({}, this.$attrs, { class: [
                                                      `${mergedClsPrefix}-modal`,
                                                      this.$attrs.class
                                                  ], ref: "bodyRef", theme: this.mergedTheme.peers.Dialog, themeOverrides: this.mergedTheme.peerOverrides.Dialog }, keep(this.$props, dialogPropKeys), { "aria-modal": "true" }), $slots)) : this.preset === 'card' ? (h(NCard, Object.assign({}, this.$attrs, { ref: "bodyRef", class: [
                                                      `${mergedClsPrefix}-modal`,
                                                      this.$attrs.class
                                                  ], theme: this.mergedTheme.peers.Card, themeOverrides: this.mergedTheme.peerOverrides.Card }, keep(this.$props, cardBasePropKeys), { "aria-modal": "true", role: "dialog" }), $slots)) : ((this.childNodeRef = childNode))), dirs);
                                          }
                                      }));
                                  }
                              })
                          ];
                      }
                  })), [
                  [
                      vShow,
                      this.displayDirective === 'if' || this.displayed || this.show
                  ]
              ])
              : null;
      }
  });

  // vars:
  // --n-bezier-ease-out
  // --n-box-shadow
  // --n-color
  // --n-text-color
  var style$Q = c$1([cB('modal-container', `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB('modal-mask', `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fadeInTransition({
    enterDuration: '.25s',
    leaveDuration: '.25s',
    enterCubicBezier: 'var(--n-bezier-ease-out)',
    leaveCubicBezier: 'var(--n-bezier-ease-out)'
  })]), cB('modal-body-wrapper', `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB('modal-scroll-content', `
 min-height: 100%;
 display: flex;
 position: relative;
 `)]), cB('modal', `
 position: relative;
 align-self: center;
 color: var(--n-text-color);
 margin: auto;
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition({
    duration: '.25s',
    enterScale: '.5'
  })])]);

  const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { show: Boolean, unstableShowMask: {
          type: Boolean,
          default: true
      }, maskClosable: {
          type: Boolean,
          default: true
      }, preset: String, to: [String, Object], displayDirective: {
          type: String,
          default: 'if'
      }, transformOrigin: {
          type: String,
          default: 'mouse'
      }, zIndex: Number, autoFocus: {
          type: Boolean,
          default: true
      }, trapFocus: {
          type: Boolean,
          default: true
      }, closeOnEsc: {
          type: Boolean,
          default: true
      }, blockScroll: { type: Boolean, default: true } }), presetProps), { 
      // events
      onEsc: Function, 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onBeforeLeave: Function, onAfterLeave: Function, onClose: Function, onPositiveClick: Function, onNegativeClick: Function, onMaskClick: Function, 
      // private
      internalDialog: Boolean, internalAppear: {
          type: Boolean,
          default: undefined
      }, 
      // deprecated
      overlayStyle: [String, Object], onBeforeHide: Function, onAfterHide: Function, onHide: Function });
  var NModal = defineComponent({
      name: 'Modal',
      inheritAttrs: false,
      props: modalProps,
      setup(props) {
          const containerRef = ref(null);
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Modal', '-modal', style$Q, modalLight$1, props, mergedClsPrefixRef);
          const clickedRef = useClicked(64);
          const clickedPositionRef = useClickPosition();
          const isMountedRef = isMounted();
          const NDialogProvider = props.internalDialog
              ? inject(dialogProviderInjectionKey, null)
              : null;
          const isComposingRef = useIsComposing();
          function doUpdateShow(show) {
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow, onHide } = props;
              if (onUpdateShow)
                  call(onUpdateShow, show);
              if (_onUpdateShow)
                  call(_onUpdateShow, show);
              // deprecated
              if (onHide && !show)
                  onHide(show);
          }
          function handleCloseClick() {
              const { onClose } = props;
              if (onClose) {
                  void Promise.resolve(onClose()).then((value) => {
                      if (value === false)
                          return;
                      doUpdateShow(false);
                  });
              }
              else {
                  doUpdateShow(false);
              }
          }
          function handlePositiveClick() {
              const { onPositiveClick } = props;
              if (onPositiveClick) {
                  void Promise.resolve(onPositiveClick()).then((value) => {
                      if (value === false)
                          return;
                      doUpdateShow(false);
                  });
              }
              else {
                  doUpdateShow(false);
              }
          }
          function handleNegativeClick() {
              const { onNegativeClick } = props;
              if (onNegativeClick) {
                  void Promise.resolve(onNegativeClick()).then((value) => {
                      if (value === false)
                          return;
                      doUpdateShow(false);
                  });
              }
              else {
                  doUpdateShow(false);
              }
          }
          function handleBeforeLeave() {
              const { onBeforeLeave, onBeforeHide } = props;
              if (onBeforeLeave)
                  call(onBeforeLeave);
              // deprecated
              if (onBeforeHide)
                  onBeforeHide();
          }
          function handleAfterLeave() {
              const { onAfterLeave, onAfterHide } = props;
              if (onAfterLeave)
                  call(onAfterLeave);
              // deprecated
              if (onAfterHide)
                  onAfterHide();
          }
          function handleClickoutside(e) {
              var _a;
              const { onMaskClick } = props;
              if (onMaskClick) {
                  onMaskClick(e);
              }
              if (props.maskClosable) {
                  if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
                      doUpdateShow(false);
                  }
              }
          }
          function handleEsc(e) {
              var _a;
              (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
              if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
                  !isComposingRef.value && doUpdateShow(false);
              }
          }
          provide(modalInjectionKey, {
              getMousePosition: () => {
                  if (NDialogProvider) {
                      const { clickedRef, clickPositionRef } = NDialogProvider;
                      if (clickedRef.value && clickPositionRef.value) {
                          return clickPositionRef.value;
                      }
                  }
                  if (clickedRef.value) {
                      return clickedPositionRef.value;
                  }
                  return null;
              },
              mergedClsPrefixRef,
              mergedThemeRef: themeRef,
              isMountedRef,
              appearRef: toRef(props, 'internalAppear'),
              transformOriginRef: toRef(props, 'transformOrigin')
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseOut }, self: { boxShadow, color, textColor } } = themeRef.value;
              return {
                  '--n-bezier-ease-out': cubicBezierEaseOut,
                  '--n-box-shadow': boxShadow,
                  '--n-color': color,
                  '--n-text-color': textColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('theme-class', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              namespace: namespaceRef,
              isMounted: isMountedRef,
              containerRef,
              presetProps: computed(() => {
                  const pickedProps = keep(props, presetPropsKeys);
                  // TODO: remove as any after vue fix the issue introduced in 3.2.27
                  return pickedProps;
              }),
              handleEsc,
              handleAfterLeave,
              handleClickoutside,
              handleBeforeLeave,
              doUpdateShow,
              handleNegativeClick,
              handlePositiveClick,
              handleCloseClick,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h(LazyTeleport, { to: this.to, show: this.show }, {
              default: () => {
                  var _a;
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  const { unstableShowMask } = this;
                  return withDirectives(h("div", { role: "none", ref: "containerRef", class: [
                          `${mergedClsPrefix}-modal-container`,
                          this.themeClass,
                          this.namespace
                      ], style: this.cssVars },
                      h(NModalBodyWrapper, Object.assign({ style: this.overlayStyle }, this.$attrs, { ref: "bodyWrapper", displayDirective: this.displayDirective, show: this.show, preset: this.preset, autoFocus: this.autoFocus, trapFocus: this.trapFocus, blockScroll: this.blockScroll }, this.presetProps, { onEsc: this.handleEsc, onClose: this.handleCloseClick, onNegativeClick: this.handleNegativeClick, onPositiveClick: this.handlePositiveClick, onBeforeLeave: this.handleBeforeLeave, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave, onClickoutside: unstableShowMask ? undefined : this.handleClickoutside, renderMask: unstableShowMask
                              ? () => {
                                  var _a;
                                  return (h(Transition, { name: "fade-in-transition", key: "mask", appear: (_a = this.internalAppear) !== null && _a !== void 0 ? _a : this.isMounted }, {
                                      default: () => {
                                          return this.show ? (h("div", { "aria-hidden": true, ref: "containerRef", class: `${mergedClsPrefix}-modal-mask`, onClick: this.handleClickoutside })) : null;
                                      }
                                  }));
                              }
                              : undefined }), this.$slots)), [
                      [
                          zindexable$1,
                          {
                              zIndex: this.zIndex,
                              enabled: this.show
                          }
                      ]
                  ]);
              }
          }));
      }
  });

  // use absolute path to make sure no circular ref of style
  // this -> modal-index -> modal-style
  const exposedDialogEnvProps = Object.assign(Object.assign({}, dialogProps), { onAfterEnter: Function, onAfterLeave: Function, transformOrigin: String, blockScroll: { type: Boolean, default: true }, closeOnEsc: { type: Boolean, default: true }, onEsc: Function, autoFocus: {
          type: Boolean,
          default: true
      }, internalStyle: [String, Object], maskClosable: {
          type: Boolean,
          default: true
      }, onPositiveClick: Function, onNegativeClick: Function, onClose: Function, onMaskClick: Function });
  const NDialogEnvironment = defineComponent({
      name: 'DialogEnvironment',
      props: Object.assign(Object.assign({}, exposedDialogEnvProps), { internalKey: {
              type: String,
              required: true
          }, to: [String, Object], 
          // private
          onInternalAfterLeave: {
              type: Function,
              required: true
          } }),
      setup(props) {
          const showRef = ref(true);
          function handleAfterLeave() {
              const { onInternalAfterLeave, internalKey, onAfterLeave } = props;
              if (onInternalAfterLeave)
                  onInternalAfterLeave(internalKey);
              if (onAfterLeave)
                  onAfterLeave();
          }
          function handlePositiveClick(e) {
              const { onPositiveClick } = props;
              if (onPositiveClick) {
                  void Promise.resolve(onPositiveClick(e)).then((result) => {
                      if (result === false)
                          return;
                      hide();
                  });
              }
              else {
                  hide();
              }
          }
          function handleNegativeClick(e) {
              const { onNegativeClick } = props;
              if (onNegativeClick) {
                  void Promise.resolve(onNegativeClick(e)).then((result) => {
                      if (result === false)
                          return;
                      hide();
                  });
              }
              else {
                  hide();
              }
          }
          function handleCloseClick() {
              const { onClose } = props;
              if (onClose) {
                  void Promise.resolve(onClose()).then((result) => {
                      if (result === false)
                          return;
                      hide();
                  });
              }
              else {
                  hide();
              }
          }
          function handleMaskClick(e) {
              const { onMaskClick, maskClosable } = props;
              if (onMaskClick) {
                  onMaskClick(e);
                  maskClosable && hide();
              }
          }
          function handleEsc() {
              const { onEsc } = props;
              if (onEsc) {
                  onEsc();
              }
          }
          function hide() {
              showRef.value = false;
          }
          function handleUpdateShow(value) {
              showRef.value = value;
          }
          return {
              show: showRef,
              hide,
              handleUpdateShow,
              handleAfterLeave,
              handleCloseClick,
              handleNegativeClick,
              handlePositiveClick,
              handleMaskClick,
              handleEsc
          };
      },
      render() {
          const { handlePositiveClick, handleUpdateShow, handleNegativeClick, handleCloseClick, handleAfterLeave, handleMaskClick, handleEsc, to, maskClosable, show } = this;
          return (h(NModal, { show: show, onUpdateShow: handleUpdateShow, onMaskClick: handleMaskClick, onEsc: handleEsc, to: to, maskClosable: maskClosable, onAfterEnter: this.onAfterEnter, onAfterLeave: handleAfterLeave, closeOnEsc: this.closeOnEsc, blockScroll: this.blockScroll, autoFocus: this.autoFocus, transformOrigin: this.transformOrigin, internalAppear: true, internalDialog: true }, {
              default: () => (h(NDialog, Object.assign({}, keep(this.$props, dialogPropKeys), { style: this.internalStyle, onClose: handleCloseClick, onNegativeClick: handleNegativeClick, onPositiveClick: handlePositiveClick })))
          }));
      }
  });

  const dialogProviderProps = {
      injectionKey: String,
      to: [String, Object]
  };
  const NDialogProvider = defineComponent({
      name: 'DialogProvider',
      props: dialogProviderProps,
      setup() {
          const dialogListRef = ref([]);
          const dialogInstRefs = {};
          function create(options = {}) {
              const key = createId();
              const dialogReactive = reactive(Object.assign(Object.assign({}, options), { key, destroy: () => {
                      dialogInstRefs[`n-dialog-${key}`].hide();
                  } }));
              dialogListRef.value.push(dialogReactive);
              return dialogReactive;
          }
          const typedApi = ['info', 'success', 'warning', 'error'].map((type) => (options) => {
              return create(Object.assign(Object.assign({}, options), { type }));
          });
          function handleAfterLeave(key) {
              const { value: dialogList } = dialogListRef;
              dialogList.splice(dialogList.findIndex((dialog) => dialog.key === key), 1);
          }
          function destroyAll() {
              Object.values(dialogInstRefs).forEach((dialogInstRef) => {
                  dialogInstRef.hide();
              });
          }
          const api = {
              create,
              destroyAll,
              info: typedApi[0],
              success: typedApi[1],
              warning: typedApi[2],
              error: typedApi[3]
          };
          provide(dialogApiInjectionKey, api);
          provide(dialogProviderInjectionKey, {
              clickedRef: useClicked(64),
              clickPositionRef: useClickPosition()
          });
          provide(dialogReactiveListInjectionKey, dialogListRef);
          return Object.assign(Object.assign({}, api), { dialogList: dialogListRef, dialogInstRefs,
              handleAfterLeave });
      },
      render() {
          var _a, _b;
          return h(Fragment, null, [
              this.dialogList.map((dialog) => h(NDialogEnvironment, omit(dialog, ['destroy', 'style'], {
                  internalStyle: dialog.style,
                  to: this.to,
                  ref: ((inst) => {
                      if (inst === null) {
                          // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
                          delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
                      }
                      else {
                          this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
                      }
                  }),
                  internalKey: dialog.key,
                  onInternalAfterLeave: this.handleAfterLeave
              }))),
              (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)
          ]);
      }
  });

  function useDialog() {
      const dialog = inject(dialogApiInjectionKey, null);
      if (dialog === null) {
          throwError('use-dialog', 'No outer <n-dialog-provider /> founded.');
      }
      return dialog;
  }
  function useDialogReactiveList() {
      const dialogReactiveList = inject(dialogReactiveListInjectionKey, null);
      if (dialogReactiveList === null) {
          throwError('use-dialog-reactive-list', 'No outer <n-dialog-provider /> founded.');
      }
      return dialogReactiveList;
  }

  const self$E = (vars) => {
      const { textColor1, dividerColor, fontWeightStrong } = vars;
      return {
          textColor: textColor1,
          color: dividerColor,
          fontWeight: fontWeightStrong
      };
  };
  const dividerLight = {
      name: 'Divider',
      common: commonLight,
      self: self$E
  };
  var dividerLight$1 = dividerLight;

  // vars:
  // --n-bezier
  // --n-color
  // --n-text-color
  // --n-font-weight
  var style$P = cB('divider', `
 position: relative;
 display: flex;
 width: 100%;
 box-sizing: border-box;
 font-size: 16px;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
`, [cNotM('vertical', `
 margin-top: 24px;
 margin-bottom: 24px;
 `, [cNotM('no-title', `
 display: flex;
 align-items: center;
 `)]), cE('title', `
 display: flex;
 align-items: center;
 margin-left: 12px;
 margin-right: 12px;
 white-space: nowrap;
 font-weight: var(--n-font-weight);
 `), cM('title-position-left', [cE('line', [cM('left', {
    width: '28px'
  })])]), cM('title-position-right', [cE('line', [cM('right', {
    width: '28px'
  })])]), cM('dashed', [cE('line', `
 background-color: #0000;
 height: 0px;
 width: 100%;
 border-style: dashed;
 border-width: 1px 0 0;
 `)]), cM('vertical', `
 display: inline-block;
 height: 1em;
 margin: 0 8px;
 vertical-align: middle;
 width: 1px;
 `), cE('line', `
 border: none;
 transition: background-color .3s var(--n-bezier), border-color .3s var(--n-bezier);
 height: 1px;
 width: 100%;
 margin: 0;
 `), cNotM('dashed', [cE('line', {
    backgroundColor: 'var(--n-color)'
  })]), cM('dashed', [cE('line', {
    borderColor: 'var(--n-color)'
  })]), cM('vertical', {
    backgroundColor: 'var(--n-color)'
  })]);

  const dividerProps = Object.assign(Object.assign({}, useTheme.props), { titlePlacement: {
          type: String,
          default: 'center'
      }, dashed: Boolean, vertical: Boolean });
  var NDivider = defineComponent({
      name: 'Divider',
      props: dividerProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Divider', '-divider', style$P, dividerLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { color, textColor, fontWeight } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color': color,
                  '--n-text-color': textColor,
                  '--n-font-weight': fontWeight
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('divider', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { $slots, titlePlacement, vertical, dashed, cssVars, mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { role: "separator", class: [
                  `${mergedClsPrefix}-divider`,
                  this.themeClass,
                  {
                      [`${mergedClsPrefix}-divider--vertical`]: vertical,
                      [`${mergedClsPrefix}-divider--no-title`]: !$slots.default,
                      [`${mergedClsPrefix}-divider--dashed`]: dashed,
                      [`${mergedClsPrefix}-divider--title-position-${titlePlacement}`]: $slots.default && titlePlacement
                  }
              ], style: cssVars },
              !vertical ? (h("div", { class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--left` })) : null,
              !vertical && $slots.default ? (h(Fragment, null,
                  h("div", { class: `${mergedClsPrefix}-divider__title` }, this.$slots),
                  h("div", { class: `${mergedClsPrefix}-divider__line ${mergedClsPrefix}-divider__line--right` }))) : null));
      }
  });

  const self$D = (vars) => {
      const { modalColor, textColor1, textColor2, boxShadow3, lineHeight, fontWeightStrong, dividerColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, borderRadius, primaryColorHover } = vars;
      return {
          bodyPadding: '16px 24px',
          headerPadding: '16px 24px',
          footerPadding: '16px 24px',
          color: modalColor,
          textColor: textColor2,
          titleTextColor: textColor1,
          titleFontSize: '18px',
          titleFontWeight: fontWeightStrong,
          boxShadow: boxShadow3,
          lineHeight,
          headerBorderBottom: `1px solid ${dividerColor}`,
          footerBorderTop: `1px solid ${dividerColor}`,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeSize: '22px',
          closeIconSize: '18px',
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          resizableTriggerColorHover: primaryColorHover
      };
  };
  const drawerLight = createTheme({
      name: 'Drawer',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1
      },
      self: self$D
  });
  var drawerLight$1 = drawerLight;

  var NDrawerBodyWrapper = defineComponent({
      name: 'NDrawerContent',
      inheritAttrs: false,
      props: {
          blockScroll: Boolean,
          show: {
              type: Boolean,
              default: undefined
          },
          displayDirective: {
              type: String,
              required: true
          },
          placement: {
              type: String,
              required: true
          },
          contentStyle: [Object, String],
          nativeScrollbar: {
              type: Boolean,
              required: true
          },
          scrollbarProps: Object,
          trapFocus: {
              type: Boolean,
              default: true
          },
          autoFocus: {
              type: Boolean,
              default: true
          },
          showMask: {
              type: [Boolean, String],
              required: true
          },
          maxWidth: Number,
          maxHeight: Number,
          minWidth: Number,
          minHeight: Number,
          resizable: Boolean,
          onClickoutside: Function,
          onAfterLeave: Function,
          onAfterEnter: Function,
          onEsc: Function
      },
      setup(props) {
          const displayedRef = ref(!!props.show);
          const bodyRef = ref(null); // used for detached content
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NDrawer = inject(drawerInjectionKey);
          let startPosition = 0;
          let memoizedBodyStyleCursor = '';
          let hoverTimerId = null;
          const isHoverOnResizeTriggerRef = ref(false);
          const isDraggingRef = ref(false);
          const isVertical = computed(() => {
              return props.placement === 'top' || props.placement === 'bottom';
          });
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('Drawer', mergedRtlRef, mergedClsPrefixRef);
          const handleMousedownResizeTrigger = (e) => {
              isDraggingRef.value = true;
              startPosition = isVertical.value ? e.clientY : e.clientX;
              memoizedBodyStyleCursor = document.body.style.cursor;
              document.body.style.cursor = isVertical.value ? 'ns-resize' : 'ew-resize';
              document.body.addEventListener('mousemove', handleBodyMousemove);
              document.body.addEventListener('mouseleave', handleBodyMouseleave);
              document.body.addEventListener('mouseup', handleBodyMouseup);
          };
          const handleMouseenterResizeTrigger = () => {
              if (hoverTimerId !== null) {
                  window.clearTimeout(hoverTimerId);
                  hoverTimerId = null;
              }
              if (isDraggingRef.value) {
                  isHoverOnResizeTriggerRef.value = true;
              }
              else {
                  hoverTimerId = window.setTimeout(() => {
                      isHoverOnResizeTriggerRef.value = true;
                  }, 300);
              }
          };
          const handleMouseleaveResizeTrigger = () => {
              if (hoverTimerId !== null) {
                  window.clearTimeout(hoverTimerId);
                  hoverTimerId = null;
              }
              isHoverOnResizeTriggerRef.value = false;
          };
          const { doUpdateHeight, doUpdateWidth } = NDrawer;
          const regulateWidth = (size) => {
              const { maxWidth } = props;
              if (maxWidth && size > maxWidth)
                  return maxWidth;
              const { minWidth } = props;
              if (minWidth && size < minWidth)
                  return minWidth;
              return size;
          };
          const regulateHeight = (size) => {
              const { maxHeight } = props;
              if (maxHeight && size > maxHeight)
                  return maxHeight;
              const { minHeight } = props;
              if (minHeight && size < minHeight)
                  return minHeight;
              return size;
          };
          const handleBodyMousemove = (e) => {
              var _a, _b;
              if (isDraggingRef.value) {
                  if (isVertical.value) {
                      let height = ((_a = bodyRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight) || 0;
                      const increment = startPosition - e.clientY;
                      height += props.placement === 'bottom' ? increment : -increment;
                      height = regulateHeight(height);
                      doUpdateHeight(height);
                      startPosition = e.clientY;
                  }
                  else {
                      let width = ((_b = bodyRef.value) === null || _b === void 0 ? void 0 : _b.offsetWidth) || 0;
                      const increment = startPosition - e.clientX;
                      width += props.placement === 'right' ? increment : -increment;
                      width = regulateWidth(width);
                      doUpdateWidth(width);
                      startPosition = e.clientX;
                  }
              }
          };
          const handleBodyMouseup = () => {
              if (isDraggingRef.value) {
                  startPosition = 0;
                  isDraggingRef.value = false;
                  document.body.style.cursor = memoizedBodyStyleCursor;
                  document.body.removeEventListener('mousemove', handleBodyMousemove);
                  document.body.removeEventListener('mouseup', handleBodyMouseup);
                  document.body.removeEventListener('mouseleave', handleBodyMouseleave);
              }
          };
          const handleBodyMouseleave = handleBodyMouseup;
          watchEffect(() => {
              if (props.show)
                  displayedRef.value = true;
          });
          watch(() => props.show, (value) => {
              if (!value) {
                  handleBodyMouseup();
              }
          });
          onBeforeUnmount(() => {
              handleBodyMouseup();
          });
          const bodyDirectivesRef = computed(() => {
              const { show } = props;
              const directives = [[vShow, show]];
              if (!props.showMask) {
                  directives.push([
                      clickoutside$1,
                      props.onClickoutside,
                      undefined,
                      { capture: true }
                  ]);
              }
              return directives;
          });
          function handleAfterLeave() {
              var _a;
              displayedRef.value = false;
              (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          useLockHtmlScroll(computed(() => props.blockScroll && displayedRef.value));
          provide(drawerBodyInjectionKey, bodyRef);
          provide(popoverBodyInjectionKey, null);
          provide(modalBodyInjectionKey, null);
          return {
              bodyRef,
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: NDrawer.mergedClsPrefixRef,
              isMounted: NDrawer.isMountedRef,
              mergedTheme: NDrawer.mergedThemeRef,
              displayed: displayedRef,
              transitionName: computed(() => {
                  return {
                      right: 'slide-in-from-right-transition',
                      left: 'slide-in-from-left-transition',
                      top: 'slide-in-from-top-transition',
                      bottom: 'slide-in-from-bottom-transition'
                  }[props.placement];
              }),
              handleAfterLeave,
              bodyDirectives: bodyDirectivesRef,
              handleMousedownResizeTrigger,
              handleMouseenterResizeTrigger,
              handleMouseleaveResizeTrigger,
              isDragging: isDraggingRef,
              isHoverOnResizeTrigger: isHoverOnResizeTriggerRef
          };
      },
      render() {
          const { $slots, mergedClsPrefix } = this;
          return this.displayDirective === 'show' || this.displayed || this.show
              ? withDirectives(
              /* Keep the wrapper dom. Make sure the drawer has a host.
              Nor the detached content will disappear without transition */
              h("div", { role: "none" },
                  h(FocusTrap, { disabled: !this.showMask || !this.trapFocus, active: this.show, autoFocus: this.autoFocus, onEsc: this.onEsc }, {
                      default: () => (h(Transition, { name: this.transitionName, appear: this.isMounted, onAfterEnter: this.onAfterEnter, onAfterLeave: this.handleAfterLeave }, {
                          default: () => withDirectives(h('div', mergeProps(this.$attrs, {
                              role: 'dialog',
                              ref: 'bodyRef',
                              'aria-modal': 'true',
                              class: [
                                  `${mergedClsPrefix}-drawer`,
                                  this.rtlEnabled &&
                                      `${mergedClsPrefix}-drawer--rtl`,
                                  `${mergedClsPrefix}-drawer--${this.placement}-placement`,
                                  /**
                                   * When the mouse is pressed to resize the drawer,
                                   * disable text selection
                                   */
                                  this.isDragging &&
                                      `${mergedClsPrefix}-drawer--unselectable`,
                                  this.nativeScrollbar &&
                                      `${mergedClsPrefix}-drawer--native-scrollbar`
                              ]
                          }), [
                              this.resizable ? (h("div", { class: [
                                      `${mergedClsPrefix}-drawer__resize-trigger`,
                                      (this.isDragging ||
                                          this.isHoverOnResizeTrigger) &&
                                          `${mergedClsPrefix}-drawer__resize-trigger--hover`
                                  ], onMouseenter: this.handleMouseenterResizeTrigger, onMouseleave: this.handleMouseleaveResizeTrigger, onMousedown: this.handleMousedownResizeTrigger })) : null,
                              this.nativeScrollbar ? (h("div", { class: `${mergedClsPrefix}-drawer-content-wrapper`, style: this.contentStyle, role: "none" }, $slots)) : (h(NScrollbar, Object.assign({}, this.scrollbarProps, { contentStyle: this.contentStyle, contentClass: `${mergedClsPrefix}-drawer-content-wrapper`, theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar }), $slots))
                          ]), this.bodyDirectives)
                      }))
                  })), [
                  [
                      vShow,
                      this.displayDirective === 'if' || this.displayed || this.show
                  ]
              ])
              : null;
      }
  });

  const { cubicBezierEaseIn: cubicBezierEaseIn$3, cubicBezierEaseOut: cubicBezierEaseOut$3 } = commonVariables$m;
  function slideInFromRightTransition({ duration = '0.3s', leaveDuration = '0.2s', name = 'slide-in-from-right' } = {}) {
      return [
          c$1(`&.${name}-transition-leave-active`, {
              transition: `transform ${leaveDuration} ${cubicBezierEaseIn$3}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
              transition: `transform ${duration} ${cubicBezierEaseOut$3}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
              transform: 'translateX(0)'
          }),
          c$1(`&.${name}-transition-enter-from`, {
              transform: 'translateX(100%)'
          }),
          c$1(`&.${name}-transition-leave-from`, {
              transform: 'translateX(0)'
          }),
          c$1(`&.${name}-transition-leave-to`, {
              transform: 'translateX(100%)'
          })
      ];
  }

  const { cubicBezierEaseIn: cubicBezierEaseIn$2, cubicBezierEaseOut: cubicBezierEaseOut$2 } = commonVariables$m;
  function slideInFromLeftTransition({ duration = '0.3s', leaveDuration = '0.2s', name = 'slide-in-from-left' } = {}) {
      return [
          c$1(`&.${name}-transition-leave-active`, {
              transition: `transform ${leaveDuration} ${cubicBezierEaseIn$2}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
              transition: `transform ${duration} ${cubicBezierEaseOut$2}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
              transform: 'translateX(0)'
          }),
          c$1(`&.${name}-transition-enter-from`, {
              transform: 'translateX(-100%)'
          }),
          c$1(`&.${name}-transition-leave-from`, {
              transform: 'translateX(0)'
          }),
          c$1(`&.${name}-transition-leave-to`, {
              transform: 'translateX(-100%)'
          })
      ];
  }

  const { cubicBezierEaseIn: cubicBezierEaseIn$1, cubicBezierEaseOut: cubicBezierEaseOut$1 } = commonVariables$m;
  function slideInFromTopTransition({ duration = '0.3s', leaveDuration = '0.2s', name = 'slide-in-from-top' } = {}) {
      return [
          c$1(`&.${name}-transition-leave-active`, {
              transition: `transform ${leaveDuration} ${cubicBezierEaseIn$1}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
              transition: `transform ${duration} ${cubicBezierEaseOut$1}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
              transform: 'translateY(0)'
          }),
          c$1(`&.${name}-transition-enter-from`, {
              transform: 'translateY(-100%)'
          }),
          c$1(`&.${name}-transition-leave-from`, {
              transform: 'translateY(0)'
          }),
          c$1(`&.${name}-transition-leave-to`, {
              transform: 'translateY(-100%)'
          })
      ];
  }

  const { cubicBezierEaseIn, cubicBezierEaseOut } = commonVariables$m;
  function slideInFromBottomTransition({ duration = '0.3s', leaveDuration = '0.2s', name = 'slide-in-from-bottom' } = {}) {
      return [
          c$1(`&.${name}-transition-leave-active`, {
              transition: `transform ${leaveDuration} ${cubicBezierEaseIn}`
          }),
          c$1(`&.${name}-transition-enter-active`, {
              transition: `transform ${duration} ${cubicBezierEaseOut}`
          }),
          c$1(`&.${name}-transition-enter-to`, {
              transform: 'translateY(0)'
          }),
          c$1(`&.${name}-transition-enter-from`, {
              transform: 'translateY(100%)'
          }),
          c$1(`&.${name}-transition-leave-from`, {
              transform: 'translateY(0)'
          }),
          c$1(`&.${name}-transition-leave-to`, {
              transform: 'translateY(100%)'
          })
      ];
  }

  // vars:
  // --n-line-height
  // --n-color
  // --n-text-color
  // --n-box-shadow
  // --n-bezier
  // --n-bezier-out
  // --n-bezier-in
  // --n-body-padding
  // --n-header-padding
  // --n-footer-padding
  // --n-title-font-size
  // --n-title-text-color
  // --n-title-font-weight
  // --n-header-border-bottom
  // --n-footer-border-top
  // --n-close-border-radius
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-close-size
  // --n-close-icon-size
  var style$O = c$1([cB('drawer', `
 word-break: break-word;
 line-height: var(--n-line-height);
 position: absolute;
 pointer-events: all;
 box-shadow: var(--n-box-shadow);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background-color: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 `, [slideInFromRightTransition(), slideInFromLeftTransition(), slideInFromTopTransition(), slideInFromBottomTransition(), cM('unselectable', `
 user-select: none; 
 -webkit-user-select: none;
 `), cM('native-scrollbar', [cB('drawer-content-wrapper', `
 overflow: auto;
 height: 100%;
 `)]), cE('resize-trigger', `
 position: absolute;
 background-color: #0000;
 transition: background-color .3s var(--n-bezier);
 `, [cM('hover', `
 background-color: var(--n-resize-trigger-color-hover);
 `)]), cB('drawer-content-wrapper', `
 box-sizing: border-box;
 `), cB('drawer-content', `
 height: 100%;
 display: flex;
 flex-direction: column;
 `, [cM('native-scrollbar', [cB('drawer-body-content-wrapper', `
 height: 100%;
 overflow: auto;
 `)]), cB('drawer-body', `
 flex: 1 0 0;
 overflow: hidden;
 `), cB('drawer-body-content-wrapper', `
 box-sizing: border-box;
 padding: var(--n-body-padding);
 `), cB('drawer-header', `
 font-weight: var(--n-title-font-weight);
 line-height: 1;
 font-size: var(--n-title-font-size);
 color: var(--n-title-text-color);
 padding: var(--n-header-padding);
 transition: border .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-divider-color);
 border-bottom: var(--n-header-border-bottom);
 display: flex;
 justify-content: space-between;
 align-items: center;
 `, [cE('close', `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cB('drawer-footer', `
 display: flex;
 justify-content: flex-end;
 border-top: var(--n-footer-border-top);
 transition: border .3s var(--n-bezier);
 padding: var(--n-footer-padding);
 `)]), cM('right-placement', `
 top: 0;
 bottom: 0;
 right: 0;
 `, [cE('resize-trigger', `
 width: 3px;
 height: 100%;
 top: 0;
 left: 0;
 transform: translateX(-1.5px);
 cursor: ew-resize;
 `)]), cM('left-placement', `
 top: 0;
 bottom: 0;
 left: 0;
 `, [cE('resize-trigger', `
 width: 3px;
 height: 100%;
 top: 0;
 right: 0;
 transform: translateX(1.5px);
 cursor: ew-resize;
 `)]), cM('top-placement', `
 top: 0;
 left: 0;
 right: 0;
 `, [cE('resize-trigger', `
 width: 100%;
 height: 3px;
 bottom: 0;
 left: 0;
 transform: translateY(1.5px);
 cursor: ns-resize;
 `)]), cM('bottom-placement', `
 left: 0;
 bottom: 0;
 right: 0;
 `, [cE('resize-trigger', `
 width: 100%;
 height: 3px;
 top: 0;
 left: 0;
 transform: translateY(-1.5px);
 cursor: ns-resize;
 `)])]), c$1('body', [c$1('>', [cB('drawer-container', {
    position: 'fixed'
  })])]), cB('drawer-container', `
 position: relative;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 `, [c$1('> *', {
    pointerEvents: 'all'
  })]), cB('drawer-mask', `
 background-color: rgba(0, 0, 0, .3);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [cM('invisible', `
 background-color: rgba(0, 0, 0, 0)
 `), fadeInTransition({
    enterDuration: '0.2s',
    leaveDuration: '0.2s',
    enterCubicBezier: 'var(--n-bezier-in)',
    leaveCubicBezier: 'var(--n-bezier-out)'
  })])]);

  const drawerProps = Object.assign(Object.assign({}, useTheme.props), { show: Boolean, width: [Number, String], height: [Number, String], placement: {
          type: String,
          default: 'right'
      }, maskClosable: {
          type: Boolean,
          default: true
      }, showMask: {
          type: [Boolean, String],
          default: true
      }, to: [String, Object], displayDirective: {
          type: String,
          default: 'if'
      }, nativeScrollbar: {
          type: Boolean,
          default: true
      }, zIndex: Number, onMaskClick: Function, scrollbarProps: Object, contentStyle: [Object, String], trapFocus: {
          type: Boolean,
          default: true
      }, onEsc: Function, autoFocus: {
          type: Boolean,
          default: true
      }, closeOnEsc: {
          type: Boolean,
          default: true
      }, blockScroll: {
          type: Boolean,
          default: true
      }, maxWidth: Number, maxHeight: Number, minWidth: Number, minHeight: Number, resizable: Boolean, defaultWidth: {
          type: [Number, String],
          default: 251
      }, defaultHeight: {
          type: [Number, String],
          default: 251
      }, onUpdateWidth: [Function, Array], onUpdateHeight: [Function, Array], 'onUpdate:width': [Function, Array], 'onUpdate:height': [Function, Array], 'onUpdate:show': [Function, Array], onUpdateShow: [Function, Array], onAfterEnter: Function, onAfterLeave: Function, 
      /** @deprecated */
      drawerStyle: [String, Object], drawerClass: String, target: null, onShow: Function, onHide: Function });
  var Drawer = defineComponent({
      name: 'Drawer',
      inheritAttrs: false,
      props: drawerProps,
      setup(props) {
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const isMountedRef = isMounted();
          const themeRef = useTheme('Drawer', '-drawer', style$O, drawerLight$1, props, mergedClsPrefixRef);
          const uncontrolledWidthRef = ref(props.defaultWidth);
          const uncontrolledHeightRef = ref(props.defaultHeight);
          const mergedWidthRef = useMergedState(toRef(props, 'width'), uncontrolledWidthRef);
          const mergedHeightRef = useMergedState(toRef(props, 'height'), uncontrolledHeightRef);
          const styleWidthRef = computed(() => {
              const { placement } = props;
              if (placement === 'top' || placement === 'bottom')
                  return '';
              return formatLength(mergedWidthRef.value);
          });
          const styleHeightRef = computed(() => {
              const { placement } = props;
              if (placement === 'left' || placement === 'right')
                  return '';
              return formatLength(mergedHeightRef.value);
          });
          const doUpdateWidth = (value) => {
              const { onUpdateWidth, 'onUpdate:width': _onUpdateWidth } = props;
              if (onUpdateWidth)
                  call(onUpdateWidth, value);
              if (_onUpdateWidth)
                  call(_onUpdateWidth, value);
              uncontrolledWidthRef.value = value;
          };
          const doUpdateHeight = (value) => {
              const { onUpdateHeight, 'onUpdate:width': _onUpdateHeight } = props;
              if (onUpdateHeight)
                  call(onUpdateHeight, value);
              if (_onUpdateHeight)
                  call(_onUpdateHeight, value);
              uncontrolledHeightRef.value = value;
          };
          const mergedBodyStyleRef = computed(() => {
              return [
                  {
                      width: styleWidthRef.value,
                      height: styleHeightRef.value
                  },
                  props.drawerStyle || ''
              ];
          });
          function handleMaskClick(e) {
              const { onMaskClick, maskClosable } = props;
              if (maskClosable) {
                  doUpdateShow(false);
              }
              if (onMaskClick)
                  onMaskClick(e);
          }
          const isComposingRef = useIsComposing();
          function handleEsc(e) {
              var _a;
              (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
              if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
                  !isComposingRef.value && doUpdateShow(false);
              }
          }
          function doUpdateShow(show) {
              const { onHide, onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, show);
              if (_onUpdateShow)
                  call(_onUpdateShow, show);
              // deprecated
              if (onHide && !show)
                  call(onHide, show);
          }
          provide(drawerInjectionKey, {
              isMountedRef,
              mergedThemeRef: themeRef,
              mergedClsPrefixRef,
              doUpdateShow,
              doUpdateHeight,
              doUpdateWidth
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut }, self: { color, textColor, boxShadow, lineHeight, headerPadding, footerPadding, bodyPadding, titleFontSize, titleTextColor, titleFontWeight, headerBorderBottom, footerBorderTop, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, closeIconSize, closeSize, closeBorderRadius, resizableTriggerColorHover } } = themeRef.value;
              return {
                  '--n-line-height': lineHeight,
                  '--n-color': color,
                  '--n-text-color': textColor,
                  '--n-box-shadow': boxShadow,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-bezier-out': cubicBezierEaseOut,
                  '--n-bezier-in': cubicBezierEaseIn,
                  '--n-header-padding': headerPadding,
                  '--n-body-padding': bodyPadding,
                  '--n-footer-padding': footerPadding,
                  '--n-title-text-color': titleTextColor,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-header-border-bottom': headerBorderBottom,
                  '--n-footer-border-top': footerBorderTop,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-close-size': closeSize,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-resize-trigger-color-hover': resizableTriggerColorHover
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('drawer', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              namespace: namespaceRef,
              mergedBodyStyle: mergedBodyStyleRef,
              handleMaskClick,
              handleEsc,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              isMounted: isMountedRef
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h(LazyTeleport, { to: this.to, show: this.show }, {
              default: () => {
                  var _a;
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  return withDirectives(h("div", { class: [
                          `${mergedClsPrefix}-drawer-container`,
                          this.namespace,
                          this.themeClass
                      ], style: this.cssVars, role: "none" },
                      this.showMask ? (h(Transition, { name: "fade-in-transition", appear: this.isMounted }, {
                          default: () => this.show ? (h("div", { "aria-hidden": true, class: [
                                  `${mergedClsPrefix}-drawer-mask`,
                                  this.showMask === 'transparent' &&
                                      `${mergedClsPrefix}-drawer-mask--invisible`
                              ], onClick: this.handleMaskClick })) : null
                      })) : null,
                      h(NDrawerBodyWrapper, Object.assign({}, this.$attrs, { class: [this.drawerClass, this.$attrs.class], style: [this.mergedBodyStyle, this.$attrs.style], blockScroll: this.blockScroll, contentStyle: this.contentStyle, placement: this.placement, scrollbarProps: this.scrollbarProps, show: this.show, displayDirective: this.displayDirective, nativeScrollbar: this.nativeScrollbar, onAfterEnter: this.onAfterEnter, onAfterLeave: this.onAfterLeave, trapFocus: this.trapFocus, autoFocus: this.autoFocus, resizable: this.resizable, maxHeight: this.maxHeight, minHeight: this.minHeight, maxWidth: this.maxWidth, minWidth: this.minWidth, showMask: this.showMask, onEsc: this.handleEsc, onClickoutside: this.handleMaskClick }), this.$slots)), [[zindexable$1, { zIndex: this.zIndex, enabled: this.show }]]);
              }
          }));
      }
  });

  const drawerContentProps = {
      title: {
          type: String
      },
      headerStyle: [Object, String],
      footerStyle: [Object, String],
      bodyStyle: [Object, String],
      bodyContentStyle: [Object, String],
      nativeScrollbar: { type: Boolean, default: true },
      scrollbarProps: Object,
      closable: Boolean
  };
  var DrawerContent = defineComponent({
      name: 'DrawerContent',
      props: drawerContentProps,
      setup() {
          const NDrawer = inject(drawerInjectionKey, null);
          if (!NDrawer) {
              throwError('drawer-content', '`n-drawer-content` must be placed inside `n-drawer`.');
          }
          const { doUpdateShow } = NDrawer;
          function handleCloseClick() {
              doUpdateShow(false);
          }
          return {
              handleCloseClick,
              mergedTheme: NDrawer.mergedThemeRef,
              mergedClsPrefix: NDrawer.mergedClsPrefixRef
          };
      },
      render() {
          const { title, mergedClsPrefix, nativeScrollbar, mergedTheme, bodyStyle, bodyContentStyle, headerStyle, footerStyle, scrollbarProps, closable, $slots } = this;
          return (h("div", { role: "none", class: [
                  `${mergedClsPrefix}-drawer-content`,
                  nativeScrollbar &&
                      `${mergedClsPrefix}-drawer-content--native-scrollbar`
              ] },
              $slots.header || title || closable ? (h("div", { class: `${mergedClsPrefix}-drawer-header`, style: headerStyle, role: "none" },
                  h("div", { class: `${mergedClsPrefix}-drawer-header__main`, role: "heading", "aria-level": "1" }, $slots.header !== undefined ? $slots.header() : title),
                  closable && (h(NBaseClose, { onClick: this.handleCloseClick, clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-drawer-header__close`, absolute: true })))) : null,
              nativeScrollbar ? (h("div", { class: `${mergedClsPrefix}-drawer-body`, style: bodyStyle, role: "none" },
                  h("div", { class: `${mergedClsPrefix}-drawer-body-content-wrapper`, style: bodyContentStyle, role: "none" }, $slots))) : (h(NScrollbar, Object.assign({ themeOverrides: mergedTheme.peerOverrides.Scrollbar, theme: mergedTheme.peers.Scrollbar }, scrollbarProps, { class: `${mergedClsPrefix}-drawer-body`, contentClass: `${mergedClsPrefix}-drawer-body-content-wrapper`, contentStyle: bodyContentStyle }), $slots)),
              $slots.footer ? (h("div", { class: `${mergedClsPrefix}-drawer-footer`, style: footerStyle, role: "none" }, $slots.footer())) : null));
      }
  });

  var commonVariables$6 = {
      actionMargin: '0 0 0 20px',
      actionMarginRtl: '0 20px 0 0'
  };

  const self$C = () => {
      return commonVariables$6;
  };
  const dynamicInputLight = createTheme({
      name: 'DynamicInput',
      common: commonLight,
      peers: {
          Input: inputLight$1,
          Button: buttonLight$1
      },
      self: self$C
  });
  var dynamicInputLight$1 = dynamicInputLight;

  const dynamicInputInjectionKey = createInjectionKey('n-dynamic-input');

  var NDynamicInputInputPreset = defineComponent({
      name: 'DynamicInputInputPreset',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          value: {
              type: String,
              default: ''
          },
          disabled: Boolean,
          parentPath: String,
          path: String,
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup() {
          const { mergedThemeRef, placeholderRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(dynamicInputInjectionKey);
          return {
              mergedTheme: mergedThemeRef,
              placeholder: placeholderRef
          };
      },
      render() {
          const { mergedTheme, placeholder, value, clsPrefix, onUpdateValue, disabled } = this;
          return (h("div", { class: `${clsPrefix}-dynamic-input-preset-input` },
              h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value, placeholder: placeholder, onUpdateValue: onUpdateValue, disabled: disabled })));
      }
  });

  var NDynamicInputPairPreset = defineComponent({
      name: 'DynamicInputPairPreset',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          value: {
              type: Object,
              default: () => ({
                  key: '',
                  value: ''
              })
          },
          disabled: Boolean,
          parentPath: String,
          path: String,
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedThemeRef, keyPlaceholderRef, valuePlaceholderRef } = inject(dynamicInputInjectionKey);
          return {
              mergedTheme: mergedThemeRef,
              keyPlaceholder: keyPlaceholderRef,
              valuePlaceholder: valuePlaceholderRef,
              handleKeyInput(key) {
                  props.onUpdateValue({
                      key,
                      value: props.value.value
                  });
              },
              handleValueInput(value) {
                  props.onUpdateValue({
                      key: props.value.key,
                      value
                  });
              }
          };
      },
      render() {
          const { mergedTheme, keyPlaceholder, valuePlaceholder, value, clsPrefix, disabled } = this;
          return (h("div", { class: `${clsPrefix}-dynamic-input-preset-pair` },
              h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.key, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: keyPlaceholder, onUpdateValue: this.handleKeyInput, disabled: disabled }),
              h(NInput, { theme: mergedTheme.peers.Input, "theme-overrides": mergedTheme.peerOverrides.Input, value: value.value, class: `${clsPrefix}-dynamic-input-pair-input`, placeholder: valuePlaceholder, onUpdateValue: this.handleValueInput, disabled: disabled })));
      }
  });

  // vars:
  // --action-margin
  var style$N = cB('dynamic-input', {
    width: '100%'
  }, [cB('dynamic-input-item', `
 margin-bottom: 10px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB('dynamic-input-preset-input', {
    flex: 1,
    alignItems: 'center'
  }), cB('dynamic-input-preset-pair', `
 flex: 1;
 display: flex;
 align-items: center;
 `, [cB('dynamic-input-pair-input', [c$1('&:first-child', {
    'margin-right': '12px'
  })])]), cE('action', `
 align-self: flex-start;
 display: flex;
 justify-content: flex-end;
 flex-shrink: 0;
 flex-grow: 0;
 margin: var(--action-margin);
 `, [cM('icon', {
    cursor: 'pointer'
  })]), c$1('&:last-child', {
    marginBottom: 0
  })]), cB('form-item', `
 padding-top: 0 !important;
 margin-right: 0 !important;
 `, [cB('form-item-blank', {
    paddingTop: '0 !important'
  })])]);

  const globalDataKeyMap = new WeakMap();
  const dynamicInputProps = Object.assign(Object.assign({}, useTheme.props), { max: Number, min: {
          type: Number,
          default: 0
      }, value: Array, 
      // TODO: make it robust for different types
      defaultValue: {
          type: Array,
          default: () => []
      }, preset: {
          type: String,
          default: 'input'
      }, keyField: String, itemClass: String, itemStyle: [String, Object], 
      // for preset pair
      keyPlaceholder: {
          type: String,
          default: ''
      }, valuePlaceholder: {
          type: String,
          default: ''
      }, 
      // for preset input
      placeholder: {
          type: String,
          default: ''
      }, disabled: Boolean, showSortButton: Boolean, createButtonProps: Object, onCreate: Function, onRemove: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 
      // deprecated
      onClear: Function, onInput: [Function, Array] });
  var DynamicInput = defineComponent({
      name: 'DynamicInput',
      props: dynamicInputProps,
      setup(props, { slots }) {
          const { mergedComponentPropsRef, mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig();
          const NFormItem = inject(formItemInjectionKey, null);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const themeRef = useTheme('DynamicInput', '-dynamic-input', style$N, dynamicInputLight$1, props, mergedClsPrefixRef);
          const insertionDisabledRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (Array.isArray(mergedValue)) {
                  const { max } = props;
                  return max !== undefined && mergedValue.length >= max;
              }
              return false;
          });
          const removeDisabledRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (Array.isArray(mergedValue))
                  return mergedValue.length <= props.min;
              return true;
          });
          const buttonSizeRef = computed(() => {
              var _a, _b;
              return (_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DynamicInput) === null || _b === void 0 ? void 0 : _b.buttonSize;
          });
          function doUpdateValue(value) {
              const { onInput, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              if (onInput)
                  call(onInput, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onUpdateValue)
                  call(onUpdateValue, value);
              uncontrolledValueRef.value = value;
          }
          function ensureKey(value, index) {
              if (value === undefined || value === null)
                  return index;
              if (typeof value !== 'object')
                  return index;
              const rawValue = isProxy(value) ? toRaw(value) : value;
              let key = globalDataKeyMap.get(rawValue);
              if (key === undefined) {
                  globalDataKeyMap.set(rawValue, (key = createId()));
              }
              return key;
          }
          function handleValueChange(index, value) {
              const { value: mergedValue } = mergedValueRef;
              const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
              const originalItem = newValue[index];
              newValue[index] = value;
              // update dataKeyMap
              if (originalItem &&
                  value &&
                  typeof originalItem === 'object' &&
                  typeof value === 'object') {
                  const rawOriginal = isProxy(originalItem)
                      ? toRaw(originalItem)
                      : originalItem;
                  const rawNew = isProxy(value) ? toRaw(value) : value;
                  // inherit key is value position is not change
                  const originalKey = globalDataKeyMap.get(rawOriginal);
                  if (originalKey !== undefined) {
                      globalDataKeyMap.set(rawNew, originalKey);
                  }
              }
              doUpdateValue(newValue);
          }
          function handleCreateClick() {
              createItem(-1);
          }
          function createItem(index) {
              const { value: mergedValue } = mergedValueRef;
              const { onCreate } = props;
              const newValue = Array.from(mergedValue !== null && mergedValue !== void 0 ? mergedValue : []);
              if (onCreate) {
                  newValue.splice(index + 1, 0, onCreate(index + 1));
                  doUpdateValue(newValue);
              }
              else if (slots.default) {
                  newValue.splice(index + 1, 0, null);
                  doUpdateValue(newValue);
              }
              else {
                  switch (props.preset) {
                      case 'input':
                          newValue.splice(index + 1, 0, '');
                          doUpdateValue(newValue);
                          break;
                      case 'pair':
                          newValue.splice(index + 1, 0, { key: '', value: '' });
                          doUpdateValue(newValue);
                          break;
                  }
              }
          }
          function remove(index) {
              const { value: mergedValue } = mergedValueRef;
              if (!Array.isArray(mergedValue))
                  return;
              const { min } = props;
              if (mergedValue.length <= min)
                  return;
              const { onRemove } = props;
              if (onRemove) {
                  onRemove(index);
              }
              const newValue = Array.from(mergedValue);
              newValue.splice(index, 1);
              doUpdateValue(newValue);
          }
          function swap(array, currentIndex, targetIndex) {
              if (currentIndex < 0 ||
                  targetIndex < 0 ||
                  currentIndex >= array.length ||
                  targetIndex >= array.length) {
                  return;
              }
              if (currentIndex === targetIndex)
                  return;
              const currentItem = array[currentIndex];
              array[currentIndex] = array[targetIndex];
              array[targetIndex] = currentItem;
          }
          function move(type, index) {
              const { value: mergedValue } = mergedValueRef;
              if (!Array.isArray(mergedValue))
                  return;
              const newValue = Array.from(mergedValue);
              if (type === 'up') {
                  swap(newValue, index, index - 1);
              }
              if (type === 'down') {
                  swap(newValue, index, index + 1);
              }
              doUpdateValue(newValue);
          }
          provide(dynamicInputInjectionKey, {
              mergedThemeRef: themeRef,
              keyPlaceholderRef: toRef(props, 'keyPlaceholder'),
              valuePlaceholderRef: toRef(props, 'valuePlaceholder'),
              placeholderRef: toRef(props, 'placeholder')
          });
          const rtlEnabledRef = useRtl('DynamicInput', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { actionMargin, actionMarginRtl } } = themeRef.value;
              return {
                  '--action-margin': actionMargin,
                  '--action-margin-rtl': actionMarginRtl
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('dynamic-input', undefined, cssVarsRef, props)
              : undefined;
          return {
              locale: useLocale('DynamicInput').localeRef,
              rtlEnabled: rtlEnabledRef,
              buttonSize: buttonSizeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              NFormItem,
              uncontrolledValue: uncontrolledValueRef,
              mergedValue: mergedValueRef,
              insertionDisabled: insertionDisabledRef,
              removeDisabled: removeDisabledRef,
              handleCreateClick,
              ensureKey,
              handleValueChange,
              remove,
              move,
              createItem,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { $slots, itemClass, buttonSize, mergedClsPrefix, mergedValue, locale, mergedTheme, keyField, itemStyle, preset, showSortButton, NFormItem, ensureKey, handleValueChange, remove, createItem, move, onRender, disabled } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-dynamic-input`,
                  this.rtlEnabled && `${mergedClsPrefix}-dynamic-input--rtl`,
                  this.themeClass
              ], style: this.cssVars }, !Array.isArray(mergedValue) || mergedValue.length === 0 ? (h(NButton, Object.assign({ block: true, ghost: true, dashed: true, size: buttonSize }, this.createButtonProps, { disabled: this.insertionDisabled || disabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: this.handleCreateClick }), {
              default: () => resolveSlot($slots['create-button-default'], () => [
                  locale.create
              ]),
              icon: () => resolveSlot($slots['create-button-icon'], () => [
                  h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) })
              ])
          })) : (mergedValue.map((_, index) => (h("div", { key: keyField ? _[keyField] : ensureKey(_, index), "data-key": keyField ? _[keyField] : ensureKey(_, index), class: [`${mergedClsPrefix}-dynamic-input-item`, itemClass], style: itemStyle },
              resolveSlotWithProps($slots.default, {
                  value: mergedValue[index],
                  index
              }, () => {
                  return [
                      preset === 'input' ? (h(NDynamicInputInputPreset, { disabled: disabled, clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem ? NFormItem.path.value : undefined, path: (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.path.value)
                              ? `${NFormItem.path.value}[${index}]`
                              : undefined, onUpdateValue: (v) => {
                              handleValueChange(index, v);
                          } })) : preset === 'pair' ? (h(NDynamicInputPairPreset, { disabled: disabled, clsPrefix: mergedClsPrefix, value: mergedValue[index], parentPath: NFormItem ? NFormItem.path.value : undefined, path: (NFormItem === null || NFormItem === void 0 ? void 0 : NFormItem.path.value)
                              ? `${NFormItem.path.value}[${index}]`
                              : undefined, onUpdateValue: (v) => {
                              handleValueChange(index, v);
                          } })) : null
                  ];
              }),
              resolveSlotWithProps($slots.action, {
                  value: mergedValue[index],
                  index,
                  create: createItem,
                  remove,
                  move
              }, () => [
                  h("div", { class: `${mergedClsPrefix}-dynamic-input-item__action` },
                      h(NButtonGroup, { size: buttonSize }, {
                          default: () => [
                              h(NButton, { disabled: this.removeDisabled || disabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, circle: true, onClick: () => {
                                      remove(index);
                                  } }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(RemoveIcon, null) }))
                              }),
                              h(NButton, { disabled: this.insertionDisabled || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                                      createItem(index);
                                  } }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) }))
                              }),
                              showSortButton ? (h(NButton, { disabled: index === 0 || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                                      move('up', index);
                                  } }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                                      default: () => h(ArrowUpIcon, null)
                                  }))
                              })) : null,
                              showSortButton ? (h(NButton, { disabled: index === mergedValue.length - 1 || disabled, circle: true, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, onClick: () => {
                                      move('down', index);
                                  } }, {
                                  icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ArrowDownIcon, null) }))
                              })) : null
                          ]
                      }))
              ])))))));
      }
  });

  var commonVars$4 = {
      gapSmall: '4px 8px',
      gapMedium: '8px 12px',
      gapLarge: '12px 16px'
  };

  const self$B = () => {
      return commonVars$4;
  };
  const spaceLight = {
      name: 'Space',
      self: self$B
  };
  var spaceLight$1 = spaceLight;

  let supportFlexGap;
  const ensureSupportFlexGap = () => {
      if (!isBrowser$2)
          return true;
      if (supportFlexGap === undefined) {
          // create flex container with row-gap set
          const flex = document.createElement('div');
          flex.style.display = 'flex';
          flex.style.flexDirection = 'column';
          flex.style.rowGap = '1px';
          // create two, elements inside it
          flex.appendChild(document.createElement('div'));
          flex.appendChild(document.createElement('div'));
          // append to the DOM (needed to obtain scrollHeight)
          document.body.appendChild(flex);
          const isSupported = flex.scrollHeight === 1; // flex container should be 1px high from the row-gap
          document.body.removeChild(flex);
          return (supportFlexGap = isSupported);
      }
      return supportFlexGap;
  };

  const spaceProps = Object.assign(Object.assign({}, useTheme.props), { align: String, justify: {
          type: String,
          default: 'start'
      }, inline: Boolean, vertical: Boolean, size: {
          type: [String, Number, Array],
          default: 'medium'
      }, wrapItem: {
          type: Boolean,
          default: true
      }, itemClass: String, itemStyle: [String, Object], wrap: {
          type: Boolean,
          default: true
      }, 
      // internal
      internalUseGap: {
          type: Boolean,
          default: undefined
      } });
  var NSpace = defineComponent({
      name: 'Space',
      props: spaceProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Space', '-space', undefined, spaceLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Space', mergedRtlRef, mergedClsPrefixRef);
          return {
              useGap: ensureSupportFlexGap(),
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              margin: computed(() => {
                  const { size } = props;
                  if (Array.isArray(size)) {
                      return {
                          horizontal: size[0],
                          vertical: size[1]
                      };
                  }
                  if (typeof size === 'number') {
                      return {
                          horizontal: size,
                          vertical: size
                      };
                  }
                  const { self: { [createKey('gap', size)]: gap } } = themeRef.value;
                  const { row, col } = getGap(gap);
                  return {
                      horizontal: depx(col),
                      vertical: depx(row)
                  };
              })
          };
      },
      render() {
          const { vertical, align, inline, justify, itemClass, itemStyle, margin, wrap, mergedClsPrefix, rtlEnabled, useGap, wrapItem, internalUseGap } = this;
          const children = flatten$3(getSlot$1(this));
          if (!children.length)
              return null;
          const horizontalMargin = `${margin.horizontal}px`;
          const semiHorizontalMargin = `${margin.horizontal / 2}px`;
          const verticalMargin = `${margin.vertical}px`;
          const semiVerticalMargin = `${margin.vertical / 2}px`;
          const lastIndex = children.length - 1;
          const isJustifySpace = justify.startsWith('space-');
          return (h("div", { role: "none", class: [
                  `${mergedClsPrefix}-space`,
                  rtlEnabled && `${mergedClsPrefix}-space--rtl`
              ], style: {
                  display: inline ? 'inline-flex' : 'flex',
                  flexDirection: vertical ? 'column' : 'row',
                  justifyContent: ['start', 'end'].includes(justify)
                      ? 'flex-' + justify
                      : justify,
                  flexWrap: !wrap || vertical ? 'nowrap' : 'wrap',
                  marginTop: useGap || vertical ? '' : `-${semiVerticalMargin}`,
                  marginBottom: useGap || vertical ? '' : `-${semiVerticalMargin}`,
                  alignItems: align,
                  gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ''
              } }, !wrapItem && (useGap || internalUseGap)
              ? children
              : children.map((child, index) => (h("div", { role: "none", class: itemClass, style: [
                      itemStyle,
                      {
                          maxWidth: '100%'
                      },
                      useGap
                          ? ''
                          : vertical
                              ? {
                                  marginBottom: index !== lastIndex ? verticalMargin : ''
                              }
                              : rtlEnabled
                                  ? {
                                      marginLeft: isJustifySpace
                                          ? justify === 'space-between' && index === lastIndex
                                              ? ''
                                              : semiHorizontalMargin
                                          : index !== lastIndex
                                              ? horizontalMargin
                                              : '',
                                      marginRight: isJustifySpace
                                          ? justify === 'space-between' && index === 0
                                              ? ''
                                              : semiHorizontalMargin
                                          : '',
                                      paddingTop: semiVerticalMargin,
                                      paddingBottom: semiVerticalMargin
                                  }
                                  : {
                                      marginRight: isJustifySpace
                                          ? justify === 'space-between' && index === lastIndex
                                              ? ''
                                              : semiHorizontalMargin
                                          : index !== lastIndex
                                              ? horizontalMargin
                                              : '',
                                      marginLeft: isJustifySpace
                                          ? justify === 'space-between' && index === 0
                                              ? ''
                                              : semiHorizontalMargin
                                          : '',
                                      paddingTop: semiVerticalMargin,
                                      paddingBottom: semiVerticalMargin
                                  }
                  ] }, child)))));
      }
  });

  const dynamicTagsLight = createTheme({
      name: 'DynamicTags',
      common: commonLight,
      peers: {
          Input: inputLight$1,
          Button: buttonLight$1,
          Tag: tagLight$1,
          Space: spaceLight$1
      },
      self() {
          return {
              inputWidth: '64px'
          };
      }
  });
  var dynamicTagsLight$1 = dynamicTagsLight;

  // vars:
  // --input-width
  var style$M = cB('dynamic-tags', [cB('input', {
    minWidth: 'var(--n-input-width)'
  })]);

  const dynamicTagsProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), { size: {
          type: String,
          default: 'medium'
      }, closable: {
          type: Boolean,
          default: true
      }, defaultValue: {
          type: Array,
          default: () => []
      }, value: Array, inputClass: String, inputStyle: [String, Object], inputProps: Object, max: Number, tagClass: String, tagStyle: [String, Object], renderTag: Function, onCreate: {
          type: Function,
          default: (label) => label
      }, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], 
      // deprecated
      onChange: [Function, Array] });
  var DynamicTags = defineComponent({
      name: 'DynamicTags',
      props: dynamicTagsProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef } = useLocale('DynamicTags');
          const formItem = useFormItem(props);
          const { mergedDisabledRef } = formItem;
          const inputValueRef = ref('');
          const showInputRef = ref(false);
          const inputForceFocusedRef = ref(true);
          const inputInstRef = ref(null);
          const themeRef = useTheme('DynamicTags', '-dynamic-tags', style$M, dynamicTagsLight$1, props, mergedClsPrefixRef);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const localizedAddRef = computed(() => {
              return localeRef.value.add;
          });
          const inputSizeRef = computed(() => {
              return smallerSize(props.size);
          });
          const triggerDisabledRef = computed(() => {
              return (mergedDisabledRef.value ||
                  (!!props.max && mergedValueRef.value.length >= props.max));
          });
          function doChange(value) {
              const { onChange, 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onChange)
                  call(onChange, value);
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function handleCloseClick(index) {
              const tags = mergedValueRef.value.slice(0);
              tags.splice(index, 1);
              doChange(tags);
          }
          function handleInputKeyUp(e) {
              switch (e.key) {
                  case 'Enter':
                      handleInputConfirm();
              }
          }
          function handleInputConfirm(externalValue) {
              const nextValue = externalValue !== null && externalValue !== void 0 ? externalValue : inputValueRef.value;
              if (nextValue) {
                  const tags = mergedValueRef.value.slice(0);
                  tags.push(props.onCreate(nextValue));
                  doChange(tags);
              }
              showInputRef.value = false;
              inputForceFocusedRef.value = true;
              inputValueRef.value = '';
          }
          function handleInputBlur() {
              handleInputConfirm();
          }
          function handleAddClick() {
              showInputRef.value = true;
              void nextTick(() => {
                  var _a;
                  (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
                  inputForceFocusedRef.value = false;
              });
          }
          const cssVarsRef = computed(() => {
              const { self: { inputWidth } } = themeRef.value;
              return {
                  '--n-input-width': inputWidth
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('dynamic-tags', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              inputInstRef,
              localizedAdd: localizedAddRef,
              inputSize: inputSizeRef,
              inputValue: inputValueRef,
              showInput: showInputRef,
              inputForceFocused: inputForceFocusedRef,
              mergedValue: mergedValueRef,
              mergedDisabled: mergedDisabledRef,
              triggerDisabled: triggerDisabledRef,
              handleInputKeyUp,
              handleAddClick,
              handleInputBlur,
              handleCloseClick,
              handleInputConfirm,
              mergedTheme: themeRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedTheme, cssVars, mergedClsPrefix, onRender, renderTag } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h(NSpace, { class: [`${mergedClsPrefix}-dynamic-tags`, this.themeClass], size: "small", style: cssVars, theme: mergedTheme.peers.Space, themeOverrides: mergedTheme.peerOverrides.Space, itemStyle: "display: flex;" }, {
              default: () => {
                  const { mergedTheme, tagClass, tagStyle, type, round, size, color, closable, mergedDisabled, showInput, inputValue, inputClass, inputStyle, inputSize, inputForceFocused, triggerDisabled, handleInputKeyUp, handleInputBlur, handleAddClick, handleCloseClick, handleInputConfirm, $slots } = this;
                  return this.mergedValue
                      .map((tag, index) => renderTag ? (renderTag(tag, index)) : (h(NTag, { key: index, theme: mergedTheme.peers.Tag, themeOverrides: mergedTheme.peerOverrides.Tag, class: tagClass, style: tagStyle, type: type, round: round, size: size, color: color, closable: closable, disabled: mergedDisabled, onClose: () => {
                          handleCloseClick(index);
                      } }, {
                      default: () => (typeof tag === 'string' ? tag : tag.label)
                  })))
                      .concat(showInput ? ($slots.input ? ($slots.input({
                      submit: handleInputConfirm,
                      deactivate: handleInputBlur
                  })) : (h(NInput, Object.assign({ placeholder: "", size: inputSize, style: inputStyle, class: inputClass, autosize: true }, this.inputProps, { ref: "inputInstRef", value: inputValue, onUpdateValue: (v) => {
                          this.inputValue = v;
                      }, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, onKeyup: handleInputKeyUp, onBlur: handleInputBlur, internalForceFocus: inputForceFocused })))) : $slots.trigger ? ($slots.trigger({
                      activate: handleAddClick,
                      disabled: triggerDisabled
                  })) : (h(NButton, { dashed: true, disabled: triggerDisabled, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: inputSize, onClick: handleAddClick }, {
                      icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) }))
                  })));
              }
          }));
      }
  });

  const elementLight = {
      name: 'Element',
      common: commonLight
  };
  var elementLight$1 = elementLight;

  const elementProps = Object.assign(Object.assign({}, useTheme.props), { tag: {
          type: String,
          default: 'div'
      } });
  var NElement = defineComponent({
      name: 'Element',
      alias: ['El'],
      props: elementProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Element', '-element', undefined, elementLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common } = themeRef.value;
              return Object.keys(common).reduce((prevValue, key) => {
                  prevValue[`--${kebabCase$1(key)}`] = common[key];
                  return prevValue;
              }, {});
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('element', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { tag, mergedClsPrefix, cssVars, themeClass, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return h(tag, {
              role: 'none',
              class: [`${mergedClsPrefix}-element`, themeClass],
              style: cssVars
          }, (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots));
      }
  });

  var commonVariables$5 = {
      feedbackPadding: '4px 0 0 2px',
      feedbackHeightSmall: '24px',
      feedbackHeightMedium: '24px',
      feedbackHeightLarge: '26px',
      feedbackFontSizeSmall: '13px',
      feedbackFontSizeMedium: '14px',
      feedbackFontSizeLarge: '14px',
      labelFontSizeLeftSmall: '14px',
      labelFontSizeLeftMedium: '14px',
      labelFontSizeLeftLarge: '15px',
      labelFontSizeTopSmall: '13px',
      labelFontSizeTopMedium: '14px',
      labelFontSizeTopLarge: '14px',
      labelHeightSmall: '24px',
      labelHeightMedium: '26px',
      labelHeightLarge: '28px',
      labelPaddingVertical: '0 0 6px 2px',
      labelPaddingHorizontal: '0 12px 0 0',
      labelTextAlignVertical: 'left',
      labelTextAlignHorizontal: 'right',
      labelFontWeight: '400'
  };

  const self$A = (vars) => {
      const { heightSmall, heightMedium, heightLarge, textColor1, errorColor, warningColor, lineHeight, textColor3 } = vars;
      return Object.assign(Object.assign({}, commonVariables$5), { blankHeightSmall: heightSmall, blankHeightMedium: heightMedium, blankHeightLarge: heightLarge, lineHeight, labelTextColor: textColor1, asteriskColor: errorColor, feedbackTextColorError: errorColor, feedbackTextColorWarning: warningColor, feedbackTextColor: textColor3 });
  };
  const formLight = {
      name: 'Form',
      common: commonLight,
      self: self$A
  };
  var formLight$1 = formLight;

  var style$L = cB('form', [cM('inline', `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB('form-item', {
    width: 'auto',
    marginRight: '18px'
  }, [c$1('&:last-child', {
    marginRight: 0
  })])])]);

  const formInjectionKey = createInjectionKey('n-form');
  const formItemInstsInjectionKey = createInjectionKey('n-form-item-insts');

  var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const formProps = Object.assign(Object.assign({}, useTheme.props), { inline: Boolean, labelWidth: [Number, String], labelAlign: String, labelPlacement: {
          type: String,
          default: 'top'
      }, model: {
          type: Object,
          default: () => { }
      }, rules: Object, disabled: Boolean, size: String, showRequireMark: {
          type: Boolean,
          default: undefined
      }, requireMarkPlacement: String, showFeedback: {
          type: Boolean,
          default: true
      }, onSubmit: {
          type: Function,
          default: (e) => {
              e.preventDefault();
          }
      }, showLabel: {
          type: Boolean,
          default: undefined
      }, validateMessages: Object });
  var Form = defineComponent({
      name: 'Form',
      props: formProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          useTheme('Form', '-form', style$L, formLight$1, props, mergedClsPrefixRef);
          // from path to form-item
          const formItems = {};
          // for label-width = 'auto'
          const maxChildLabelWidthRef = ref(undefined);
          const deriveMaxChildLabelWidth = (currentWidth) => {
              const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
              if (currentMaxChildLabelWidth === undefined ||
                  currentWidth >= currentMaxChildLabelWidth) {
                  maxChildLabelWidthRef.value = currentWidth;
              }
          };
          function validate(validateCallback, shouldRuleBeApplied = () => true) {
              return __awaiter$6(this, void 0, void 0, function* () {
                  yield new Promise((resolve, reject) => {
                      const formItemValidationPromises = [];
                      for (const key of keysOf(formItems)) {
                          const formItemInstances = formItems[key];
                          for (const formItemInstance of formItemInstances) {
                              if (formItemInstance.path) {
                                  formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                              }
                          }
                      }
                      void Promise.all(formItemValidationPromises).then((results) => {
                          if (results.some((result) => !result.valid)) {
                              const errors = results
                                  .filter((result) => result.errors)
                                  .map((result) => result.errors);
                              if (validateCallback) {
                                  validateCallback(errors);
                              }
                              reject(errors);
                          }
                          else {
                              if (validateCallback)
                                  validateCallback();
                              resolve();
                          }
                      });
                  });
              });
          }
          function restoreValidation() {
              for (const key of keysOf(formItems)) {
                  const formItemInstances = formItems[key];
                  for (const formItemInstance of formItemInstances) {
                      formItemInstance.restoreValidation();
                  }
              }
          }
          provide(formInjectionKey, {
              props,
              maxChildLabelWidthRef,
              deriveMaxChildLabelWidth
          });
          provide(formItemInstsInjectionKey, { formItems });
          const formExposedMethod = {
              validate,
              restoreValidation
          };
          return Object.assign(formExposedMethod, {
              mergedClsPrefix: mergedClsPrefixRef
          });
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("form", { class: [
                  `${mergedClsPrefix}-form`,
                  this.inline && `${mergedClsPrefix}-form--inline`
              ], onSubmit: this.onSubmit }, this.$slots));
      }
  });

  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function (target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];

        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }

      return target;
    };
    return _extends.apply(this, arguments);
  }

  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;

    _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };
    return _setPrototypeOf(o, p);
  }

  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  /* eslint no-console:0 */
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning() {}; // don't print warning message when in production env or node runtime

  if (typeof process !== 'undefined' && process.env && "production" !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
    warning = function warning(type, errors) {
      if (typeof console !== 'undefined' && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === 'undefined') {
        if (errors.every(function (e) {
          return typeof e === 'string';
        })) {
          console.warn(type, errors);
        }
      }
    };
  }

  function convertFieldsError(errors) {
    if (!errors || !errors.length) return null;
    var fields = {};
    errors.forEach(function (error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format$1(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var i = 0;
    var len = args.length;

    if (typeof template === 'function') {
      return template.apply(null, args);
    }

    if (typeof template === 'string') {
      var str = template.replace(formatRegExp, function (x) {
        if (x === '%%') {
          return '%';
        }

        if (i >= len) {
          return x;
        }

        switch (x) {
          case '%s':
            return String(args[i++]);

          case '%d':
            return Number(args[i++]);

          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }

            break;

          default:
            return x;
        }
      });
      return str;
    }

    return template;
  }

  function isNativeStringType(type) {
    return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
  }

  function isEmptyValue(value, type) {
    if (value === undefined || value === null) {
      return true;
    }

    if (type === 'array' && Array.isArray(value) && !value.length) {
      return true;
    }

    if (isNativeStringType(type) && typeof value === 'string' && !value) {
      return true;
    }

    return false;
  }

  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;

    function count(errors) {
      results.push.apply(results, errors || []);
      total++;

      if (total === arrLength) {
        callback(results);
      }
    }

    arr.forEach(function (a) {
      func(a, count);
    });
  }

  function asyncSerialArray(arr, func, callback) {
    var index = 0;
    var arrLength = arr.length;

    function next(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }

      var original = index;
      index = index + 1;

      if (original < arrLength) {
        func(arr[original], next);
      } else {
        callback([]);
      }
    }

    next([]);
  }

  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function (k) {
      ret.push.apply(ret, objArr[k] || []);
    });
    return ret;
  }

  var AsyncValidationError = /*#__PURE__*/function (_Error) {
    _inheritsLoose(AsyncValidationError, _Error);

    function AsyncValidationError(errors, fields) {
      var _this;

      _this = _Error.call(this, 'Async Validation Error') || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }

    return AsyncValidationError;
  }( /*#__PURE__*/_wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function (resolve, reject) {
        var next = function next(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };

        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next);
      });

      _pending["catch"](function (e) {
        return e;
      });

      return _pending;
    }

    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        results.push.apply(results, errors);
        total++;

        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };

      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }

      objArrKeys.forEach(function (key) {
        var arr = objArr[key];

        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next);
        } else {
          asyncParallelArray(arr, func, next);
        }
      });
    });
    pending["catch"](function (e) {
      return e;
    });
    return pending;
  }

  function isErrorObj(obj) {
    return !!(obj && obj.message !== undefined);
  }

  function getValue(value, path) {
    var v = value;

    for (var i = 0; i < path.length; i++) {
      if (v == undefined) {
        return v;
      }

      v = v[path[i]];
    }

    return v;
  }

  function complementError(rule, source) {
    return function (oe) {
      var fieldValue;

      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }

      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }

      return {
        message: typeof oe === 'function' ? oe() : oe,
        fieldValue: fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];

          if (typeof value === 'object' && typeof target[s] === 'object') {
            target[s] = _extends({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }

    return target;
  }

  var required$1 = function required(rule, value, source, errors, options, type) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
      errors.push(format$1(options.messages.required, rule.fullField));
    }
  };

  /**
   *  Rule for validating whitespace.
   *
   *  @param rule The validation rule.
   *  @param value The value of the field on the source object.
   *  @param source The source object being validated.
   *  @param errors An array of errors that this rule may add
   *  validation errors to.
   *  @param options The validation options.
   *  @param options.messages The validation messages.
   */

  var whitespace = function whitespace(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === '') {
      errors.push(format$1(options.messages.whitespace, rule.fullField));
    }
  };

  // https://github.com/kevva/url-regex/blob/master/index.js
  var urlReg;
  var getUrlRegex = (function () {
    if (urlReg) {
      return urlReg;
    }

    var word = '[a-fA-F\\d:]';

    var b = function b(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : '';
    };

    var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
    var v6seg = '[a-fA-F\\d]{1,4}';
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, '').replace(/\n/g, '').trim(); // Pre-compile only the exact regexes because adding a global flag make regexes stateful

    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");

    var ip = function ip(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", 'g');
    };

    ip.v4 = function (options) {
      return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), 'g');
    };

    ip.v6 = function (options) {
      return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), 'g');
    };

    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = '(?:\\S+(?::\\S*)?@)?';
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = '(?::\\d{2,5})?';
    var path = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
    urlReg = new RegExp("(?:^" + regex + "$)", 'i');
    return urlReg;
  });

  /* eslint max-len:0 */

  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }

      try {
        return !!new RegExp(value);
      } catch (e) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }

      return typeof value === 'number';
    },
    object: function object(value) {
      return typeof value === 'object' && !types.array(value);
    },
    method: function method(value) {
      return typeof value === 'function';
    },
    email: function email(value) {
      return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === 'string' && !!value.match(pattern$2.hex);
    }
  };

  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === undefined) {
      required$1(rule, value, source, errors, options);
      return;
    }

    var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
    var ruleType = rule.type;

    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
      } // straight typeof check

    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };

  var range = function range(rule, value, source, errors, options) {
    var len = typeof rule.len === 'number';
    var min = typeof rule.min === 'number';
    var max = typeof rule.max === 'number'; // U+010000U+10FFFFSupplementary Plane

    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === 'number';
    var str = typeof value === 'string';
    var arr = Array.isArray(value);

    if (num) {
      key = 'number';
    } else if (str) {
      key = 'string';
    } else if (arr) {
      key = 'array';
    } // if the value is not of a supported type for range validation
    // the validation rule rule should use the
    // type property to also test for a particular type


    if (!key) {
      return false;
    }

    if (arr) {
      val = value.length;
    }

    if (str) {
      // U+010000lengthbug"".lenght !== 3
      val = value.replace(spRegexp, '_').length;
    }

    if (len) {
      if (val !== rule.len) {
        errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };

  var ENUM$1 = 'enum';

  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];

    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format$1(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
    }
  };

  var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        // if a RegExp instance is passed, reset `lastIndex` in case its `global`
        // flag is accidentally set to `true`, which in a validation scenario
        // is not necessary and the result might be misleading
        rule.pattern.lastIndex = 0;

        if (!rule.pattern.test(value)) {
          errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === 'string') {
        var _pattern = new RegExp(rule.pattern);

        if (!_pattern.test(value)) {
          errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };

  var rules = {
    required: required$1,
    whitespace: whitespace,
    type: type$1,
    range: range,
    "enum": enumerable$1,
    pattern: pattern$1
  };

  var string = function string(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, 'string');

      if (!isEmptyValue(value, 'string')) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);

        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }

    callback(errors);
  };

  var method = function method(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var number = function number(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (value === '') {
        value = undefined;
      }

      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var _boolean = function _boolean(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var regexp = function regexp(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var integer = function integer(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var floatFn = function floatFn(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var array = function array(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if ((value === undefined || value === null) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, 'array');

      if (value !== undefined && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var object = function object(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var ENUM = 'enum';

  var enumerable = function enumerable(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (value !== undefined) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var pattern = function pattern(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, 'string') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value, 'string')) {
        rules.pattern(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var date = function date(rule, value, callback, source, options) {
    // console.log('integer rule called %j', rule);
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

    if (validate) {
      if (isEmptyValue(value, 'date') && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);

      if (!isEmptyValue(value, 'date')) {
        var dateObject;

        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }

        rules.type(rule, dateObject, source, errors, options);

        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }

    callback(errors);
  };

  var required = function required(rule, value, callback, source, options) {
    var errors = [];
    var type = Array.isArray(value) ? 'array' : typeof value;
    rules.required(rule, value, source, errors, options, type);
    callback(errors);
  };

  var type = function type(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options, ruleType);

      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }

    callback(errors);
  };

  var any = function any(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }

      rules.required(rule, value, source, errors, options);
    }

    callback(errors);
  };

  var validators = {
    string: string,
    method: method,
    number: number,
    "boolean": _boolean,
    regexp: regexp,
    integer: integer,
    "float": floatFn,
    array: array,
    object: object,
    "enum": enumerable,
    pattern: pattern,
    date: date,
    url: type,
    hex: type,
    email: type,
    required: required,
    any: any
  };

  function newMessages() {
    return {
      "default": 'Validation error on field %s',
      required: '%s is required',
      "enum": '%s must be one of %s',
      whitespace: '%s cannot be empty',
      date: {
        format: '%s date %s is invalid for format %s',
        parse: '%s date could not be parsed, %s is invalid ',
        invalid: '%s date %s is invalid'
      },
      types: {
        string: '%s is not a %s',
        method: '%s is not a %s (function)',
        array: '%s is not an %s',
        object: '%s is not an %s',
        number: '%s is not a %s',
        date: '%s is not a %s',
        "boolean": '%s is not a %s',
        integer: '%s is not an %s',
        "float": '%s is not a %s',
        regexp: '%s is not a valid %s',
        email: '%s is not a valid %s',
        url: '%s is not a valid %s',
        hex: '%s is not a valid %s'
      },
      string: {
        len: '%s must be exactly %s characters',
        min: '%s must be at least %s characters',
        max: '%s cannot be longer than %s characters',
        range: '%s must be between %s and %s characters'
      },
      number: {
        len: '%s must equal %s',
        min: '%s cannot be less than %s',
        max: '%s cannot be greater than %s',
        range: '%s must be between %s and %s'
      },
      array: {
        len: '%s must be exactly %s in length',
        min: '%s cannot be less than %s in length',
        max: '%s cannot be greater than %s in length',
        range: '%s must be between %s and %s in length'
      },
      pattern: {
        mismatch: '%s value %s does not match pattern %s'
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();

  /**
   *  Encapsulates a validation schema.
   *
   *  @param descriptor An object declaring validation rules
   *  for this schema.
   */

  var Schema = /*#__PURE__*/function () {
    // ========================= Static =========================
    // ======================== Instance ========================
    function Schema(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }

    var _proto = Schema.prototype;

    _proto.define = function define(rules) {
      var _this = this;

      if (!rules) {
        throw new Error('Cannot configure a schema with no rules');
      }

      if (typeof rules !== 'object' || Array.isArray(rules)) {
        throw new Error('Rules must be an object');
      }

      this.rules = {};
      Object.keys(rules).forEach(function (name) {
        var item = rules[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };

    _proto.messages = function messages(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }

      return this._messages;
    };

    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;

      if (o === void 0) {
        o = {};
      }

      if (oc === void 0) {
        oc = function oc() {};
      }

      var source = source_;
      var options = o;
      var callback = oc;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }

        return Promise.resolve(source);
      }

      function complete(results) {
        var errors = [];
        var fields = {};

        function add(e) {
          if (Array.isArray(e)) {
            var _errors;

            errors = (_errors = errors).concat.apply(_errors, e);
          } else {
            errors.push(e);
          }
        }

        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }

        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }

      if (options.messages) {
        var messages$1 = this.messages();

        if (messages$1 === messages) {
          messages$1 = newMessages();
        }

        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }

      var series = {};
      var keys = options.keys || Object.keys(this.rules);
      keys.forEach(function (z) {
        var arr = _this2.rules[z];
        var value = source[z];
        arr.forEach(function (r) {
          var rule = r;

          if (typeof rule.transform === 'function') {
            if (source === source_) {
              source = _extends({}, source);
            }

            value = source[z] = rule.transform(value);
          }

          if (typeof rule === 'function') {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends({}, rule);
          } // Fill validator. Skip if nothing need to validate


          rule.validator = _this2.getValidationMethod(rule);

          if (!rule.validator) {
            return;
          }

          rule.field = z;
          rule.fullField = rule.fullField || z;
          rule.type = _this2.getType(rule);
          series[z] = series[z] || [];
          series[z].push({
            rule: rule,
            value: value,
            source: source,
            field: z
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function (data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;

        function addFullField(key, schema) {
          return _extends({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }

        function cb(e) {
          if (e === void 0) {
            e = [];
          }

          var errorList = Array.isArray(e) ? e : [e];

          if (!options.suppressWarning && errorList.length) {
            Schema.warning('async-validator:', errorList);
          }

          if (errorList.length && rule.message !== undefined) {
            errorList = [].concat(rule.message);
          } // Fill error info


          var filledErrors = errorList.map(complementError(rule, source));

          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }

          if (!deep) {
            doIt(filledErrors);
          } else {
            // if rule is required but the target object
            // does not exist fail at the rule level and don't
            // go deeper
            if (rule.required && !data.value) {
              if (rule.message !== undefined) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format$1(options.messages.required, rule.field))];
              }

              return doIt(filledErrors);
            }

            var fieldsSchema = {};

            if (rule.defaultField) {
              Object.keys(data.value).map(function (key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }

            fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function (field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema(paredFieldsSchema);
            schema.messages(options.messages);

            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }

            schema.validate(data.value, data.rule.options || options, function (errs) {
              var finalErrors = [];

              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }

              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }

              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }

        var res;

        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            console.error == null ? void 0 : console.error(error); // rethrow to report error

            if (!options.suppressValidatorError) {
              setTimeout(function () {
                throw error;
              }, 0);
            }

            cb(error.message);
          }

          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }

        if (res && res.then) {
          res.then(function () {
            return cb();
          }, function (e) {
            return cb(e);
          });
        }
      }, function (results) {
        complete(results);
      }, source);
    };

    _proto.getType = function getType(rule) {
      if (rule.type === undefined && rule.pattern instanceof RegExp) {
        rule.type = 'pattern';
      }

      if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
        throw new Error(format$1('Unknown rule type %s', rule.type));
      }

      return rule.type || 'string';
    };

    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === 'function') {
        return rule.validator;
      }

      var keys = Object.keys(rule);
      var messageIndex = keys.indexOf('message');

      if (messageIndex !== -1) {
        keys.splice(messageIndex, 1);
      }

      if (keys.length === 1 && keys[0] === 'required') {
        return validators.required;
      }

      return validators[this.getType(rule)] || undefined;
    };

    return Schema;
  }();

  Schema.register = function register(type, validator) {
    if (typeof validator !== 'function') {
      throw new Error('Cannot register a validator by type, validator is not a function');
    }

    validators[type] = validator;
  };

  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators;

  function formItemSize(props) {
      const NForm = inject(formInjectionKey, null);
      return {
          mergedSize: computed(() => {
              if (props.size !== undefined)
                  return props.size;
              if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.size) !== undefined)
                  return NForm.props.size;
              return 'medium';
          })
      };
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function formItemMisc(props) {
      const NForm = inject(formInjectionKey, null);
      const mergedLabelPlacementRef = computed(() => {
          const { labelPlacement } = props;
          if (labelPlacement !== undefined)
              return labelPlacement;
          if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelPlacement)
              return NForm.props.labelPlacement;
          return 'top';
      });
      const isAutoLabelWidthRef = computed(() => {
          return (mergedLabelPlacementRef.value === 'left' &&
              (props.labelWidth === 'auto' || (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) === 'auto'));
      });
      const mergedLabelWidthRef = computed(() => {
          if (mergedLabelPlacementRef.value === 'top')
              return;
          const { labelWidth } = props;
          if (labelWidth !== undefined && labelWidth !== 'auto') {
              return formatLength(labelWidth);
          }
          if (isAutoLabelWidthRef.value) {
              const autoComputedWidth = NForm === null || NForm === void 0 ? void 0 : NForm.maxChildLabelWidthRef.value;
              if (autoComputedWidth !== undefined) {
                  return formatLength(autoComputedWidth);
              }
              else {
                  return undefined;
              }
          }
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.labelWidth) !== undefined) {
              return formatLength(NForm.props.labelWidth);
          }
          return undefined;
      });
      const mergedLabelAlignRef = computed(() => {
          const { labelAlign } = props;
          if (labelAlign)
              return labelAlign;
          if (NForm === null || NForm === void 0 ? void 0 : NForm.props.labelAlign)
              return NForm.props.labelAlign;
          return undefined;
      });
      const mergedLabelStyleRef = computed(() => {
          var _a;
          return [
              (_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style,
              props.labelStyle,
              {
                  width: mergedLabelWidthRef.value
              }
          ];
      });
      const mergedShowRequireMarkRef = computed(() => {
          const { showRequireMark } = props;
          if (showRequireMark !== undefined)
              return showRequireMark;
          return NForm === null || NForm === void 0 ? void 0 : NForm.props.showRequireMark;
      });
      const mergedRequireMarkPlacementRef = computed(() => {
          const { requireMarkPlacement } = props;
          if (requireMarkPlacement !== undefined)
              return requireMarkPlacement;
          return (NForm === null || NForm === void 0 ? void 0 : NForm.props.requireMarkPlacement) || 'right';
      });
      const validationErroredRef = ref(false);
      const mergedValidationStatusRef = computed(() => {
          const { validationStatus } = props;
          if (validationStatus !== undefined)
              return validationStatus;
          if (validationErroredRef.value)
              return 'error';
          return undefined;
      });
      const mergedShowFeedbackRef = computed(() => {
          const { showFeedback } = props;
          if (showFeedback !== undefined)
              return showFeedback;
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showFeedback) !== undefined)
              return NForm.props.showFeedback;
          return true;
      });
      const mergedShowLabelRef = computed(() => {
          const { showLabel } = props;
          if (showLabel !== undefined)
              return showLabel;
          if ((NForm === null || NForm === void 0 ? void 0 : NForm.props.showLabel) !== undefined)
              return NForm.props.showLabel;
          return true;
      });
      return {
          validationErrored: validationErroredRef,
          mergedLabelStyle: mergedLabelStyleRef,
          mergedLabelPlacement: mergedLabelPlacementRef,
          mergedLabelAlign: mergedLabelAlignRef,
          mergedShowRequireMark: mergedShowRequireMarkRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
          mergedValidationStatus: mergedValidationStatusRef,
          mergedShowFeedback: mergedShowFeedbackRef,
          mergedShowLabel: mergedShowLabelRef,
          isAutoLabelWidth: isAutoLabelWidthRef
      };
  }
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function formItemRule(props) {
      const NForm = inject(formInjectionKey, null);
      const compatibleRulePathRef = computed(() => {
          const { rulePath } = props;
          if (rulePath !== undefined)
              return rulePath;
          const { path } = props;
          if (path !== undefined)
              return path;
          return undefined;
      });
      const mergedRulesRef = computed(() => {
          const rules = [];
          const { rule } = props;
          if (rule !== undefined) {
              if (Array.isArray(rule))
                  rules.push(...rule);
              else
                  rules.push(rule);
          }
          if (NForm) {
              const { rules: formRules } = NForm.props;
              const { value: rulePath } = compatibleRulePathRef;
              if (formRules !== undefined && rulePath !== undefined) {
                  const formRule = get(formRules, rulePath);
                  if (formRule !== undefined) {
                      if (Array.isArray(formRule)) {
                          rules.push(...formRule);
                      }
                      else {
                          // terminate object must be a form item rule
                          rules.push(formRule);
                      }
                  }
              }
          }
          return rules;
      });
      const hasRequiredRuleRef = computed(() => {
          return mergedRulesRef.value.some((rule) => rule.required);
      });
      // deprecated
      const mergedRequiredRef = computed(() => {
          return hasRequiredRuleRef.value || props.required;
      });
      return {
          mergedRules: mergedRulesRef,
          mergedRequired: mergedRequiredRef
      };
  }

  const {
    cubicBezierEaseInOut
  } = commonVariables$m;
  function fadeDownTransition({
    name = 'fade-down',
    fromOffset = '-4px',
    enterDuration = '.3s',
    leaveDuration = '.3s',
    enterCubicBezier = cubicBezierEaseInOut,
    leaveCubicBezier = cubicBezierEaseInOut
  } = {}) {
    return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
      opacity: 0,
      transform: `translateY(${fromOffset})`
    }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
      opacity: 1,
      transform: 'translateY(0)'
    }), c$1(`&.${name}-transition-leave-active`, {
      transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
    }), c$1(`&.${name}-transition-enter-active`, {
      transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
    })];
  }

  // vars:
  // --n-line-height
  // --n-blank-height
  // --n-feedback-padding
  // --n-feedback-font-size
  // --n-label-font-size-left
  // --n-label-font-size-top
  // --n-label-height
  // --n-label-padding
  // --n-asterisk-color
  // --n-label-text-color
  // --n-bezier
  // --n-feedback-text-color
  // --n-feedback-text-color-warning
  // --n-feedback-text-color-error
  // --n-label-text-align
  // --n-label-padding
  var style$K = cB('form-item', `
 display: grid;
 line-height: var(--n-line-height);
`, [cB('form-item-label', `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE('asterisk', `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE('asterisk-placeholder', `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB('form-item-blank', `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM('auto-label-width', [cB('form-item-label', 'white-space: nowrap;')]), cM('left-labelled', `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: start;
 `, [cB('form-item-label', `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM('reverse-columns-space', `
 grid-template-columns: auto 1fr;
 `), cM('left-mark', `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM('right-mark', `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM('right-hanging-mark', `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE('text', `
 grid-area: text; 
 `), cE('asterisk', `
 grid-area: mark; 
 align-self: end;
 `)])]), cM('top-labelled', `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM('no-label', `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB('form-item-label', `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB('form-item-blank', `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB('form-item-feedback-wrapper', `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1('&:not(:empty)', `
 padding: var(--n-feedback-padding);
 `), cB('form-item-feedback', {
    transition: 'color .3s var(--n-bezier)',
    color: 'var(--n-feedback-text-color)'
  }, [cM('warning', {
    color: 'var(--n-feedback-text-color-warning)'
  }), cM('error', {
    color: 'var(--n-feedback-text-color-error)'
  }), fadeDownTransition({
    fromOffset: '-3px',
    enterDuration: '.3s',
    leaveDuration: '.2s'
  })])])]);

  var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const formItemProps = Object.assign(Object.assign({}, useTheme.props), { label: String, labelWidth: [Number, String], labelStyle: [String, Object], labelAlign: String, labelPlacement: String, path: String, first: Boolean, rulePath: String, required: Boolean, showRequireMark: {
          type: Boolean,
          default: undefined
      }, requireMarkPlacement: String, showFeedback: {
          type: Boolean,
          default: undefined
      }, rule: [Object, Array], size: String, ignorePathChange: Boolean, validationStatus: String, feedback: String, showLabel: {
          type: Boolean,
          default: undefined
      }, labelProps: Object });
  const formItemPropKeys = keysOf(formItemProps);
  // wrap sync validator
  function wrapValidator(validator, async) {
      return (...args) => {
          try {
              const validateResult = validator(...args);
              if ((!async &&
                  (typeof validateResult === 'boolean' ||
                      validateResult instanceof Error ||
                      Array.isArray(validateResult))) || // Error[]
                  (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
                  return validateResult;
              }
              else if (validateResult === undefined) {
                  return true;
              }
              else {
                  warn$2('form-item/validate', `You return a ${typeof validateResult} ` +
                      'typed value in the validator method, which is not recommended. Please use ' +
                      (async ? '`Promise`' : '`boolean`, `Error` or `Promise`') +
                      ' typed value instead.');
                  return true;
              }
          }
          catch (err) {
              warn$2('form-item/validate', 'An error is catched in the validation, ' +
                  "so the validation won't be done. Your callback in `validate` method of " +
                  "`n-form` or `n-form-item` won't be called in this validation.");
              console.error(err);
              // If returns undefined, async-validator won't trigger callback
              // so the result will be abandoned, which means not true and not false
              return undefined;
          }
      };
  }
  var NFormItem = defineComponent({
      name: 'FormItem',
      props: formItemProps,
      setup(props) {
          useInjectionInstanceCollection(formItemInstsInjectionKey, 'formItems', toRef(props, 'path'));
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const NForm = inject(formInjectionKey, null);
          const formItemSizeRefs = formItemSize(props);
          const formItemMiscRefs = formItemMisc(props);
          const { validationErrored: validationErroredRef } = formItemMiscRefs;
          const { mergedRequired: mergedRequiredRef, mergedRules: mergedRulesRef } = formItemRule(props);
          const { mergedSize: mergedSizeRef } = formItemSizeRefs;
          const { mergedLabelPlacement: labelPlacementRef, mergedLabelAlign: labelTextAlignRef, mergedRequireMarkPlacement: mergedRequireMarkPlacementRef } = formItemMiscRefs;
          const renderExplainsRef = ref([]);
          const feedbackIdRef = ref(createId());
          const mergedDisabledRef = NForm
              ? toRef(NForm.props, 'disabled')
              : ref(false);
          const themeRef = useTheme('Form', '-form-item', style$K, formLight$1, props, mergedClsPrefixRef);
          watch(toRef(props, 'path'), () => {
              if (props.ignorePathChange)
                  return;
              restoreValidation();
          });
          function restoreValidation() {
              renderExplainsRef.value = [];
              validationErroredRef.value = false;
              if (props.feedback) {
                  feedbackIdRef.value = createId();
              }
          }
          function handleContentBlur() {
              void internalValidate('blur');
          }
          function handleContentChange() {
              void internalValidate('change');
          }
          function handleContentFocus() {
              void internalValidate('focus');
          }
          function handleContentInput() {
              void internalValidate('input');
          }
          function validate(options, callback) {
              return __awaiter$5(this, void 0, void 0, function* () {
                  /** the following code is for compatibility */
                  let trigger;
                  let validateCallback;
                  let shouldRuleBeApplied;
                  let asyncValidatorOptions;
                  if (typeof options === 'string') {
                      trigger = options;
                      validateCallback = callback;
                  }
                  else if (options !== null && typeof options === 'object') {
                      trigger = options.trigger;
                      validateCallback = options.callback;
                      shouldRuleBeApplied = options.shouldRuleBeApplied;
                      asyncValidatorOptions = options.options;
                  }
                  yield new Promise((resolve, reject) => {
                      void internalValidate(trigger, shouldRuleBeApplied, asyncValidatorOptions).then(({ valid, errors }) => {
                          if (valid) {
                              if (validateCallback) {
                                  validateCallback();
                              }
                              resolve();
                          }
                          else {
                              if (validateCallback) {
                                  validateCallback(errors);
                              }
                              reject(errors);
                          }
                      });
                  });
              });
          }
          const internalValidate = (trigger = null, shouldRuleBeApplied = () => true, options = {
              suppressWarning: true
          }) => __awaiter$5(this, void 0, void 0, function* () {
              const { path } = props;
              if (!options) {
                  options = {};
              }
              else {
                  if (!options.first)
                      options.first = props.first;
              }
              const { value: rules } = mergedRulesRef;
              const value = NForm ? get(NForm.props.model, path || '') : undefined;
              const messageRenderers = {};
              const originalMessageRendersMessage = {};
              const activeRules = (!trigger
                  ? rules
                  : rules.filter((rule) => {
                      if (Array.isArray(rule.trigger)) {
                          return rule.trigger.includes(trigger);
                      }
                      else {
                          return rule.trigger === trigger;
                      }
                  }))
                  .filter(shouldRuleBeApplied)
                  .map((rule, i) => {
                  const shallowClonedRule = Object.assign({}, rule);
                  if (shallowClonedRule.validator) {
                      shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
                  }
                  if (shallowClonedRule.asyncValidator) {
                      shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
                  }
                  if (shallowClonedRule.renderMessage) {
                      const rendererKey = `__renderMessage__${i}`;
                      originalMessageRendersMessage[rendererKey] =
                          shallowClonedRule.message;
                      shallowClonedRule.message = rendererKey;
                      messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
                  }
                  return shallowClonedRule;
              });
              if (!activeRules.length) {
                  return {
                      valid: true
                  };
              }
              const mergedPath = path !== null && path !== void 0 ? path : '__n_no_path__';
              const validator = new Schema({ [mergedPath]: activeRules });
              const { validateMessages } = (NForm === null || NForm === void 0 ? void 0 : NForm.props) || {};
              if (validateMessages) {
                  validator.messages(validateMessages);
              }
              return yield new Promise((resolve) => {
                  void validator.validate({ [mergedPath]: value }, options, (errors) => {
                      if (errors === null || errors === void 0 ? void 0 : errors.length) {
                          renderExplainsRef.value = errors.map((error) => {
                              const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || '';
                              return {
                                  key: transformedMessage,
                                  render: () => {
                                      if (transformedMessage.startsWith('__renderMessage__')) {
                                          return messageRenderers[transformedMessage]();
                                      }
                                      return transformedMessage;
                                  }
                              };
                          });
                          errors.forEach((error) => {
                              var _a;
                              if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith('__renderMessage__')) {
                                  error.message = originalMessageRendersMessage[error.message];
                              }
                          });
                          validationErroredRef.value = true;
                          resolve({
                              valid: false,
                              errors
                          });
                      }
                      else {
                          restoreValidation();
                          resolve({
                              valid: true
                          });
                      }
                  });
              });
          });
          provide(formItemInjectionKey, {
              path: toRef(props, 'path'),
              disabled: mergedDisabledRef,
              mergedSize: formItemSizeRefs.mergedSize,
              mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
              restoreValidation,
              handleContentBlur,
              handleContentChange,
              handleContentFocus,
              handleContentInput
          });
          const exposedRef = {
              validate,
              restoreValidation,
              internalValidate
          };
          const labelElementRef = ref(null);
          onMounted(() => {
              if (!formItemMiscRefs.isAutoLabelWidth.value)
                  return;
              const labelElement = labelElementRef.value;
              if (labelElement !== null) {
                  const memoizedWhitespace = labelElement.style.whiteSpace;
                  labelElement.style.whiteSpace = 'nowrap';
                  labelElement.style.width = '';
                  NForm === null || NForm === void 0 ? void 0 : NForm.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
                  labelElement.style.whiteSpace = memoizedWhitespace;
              }
          });
          const cssVarsRef = computed(() => {
              var _a;
              const { value: size } = mergedSizeRef;
              const { value: labelPlacement } = labelPlacementRef;
              const direction = labelPlacement === 'top' ? 'vertical' : 'horizontal';
              const { common: { cubicBezierEaseInOut }, self: { labelTextColor, asteriskColor, lineHeight, feedbackTextColor, feedbackTextColorWarning, feedbackTextColorError, feedbackPadding, labelFontWeight, [createKey('labelHeight', size)]: labelHeight, [createKey('blankHeight', size)]: blankHeight, [createKey('feedbackFontSize', size)]: feedbackFontSize, [createKey('feedbackHeight', size)]: feedbackHeight, [createKey('labelPadding', direction)]: labelPadding, [createKey('labelTextAlign', direction)]: labelTextAlign, [createKey(createKey('labelFontSize', labelPlacement), size)]: labelFontSize } } = themeRef.value;
              let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
              if (labelPlacement === 'top') {
                  mergedLabelTextAlign =
                      mergedLabelTextAlign === 'right' ? 'flex-end' : 'flex-start';
              }
              const cssVars = {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-line-height': lineHeight,
                  '--n-blank-height': blankHeight,
                  '--n-label-font-size': labelFontSize,
                  '--n-label-text-align': mergedLabelTextAlign,
                  '--n-label-height': labelHeight,
                  '--n-label-padding': labelPadding,
                  '--n-label-font-weight': labelFontWeight,
                  '--n-asterisk-color': asteriskColor,
                  '--n-label-text-color': labelTextColor,
                  '--n-feedback-padding': feedbackPadding,
                  '--n-feedback-font-size': feedbackFontSize,
                  '--n-feedback-height': feedbackHeight,
                  '--n-feedback-text-color': feedbackTextColor,
                  '--n-feedback-text-color-warning': feedbackTextColorWarning,
                  '--n-feedback-text-color-error': feedbackTextColorError
              };
              return cssVars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('form-item', computed(() => {
                  var _a;
                  return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ''}`;
              }), cssVarsRef, props)
              : undefined;
          const reverseColSpaceRef = computed(() => {
              // label placement left
              // require-mark-placement | label align | areas (1fr auto)
              // left                   | left        | mark text (need reverse)
              // left                   | right       | mark text (okay)
              // right                  | left        | mark text (okay)
              // right                  | right       | mark text (okay)
              // right-hanging          | left        | text mark (okay)
              // right-hanging          | right       | text mark (okay)
              return (labelPlacementRef.value === 'left' &&
                  mergedRequireMarkPlacementRef.value === 'left' &&
                  labelTextAlignRef.value === 'left');
          });
          return Object.assign(Object.assign(Object.assign(Object.assign({ labelElementRef, mergedClsPrefix: mergedClsPrefixRef, mergedRequired: mergedRequiredRef, feedbackId: feedbackIdRef, renderExplains: renderExplainsRef, reverseColSpace: reverseColSpaceRef }, formItemMiscRefs), formItemSizeRefs), exposedRef), { cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          const { $slots, mergedClsPrefix, mergedShowLabel, mergedShowRequireMark, mergedRequireMarkPlacement, onRender } = this;
          const renderedShowRequireMark = mergedShowRequireMark !== undefined
              ? mergedShowRequireMark
              : this.mergedRequired;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderLabel = () => {
              const labelText = this.$slots.label ? this.$slots.label() : this.label;
              if (!labelText)
                  return null;
              const textNode = (h("span", { class: `${mergedClsPrefix}-form-item-label__text` }, labelText));
              const markNode = renderedShowRequireMark ? (h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk` }, mergedRequireMarkPlacement !== 'left' ? '\u00A0*' : '*\u00A0')) : (mergedRequireMarkPlacement === 'right-hanging' && (h("span", { class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder` }, '\u00A0*')));
              const { labelProps } = this;
              return (h("label", Object.assign({}, labelProps, { class: [
                      labelProps === null || labelProps === void 0 ? void 0 : labelProps.class,
                      `${mergedClsPrefix}-form-item-label`,
                      `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`,
                      this.reverseColSpace &&
                          `${mergedClsPrefix}-form-item-label--reverse-columns-space`
                  ], style: this.mergedLabelStyle, ref: "labelElementRef" }), mergedRequireMarkPlacement === 'left'
                  ? [markNode, textNode]
                  : [textNode, markNode]));
          };
          return (h("div", { class: [
                  `${mergedClsPrefix}-form-item`,
                  this.themeClass,
                  `${mergedClsPrefix}-form-item--${this.mergedSize}-size`,
                  `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`,
                  this.isAutoLabelWidth &&
                      `${mergedClsPrefix}-form-item--auto-label-width`,
                  !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`
              ], style: this.cssVars },
              mergedShowLabel && renderLabel(),
              h("div", { class: [
                      `${mergedClsPrefix}-form-item-blank`,
                      this.mergedValidationStatus &&
                          `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`
                  ] }, $slots),
              this.mergedShowFeedback ? (h("div", { key: this.feedbackId, class: `${mergedClsPrefix}-form-item-feedback-wrapper` },
                  h(Transition, { name: "fade-down-transition", mode: "out-in" }, {
                      default: () => {
                          const { mergedValidationStatus } = this;
                          return resolveWrappedSlot($slots.feedback, (children) => {
                              var _a;
                              const { feedback } = this;
                              const feedbackNodes = children || feedback ? (h("div", { key: "__feedback__", class: `${mergedClsPrefix}-form-item-feedback__line` }, children || feedback)) : this.renderExplains.length ? ((_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({ key, render }) => (h("div", { key: key, class: `${mergedClsPrefix}-form-item-feedback__line` }, render())))) : null;
                              return feedbackNodes ? (mergedValidationStatus === 'warning' ? (h("div", { key: "controlled-warning", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning` }, feedbackNodes)) : mergedValidationStatus === 'error' ? (h("div", { key: "controlled-error", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error` }, feedbackNodes)) : mergedValidationStatus === 'success' ? (h("div", { key: "controlled-success", class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success` }, feedbackNodes)) : (h("div", { key: "controlled-default", class: `${mergedClsPrefix}-form-item-feedback` }, feedbackNodes))) : null;
                          });
                      }
                  }))) : null));
      }
  });

  const defaultSpan$1 = 1;
  const gridInjectionKey = createInjectionKey('n-grid');

  const defaultSpan = 1;
  const gridItemProps = {
      span: {
          type: [Number, String],
          default: defaultSpan
      },
      offset: {
          type: [Number, String],
          default: 0
      },
      suffix: Boolean,
      // private props
      privateOffset: Number,
      privateSpan: Number,
      privateColStart: Number,
      privateShow: {
          type: Boolean,
          default: true
      }
  };
  const gridItemPropKeys = keysOf(gridItemProps);
  var NGi = defineComponent({
      __GRID_ITEM__: true,
      name: 'GridItem',
      alias: ['Gi'],
      props: gridItemProps,
      setup() {
          const { isSsrRef, xGapRef, itemStyleRef, overflowRef, layoutShiftDisabledRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(gridInjectionKey);
          const self = getCurrentInstance();
          return {
              overflow: overflowRef,
              itemStyle: itemStyleRef,
              layoutShiftDisabled: layoutShiftDisabledRef,
              mergedXGap: computed(() => {
                  return pxfy(xGapRef.value || 0);
              }),
              deriveStyle: () => {
                  void isSsrRef.value;
                  // Here is quite a hack, I hope there is a better way to solve it
                  const { privateSpan = defaultSpan, privateShow = true, privateColStart = undefined, privateOffset = 0
                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                   } = self.vnode.props;
                  const { value: xGap } = xGapRef;
                  const mergedXGap = pxfy(xGap || 0);
                  return {
                      display: !privateShow ? 'none' : '',
                      gridColumn: `${privateColStart !== null && privateColStart !== void 0 ? privateColStart : `span ${privateSpan}`} / span ${privateSpan}`,
                      marginLeft: privateOffset
                          ? `calc((100% - (${privateSpan} - 1) * ${mergedXGap}) / ${privateSpan} * ${privateOffset} + ${mergedXGap} * ${privateOffset})`
                          : ''
                  };
              }
          };
      },
      render() {
          var _a, _b;
          if (this.layoutShiftDisabled) {
              const { span, offset, mergedXGap } = this;
              return (h("div", { style: {
                      gridColumn: `span ${span} / span ${span}`,
                      marginLeft: offset
                          ? `calc((100% - (${span} - 1) * ${mergedXGap}) / ${span} * ${offset} + ${mergedXGap} * ${offset})`
                          : ''
                  } }, this.$slots));
          }
          return (h("div", { style: [this.itemStyle, this.deriveStyle()] }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, { overflow: this.overflow })));
      }
  });

  const formItemGiProps = Object.assign(Object.assign({}, gridItemProps), formItemProps);
  var FormItemGridItem = defineComponent({
      __GRID_ITEM__: true,
      name: 'FormItemGridItem',
      alias: ['FormItemGi'],
      props: formItemGiProps,
      setup() {
          const formItemInstRef = ref(null);
          const validate = ((...args) => {
              const { value } = formItemInstRef;
              if (value) {
                  return value.validate(...args);
              }
          });
          const restoreValidation = () => {
              const { value } = formItemInstRef;
              if (value) {
                  value.restoreValidation();
              }
          };
          return {
              formItemInstRef,
              validate,
              restoreValidation
          };
      },
      render() {
          return h(NGi, keep(this.$.vnode.props || {}, gridItemPropKeys), {
              default: () => {
                  const itemProps = keep(this.$props, formItemPropKeys);
                  return h(NFormItem, Object.assign({ ref: 'formItemInstRef' }, itemProps), this.$slots);
              }
          });
      }
  });

  const positionStyles = repeat(24, null).map((_, index) => {
    const prefixIndex = index + 1;
    const percent = `calc(100% / 24 * ${prefixIndex})`;
    return [cM(`${prefixIndex}-span`, {
      width: percent
    }), cM(`${prefixIndex}-offset`, {
      marginLeft: percent
    }), cM(`${prefixIndex}-push`, {
      left: percent
    }), cM(`${prefixIndex}-pull`, {
      right: percent
    })];
  });
  var style$J = c$1([cB('row', {
    width: '100%',
    display: 'flex',
    flexWrap: 'wrap'
  }), cB('col', {
    verticalAlign: 'top',
    boxSizing: 'border-box',
    display: 'inline-block',
    position: 'relative',
    zIndex: 'auto'
  }, [cE('box', {
    position: 'relative',
    zIndex: 'auto',
    width: '100%',
    height: '100%'
  }), positionStyles])]);

  const rowInjectionKey = createInjectionKey('n-row');
  const rowProps = {
      gutter: {
          type: [Array, Number, String],
          default: 0
      },
      alignItems: String,
      justifyContent: String
  };
  const rowPropKeys = keysOf(rowProps);
  var NRow = defineComponent({
      name: 'Row',
      props: rowProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          useStyle('-legacy-grid', style$J, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Row', mergedRtlRef, mergedClsPrefixRef);
          const verticalGutterRef = useMemo(() => {
              const { gutter } = props;
              if (Array.isArray(gutter)) {
                  return gutter[1] || 0;
              }
              return 0;
          });
          const horizontalGutterRef = useMemo(() => {
              const { gutter } = props;
              if (Array.isArray(gutter)) {
                  return gutter[0];
              }
              return Number(gutter);
          });
          provide(rowInjectionKey, {
              mergedClsPrefixRef,
              gutterRef: toRef(props, 'gutter'),
              verticalGutterRef,
              horizontalGutterRef
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              rtlEnabled: rtlEnabledRef,
              styleMargin: useMemo(() => `-${formatLength(verticalGutterRef.value, {
                c: 0.5
            })} -${formatLength(horizontalGutterRef.value, { c: 0.5 })}`),
              styleWidth: useMemo(() => `calc(100% + ${formatLength(horizontalGutterRef.value)})`)
          };
      },
      render() {
          return (h("div", { class: [
                  `${this.mergedClsPrefix}-row`,
                  this.rtlEnabled && `${this.mergedClsPrefix}-row--rtl`
              ], style: {
                  margin: this.styleMargin,
                  width: this.styleWidth,
                  alignItems: this.alignItems,
                  justifyContent: this.justifyContent
              } }, this.$slots));
      }
  });

  const colProps = {
      span: {
          type: [String, Number],
          default: 1
      },
      push: {
          type: [String, Number],
          default: 0
      },
      pull: {
          type: [String, Number],
          default: 0
      },
      offset: {
          type: [String, Number],
          default: 0
      }
  };
  const colPropKeys = keysOf(colProps);
  var NCol = defineComponent({
      name: 'Col',
      props: colProps,
      setup(props) {
          const NRow = inject(rowInjectionKey, null);
          if (!NRow)
              throwError('col', '`n-col` must be placed inside `n-row`.');
          return {
              mergedClsPrefix: NRow.mergedClsPrefixRef,
              gutter: NRow.gutterRef,
              stylePadding: computed(() => `${formatLength(NRow.verticalGutterRef.value, {
                c: 0.5
            })} ${formatLength(NRow.horizontalGutterRef.value, { c: 0.5 })}`),
              mergedPush: computed(() => Number(props.push) - Number(props.pull))
          };
      },
      render() {
          const { $slots, span, mergedPush, offset, stylePadding, gutter, mergedClsPrefix } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-col`,
                  {
                      [`${mergedClsPrefix}-col--${span}-span`]: true,
                      [`${mergedClsPrefix}-col--${mergedPush}-push`]: mergedPush > 0,
                      [`${mergedClsPrefix}-col--${-mergedPush}-pull`]: mergedPush < 0,
                      [`${mergedClsPrefix}-col--${offset}-offset`]: offset
                  }
              ], style: {
                  padding: stylePadding
              } }, gutter ? h("div", null, $slots) : $slots));
      }
  });

  const formItemColProps = Object.assign(Object.assign({}, colProps), formItemProps);
  const formItemColPropKeys = keysOf(formItemColProps);
  var NFormItemCol = defineComponent({
      name: 'FormItemCol',
      props: formItemColProps,
      setup() {
          const formItemInstRef = ref(null);
          const validate = ((...args) => {
              const { value } = formItemInstRef;
              if (value) {
                  return value.validate(...args);
              }
          });
          const restoreValidation = () => {
              const { value } = formItemInstRef;
              if (value) {
                  value.restoreValidation();
              }
          };
          return {
              formItemInstRef,
              validate,
              restoreValidation
          };
      },
      render() {
          return h(NCol, keep(this.$props, colPropKeys), {
              default: () => {
                  const itemProps = keep(this.$props, formItemPropKeys);
                  return h(NFormItem, Object.assign({ ref: 'formItemInstRef' }, itemProps), this.$slots);
              }
          });
      }
  });

  const formItemRowProps = Object.assign(Object.assign({}, rowProps), formItemColProps);
  var FormItemRow = defineComponent({
      name: 'FormItemRow',
      props: formItemRowProps,
      setup() {
          const formItemColInstRef = ref(null);
          const validate = ((...args) => {
              const { value } = formItemColInstRef;
              if (value) {
                  return value.validate(...args);
              }
          });
          const restoreValidation = () => {
              const { value } = formItemColInstRef;
              if (value) {
                  value.restoreValidation();
              }
          };
          return {
              formItemColInstRef,
              validate,
              restoreValidation
          };
      },
      render() {
          return h(NRow, keep(this.$props, rowPropKeys), {
              default: () => {
                  const colProps = keep(this.$props, formItemColPropKeys);
                  return h(NFormItemCol, Object.assign(Object.assign({ ref: 'formItemColInstRef' }, colProps), { span: 24 }), this.$slots);
              }
          });
      }
  });

  var GlobalStyle = defineComponent({
      name: 'GlobalStyle',
      setup() {
          if (typeof document === 'undefined')
              return; // TODO: inject style for SSR
          const NConfigProvider = inject(configProviderInjectionKey, null);
          const { body } = document;
          const { style } = body;
          let styleApplied = false;
          let firstApply = true;
          onBeforeMount(() => {
              watchEffect(() => {
                  var _a, _b;
                  const { textColor2, fontSize, fontFamily, bodyColor, cubicBezierEaseInOut, lineHeight } = NConfigProvider
                      ? merge$2({}, ((_a = NConfigProvider.mergedThemeRef.value) === null || _a === void 0 ? void 0 : _a.common) || commonLight, (_b = NConfigProvider.mergedThemeOverridesRef.value) === null || _b === void 0 ? void 0 : _b.common)
                      : commonLight;
                  if (styleApplied || !body.hasAttribute('n-styled')) {
                      style.setProperty('-webkit-text-size-adjust', '100%');
                      style.setProperty('-webkit-tap-highlight-color', 'transparent');
                      style.padding = '0';
                      style.margin = '0';
                      style.backgroundColor = bodyColor;
                      style.color = textColor2;
                      style.fontSize = fontSize;
                      style.fontFamily = fontFamily;
                      style.lineHeight = lineHeight;
                      const transition = `color .3s ${cubicBezierEaseInOut}, background-color .3s ${cubicBezierEaseInOut}`;
                      if (firstApply) {
                          setTimeout(() => {
                              style.transition = transition;
                          }, 0);
                      }
                      else {
                          style.transition = transition;
                      }
                      body.setAttribute('n-styled', '');
                      styleApplied = true;
                      firstApply = false;
                  }
              });
          });
          onUnmounted(() => {
              if (styleApplied) {
                  body.removeAttribute('n-styled');
              }
          });
      },
      render() {
          return null;
      }
  });

  const self$z = (vars) => {
      const { primaryColor, successColor, warningColor, errorColor, infoColor, fontWeightStrong } = vars;
      return {
          fontWeight: fontWeightStrong,
          rotate: '252deg',
          colorStartPrimary: changeColor(primaryColor, { alpha: 0.6 }),
          colorEndPrimary: primaryColor,
          colorStartInfo: changeColor(infoColor, { alpha: 0.6 }),
          colorEndInfo: infoColor,
          colorStartWarning: changeColor(warningColor, { alpha: 0.6 }),
          colorEndWarning: warningColor,
          colorStartError: changeColor(errorColor, { alpha: 0.6 }),
          colorEndError: errorColor,
          colorStartSuccess: changeColor(successColor, { alpha: 0.6 }),
          colorEndSuccess: successColor
      };
  };
  const gradientTextLight = {
      name: 'GradientText',
      common: commonLight,
      self: self$z
  };
  var gradientTextLight$1 = gradientTextLight;

  // vars:
  // --n-font-weight
  // --n-rotate
  // --n-bezier
  // --n-color-start
  // --n-color-end
  var style$I = cB('gradient-text', `
 display: inline-block;
 font-weight: var(--n-font-weight);
 -webkit-background-clip: text;
 background-clip: text;
 color: #0000;
 white-space: nowrap;
 background-image: linear-gradient(var(--n-rotate), var(--n-color-start) 0%, var(--n-color-end) 100%);
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier);
`);

  const gradientTextProps = Object.assign(Object.assign({}, useTheme.props), { size: [String, Number], fontSize: [String, Number], type: {
          type: String,
          default: 'primary'
      }, color: [Object, String], gradient: [Object, String] });
  var GradientText = defineComponent({
      name: 'GradientText',
      props: gradientTextProps,
      setup(props) {
          useHoudini();
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const compatibleTypeRef = computed(() => {
              const { type } = props;
              if (type === 'danger')
                  return 'error';
              return type;
          });
          const styleFontSizeRef = computed(() => {
              let fontSize = props.size || props.fontSize;
              if (fontSize)
                  fontSize = formatLength(fontSize);
              return fontSize || undefined;
          });
          const styleBgImageRef = computed(() => {
              const gradient = props.color || props.gradient;
              if (typeof gradient === 'string') {
                  return gradient;
              }
              else if (gradient) {
                  const deg = gradient.deg || 0;
                  const from = gradient.from;
                  const to = gradient.to;
                  return `linear-gradient(${deg}deg, ${from} 0%, ${to} 100%)`;
              }
              return undefined;
          });
          const themeRef = useTheme('GradientText', '-gradient-text', style$I, gradientTextLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { value: type } = compatibleTypeRef;
              const { common: { cubicBezierEaseInOut }, self: { rotate, [createKey('colorStart', type)]: colorStart, [createKey('colorEnd', type)]: colorEnd, fontWeight } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-rotate': rotate,
                  '--n-color-start': colorStart,
                  '--n-color-end': colorEnd,
                  '--n-font-weight': fontWeight
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('gradient-text', computed(() => compatibleTypeRef.value[0]), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              compatibleType: compatibleTypeRef,
              styleFontSize: styleFontSizeRef,
              styleBgImage: styleBgImageRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("span", { class: [
                  `${mergedClsPrefix}-gradient-text`,
                  `${mergedClsPrefix}-gradient-text--${this.compatibleType}-type`,
                  this.themeClass
              ], style: [
                  {
                      fontSize: this.styleFontSize,
                      backgroundImage: this.styleBgImage
                  },
                  this.cssVars
              ] }, this.$slots));
      }
  });

  const defaultBreakpoints = {
      xs: 0, // mobile
      s: 640, // tablet
      m: 1024, // laptop s
      l: 1280, // laptop
      xl: 1536, // laptop l
      xxl: 1920 // normal desktop display
  };

  const defaultCols = 24;
  const SSR_ATTR_NAME = '__ssr__';
  const gridProps = {
      layoutShiftDisabled: Boolean,
      responsive: {
          type: [String, Boolean],
          default: 'self'
      },
      cols: {
          type: [Number, String],
          default: defaultCols
      },
      itemResponsive: Boolean,
      collapsed: Boolean,
      // may create grid rows < collapsedRows since a item may take all the row
      collapsedRows: {
          type: Number,
          default: 1
      },
      itemStyle: [Object, String],
      xGap: {
          type: [Number, String],
          default: 0
      },
      yGap: {
          type: [Number, String],
          default: 0
      }
  };
  var NGrid = defineComponent({
      name: 'Grid',
      inheritAttrs: false,
      props: gridProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedBreakpointsRef } = useConfig(props);
          const numRegex = /^\d+$/;
          const widthRef = ref(undefined);
          const breakpointsRef = useBreakpoints((mergedBreakpointsRef === null || mergedBreakpointsRef === void 0 ? void 0 : mergedBreakpointsRef.value) || defaultBreakpoints);
          const isResponsiveRef = useMemo(() => {
              if (props.itemResponsive)
                  return true;
              if (!numRegex.test(props.cols.toString()))
                  return true;
              if (!numRegex.test(props.xGap.toString()))
                  return true;
              if (!numRegex.test(props.yGap.toString()))
                  return true;
              return false;
          });
          const responsiveQueryRef = computed(() => {
              if (!isResponsiveRef.value)
                  return undefined;
              return props.responsive === 'self' ? widthRef.value : breakpointsRef.value;
          });
          const responsiveColsRef = useMemo(() => {
              var _a;
              return ((_a = Number(parseResponsivePropValue(props.cols.toString(), responsiveQueryRef.value))) !== null && _a !== void 0 ? _a : defaultCols);
          });
          const responsiveXGapRef = useMemo(() => parseResponsivePropValue(props.xGap.toString(), responsiveQueryRef.value));
          const responsiveYGapRef = useMemo(() => parseResponsivePropValue(props.yGap.toString(), responsiveQueryRef.value));
          const handleResize = (entry) => {
              widthRef.value = entry.contentRect.width;
          };
          const handleResizeRaf = (entry) => {
              beforeNextFrameOnce(handleResize, entry);
          };
          const overflowRef = ref(false);
          const handleResizeRef = computed(() => {
              if (props.responsive === 'self') {
                  return handleResizeRaf;
              }
              return undefined;
          });
          // for SSR, fix bug https://github.com/tusen-ai/naive-ui/issues/2462
          const isSsrRef = ref(false);
          const contentElRef = ref();
          onMounted(() => {
              const { value: contentEl } = contentElRef;
              if (contentEl) {
                  if (contentEl.hasAttribute(SSR_ATTR_NAME)) {
                      contentEl.removeAttribute(SSR_ATTR_NAME);
                      isSsrRef.value = true;
                  }
              }
          });
          provide(gridInjectionKey, {
              layoutShiftDisabledRef: toRef(props, 'layoutShiftDisabled'),
              isSsrRef,
              itemStyleRef: toRef(props, 'itemStyle'),
              xGapRef: responsiveXGapRef,
              overflowRef
          });
          return {
              isSsr: !isBrowser$2,
              contentEl: contentElRef,
              mergedClsPrefix: mergedClsPrefixRef,
              style: computed(() => {
                  if (props.layoutShiftDisabled) {
                      return {
                          width: '100%',
                          display: 'grid',
                          gridTemplateColumns: `repeat(${props.cols}, minmax(0, 1fr))`,
                          columnGap: pxfy(props.xGap),
                          rowGap: pxfy(props.yGap)
                      };
                  }
                  return {
                      width: '100%',
                      display: 'grid',
                      gridTemplateColumns: `repeat(${responsiveColsRef.value}, minmax(0, 1fr))`,
                      columnGap: pxfy(responsiveXGapRef.value),
                      rowGap: pxfy(responsiveYGapRef.value)
                  };
              }),
              isResponsive: isResponsiveRef,
              responsiveQuery: responsiveQueryRef,
              responsiveCols: responsiveColsRef,
              handleResize: handleResizeRef,
              overflow: overflowRef
          };
      },
      render() {
          if (this.layoutShiftDisabled) {
              return h('div', mergeProps({
                  ref: 'contentEl',
                  class: `${this.mergedClsPrefix}-grid`,
                  style: this.style
              }, this.$attrs), this.$slots);
          }
          const renderContent = () => {
              var _a, _b, _c, _d, _e, _f, _g;
              this.overflow = false;
              // render will be called twice when mounted, I can't figure out why
              // 2 jobs will be pushed into job queues with same id, and then be flushed
              const rawChildren = flatten$3(getSlot$1(this));
              const childrenAndRawSpan = [];
              const { collapsed, collapsedRows, responsiveCols, responsiveQuery } = this;
              rawChildren.forEach((child) => {
                  var _a, _b, _c, _d, _e;
                  if (((_a = child === null || child === void 0 ? void 0 : child.type) === null || _a === void 0 ? void 0 : _a.__GRID_ITEM__) !== true)
                      return;
                  if (isNodeVShowFalse(child)) {
                      const clonedNode = cloneVNode(child);
                      if (clonedNode.props) {
                          clonedNode.props.privateShow = false;
                      }
                      else {
                          clonedNode.props = { privateShow: false };
                      }
                      childrenAndRawSpan.push({
                          child: clonedNode,
                          rawChildSpan: 0
                      });
                      return;
                  }
                  // We don't want v-show to control display, so we need to stripe it
                  // here, nor it may mess child's style
                  child.dirs = ((_b = child.dirs) === null || _b === void 0 ? void 0 : _b.filter(({ dir }) => dir !== vShow)) || null;
                  if (((_c = child.dirs) === null || _c === void 0 ? void 0 : _c.length) === 0) {
                      child.dirs = null;
                  }
                  const clonedChild = cloneVNode(child);
                  const rawChildSpan = Number((_e = parseResponsivePropValue((_d = clonedChild.props) === null || _d === void 0 ? void 0 : _d.span, responsiveQuery)) !== null && _e !== void 0 ? _e : defaultSpan$1);
                  if (rawChildSpan === 0)
                      return;
                  childrenAndRawSpan.push({
                      child: clonedChild,
                      rawChildSpan
                  });
              });
              let suffixSpan = 0;
              const maybeSuffixNode = (_a = childrenAndRawSpan[childrenAndRawSpan.length - 1]) === null || _a === void 0 ? void 0 : _a.child;
              if (maybeSuffixNode === null || maybeSuffixNode === void 0 ? void 0 : maybeSuffixNode.props) {
                  const suffixPropValue = (_b = maybeSuffixNode.props) === null || _b === void 0 ? void 0 : _b.suffix;
                  if (suffixPropValue !== undefined && suffixPropValue !== false) {
                      suffixSpan = Number((_d = parseResponsivePropValue((_c = maybeSuffixNode.props) === null || _c === void 0 ? void 0 : _c.span, responsiveQuery)) !== null && _d !== void 0 ? _d : defaultSpan$1);
                      maybeSuffixNode.props.privateSpan = suffixSpan;
                      maybeSuffixNode.props.privateColStart =
                          responsiveCols + 1 - suffixSpan;
                      maybeSuffixNode.props.privateShow =
                          (_e = maybeSuffixNode.props.privateShow) !== null && _e !== void 0 ? _e : true;
                  }
              }
              let spanCounter = 0;
              let done = false;
              for (const { child, rawChildSpan } of childrenAndRawSpan) {
                  if (done) {
                      this.overflow = true;
                  }
                  if (!done) {
                      const childOffset = Number((_g = parseResponsivePropValue((_f = child.props) === null || _f === void 0 ? void 0 : _f.offset, responsiveQuery)) !== null && _g !== void 0 ? _g : 0);
                      // it could be 0 sometimes (v-show = false)
                      const childSpan = Math.min(rawChildSpan + childOffset, responsiveCols);
                      if (!child.props) {
                          child.props = {
                              privateSpan: childSpan,
                              privateOffset: childOffset
                          };
                      }
                      else {
                          child.props.privateSpan = childSpan;
                          child.props.privateOffset = childOffset;
                      }
                      if (collapsed) {
                          const remainder = spanCounter % responsiveCols;
                          if (childSpan + remainder > responsiveCols) {
                              spanCounter += responsiveCols - remainder;
                          }
                          if (childSpan + spanCounter + suffixSpan >
                              collapsedRows * responsiveCols) {
                              done = true;
                          }
                          else {
                              spanCounter += childSpan;
                          }
                      }
                  }
                  if (done) {
                      if (child.props) {
                          // suffix node's privateShow may be true
                          if (child.props.privateShow !== true) {
                              child.props.privateShow = false;
                          }
                      }
                      else {
                          child.props = {
                              privateShow: false
                          };
                      }
                  }
              }
              return h('div', mergeProps({
                  ref: 'contentEl',
                  class: `${this.mergedClsPrefix}-grid`,
                  style: this.style,
                  [SSR_ATTR_NAME]: this.isSsr || undefined
              }, this.$attrs), childrenAndRawSpan.map(({ child }) => child));
          };
          return this.isResponsive && this.responsive === 'self' ? (h(VResizeObserver, { onResize: this.handleResize }, {
              default: renderContent
          })) : (renderContent());
      }
  });

  const self$y = (vars) => {
      const { primaryColor, baseColor } = vars;
      return {
          color: primaryColor,
          iconColor: baseColor
      };
  };
  const iconWrapperLight = {
      name: 'IconWrapper',
      common: commonLight,
      self: self$y
  };
  var iconWrapperLight$1 = iconWrapperLight;

  // vars:
  // --n-bezier
  // --n-border-radius
  // --n-color
  // --n-icon-color
  var style$H = cB('icon-wrapper', `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-icon-color);
`);

  const iconWrapperProps = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: Number,
          default: 24
      }, borderRadius: {
          type: Number,
          default: 6
      }, color: String, iconColor: String });
  const NIconWrapper = defineComponent({
      name: 'IconWrapper',
      props: iconWrapperProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('IconWrapper', '-icon-wrapper', style$H, iconWrapperLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { color, iconColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color': color,
                  '--n-icon-color': iconColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('icon-wrapper', undefined, cssVarsRef, props)
              : undefined;
          return () => {
              const size = formatLength(props.size);
              themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
              return (h("div", { class: [
                      `${mergedClsPrefixRef.value}-icon-wrapper`,
                      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value
                  ], style: [
                      cssVarsRef === null || cssVarsRef === void 0 ? void 0 : cssVarsRef.value,
                      {
                          height: size,
                          width: size,
                          borderRadius: formatLength(props.borderRadius),
                          backgroundColor: props.color,
                          color: props.iconColor
                      }
                  ] }, slots));
          };
      }
  });

  const imagePreviewSharedProps = Object.assign(Object.assign({}, useTheme.props), { onPreviewPrev: Function, onPreviewNext: Function, showToolbar: { type: Boolean, default: true }, showToolbarTooltip: Boolean });
  const imageContextKey = createInjectionKey('n-image');

  var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const isImageFileType = (type) => type.includes('image/');
  const getExtname = (url = '') => {
      const temp = url.split('/');
      const filename = temp[temp.length - 1];
      const filenameWithoutSuffix = filename.split(/#|\?/)[0];
      return (/\.[^./\\]*$/.exec(filenameWithoutSuffix) || [''])[0];
  };
  const imageExtensionRegex = /(webp|svg|png|gif|jpg|jpeg|jfif|bmp|dpg|ico)$/i;
  // Do not need File object
  const isImageFile = (file) => {
      if (file.type) {
          return isImageFileType(file.type);
      }
      const fileNameExtension = getExtname(file.name || '');
      if (imageExtensionRegex.test(fileNameExtension)) {
          return true;
      }
      const url = file.thumbnailUrl || file.url || '';
      const urlExtension = getExtname(url);
      if (/^data:image\//.test(url) || imageExtensionRegex.test(urlExtension)) {
          return true;
      }
      return false;
  };
  function createImageDataUrl(file) {
      return __awaiter$4(this, void 0, void 0, function* () {
          return yield new Promise((resolve) => {
              if (!file.type || !isImageFileType(file.type)) {
                  resolve('');
                  return;
              }
              resolve(window.URL.createObjectURL(file));
          });
      });
  }
  const environmentSupportFile = isBrowser$2 && window.FileReader && window.File;
  function isFileSystemDirectoryEntry(item) {
      return item.isDirectory;
  }
  function isFileSystemFileEntry(item) {
      return item.isFile;
  }
  function getFilesFromEntries(entries, directory) {
      return __awaiter$4(this, void 0, void 0, function* () {
          const fileAndEntries = [];
          let _resolve;
          let requestCallbackCount = 0;
          function lock() {
              requestCallbackCount++;
          }
          function unlock() {
              requestCallbackCount--;
              if (!requestCallbackCount) {
                  _resolve(fileAndEntries);
              }
          }
          function _getFilesFromEntries(entries) {
              entries.forEach((entry) => {
                  if (!entry)
                      return;
                  lock();
                  if (directory && isFileSystemDirectoryEntry(entry)) {
                      const directoryReader = entry.createReader();
                      lock();
                      directoryReader.readEntries((entries) => {
                          _getFilesFromEntries(entries);
                          unlock();
                      }, () => {
                          unlock();
                      });
                  }
                  else if (isFileSystemFileEntry(entry)) {
                      lock();
                      entry.file((file) => {
                          fileAndEntries.push({ file, entry, source: 'dnd' });
                          unlock();
                      }, () => {
                          unlock();
                      });
                  }
                  unlock();
              });
          }
          yield new Promise((resolve) => {
              _resolve = resolve;
              _getFilesFromEntries(entries);
          });
          return fileAndEntries;
      });
  }
  function createSettledFileInfo(fileInfo) {
      const { id, name, percentage, status, url, file, thumbnailUrl, type, fullPath, batchId } = fileInfo;
      return {
          id,
          name,
          percentage: percentage !== null && percentage !== void 0 ? percentage : null,
          status,
          url: url !== null && url !== void 0 ? url : null,
          file: file !== null && file !== void 0 ? file : null,
          thumbnailUrl: thumbnailUrl !== null && thumbnailUrl !== void 0 ? thumbnailUrl : null,
          type: type !== null && type !== void 0 ? type : null,
          fullPath: fullPath !== null && fullPath !== void 0 ? fullPath : null,
          batchId: batchId !== null && batchId !== void 0 ? batchId : null
      };
  }
  /**
   * This is a rather simple version. I may fix it later to make it more accurate.
   * I've looked at https://github.com/broofa/mime, however it doesn't has a esm
   * version, so I can't simply use it.
   */
  function matchType(name, mimeType, accept) {
      name = name.toLowerCase();
      mimeType = mimeType.toLocaleLowerCase();
      accept = accept.toLocaleLowerCase();
      const acceptAtoms = accept
          .split(',')
          .map((acceptAtom) => acceptAtom.trim())
          .filter(Boolean);
      return acceptAtoms.some((acceptAtom) => {
          if (acceptAtom.startsWith('.')) {
              // suffix
              if (name.endsWith(acceptAtom))
                  return true;
          }
          else if (acceptAtom.includes('/')) {
              // mime type
              const [type, subtype] = mimeType.split('/');
              const [acceptType, acceptSubtype] = acceptAtom.split('/');
              if (acceptType === '*' || (type && acceptType && acceptType === type)) {
                  if (acceptSubtype === '*' ||
                      (subtype && acceptSubtype && acceptSubtype === subtype)) {
                      return true;
                  }
              }
          }
          else {
              // invalid type
              return true;
          }
          return false;
      });
  }
  const download = (url, name) => {
      if (!url)
          return;
      const a = document.createElement('a');
      a.href = url;
      if (name !== undefined) {
          a.download = name;
      }
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
  };

  function self$x() {
      return {
          toolbarIconColor: 'rgba(255, 255, 255, .9)',
          toolbarColor: 'rgba(0, 0, 0, .35)',
          toolbarBoxShadow: 'none',
          toolbarBorderRadius: '24px'
      };
  }
  const imageLight = createTheme({
      name: 'Image',
      common: commonLight,
      peers: {
          Tooltip: tooltipLight$1
      },
      self: self$x
  });

  var commonVars$3 = {
      closeMargin: '16px 12px',
      closeSize: '20px',
      closeIconSize: '16px',
      width: '365px',
      padding: '16px',
      titleFontSize: '16px',
      metaFontSize: '12px',
      descriptionFontSize: '12px'
  };

  const self$w = (vars) => {
      const { textColor2, successColor, infoColor, warningColor, errorColor, popoverColor, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, textColor1, textColor3, borderRadius, fontWeightStrong, boxShadow2, lineHeight, fontSize } = vars;
      return Object.assign(Object.assign({}, commonVars$3), { borderRadius,
          lineHeight,
          fontSize, headerFontWeight: fontWeightStrong, iconColor: textColor2, iconColorSuccess: successColor, iconColorInfo: infoColor, iconColorWarning: warningColor, iconColorError: errorColor, color: popoverColor, textColor: textColor2, closeIconColor,
          closeIconColorHover,
          closeIconColorPressed, closeBorderRadius: borderRadius, closeColorHover,
          closeColorPressed, headerTextColor: textColor1, descriptionTextColor: textColor3, actionTextColor: textColor2, boxShadow: boxShadow2 });
  };
  const notificationLight = createTheme({
      name: 'Notification',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1
      },
      self: self$w
  });
  var notificationLight$1 = notificationLight;

  var commonVariables$4 = {
      margin: '0 0 8px 0',
      padding: '10px 20px',
      maxWidth: '720px',
      minWidth: '420px',
      iconMargin: '0 10px 0 0',
      closeMargin: '0 0 0 10px',
      closeSize: '20px',
      closeIconSize: '16px',
      iconSize: '20px',
      fontSize: '14px'
  };

  const self$v = (vars) => {
      const { textColor2, closeIconColor, closeIconColorHover, closeIconColorPressed, infoColor, successColor, errorColor, warningColor, popoverColor, boxShadow2, primaryColor, lineHeight, borderRadius, closeColorHover, closeColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$4), { closeBorderRadius: borderRadius, textColor: textColor2, textColorInfo: textColor2, textColorSuccess: textColor2, textColorError: textColor2, textColorWarning: textColor2, textColorLoading: textColor2, color: popoverColor, colorInfo: popoverColor, colorSuccess: popoverColor, colorError: popoverColor, colorWarning: popoverColor, colorLoading: popoverColor, boxShadow: boxShadow2, boxShadowInfo: boxShadow2, boxShadowSuccess: boxShadow2, boxShadowError: boxShadow2, boxShadowWarning: boxShadow2, boxShadowLoading: boxShadow2, iconColor: textColor2, iconColorInfo: infoColor, iconColorSuccess: successColor, iconColorWarning: warningColor, iconColorError: errorColor, iconColorLoading: primaryColor, closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed, closeColorHoverInfo: closeColorHover, closeColorPressedInfo: closeColorPressed, closeIconColorInfo: closeIconColor, closeIconColorHoverInfo: closeIconColorHover, closeIconColorPressedInfo: closeIconColorPressed, closeColorHoverSuccess: closeColorHover, closeColorPressedSuccess: closeColorPressed, closeIconColorSuccess: closeIconColor, closeIconColorHoverSuccess: closeIconColorHover, closeIconColorPressedSuccess: closeIconColorPressed, closeColorHoverError: closeColorHover, closeColorPressedError: closeColorPressed, closeIconColorError: closeIconColor, closeIconColorHoverError: closeIconColorHover, closeIconColorPressedError: closeIconColorPressed, closeColorHoverWarning: closeColorHover, closeColorPressedWarning: closeColorPressed, closeIconColorWarning: closeIconColor, closeIconColorHoverWarning: closeIconColorHover, closeIconColorPressedWarning: closeIconColorPressed, closeColorHoverLoading: closeColorHover, closeColorPressedLoading: closeColorPressed, closeIconColorLoading: closeIconColor, closeIconColorHoverLoading: closeIconColorHover, closeIconColorPressedLoading: closeIconColorPressed, loadingColor: primaryColor, lineHeight,
          borderRadius });
  };
  const messageLight = {
      name: 'Message',
      common: commonLight,
      self: self$v
  };
  var messageLight$1 = messageLight;

  const self$u = (vars) => {
      const { textColorDisabled } = vars;
      return {
          iconColorDisabled: textColorDisabled
      };
  };
  const inputNumberLight = createTheme({
      name: 'InputNumber',
      common: commonLight,
      peers: {
          Button: buttonLight$1,
          Input: inputLight$1
      },
      self: self$u
  });
  var inputNumberLight$1 = inputNumberLight;

  const self$t = (vars) => {
      const { baseColor, textColor2, bodyColor, cardColor, dividerColor, actionColor, scrollbarColor, scrollbarColorHover, invertedColor } = vars;
      return {
          textColor: textColor2,
          textColorInverted: '#FFF',
          color: bodyColor,
          colorEmbedded: actionColor,
          headerColor: cardColor,
          headerColorInverted: invertedColor,
          footerColor: actionColor,
          footerColorInverted: invertedColor,
          headerBorderColor: dividerColor,
          headerBorderColorInverted: invertedColor,
          footerBorderColor: dividerColor,
          footerBorderColorInverted: invertedColor,
          siderBorderColor: dividerColor,
          siderBorderColorInverted: invertedColor,
          siderColor: cardColor,
          siderColorInverted: invertedColor,
          siderToggleButtonBorder: `1px solid ${dividerColor}`,
          siderToggleButtonColor: baseColor,
          siderToggleButtonIconColor: textColor2,
          siderToggleButtonIconColorInverted: textColor2,
          siderToggleBarColor: composite(bodyColor, scrollbarColor),
          siderToggleBarColorHover: composite(bodyColor, scrollbarColorHover),
          // hack for inverted background
          __invertScrollbar: 'true'
      };
  };
  const layoutLight = createTheme({
      name: 'Layout',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1
      },
      self: self$t
  });
  var layoutLight$1 = layoutLight;

  const self$s = (vars) => {
      const { textColor2, cardColor, modalColor, popoverColor, dividerColor, borderRadius, fontSize, hoverColor } = vars;
      return {
          textColor: textColor2,
          color: cardColor,
          colorHover: hoverColor,
          colorModal: modalColor,
          colorHoverModal: composite(modalColor, hoverColor),
          colorPopover: popoverColor,
          colorHoverPopover: composite(popoverColor, hoverColor),
          borderColor: dividerColor,
          borderColorModal: composite(modalColor, dividerColor),
          borderColorPopover: composite(popoverColor, dividerColor),
          borderRadius,
          fontSize
      };
  };
  const listLight = {
      name: 'List',
      common: commonLight,
      self: self$s
  };
  var listLight$1 = listLight;

  const self$r = (vars) => {
      const { primaryColor, errorColor } = vars;
      return {
          colorError: errorColor,
          colorLoading: primaryColor,
          height: '2px'
      };
  };
  const loadingBarLight = {
      name: 'LoadingBar',
      common: commonLight,
      self: self$r
  };
  var loadingBarLight$1 = loadingBarLight;

  const self$q = (vars) => {
      const { textColor2, modalColor, borderColor, fontSize, primaryColor } = vars;
      return {
          loaderFontSize: fontSize,
          loaderTextColor: textColor2,
          loaderColor: modalColor,
          loaderBorder: `1px solid ${borderColor}`,
          loadingColor: primaryColor
      };
  };
  const logLight = createTheme({
      name: 'Log',
      common: commonLight,
      peers: {
          Scrollbar: scrollbarLight$1,
          Code: codeLight$1
      },
      self: self$q
  });
  var logLight$1 = logLight;

  const self$p = (vars) => {
      const { boxShadow2 } = vars;
      return {
          menuBoxShadow: boxShadow2
      };
  };
  const mentionLight = createTheme({
      name: 'Mention',
      common: commonLight,
      peers: {
          InternalSelectMenu: internalSelectMenuLight$1,
          Input: inputLight$1
      },
      self: self$p
  });
  var mentionLight$1 = mentionLight;

  function createPartialInvertedVars(color, activeItemColor, activeTextColor, groupTextColor) {
      return {
          itemColorHoverInverted: '#0000',
          itemColorActiveInverted: activeItemColor,
          itemColorActiveHoverInverted: activeItemColor,
          itemColorActiveCollapsedInverted: activeItemColor,
          itemTextColorInverted: color,
          itemTextColorHoverInverted: activeTextColor,
          itemTextColorChildActiveInverted: activeTextColor,
          itemTextColorChildActiveHoverInverted: activeTextColor,
          itemTextColorActiveInverted: activeTextColor,
          itemTextColorActiveHoverInverted: activeTextColor,
          itemTextColorHorizontalInverted: color,
          itemTextColorHoverHorizontalInverted: activeTextColor,
          itemTextColorChildActiveHorizontalInverted: activeTextColor,
          itemTextColorChildActiveHoverHorizontalInverted: activeTextColor,
          itemTextColorActiveHorizontalInverted: activeTextColor,
          itemTextColorActiveHoverHorizontalInverted: activeTextColor,
          itemIconColorInverted: color,
          itemIconColorHoverInverted: activeTextColor,
          itemIconColorActiveInverted: activeTextColor,
          itemIconColorActiveHoverInverted: activeTextColor,
          itemIconColorChildActiveInverted: activeTextColor,
          itemIconColorChildActiveHoverInverted: activeTextColor,
          itemIconColorCollapsedInverted: color,
          itemIconColorHorizontalInverted: color,
          itemIconColorHoverHorizontalInverted: activeTextColor,
          itemIconColorActiveHorizontalInverted: activeTextColor,
          itemIconColorActiveHoverHorizontalInverted: activeTextColor,
          itemIconColorChildActiveHorizontalInverted: activeTextColor,
          itemIconColorChildActiveHoverHorizontalInverted: activeTextColor,
          arrowColorInverted: color,
          arrowColorHoverInverted: activeTextColor,
          arrowColorActiveInverted: activeTextColor,
          arrowColorActiveHoverInverted: activeTextColor,
          arrowColorChildActiveInverted: activeTextColor,
          arrowColorChildActiveHoverInverted: activeTextColor,
          groupTextColorInverted: groupTextColor
      };
  }
  const self$o = (vars) => {
      const { borderRadius, textColor3, primaryColor, textColor2, textColor1, fontSize, dividerColor, hoverColor, primaryColorHover } = vars;
      return Object.assign({ borderRadius, color: '#0000', groupTextColor: textColor3, itemColorHover: hoverColor, itemColorActive: changeColor(primaryColor, { alpha: 0.1 }), itemColorActiveHover: changeColor(primaryColor, { alpha: 0.1 }), itemColorActiveCollapsed: changeColor(primaryColor, { alpha: 0.1 }), itemTextColor: textColor2, itemTextColorHover: textColor2, itemTextColorActive: primaryColor, itemTextColorActiveHover: primaryColor, itemTextColorChildActive: primaryColor, itemTextColorChildActiveHover: primaryColor, itemTextColorHorizontal: textColor2, itemTextColorHoverHorizontal: primaryColorHover, itemTextColorActiveHorizontal: primaryColor, itemTextColorActiveHoverHorizontal: primaryColor, itemTextColorChildActiveHorizontal: primaryColor, itemTextColorChildActiveHoverHorizontal: primaryColor, itemIconColor: textColor1, itemIconColorHover: textColor1, itemIconColorActive: primaryColor, itemIconColorActiveHover: primaryColor, itemIconColorChildActive: primaryColor, itemIconColorChildActiveHover: primaryColor, itemIconColorCollapsed: textColor1, itemIconColorHorizontal: textColor1, itemIconColorHoverHorizontal: primaryColorHover, itemIconColorActiveHorizontal: primaryColor, itemIconColorActiveHoverHorizontal: primaryColor, itemIconColorChildActiveHorizontal: primaryColor, itemIconColorChildActiveHoverHorizontal: primaryColor, itemHeight: '42px', arrowColor: textColor2, arrowColorHover: textColor2, arrowColorActive: primaryColor, arrowColorActiveHover: primaryColor, arrowColorChildActive: primaryColor, arrowColorChildActiveHover: primaryColor, colorInverted: '#0000', borderColorHorizontal: '#0000', fontSize,
          dividerColor }, createPartialInvertedVars('#BBB', primaryColor, '#FFF', '#AAA'));
  };
  const menuLight = createTheme({
      name: 'Menu',
      common: commonLight,
      peers: {
          Tooltip: tooltipLight$1,
          Dropdown: dropdownLight$1
      },
      self: self$o
  });
  var menuLight$1 = menuLight;

  var common = {
      titleFontSize: '18px',
      backSize: '22px'
  };

  function self$n(vars) {
      const { textColor1, textColor2, textColor3, fontSize, fontWeightStrong, primaryColorHover, primaryColorPressed } = vars;
      return Object.assign(Object.assign({}, common), { titleFontWeight: fontWeightStrong, fontSize, titleTextColor: textColor1, backColor: textColor2, backColorHover: primaryColorHover, backColorPressed: primaryColorPressed, subtitleTextColor: textColor3 });
  }
  const pageHeaderLight = createTheme({
      name: 'PageHeader',
      common: commonLight,
      self: self$n
  });

  var commonVars$2 = {
      iconSize: '22px'
  };

  const self$m = (vars) => {
      const { fontSize, warningColor } = vars;
      return Object.assign(Object.assign({}, commonVars$2), { fontSize, iconColor: warningColor });
  };
  const popconfirmLight = createTheme({
      name: 'Popconfirm',
      common: commonLight,
      peers: {
          Button: buttonLight$1,
          Popover: popoverLight$1
      },
      self: self$m
  });
  var popconfirmLight$1 = popconfirmLight;

  const self$l = (vars) => {
      const { infoColor, successColor, warningColor, errorColor, textColor2, progressRailColor, fontSize, fontWeight } = vars;
      return {
          fontSize,
          fontSizeCircle: '28px',
          fontWeightCircle: fontWeight,
          railColor: progressRailColor,
          railHeight: '8px',
          iconSizeCircle: '36px',
          iconSizeLine: '18px',
          iconColor: infoColor,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          textColorCircle: textColor2,
          textColorLineInner: 'rgb(255, 255, 255)',
          textColorLineOuter: textColor2,
          fillColor: infoColor,
          fillColorInfo: infoColor,
          fillColorSuccess: successColor,
          fillColorWarning: warningColor,
          fillColorError: errorColor,
          lineBgProcessing: 'linear-gradient(90deg, rgba(255, 255, 255, .3) 0%, rgba(255, 255, 255, .5) 100%)'
      };
  };
  const progressLight = {
      name: 'Progress',
      common: commonLight,
      self: self$l
  };
  var progressLight$1 = progressLight;

  const self$k = (vars) => {
      const { railColor } = vars;
      return {
          itemColor: railColor,
          itemColorActive: '#FFCC33',
          sizeSmall: '16px',
          sizeMedium: '20px',
          sizeLarge: '24px'
      };
  };
  const themeLight$2 = {
      name: 'Rate',
      common: commonLight,
      self: self$k
  };
  var rateLight = themeLight$2;

  var commonVariables$3 = {
      titleFontSizeSmall: '26px',
      titleFontSizeMedium: '32px',
      titleFontSizeLarge: '40px',
      titleFontSizeHuge: '48px',
      fontSizeSmall: '14px',
      fontSizeMedium: '14px',
      fontSizeLarge: '15px',
      fontSizeHuge: '16px',
      iconSizeSmall: '64px',
      iconSizeMedium: '80px',
      iconSizeLarge: '100px',
      iconSizeHuge: '125px',
      iconColor418: undefined,
      iconColor404: undefined,
      iconColor403: undefined,
      iconColor500: undefined
  };

  const self$j = (vars) => {
      const { textColor2, textColor1, errorColor, successColor, infoColor, warningColor, lineHeight, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, commonVariables$3), { lineHeight, titleFontWeight: fontWeightStrong, titleTextColor: textColor1, textColor: textColor2, iconColorError: errorColor, iconColorSuccess: successColor, iconColorInfo: infoColor, iconColorWarning: warningColor });
  };
  const resultLight = {
      name: 'Result',
      common: commonLight,
      self: self$j
  };
  var resultLight$1 = resultLight;

  var sizeVariables$3 = {
      railHeight: '4px',
      railWidthVertical: '4px',
      handleSize: '18px',
      dotHeight: '8px',
      dotWidth: '8px',
      dotBorderRadius: '4px'
  };

  const self$i = (vars) => {
      const indicatorColor = 'rgba(0, 0, 0, .85)';
      const boxShadow = '0 2px 8px 0 rgba(0, 0, 0, 0.12)';
      const { railColor, primaryColor, baseColor, cardColor, modalColor, popoverColor, borderRadius, fontSize, opacityDisabled } = vars;
      return Object.assign(Object.assign({}, sizeVariables$3), { fontSize, markFontSize: fontSize, railColor, railColorHover: railColor, fillColor: primaryColor, fillColorHover: primaryColor, opacityDisabled, handleColor: '#FFF', dotColor: cardColor, dotColorModal: modalColor, dotColorPopover: popoverColor, handleBoxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', handleBoxShadowHover: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', handleBoxShadowActive: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', handleBoxShadowFocus: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', indicatorColor, indicatorBoxShadow: boxShadow, indicatorTextColor: baseColor, indicatorBorderRadius: borderRadius, dotBorder: `2px solid ${railColor}`, dotBorderActive: `2px solid ${primaryColor}`, dotBoxShadow: '' });
  };
  const sliderLight = {
      name: 'Slider',
      common: commonLight,
      self: self$i
  };
  var sliderLight$1 = sliderLight;

  const self$h = (vars) => {
      const { opacityDisabled, heightTiny, heightSmall, heightMedium, heightLarge, heightHuge, primaryColor, fontSize } = vars;
      return {
          fontSize,
          textColor: primaryColor,
          sizeTiny: heightTiny,
          sizeSmall: heightSmall,
          sizeMedium: heightMedium,
          sizeLarge: heightLarge,
          sizeHuge: heightHuge,
          color: primaryColor,
          opacitySpinning: opacityDisabled
      };
  };
  const spinLight = {
      name: 'Spin',
      common: commonLight,
      self: self$h
  };
  var spinLight$1 = spinLight;

  const self$g = (vars) => {
      const { textColor2, textColor3, fontSize, fontWeight } = vars;
      return {
          labelFontSize: fontSize,
          labelFontWeight: fontWeight,
          valueFontWeight: fontWeight,
          valueFontSize: '24px',
          labelTextColor: textColor3,
          valuePrefixTextColor: textColor2,
          valueSuffixTextColor: textColor2,
          valueTextColor: textColor2
      };
  };
  const statisticLight = {
      name: 'Statistic',
      common: commonLight,
      self: self$g
  };
  var statisticLight$1 = statisticLight;

  var commonVariables$2 = {
      stepHeaderFontSizeSmall: '14px',
      stepHeaderFontSizeMedium: '16px',
      indicatorIndexFontSizeSmall: '14px',
      indicatorIndexFontSizeMedium: '16px',
      indicatorSizeSmall: '22px',
      indicatorSizeMedium: '28px',
      indicatorIconSizeSmall: '14px',
      indicatorIconSizeMedium: '18px'
  };

  const self$f = (vars) => {
      const { fontWeightStrong, baseColor, textColorDisabled, primaryColor, errorColor, textColor1, textColor2 } = vars;
      return Object.assign(Object.assign({}, commonVariables$2), { stepHeaderFontWeight: fontWeightStrong, indicatorTextColorProcess: baseColor, indicatorTextColorWait: textColorDisabled, indicatorTextColorFinish: primaryColor, indicatorTextColorError: errorColor, indicatorBorderColorProcess: primaryColor, indicatorBorderColorWait: textColorDisabled, indicatorBorderColorFinish: primaryColor, indicatorBorderColorError: errorColor, indicatorColorProcess: primaryColor, indicatorColorWait: '#0000', indicatorColorFinish: '#0000', indicatorColorError: '#0000', splitorColorProcess: textColorDisabled, splitorColorWait: textColorDisabled, splitorColorFinish: primaryColor, splitorColorError: textColorDisabled, headerTextColorProcess: textColor1, headerTextColorWait: textColorDisabled, headerTextColorFinish: textColorDisabled, headerTextColorError: errorColor, descriptionTextColorProcess: textColor2, descriptionTextColorWait: textColorDisabled, descriptionTextColorFinish: textColorDisabled, descriptionTextColorError: errorColor });
  };
  const stepsLight = {
      name: 'Steps',
      common: commonLight,
      self: self$f
  };
  var stepsLight$1 = stepsLight;

  var commonVars$1 = {
      buttonHeightSmall: '14px',
      buttonHeightMedium: '18px',
      buttonHeightLarge: '22px',
      buttonWidthSmall: '14px',
      buttonWidthMedium: '18px',
      buttonWidthLarge: '22px',
      buttonWidthPressedSmall: '20px',
      buttonWidthPressedMedium: '24px',
      buttonWidthPressedLarge: '28px',
      railHeightSmall: '18px',
      railHeightMedium: '22px',
      railHeightLarge: '26px',
      railWidthSmall: '32px',
      railWidthMedium: '40px',
      railWidthLarge: '48px'
  };

  const self$e = (vars) => {
      const { primaryColor, opacityDisabled, borderRadius, textColor3 } = vars;
      const railOverlayColor = 'rgba(0, 0, 0, .14)';
      return Object.assign(Object.assign({}, commonVars$1), { iconColor: textColor3, textColor: 'white', loadingColor: primaryColor, opacityDisabled, railColor: railOverlayColor, railColorActive: primaryColor, buttonBoxShadow: '0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)', buttonColor: '#FFF', railBorderRadiusSmall: borderRadius, railBorderRadiusMedium: borderRadius, railBorderRadiusLarge: borderRadius, buttonBorderRadiusSmall: borderRadius, buttonBorderRadiusMedium: borderRadius, buttonBorderRadiusLarge: borderRadius, boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, { alpha: 0.2 })}` });
  };
  const switchLight = {
      name: 'Switch',
      common: commonLight,
      self: self$e
  };
  var switchLight$1 = switchLight;

  var sizeVariables$2 = {
      thPaddingSmall: '6px',
      thPaddingMedium: '12px',
      thPaddingLarge: '12px',
      tdPaddingSmall: '6px',
      tdPaddingMedium: '12px',
      tdPaddingLarge: '12px'
  };

  const self$d = (vars) => {
      const { dividerColor, cardColor, modalColor, popoverColor, tableHeaderColor, tableColorStriped, textColor1, textColor2, borderRadius, fontWeightStrong, lineHeight, fontSizeSmall, fontSizeMedium, fontSizeLarge } = vars;
      return Object.assign(Object.assign({}, sizeVariables$2), { fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight,
          borderRadius, borderColor: composite(cardColor, dividerColor), borderColorModal: composite(modalColor, dividerColor), borderColorPopover: composite(popoverColor, dividerColor), tdColor: cardColor, tdColorModal: modalColor, tdColorPopover: popoverColor, tdColorStriped: composite(cardColor, tableColorStriped), tdColorStripedModal: composite(modalColor, tableColorStriped), tdColorStripedPopover: composite(popoverColor, tableColorStriped), thColor: composite(cardColor, tableHeaderColor), thColorModal: composite(modalColor, tableHeaderColor), thColorPopover: composite(popoverColor, tableHeaderColor), thTextColor: textColor1, tdTextColor: textColor2, thFontWeight: fontWeightStrong });
  };
  const tableLight = {
      name: 'Table',
      common: commonLight,
      self: self$d
  };
  var tableLight$1 = tableLight;

  var sizeVariables$1 = {
      tabFontSizeSmall: '14px',
      tabFontSizeMedium: '14px',
      tabFontSizeLarge: '16px',
      tabGapSmallLine: '36px',
      tabGapMediumLine: '36px',
      tabGapLargeLine: '36px',
      tabGapSmallLineVertical: '8px',
      tabGapMediumLineVertical: '8px',
      tabGapLargeLineVertical: '8px',
      tabPaddingSmallLine: '6px 0',
      tabPaddingMediumLine: '10px 0',
      tabPaddingLargeLine: '14px 0',
      tabPaddingVerticalSmallLine: '6px 12px',
      tabPaddingVerticalMediumLine: '8px 16px',
      tabPaddingVerticalLargeLine: '10px 20px',
      tabGapSmallBar: '36px',
      tabGapMediumBar: '36px',
      tabGapLargeBar: '36px',
      tabGapSmallBarVertical: '8px',
      tabGapMediumBarVertical: '8px',
      tabGapLargeBarVertical: '8px',
      tabPaddingSmallBar: '4px 0',
      tabPaddingMediumBar: '6px 0',
      tabPaddingLargeBar: '10px 0',
      tabPaddingVerticalSmallBar: '6px 12px',
      tabPaddingVerticalMediumBar: '8px 16px',
      tabPaddingVerticalLargeBar: '10px 20px',
      tabGapSmallCard: '4px',
      tabGapMediumCard: '4px',
      tabGapLargeCard: '4px',
      tabGapSmallCardVertical: '4px',
      tabGapMediumCardVertical: '4px',
      tabGapLargeCardVertical: '4px',
      tabPaddingSmallCard: '8px 16px',
      tabPaddingMediumCard: '10px 20px',
      tabPaddingLargeCard: '12px 24px',
      tabPaddingSmallSegment: '4px 0',
      tabPaddingMediumSegment: '6px 0',
      tabPaddingLargeSegment: '8px 0',
      tabPaddingVerticalLargeSegment: '0 8px',
      tabPaddingVerticalSmallCard: '8px 12px',
      tabPaddingVerticalMediumCard: '10px 16px',
      tabPaddingVerticalLargeCard: '12px 20px',
      tabPaddingVerticalSmallSegment: '0 4px',
      tabPaddingVerticalMediumSegment: '0 6px',
      tabGapSmallSegment: '0',
      tabGapMediumSegment: '0',
      tabGapLargeSegment: '0',
      tabGapSmallSegmentVertical: '0',
      tabGapMediumSegmentVertical: '0',
      tabGapLargeSegmentVertical: '0',
      panePaddingSmall: '8px 0 0 0',
      panePaddingMedium: '12px 0 0 0',
      panePaddingLarge: '16px 0 0 0',
      closeSize: '18px',
      closeIconSize: '14px'
  };

  const self$c = (vars) => {
      const { textColor2, primaryColor, textColorDisabled, closeIconColor, closeIconColorHover, closeIconColorPressed, closeColorHover, closeColorPressed, tabColor, baseColor, dividerColor, fontWeight, textColor1, borderRadius, fontSize, fontWeightStrong } = vars;
      return Object.assign(Object.assign({}, sizeVariables$1), { colorSegment: tabColor, tabFontSizeCard: fontSize, tabTextColorLine: textColor1, tabTextColorActiveLine: primaryColor, tabTextColorHoverLine: primaryColor, tabTextColorDisabledLine: textColorDisabled, tabTextColorSegment: textColor1, tabTextColorActiveSegment: textColor2, tabTextColorHoverSegment: textColor2, tabTextColorDisabledSegment: textColorDisabled, tabTextColorBar: textColor1, tabTextColorActiveBar: primaryColor, tabTextColorHoverBar: primaryColor, tabTextColorDisabledBar: textColorDisabled, tabTextColorCard: textColor1, tabTextColorHoverCard: textColor1, tabTextColorActiveCard: primaryColor, tabTextColorDisabledCard: textColorDisabled, barColor: primaryColor, closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed, closeBorderRadius: borderRadius, tabColor, tabColorSegment: baseColor, tabBorderColor: dividerColor, tabFontWeightActive: fontWeight, tabFontWeight: fontWeight, tabBorderRadius: borderRadius, paneTextColor: textColor2, fontWeightStrong });
  };
  const tabsLight = {
      name: 'Tabs',
      common: commonLight,
      self: self$c
  };
  var tabsLight$1 = tabsLight;

  const self$b = (vars) => {
      const { textColor1, textColor2, fontWeightStrong, fontSize } = vars;
      return {
          fontSize,
          titleTextColor: textColor1,
          textColor: textColor2,
          titleFontWeight: fontWeightStrong
      };
  };
  const thingLight = {
      name: 'Thing',
      common: commonLight,
      self: self$b
  };
  var thingLight$1 = thingLight;

  var sizeVariables = {
      titleMarginMedium: '0 0 6px 0',
      titleMarginLarge: '-2px 0 6px 0',
      titleFontSizeMedium: '14px',
      titleFontSizeLarge: '16px',
      iconSizeMedium: '14px',
      iconSizeLarge: '14px'
  };

  const self$a = (vars) => {
      const { textColor3, infoColor, errorColor, successColor, warningColor, textColor1, textColor2, railColor, fontWeightStrong, fontSize } = vars;
      return Object.assign(Object.assign({}, sizeVariables), { contentFontSize: fontSize, titleFontWeight: fontWeightStrong, circleBorder: `2px solid ${textColor3}`, circleBorderInfo: `2px solid ${infoColor}`, circleBorderError: `2px solid ${errorColor}`, circleBorderSuccess: `2px solid ${successColor}`, circleBorderWarning: `2px solid ${warningColor}`, iconColor: textColor3, iconColorInfo: infoColor, iconColorError: errorColor, iconColorSuccess: successColor, iconColorWarning: warningColor, titleTextColor: textColor1, contentTextColor: textColor2, metaTextColor: textColor3, lineColor: railColor });
  };
  const timelineLight = {
      name: 'Timeline',
      common: commonLight,
      self: self$a
  };
  var timelineLight$1 = timelineLight;

  var commonVariables$1 = {
      extraFontSizeSmall: '12px',
      extraFontSizeMedium: '12px',
      extraFontSizeLarge: '14px',
      titleFontSizeSmall: '14px',
      titleFontSizeMedium: '16px',
      titleFontSizeLarge: '16px',
      closeSize: '20px',
      closeIconSize: '16px',
      headerHeightSmall: '44px',
      headerHeightMedium: '44px',
      headerHeightLarge: '50px'
  };

  const self$9 = (vars) => {
      const { fontWeight, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, textColor3, borderColor, hoverColor, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed } = vars;
      return Object.assign(Object.assign({}, commonVariables$1), { itemHeightSmall: heightMedium, itemHeightMedium: heightMedium, itemHeightLarge: heightLarge, fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius, dividerColor: borderColor, borderColor, listColor: cardColor, headerColor: composite(cardColor, tableHeaderColor), titleTextColor: textColor1, titleTextColorDisabled: textColorDisabled, extraTextColor: textColor3, extraTextColorDisabled: textColorDisabled, itemTextColor: textColor2, itemTextColorDisabled: textColorDisabled, itemColorPending: hoverColor, titleFontWeight: fontWeight, closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed });
  };
  const transferLight$1 = createTheme({
      name: 'Transfer',
      common: commonLight,
      peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Input: inputLight$1,
          Empty: emptyLight$1,
          Button: buttonLight$1
      },
      self: self$9
  });
  var transferLight$2 = transferLight$1;

  const self$8 = (vars) => {
      const { borderRadiusSmall, dividerColor, hoverColor, pressedColor, primaryColor, textColor3, textColor2, textColorDisabled, fontSize } = vars;
      return {
          fontSize,
          lineHeight: '1.5',
          nodeHeight: '30px',
          nodeWrapperPadding: '3px 0',
          nodeBorderRadius: borderRadiusSmall,
          nodeColorHover: hoverColor,
          nodeColorPressed: pressedColor,
          nodeColorActive: changeColor(primaryColor, { alpha: 0.1 }),
          arrowColor: textColor3,
          nodeTextColor: textColor2,
          nodeTextColorDisabled: textColorDisabled,
          loadingColor: primaryColor,
          dropMarkColor: primaryColor,
          lineColor: dividerColor
      };
  };
  const treeLight = createTheme({
      name: 'Tree',
      common: commonLight,
      peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Empty: emptyLight$1
      },
      self: self$8
  });
  var treeLight$1 = treeLight;

  const self$7 = (vars) => {
      const { popoverColor, boxShadow2, borderRadius, heightMedium, dividerColor, textColor2 } = vars;
      return {
          menuPadding: '4px',
          menuColor: popoverColor,
          menuBoxShadow: boxShadow2,
          menuBorderRadius: borderRadius,
          menuHeight: `calc(${heightMedium} * 7.6)`,
          actionDividerColor: dividerColor,
          actionTextColor: textColor2,
          actionPadding: '8px 12px'
      };
  };
  const treeSelectLight = createTheme({
      name: 'TreeSelect',
      common: commonLight,
      peers: {
          Tree: treeLight$1,
          Empty: emptyLight$1,
          InternalSelection: internalSelectionLight$1
      },
      self: self$7
  });
  var treeSelectLight$1 = treeSelectLight;

  var commonVars = {
      headerFontSize1: '30px',
      headerFontSize2: '22px',
      headerFontSize3: '18px',
      headerFontSize4: '16px',
      headerFontSize5: '16px',
      headerFontSize6: '16px',
      headerMargin1: '28px 0 20px 0',
      headerMargin2: '28px 0 20px 0',
      headerMargin3: '28px 0 20px 0',
      headerMargin4: '28px 0 18px 0',
      headerMargin5: '28px 0 18px 0',
      headerMargin6: '28px 0 18px 0',
      headerPrefixWidth1: '16px',
      headerPrefixWidth2: '16px',
      headerPrefixWidth3: '12px',
      headerPrefixWidth4: '12px',
      headerPrefixWidth5: '12px',
      headerPrefixWidth6: '12px',
      headerBarWidth1: '4px',
      headerBarWidth2: '4px',
      headerBarWidth3: '3px',
      headerBarWidth4: '3px',
      headerBarWidth5: '3px',
      headerBarWidth6: '3px',
      pMargin: '16px 0 16px 0',
      liMargin: '.25em 0 0 0',
      olPadding: '0 0 0 2em',
      ulPadding: '0 0 0 2em'
  };

  const self$6 = (vars) => {
      const { primaryColor, textColor2, borderColor, lineHeight, fontSize, borderRadiusSmall, dividerColor, fontWeightStrong, textColor1, textColor3, infoColor, warningColor, errorColor, successColor, codeColor } = vars;
      return Object.assign(Object.assign({}, commonVars), { aTextColor: primaryColor, blockquoteTextColor: textColor2, blockquotePrefixColor: borderColor, blockquoteLineHeight: lineHeight, blockquoteFontSize: fontSize, codeBorderRadius: borderRadiusSmall, liTextColor: textColor2, liLineHeight: lineHeight, liFontSize: fontSize, hrColor: dividerColor, headerFontWeight: fontWeightStrong, headerTextColor: textColor1, pTextColor: textColor2, pTextColor1Depth: textColor1, pTextColor2Depth: textColor2, pTextColor3Depth: textColor3, pLineHeight: lineHeight, pFontSize: fontSize, headerBarColor: primaryColor, headerBarColorPrimary: primaryColor, headerBarColorInfo: infoColor, headerBarColorError: errorColor, headerBarColorWarning: warningColor, headerBarColorSuccess: successColor, textColor: textColor2, textColor1Depth: textColor1, textColor2Depth: textColor2, textColor3Depth: textColor3, textColorPrimary: primaryColor, textColorInfo: infoColor, textColorSuccess: successColor, textColorWarning: warningColor, textColorError: errorColor, codeTextColor: textColor2, codeColor, codeBorder: '1px solid #0000' });
  };
  const typographyLight = {
      name: 'Typography',
      common: commonLight,
      self: self$6
  };
  var typographyLight$1 = typographyLight;

  const self$5 = (vars) => {
      const { iconColor, primaryColor, errorColor, textColor2, successColor, opacityDisabled, actionColor, borderColor, hoverColor, lineHeight, borderRadius, fontSize } = vars;
      return {
          fontSize,
          lineHeight,
          borderRadius,
          draggerColor: actionColor,
          draggerBorder: `1px dashed ${borderColor}`,
          draggerBorderHover: `1px dashed ${primaryColor}`,
          itemColorHover: hoverColor,
          itemColorHoverError: changeColor(errorColor, {
              alpha: 0.06
          }),
          itemTextColor: textColor2,
          itemTextColorError: errorColor,
          itemTextColorSuccess: successColor,
          itemIconColor: iconColor,
          itemDisabledOpacity: opacityDisabled,
          itemBorderImageCardError: `1px solid ${errorColor}`,
          itemBorderImageCard: `1px solid ${borderColor}`
      };
  };
  const uploadLight = createTheme({
      name: 'Upload',
      common: commonLight,
      peers: {
          Button: buttonLight$1,
          Progress: progressLight$1
      },
      self: self$5
  });
  var uploadLight$1 = uploadLight;

  const watermarkLight = createTheme({
      name: 'Watermark',
      common: commonLight,
      self(vars) {
          const { fontFamily } = vars;
          return {
              fontFamily
          };
      }
  });
  var watermarkLight$1 = watermarkLight;

  const prevIcon = (h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M6 5C5.75454 5 5.55039 5.17688 5.50806 5.41012L5.5 5.5V14.5C5.5 14.7761 5.72386 15 6 15C6.24546 15 6.44961 14.8231 6.49194 14.5899L6.5 14.5V5.5C6.5 5.22386 6.27614 5 6 5ZM13.8536 5.14645C13.68 4.97288 13.4106 4.9536 13.2157 5.08859L13.1464 5.14645L8.64645 9.64645C8.47288 9.82001 8.4536 10.0894 8.58859 10.2843L8.64645 10.3536L13.1464 14.8536C13.3417 15.0488 13.6583 15.0488 13.8536 14.8536C14.0271 14.68 14.0464 14.4106 13.9114 14.2157L13.8536 14.1464L9.70711 10L13.8536 5.85355C14.0488 5.65829 14.0488 5.34171 13.8536 5.14645Z", fill: "currentColor" })));
  const nextIcon = (h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M13.5 5C13.7455 5 13.9496 5.17688 13.9919 5.41012L14 5.5V14.5C14 14.7761 13.7761 15 13.5 15C13.2545 15 13.0504 14.8231 13.0081 14.5899L13 14.5V5.5C13 5.22386 13.2239 5 13.5 5ZM5.64645 5.14645C5.82001 4.97288 6.08944 4.9536 6.28431 5.08859L6.35355 5.14645L10.8536 9.64645C11.0271 9.82001 11.0464 10.0894 10.9114 10.2843L10.8536 10.3536L6.35355 14.8536C6.15829 15.0488 5.84171 15.0488 5.64645 14.8536C5.47288 14.68 5.4536 14.4106 5.58859 14.2157L5.64645 14.1464L9.79289 10L5.64645 5.85355C5.45118 5.65829 5.45118 5.34171 5.64645 5.14645Z", fill: "currentColor" })));
  const closeIcon = (h("svg", { viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
      h("path", { d: "M4.089 4.216l.057-.07a.5.5 0 0 1 .638-.057l.07.057L10 9.293l5.146-5.147a.5.5 0 0 1 .638-.057l.07.057a.5.5 0 0 1 .057.638l-.057.07L10.707 10l5.147 5.146a.5.5 0 0 1 .057.638l-.057.07a.5.5 0 0 1-.638.057l-.07-.057L10 10.707l-5.146 5.147a.5.5 0 0 1-.638.057l-.07-.057a.5.5 0 0 1-.057-.638l.057-.07L9.293 10L4.146 4.854a.5.5 0 0 1-.057-.638l.057-.07l-.057.07z", fill: "currentColor" })));
  const downloadIcon = (h("svg", { xmlns: "http://www.w3.org/2000/svg", width: "32", height: "32", viewBox: "0 0 1024 1024" },
      h("path", { fill: "currentColor", d: "M505.7 661a8 8 0 0 0 12.6 0l112-141.7c4.1-5.2.4-12.9-6.3-12.9h-74.1V168c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v338.3H400c-6.7 0-10.4 7.7-6.3 12.9l112 141.8zM878 626h-60c-4.4 0-8 3.6-8 8v154H214V634c0-4.4-3.6-8-8-8h-60c-4.4 0-8 3.6-8 8v198c0 17.7 14.3 32 32 32h684c17.7 0 32-14.3 32-32V634c0-4.4-3.6-8-8-8z" })));

  // vars:
  // --n-toolbar-icon-color
  // --n-toolbar-color
  // --n-toolbar-border-radius
  // --n-toolbar-box-shadow
  // --n-bezier
  var style$G = c$1([c$1('body >', [cB('image-container', 'position: fixed;')]), cB('image-preview-container', `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 `), cB('image-preview-overlay', `
 z-index: -1;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background: rgba(0, 0, 0, .3);
 `, [fadeInTransition()]), cB('image-preview-toolbar', `
 z-index: 1;
 position: absolute;
 left: 50%;
 transform: translateX(-50%);
 border-radius: var(--n-toolbar-border-radius);
 height: 48px;
 bottom: 40px;
 padding: 0 12px;
 background: var(--n-toolbar-color);
 box-shadow: var(--n-toolbar-box-shadow);
 color: var(--n-toolbar-icon-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB('base-icon', `
 padding: 0 8px;
 font-size: 28px;
 cursor: pointer;
 `), fadeInTransition()]), cB('image-preview-wrapper', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 pointer-events: none;
 `, [fadeInScaleUpTransition()]), cB('image-preview', `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: all;
 margin: auto;
 max-height: calc(100vh - 32px);
 max-width: calc(100vw - 32px);
 transition: transform .3s var(--n-bezier);
 `), cB('image', `
 display: inline-flex;
 max-height: 100%;
 max-width: 100%;
 `, [cNotM('preview-disabled', `
 cursor: pointer;
 `), c$1('img', `
 border-radius: inherit;
 `)])]);

  const BLEEDING = 32;
  var NImagePreview = defineComponent({
      name: 'ImagePreview',
      props: Object.assign(Object.assign({}, imagePreviewSharedProps), { onNext: Function, onPrev: Function, clsPrefix: {
              type: String,
              required: true
          } }),
      setup(props) {
          const themeRef = useTheme('Image', '-image', style$G, imageLight, props, toRef(props, 'clsPrefix'));
          let thumbnailEl = null;
          const previewRef = ref(null);
          const previewWrapperRef = ref(null);
          const previewSrcRef = ref(undefined);
          const showRef = ref(false);
          const displayedRef = ref(false);
          const { localeRef } = useLocale('Image');
          function syncTransformOrigin() {
              const { value: previewWrapper } = previewWrapperRef;
              if (!thumbnailEl || !previewWrapper)
                  return;
              const { style } = previewWrapper;
              const tbox = thumbnailEl.getBoundingClientRect();
              const tx = tbox.left + tbox.width / 2;
              const ty = tbox.top + tbox.height / 2;
              style.transformOrigin = `${tx}px ${ty}px`;
          }
          function handleKeydown(e) {
              var _a, _b;
              switch (e.key) {
                  case ' ':
                      e.preventDefault();
                      break;
                  case 'ArrowLeft':
                      (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
                      break;
                  case 'ArrowRight':
                      (_b = props.onNext) === null || _b === void 0 ? void 0 : _b.call(props);
                      break;
                  case 'Escape':
                      toggleShow();
                      break;
              }
          }
          watch(showRef, (value) => {
              if (value) {
                  on('keydown', document, handleKeydown);
              }
              else
                  off('keydown', document, handleKeydown);
          });
          onBeforeUnmount(() => {
              off('keydown', document, handleKeydown);
          });
          let startX = 0;
          let startY = 0;
          let offsetX = 0;
          let offsetY = 0;
          let startOffsetX = 0;
          let startOffsetY = 0;
          let mouseDownClientX = 0;
          let mouseDownClientY = 0;
          let dragging = false;
          function handleMouseMove(e) {
              const { clientX, clientY } = e;
              offsetX = clientX - startX;
              offsetY = clientY - startY;
              beforeNextFrameOnce(derivePreviewStyle);
          }
          function getMoveStrategy(opts) {
              const { mouseUpClientX, mouseUpClientY, mouseDownClientX, mouseDownClientY } = opts;
              const deltaHorizontal = mouseDownClientX - mouseUpClientX;
              const deltaVertical = mouseDownClientY - mouseUpClientY;
              const moveVerticalDirection = `vertical${deltaVertical > 0 ? 'Top' : 'Bottom'}`;
              const moveHorizontalDirection = `horizontal${deltaHorizontal > 0 ? 'Left' : 'Right'}`;
              return {
                  moveVerticalDirection,
                  moveHorizontalDirection,
                  deltaHorizontal,
                  deltaVertical
              };
          }
          // avoid image move outside viewport
          function getDerivedOffset(moveStrategy) {
              const { value: preview } = previewRef;
              if (!preview)
                  return { offsetX: 0, offsetY: 0 };
              const pbox = preview.getBoundingClientRect();
              const { moveVerticalDirection, moveHorizontalDirection, deltaHorizontal, deltaVertical } = moveStrategy || {};
              let nextOffsetX = 0;
              let nextOffsetY = 0;
              if (pbox.width <= window.innerWidth) {
                  nextOffsetX = 0;
              }
              else if (pbox.left > 0) {
                  nextOffsetX = (pbox.width - window.innerWidth) / 2;
              }
              else if (pbox.right < window.innerWidth) {
                  nextOffsetX = -(pbox.width - window.innerWidth) / 2;
              }
              else if (moveHorizontalDirection === 'horizontalRight') {
                  nextOffsetX = Math.min((pbox.width - window.innerWidth) / 2, startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
              }
              else {
                  nextOffsetX = Math.max(-((pbox.width - window.innerWidth) / 2), startOffsetX - (deltaHorizontal !== null && deltaHorizontal !== void 0 ? deltaHorizontal : 0));
              }
              if (pbox.height <= window.innerHeight) {
                  nextOffsetY = 0;
              }
              else if (pbox.top > 0) {
                  nextOffsetY = (pbox.height - window.innerHeight) / 2;
              }
              else if (pbox.bottom < window.innerHeight) {
                  nextOffsetY = -(pbox.height - window.innerHeight) / 2;
              }
              else if (moveVerticalDirection === 'verticalBottom') {
                  nextOffsetY = Math.min((pbox.height - window.innerHeight) / 2, startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
              }
              else {
                  nextOffsetY = Math.max(-((pbox.height - window.innerHeight) / 2), startOffsetY - (deltaVertical !== null && deltaVertical !== void 0 ? deltaVertical : 0));
              }
              return {
                  offsetX: nextOffsetX,
                  offsetY: nextOffsetY
              };
          }
          function handleMouseUp(e) {
              off('mousemove', document, handleMouseMove);
              off('mouseup', document, handleMouseUp);
              const { clientX: mouseUpClientX, clientY: mouseUpClientY } = e;
              dragging = false;
              const moveStrategy = getMoveStrategy({
                  mouseUpClientX,
                  mouseUpClientY,
                  mouseDownClientX,
                  mouseDownClientY
              });
              const offset = getDerivedOffset(moveStrategy);
              offsetX = offset.offsetX;
              offsetY = offset.offsetY;
              derivePreviewStyle();
          }
          const imageContext = inject(imageContextKey, null);
          function handlePreviewMousedown(e) {
              var _a, _b;
              (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onMousedown) === null || _b === void 0 ? void 0 : _b.call(_a, e);
              if (e.button !== 0)
                  return;
              const { clientX, clientY } = e;
              dragging = true;
              startX = clientX - offsetX;
              startY = clientY - offsetY;
              startOffsetX = offsetX;
              startOffsetY = offsetY;
              mouseDownClientX = clientX;
              mouseDownClientY = clientY;
              derivePreviewStyle();
              on('mousemove', document, handleMouseMove);
              on('mouseup', document, handleMouseUp);
          }
          function handlePreviewDblclick(e) {
              var _a, _b;
              (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDblclick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
              const originalImageSizeScale = getOrignalImageSizeScale();
              scale = scale === originalImageSizeScale ? 1 : originalImageSizeScale;
              derivePreviewStyle();
          }
          const scaleRadix = 1.5;
          let scaleExp = 0;
          let scale = 1;
          let rotate = 0;
          function resetScale() {
              scale = 1;
              scaleExp = 0;
          }
          function handleSwitchPrev() {
              var _a;
              resetScale();
              rotate = 0;
              (_a = props.onPrev) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function handleSwitchNext() {
              var _a;
              resetScale();
              rotate = 0;
              (_a = props.onNext) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          function rotateCounterclockwise() {
              rotate -= 90;
              derivePreviewStyle();
          }
          function rotateClockwise() {
              rotate += 90;
              derivePreviewStyle();
          }
          function getMaxScale() {
              const { value: preview } = previewRef;
              if (!preview)
                  return 1;
              const { innerWidth, innerHeight } = window;
              const heightMaxScale = Math.max(1, preview.naturalHeight / (innerHeight - BLEEDING));
              const widthMaxScale = Math.max(1, preview.naturalWidth / (innerWidth - BLEEDING));
              return Math.max(3, heightMaxScale * 2, widthMaxScale * 2);
          }
          function getOrignalImageSizeScale() {
              const { value: preview } = previewRef;
              if (!preview)
                  return 1;
              const { innerWidth, innerHeight } = window;
              const heightScale = preview.naturalHeight / (innerHeight - BLEEDING);
              const widthScale = preview.naturalWidth / (innerWidth - BLEEDING);
              if (heightScale < 1 && widthScale < 1) {
                  return 1;
              }
              return Math.max(heightScale, widthScale);
          }
          function zoomIn() {
              const maxScale = getMaxScale();
              if (scale < maxScale) {
                  scaleExp += 1;
                  scale = Math.min(maxScale, Math.pow(scaleRadix, scaleExp));
                  derivePreviewStyle();
              }
          }
          function zoomOut() {
              if (scale > 0.5) {
                  const originalScale = scale;
                  scaleExp -= 1;
                  scale = Math.max(0.5, Math.pow(scaleRadix, scaleExp));
                  const diff = originalScale - scale;
                  derivePreviewStyle(false);
                  const offset = getDerivedOffset();
                  scale += diff;
                  derivePreviewStyle(false);
                  scale -= diff;
                  offsetX = offset.offsetX;
                  offsetY = offset.offsetY;
                  derivePreviewStyle();
              }
          }
          function handleDownloadClick() {
              const src = previewSrcRef.value;
              if (src) {
                  download(src, undefined);
              }
          }
          function derivePreviewStyle(transition = true) {
              var _a;
              const { value: preview } = previewRef;
              if (!preview)
                  return;
              const { style } = preview;
              const controlledStyle = normalizeStyle((_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.style);
              let controlledStyleString = '';
              if (typeof controlledStyle === 'string') {
                  controlledStyleString = controlledStyle + ';';
              }
              else {
                  for (const key in controlledStyle) {
                      controlledStyleString += `${kebabCase$1(key)}: ${controlledStyle[key]};`;
                  }
              }
              const transformStyle = `transform-origin: center; transform: translateX(${offsetX}px) translateY(${offsetY}px) rotate(${rotate}deg) scale(${scale});`;
              if (dragging) {
                  style.cssText =
                      controlledStyleString +
                          'cursor: grabbing; transition: none;' +
                          transformStyle;
              }
              else {
                  style.cssText =
                      controlledStyleString +
                          'cursor: grab;' +
                          transformStyle +
                          (transition ? '' : 'transition: none;');
              }
              if (!transition) {
                  void preview.offsetHeight;
              }
          }
          function toggleShow() {
              showRef.value = !showRef.value;
              displayedRef.value = true;
          }
          function resizeToOrignalImageSize() {
              scale = getOrignalImageSizeScale();
              scaleExp = Math.ceil(Math.log(scale) / Math.log(scaleRadix));
              offsetX = 0;
              offsetY = 0;
              derivePreviewStyle();
          }
          const exposedMethods = {
              setPreviewSrc: (src) => {
                  previewSrcRef.value = src;
              },
              setThumbnailEl: (el) => {
                  thumbnailEl = el;
              },
              toggleShow
          };
          function withTooltip(node, tooltipKey) {
              if (props.showToolbarTooltip) {
                  const { value: theme } = themeRef;
                  return (h(NTooltip, { to: false, theme: theme.peers.Tooltip, themeOverrides: theme.peerOverrides.Tooltip, keepAliveOnHover: false }, {
                      default: () => {
                          return localeRef.value[tooltipKey];
                      },
                      trigger: () => node
                  }));
              }
              else {
                  return node;
              }
          }
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { toolbarIconColor, toolbarBorderRadius, toolbarBoxShadow, toolbarColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-toolbar-icon-color': toolbarIconColor,
                  '--n-toolbar-color': toolbarColor,
                  '--n-toolbar-border-radius': toolbarBorderRadius,
                  '--n-toolbar-box-shadow': toolbarBoxShadow
              };
          });
          const { inlineThemeDisabled } = useConfig();
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('image-preview', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign({ previewRef,
              previewWrapperRef, previewSrc: previewSrcRef, show: showRef, appear: isMounted(), displayed: displayedRef, previewedImgProps: imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef, handleWheel(e) {
                  e.preventDefault();
              },
              handlePreviewMousedown,
              handlePreviewDblclick,
              syncTransformOrigin, handleAfterLeave: () => {
                  resetScale();
                  rotate = 0;
                  displayedRef.value = false;
              }, handleDragStart: (e) => {
                  var _a, _b;
                  (_b = (_a = imageContext === null || imageContext === void 0 ? void 0 : imageContext.previewedImgPropsRef.value) === null || _a === void 0 ? void 0 : _a.onDragstart) === null || _b === void 0 ? void 0 : _b.call(_a, e);
                  e.preventDefault();
              }, zoomIn,
              zoomOut,
              handleDownloadClick,
              rotateCounterclockwise,
              rotateClockwise,
              handleSwitchPrev,
              handleSwitchNext,
              withTooltip,
              resizeToOrignalImageSize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
      },
      render() {
          var _a, _b;
          const { clsPrefix } = this;
          return (h(Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 :
              _b.call(_a),
              h(LazyTeleport, { show: this.show }, {
                  default: () => {
                      var _a;
                      if (!(this.show || this.displayed)) {
                          return null;
                      }
                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                      return withDirectives(h("div", { class: [
                              `${clsPrefix}-image-preview-container`,
                              this.themeClass
                          ], style: this.cssVars, onWheel: this.handleWheel },
                          h(Transition, { name: "fade-in-transition", appear: this.appear }, {
                              default: () => this.show ? (h("div", { class: `${clsPrefix}-image-preview-overlay`, onClick: this.toggleShow })) : null
                          }),
                          this.showToolbar ? (h(Transition, { name: "fade-in-transition", appear: this.appear }, {
                              default: () => {
                                  if (!this.show)
                                      return null;
                                  const { withTooltip } = this;
                                  return (h("div", { class: `${clsPrefix}-image-preview-toolbar` },
                                      this.onPrev ? (h(Fragment, null,
                                          withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.handleSwitchPrev }, { default: () => prevIcon }), 'tipPrevious'),
                                          withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.handleSwitchNext }, { default: () => nextIcon }), 'tipNext'))) : null,
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.rotateCounterclockwise }, {
                                          default: () => (h(RotateCounterclockwiseIcon, null))
                                      }), 'tipCounterclockwise'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.rotateClockwise }, {
                                          default: () => h(RotateClockwiseIcon, null)
                                      }), 'tipClockwise'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.resizeToOrignalImageSize }, {
                                          default: () => {
                                              return h(ResizeSmallIcon, null);
                                          }
                                      }), 'tipOriginalSize'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.zoomOut }, { default: () => h(ZoomOutIcon, null) }), 'tipZoomOut'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.zoomIn }, { default: () => h(ZoomInIcon, null) }), 'tipZoomIn'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.handleDownloadClick }, { default: () => downloadIcon }), 'tipDownload'),
                                      withTooltip(h(NBaseIcon, { clsPrefix: clsPrefix, onClick: this.toggleShow }, { default: () => closeIcon }), 'tipClose')));
                              }
                          })) : null,
                          h(Transition, { name: "fade-in-scale-up-transition", onAfterLeave: this.handleAfterLeave, appear: this.appear, 
                              // BUG:
                              // onEnter will be called twice, I don't know why
                              // Maybe it is a bug of vue
                              onEnter: this.syncTransformOrigin, onBeforeLeave: this.syncTransformOrigin }, {
                              default: () => {
                                  const { previewedImgProps = {} } = this;
                                  return withDirectives(h("div", { class: `${clsPrefix}-image-preview-wrapper`, ref: "previewWrapperRef" },
                                      h("img", Object.assign({}, previewedImgProps, { draggable: false, onMousedown: this.handlePreviewMousedown, onDblclick: this.handlePreviewDblclick, class: [
                                              `${clsPrefix}-image-preview`,
                                              previewedImgProps.class
                                          ], key: this.previewSrc, src: this.previewSrc, ref: "previewRef", onDragstart: this.handleDragStart }))), [[vShow, this.show]]);
                              }
                          })), [[zindexable$1, { enabled: this.show }]]);
                  }
              })));
      }
  });

  const imageGroupInjectionKey = createInjectionKey('n-image-group');
  const imageGroupProps = imagePreviewSharedProps;
  var NImageGroup = defineComponent({
      name: 'ImageGroup',
      props: imageGroupProps,
      setup(props) {
          let currentSrc;
          const { mergedClsPrefixRef } = useConfig(props);
          const groupId = `c${createId()}`;
          const vm = getCurrentInstance();
          const setPreviewSrc = (src) => {
              var _a;
              currentSrc = src;
              (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setPreviewSrc(src);
          };
          function go(step) {
              var _a, _b;
              if (!(vm === null || vm === void 0 ? void 0 : vm.proxy))
                  return;
              const container = vm.proxy.$el.parentElement;
              // use dom api since we can't get the correct order before all children are rendered
              const imgs = container.querySelectorAll(`[data-group-id=${groupId}]:not([data-error=true])`);
              if (!imgs.length)
                  return;
              const index = Array.from(imgs).findIndex((img) => img.dataset.previewSrc === currentSrc);
              if (~index) {
                  setPreviewSrc(imgs[(index + step + imgs.length) % imgs.length].dataset.previewSrc);
              }
              else {
                  setPreviewSrc(imgs[0].dataset.previewSrc);
              }
              step === 1 ? (_a = props.onPreviewNext) === null || _a === void 0 ? void 0 : _a.call(props) : (_b = props.onPreviewPrev) === null || _b === void 0 ? void 0 : _b.call(props);
          }
          provide(imageGroupInjectionKey, {
              mergedClsPrefixRef,
              setPreviewSrc,
              setThumbnailEl: (el) => {
                  var _a;
                  (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.setThumbnailEl(el);
              },
              toggleShow: () => {
                  var _a;
                  (_a = previewInstRef.value) === null || _a === void 0 ? void 0 : _a.toggleShow();
              },
              groupId
          });
          const previewInstRef = ref(null);
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              previewInstRef,
              next: () => {
                  go(1);
              },
              prev: () => {
                  go(-1);
              }
          };
      },
      render() {
          return (h(NImagePreview, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: this.mergedClsPrefix, ref: "previewInstRef", onPrev: this.prev, onNext: this.next, showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip }, this.$slots));
      }
  });

  const imageProps = Object.assign({ alt: String, height: [String, Number], imgProps: Object, previewedImgProps: Object, lazy: Boolean, intersectionObserverOptions: Object, objectFit: {
          type: String,
          default: 'fill'
      }, previewSrc: String, fallbackSrc: String, width: [String, Number], src: String, previewDisabled: Boolean, loadDescription: String, onError: Function, onLoad: Function }, imagePreviewSharedProps);
  var NImage = defineComponent({
      name: 'Image',
      props: imageProps,
      inheritAttrs: false,
      setup(props) {
          const imageRef = ref(null);
          const showErrorRef = ref(false);
          const previewInstRef = ref(null);
          const imageGroupHandle = inject(imageGroupInjectionKey, null);
          const { mergedClsPrefixRef } = imageGroupHandle || useConfig(props);
          const exposedMethods = {
              click: () => {
                  if (props.previewDisabled || showErrorRef.value)
                      return;
                  const mergedPreviewSrc = props.previewSrc || props.src;
                  if (imageGroupHandle) {
                      imageGroupHandle.setPreviewSrc(mergedPreviewSrc);
                      imageGroupHandle.setThumbnailEl(imageRef.value);
                      imageGroupHandle.toggleShow();
                      return;
                  }
                  const { value: previewInst } = previewInstRef;
                  if (!previewInst)
                      return;
                  previewInst.setPreviewSrc(mergedPreviewSrc);
                  previewInst.setThumbnailEl(imageRef.value);
                  previewInst.toggleShow();
              }
          };
          const shouldStartLoadingRef = ref(!props.lazy);
          onMounted(() => {
              var _a;
              (_a = imageRef.value) === null || _a === void 0 ? void 0 : _a.setAttribute('data-group-id', (imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId) || '');
          });
          onMounted(() => {
              // Use IntersectionObserver if lazy and intersectionObserverOptions is set
              if (props.lazy && props.intersectionObserverOptions) {
                  let unobserve;
                  const stopWatchHandle = watchEffect(() => {
                      unobserve === null || unobserve === void 0 ? void 0 : unobserve();
                      unobserve = undefined;
                      unobserve = observeIntersection(imageRef.value, props.intersectionObserverOptions, shouldStartLoadingRef);
                  });
                  onBeforeUnmount(() => {
                      stopWatchHandle();
                      unobserve === null || unobserve === void 0 ? void 0 : unobserve();
                  });
              }
          });
          watchEffect(() => {
              var _a;
              void props.src;
              void ((_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.src);
              showErrorRef.value = false;
          });
          const loadedRef = ref(false);
          provide(imageContextKey, {
              previewedImgPropsRef: toRef(props, 'previewedImgProps')
          });
          return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, groupId: imageGroupHandle === null || imageGroupHandle === void 0 ? void 0 : imageGroupHandle.groupId, previewInstRef,
              imageRef, showError: showErrorRef, shouldStartLoading: shouldStartLoadingRef, loaded: loadedRef, mergedOnClick: (e) => {
                  var _a, _b;
                  exposedMethods.click();
                  (_b = (_a = props.imgProps) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
              }, mergedOnError: (e) => {
                  if (!shouldStartLoadingRef.value)
                      return;
                  showErrorRef.value = true;
                  const { onError, imgProps: { onError: imgPropsOnError } = {} } = props;
                  onError === null || onError === void 0 ? void 0 : onError(e);
                  imgPropsOnError === null || imgPropsOnError === void 0 ? void 0 : imgPropsOnError(e);
              }, mergedOnLoad: (e) => {
                  const { onLoad, imgProps: { onLoad: imgPropsOnLoad } = {} } = props;
                  onLoad === null || onLoad === void 0 ? void 0 : onLoad(e);
                  imgPropsOnLoad === null || imgPropsOnLoad === void 0 ? void 0 : imgPropsOnLoad(e);
                  loadedRef.value = true;
              } }, exposedMethods);
      },
      render() {
          var _a, _b;
          const { mergedClsPrefix, imgProps = {}, loaded, $attrs, lazy } = this;
          const placeholderNode = (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a);
          const loadSrc = this.src || imgProps.src;
          const imgNode = h('img', Object.assign(Object.assign({}, imgProps), { ref: 'imageRef', width: this.width || imgProps.width, height: this.height || imgProps.height, src: this.showError
                  ? this.fallbackSrc
                  : lazy && this.intersectionObserverOptions
                      ? this.shouldStartLoading
                          ? loadSrc
                          : undefined
                      : loadSrc, alt: this.alt || imgProps.alt, 'aria-label': this.alt || imgProps.alt, onClick: this.mergedOnClick, onError: this.mergedOnError, onLoad: this.mergedOnLoad, 
              // If interseciton observer options is set, do not use native lazy
              loading: isImageSupportNativeLazy && lazy && !this.intersectionObserverOptions
                  ? 'lazy'
                  : 'eager', style: [
                  imgProps.style || '',
                  placeholderNode && !loaded
                      ? { height: '0', width: '0', visibility: 'hidden' }
                      : '',
                  { objectFit: this.objectFit }
              ], 'data-error': this.showError, 'data-preview-src': this.previewSrc || this.src }));
          return (h("div", Object.assign({}, $attrs, { role: "none", class: [
                  $attrs.class,
                  `${mergedClsPrefix}-image`,
                  (this.previewDisabled || this.showError) &&
                      `${mergedClsPrefix}-image--preview-disabled`
              ] }),
              this.groupId ? (imgNode) : (h(NImagePreview, { theme: this.theme, themeOverrides: this.themeOverrides, clsPrefix: mergedClsPrefix, ref: "previewInstRef", showToolbar: this.showToolbar, showToolbarTooltip: this.showToolbarTooltip }, {
                  default: () => imgNode
              })),
              !loaded && placeholderNode));
      }
  });

  // string => string (expected, not implemented)
  // string => number (legacy)
  function parse(value) {
      if (value === undefined ||
          value === null ||
          (typeof value === 'string' && value.trim() === '')) {
          return null;
      }
      return Number(value);
  }
  // can be parsed to number but shouldn't be applied when inputing
  // when value includes `.`, ending with 0 and`.`, doesn't update, if 0 parse func will remove 0
  function isWipValue(value) {
      return (value.includes('.') &&
          (/^(-)?\d+.*(\.|0)$/.test(value) || /^\.\d+$/.test(value)));
  }
  // string => boolean (expected, not implemented)
  // number => boolean (legacy)
  function validator(value) {
      if (value === undefined || value === null)
          return true;
      if (Number.isNaN(value))
          return false;
      return true;
  }
  // string => string (expected, not implemented)
  // number => string (legacy)
  function format(value, precision) {
      if (value === undefined || value === null)
          return '';
      return precision === undefined ? String(value) : value.toFixed(precision);
  }
  function parseNumber(number) {
      if (number === null)
          return null;
      if (typeof number === 'number') {
          return number;
      }
      else {
          const parsedNumber = Number(number);
          if (Number.isNaN(parsedNumber))
              return null;
          else {
              return parsedNumber;
          }
      }
  }

  var style$F = c$1([cB('input-number-suffix', `
 display: inline-block;
 margin-right: 10px;
 `), cB('input-number-prefix', `
 display: inline-block;
 margin-left: 10px;
 `)]);

  const HOLDING_CHANGE_THRESHOLD = 800;
  const HOLDING_CHANGE_INTERVAL = 100;
  const inputNumberProps = Object.assign(Object.assign({}, useTheme.props), { autofocus: Boolean, loading: {
          type: Boolean,
          default: undefined
      }, placeholder: String, defaultValue: {
          type: Number,
          default: null
      }, value: Number, step: {
          type: [Number, String],
          default: 1
      }, min: [Number, String], max: [Number, String], size: String, disabled: {
          type: Boolean,
          default: undefined
      }, validator: Function, bordered: {
          type: Boolean,
          default: undefined
      }, showButton: {
          type: Boolean,
          default: true
      }, buttonPlacement: {
          type: String,
          default: 'right'
      }, readonly: Boolean, clearable: Boolean, keyboard: {
          type: Object,
          default: {}
      }, updateValueOnInput: {
          type: Boolean,
          default: true
      }, parse: Function, format: Function, precision: Number, status: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onFocus: [Function, Array], onBlur: [Function, Array], onClear: [Function, Array], 
      // deprecated
      onChange: [Function, Array] });
  var InputNumber = defineComponent({
      name: 'InputNumber',
      props: inputNumberProps,
      setup(props) {
          const { mergedBorderedRef, mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('InputNumber', '-input-number', style$F, inputNumberLight$1, props, mergedClsPrefixRef);
          const { localeRef } = useLocale('InputNumber');
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef } = formItem;
          // dom ref
          const inputInstRef = ref(null);
          const minusButtonInstRef = ref(null);
          const addButtonInstRef = ref(null);
          // value
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const displayedValueRef = ref('');
          const getPrecision = (value) => {
              const fraction = String(value).split('.')[1];
              return fraction ? fraction.length : 0;
          };
          const getMaxPrecision = (currentValue) => {
              const precisions = [props.min, props.max, props.step, currentValue].map((value) => {
                  if (value === undefined)
                      return 0;
                  return getPrecision(value);
              });
              return Math.max(...precisions);
          };
          const mergedPlaceholderRef = useMemo(() => {
              const { placeholder } = props;
              if (placeholder !== undefined)
                  return placeholder;
              return localeRef.value.placeholder;
          });
          const mergedStepRef = useMemo(() => {
              const parsedNumber = parseNumber(props.step);
              if (parsedNumber !== null) {
                  return parsedNumber === 0 ? 1 : Math.abs(parsedNumber);
              }
              return 1;
          });
          const mergedMinRef = useMemo(() => {
              const parsedNumber = parseNumber(props.min);
              if (parsedNumber !== null)
                  return parsedNumber;
              else
                  return null;
          });
          const mergedMaxRef = useMemo(() => {
              const parsedNumber = parseNumber(props.max);
              if (parsedNumber !== null)
                  return parsedNumber;
              else
                  return null;
          });
          const doUpdateValue = (value) => {
              const { value: mergedValue } = mergedValueRef;
              if (value === mergedValue) {
                  deriveDisplayedValueFromValue();
                  return;
              }
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue, onChange } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onChange)
                  call(onChange, value);
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          };
          const deriveValueFromDisplayedValue = ({ offset, doUpdateIfValid, fixPrecision, isInputing }) => {
              const { value: displayedValue } = displayedValueRef;
              if (isInputing && isWipValue(displayedValue)) {
                  return false;
              }
              const parsedValue = (props.parse || parse)(displayedValue);
              if (parsedValue === null) {
                  if (doUpdateIfValid)
                      doUpdateValue(null);
                  return null;
              }
              if (validator(parsedValue)) {
                  const currentPrecision = getPrecision(parsedValue);
                  const { precision } = props;
                  if (precision !== undefined &&
                      precision < currentPrecision &&
                      !fixPrecision) {
                      return false;
                  }
                  let nextValue = parseFloat((parsedValue + offset).toFixed(precision !== null && precision !== void 0 ? precision : getMaxPrecision(parsedValue)));
                  if (validator(nextValue)) {
                      const { value: mergedMax } = mergedMaxRef;
                      const { value: mergedMin } = mergedMinRef;
                      if (mergedMax !== null && nextValue > mergedMax) {
                          if (!doUpdateIfValid || isInputing)
                              return false;
                          // if doUpdateIfValid=true, we try to make it a valid value
                          nextValue = mergedMax;
                      }
                      if (mergedMin !== null && nextValue < mergedMin) {
                          if (!doUpdateIfValid || isInputing)
                              return false;
                          // if doUpdateIfValid=true, we try to make it a valid value
                          nextValue = mergedMin;
                      }
                      if (props.validator && !props.validator(nextValue))
                          return false;
                      if (doUpdateIfValid)
                          doUpdateValue(nextValue);
                      return nextValue;
                  }
              }
              return false;
          };
          const deriveDisplayedValueFromValue = () => {
              const { value: mergedValue } = mergedValueRef;
              if (validator(mergedValue)) {
                  const { format: formatProp, precision } = props;
                  if (formatProp) {
                      displayedValueRef.value = formatProp(mergedValue);
                  }
                  else {
                      if (mergedValue === null ||
                          precision === undefined ||
                          // precision overflow
                          getPrecision(mergedValue) > precision) {
                          displayedValueRef.value = format(mergedValue, undefined);
                      }
                      else {
                          displayedValueRef.value = format(mergedValue, precision);
                      }
                  }
              }
              else {
                  // null can pass the validator check
                  // so mergedValue is a number
                  displayedValueRef.value = String(mergedValue);
              }
          };
          deriveDisplayedValueFromValue();
          const displayedValueInvalidRef = useMemo(() => {
              const derivedValue = deriveValueFromDisplayedValue({
                  offset: 0,
                  doUpdateIfValid: false,
                  isInputing: false,
                  fixPrecision: false
              });
              return derivedValue === false;
          });
          const minusableRef = useMemo(() => {
              const { value: mergedValue } = mergedValueRef;
              if (props.validator && mergedValue === null) {
                  return false;
              }
              const { value: mergedStep } = mergedStepRef;
              const derivedNextValue = deriveValueFromDisplayedValue({
                  offset: -mergedStep,
                  doUpdateIfValid: false,
                  isInputing: false,
                  fixPrecision: false
              });
              return derivedNextValue !== false;
          });
          const addableRef = useMemo(() => {
              const { value: mergedValue } = mergedValueRef;
              if (props.validator && mergedValue === null) {
                  return false;
              }
              const { value: mergedStep } = mergedStepRef;
              const derivedNextValue = deriveValueFromDisplayedValue({
                  offset: +mergedStep,
                  doUpdateIfValid: false,
                  isInputing: false,
                  fixPrecision: false
              });
              return derivedNextValue !== false;
          });
          function doFocus(e) {
              const { onFocus } = props;
              const { nTriggerFormFocus } = formItem;
              if (onFocus)
                  call(onFocus, e);
              nTriggerFormFocus();
          }
          function doBlur(e) {
              var _a, _b;
              if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
                  // hit input wrapper
                  // which means not activated
                  return;
              }
              const value = deriveValueFromDisplayedValue({
                  offset: 0,
                  doUpdateIfValid: true,
                  isInputing: false,
                  fixPrecision: true
              });
              // If valid, update event has been emitted
              // make sure e.target.value is correct in blur callback
              if (value !== false) {
                  const inputElRef = (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.inputElRef;
                  if (inputElRef) {
                      inputElRef.value = String(value || '');
                  }
                  // If value is not changed, the displayed value may be greater than or
                  // less than the current value. The derived value is reformatted so the
                  // value is not changed. We can simply derive a new displayed value
                  if (mergedValueRef.value === value) {
                      deriveDisplayedValueFromValue();
                  }
              }
              else {
                  // If not valid, nothing will be emitted, so derive displayed value from
                  // origin value
                  deriveDisplayedValueFromValue();
              }
              const { onBlur } = props;
              const { nTriggerFormBlur } = formItem;
              if (onBlur)
                  call(onBlur, e);
              nTriggerFormBlur();
              // User may change value in blur callback, we make sure it will be
              // displayed. Sometimes mergedValue won't be viewed as changed
              void nextTick(() => {
                  deriveDisplayedValueFromValue();
              });
          }
          function doClear(e) {
              const { onClear } = props;
              if (onClear)
                  call(onClear, e);
          }
          function doAdd() {
              const { value: addable } = addableRef;
              if (!addable) {
                  clearAddHoldTimeout();
                  return;
              }
              const { value: mergedValue } = mergedValueRef;
              if (mergedValue === null) {
                  if (!props.validator) {
                      doUpdateValue(createValidValue());
                  }
              }
              else {
                  const { value: mergedStep } = mergedStepRef;
                  deriveValueFromDisplayedValue({
                      offset: mergedStep,
                      doUpdateIfValid: true,
                      isInputing: false,
                      fixPrecision: true
                  });
              }
          }
          function doMinus() {
              const { value: minusable } = minusableRef;
              if (!minusable) {
                  clearMinusHoldTimeout();
                  return;
              }
              const { value: mergedValue } = mergedValueRef;
              if (mergedValue === null) {
                  if (!props.validator) {
                      doUpdateValue(createValidValue());
                  }
              }
              else {
                  const { value: mergedStep } = mergedStepRef;
                  deriveValueFromDisplayedValue({
                      offset: -mergedStep,
                      doUpdateIfValid: true,
                      isInputing: false,
                      fixPrecision: true
                  });
              }
          }
          const handleFocus = doFocus;
          const handleBlur = doBlur;
          function createValidValue() {
              if (props.validator)
                  return null;
              const { value: mergedMin } = mergedMinRef;
              const { value: mergedMax } = mergedMaxRef;
              if (mergedMin !== null) {
                  return Math.max(0, mergedMin);
              }
              else if (mergedMax !== null) {
                  return Math.min(0, mergedMax);
              }
              else {
                  return 0;
              }
          }
          function handleClear(e) {
              doClear(e);
              doUpdateValue(null);
          }
          function handleMouseDown(e) {
              var _a, _b, _c;
              if ((_a = addButtonInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.target)) {
                  e.preventDefault();
              }
              if ((_b = minusButtonInstRef.value) === null || _b === void 0 ? void 0 : _b.$el.contains(e.target)) {
                  e.preventDefault();
              }
              (_c = inputInstRef.value) === null || _c === void 0 ? void 0 : _c.activate();
          }
          let minusHoldStateIntervalId = null;
          let addHoldStateIntervalId = null;
          let firstMinusMousedownId = null;
          function clearMinusHoldTimeout() {
              if (firstMinusMousedownId) {
                  window.clearTimeout(firstMinusMousedownId);
                  firstMinusMousedownId = null;
              }
              if (minusHoldStateIntervalId) {
                  window.clearInterval(minusHoldStateIntervalId);
                  minusHoldStateIntervalId = null;
              }
          }
          function clearAddHoldTimeout() {
              if (firstAddMousedownId) {
                  window.clearTimeout(firstAddMousedownId);
                  firstAddMousedownId = null;
              }
              if (addHoldStateIntervalId) {
                  window.clearInterval(addHoldStateIntervalId);
                  addHoldStateIntervalId = null;
              }
          }
          function handleMinusMousedown() {
              clearMinusHoldTimeout();
              firstMinusMousedownId = window.setTimeout(() => {
                  minusHoldStateIntervalId = window.setInterval(() => {
                      doMinus();
                  }, HOLDING_CHANGE_INTERVAL);
              }, HOLDING_CHANGE_THRESHOLD);
              on('mouseup', document, clearMinusHoldTimeout, {
                  once: true
              });
          }
          let firstAddMousedownId = null;
          function handleAddMousedown() {
              clearAddHoldTimeout();
              firstAddMousedownId = window.setTimeout(() => {
                  addHoldStateIntervalId = window.setInterval(() => {
                      doAdd();
                  }, HOLDING_CHANGE_INTERVAL);
              }, HOLDING_CHANGE_THRESHOLD);
              on('mouseup', document, clearAddHoldTimeout, {
                  once: true
              });
          }
          const handleAddClick = () => {
              if (addHoldStateIntervalId)
                  return;
              doAdd();
          };
          const handleMinusClick = () => {
              if (minusHoldStateIntervalId)
                  return;
              doMinus();
          };
          function handleKeyDown(e) {
              var _a, _b;
              if (e.key === 'Enter') {
                  if (e.target === ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.wrapperElRef)) {
                      // hit input wrapper
                      // which means not activated
                      return;
                  }
                  const value = deriveValueFromDisplayedValue({
                      offset: 0,
                      doUpdateIfValid: true,
                      isInputing: false,
                      fixPrecision: true
                  });
                  if (value !== false) {
                      (_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.deactivate();
                  }
              }
              else if (e.key === 'ArrowUp') {
                  if (!addableRef.value)
                      return;
                  if (props.keyboard.ArrowUp === false)
                      return;
                  e.preventDefault();
                  const value = deriveValueFromDisplayedValue({
                      offset: 0,
                      doUpdateIfValid: true,
                      isInputing: false,
                      fixPrecision: true
                  });
                  if (value !== false) {
                      doAdd();
                  }
              }
              else if (e.key === 'ArrowDown') {
                  if (!minusableRef.value)
                      return;
                  if (props.keyboard.ArrowDown === false)
                      return;
                  e.preventDefault();
                  const value = deriveValueFromDisplayedValue({
                      offset: 0,
                      doUpdateIfValid: true,
                      isInputing: false,
                      fixPrecision: true
                  });
                  if (value !== false) {
                      doMinus();
                  }
              }
          }
          function handleUpdateDisplayedValue(value) {
              displayedValueRef.value = value;
              if (props.updateValueOnInput &&
                  !props.format &&
                  !props.parse &&
                  props.precision === undefined) {
                  deriveValueFromDisplayedValue({
                      offset: 0,
                      doUpdateIfValid: true,
                      isInputing: true,
                      fixPrecision: false
                  });
              }
          }
          watch(mergedValueRef, () => {
              deriveDisplayedValueFromValue();
          });
          const exposedMethods = {
              focus: () => { var _a; return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus(); },
              blur: () => { var _a; return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur(); },
              select: () => { var _a; return (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.select(); }
          };
          const rtlEnabledRef = useRtl('InputNumber', mergedRtlRef, mergedClsPrefixRef);
          return Object.assign(Object.assign({}, exposedMethods), { rtlEnabled: rtlEnabledRef, inputInstRef,
              minusButtonInstRef,
              addButtonInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedBordered: mergedBorderedRef, uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, mergedPlaceholder: mergedPlaceholderRef, displayedValueInvalid: displayedValueInvalidRef, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, displayedValue: displayedValueRef, addable: addableRef, minusable: minusableRef, mergedStatus: mergedStatusRef, handleFocus,
              handleBlur,
              handleClear,
              handleMouseDown,
              handleAddClick,
              handleMinusClick,
              handleAddMousedown,
              handleMinusMousedown,
              handleKeyDown,
              handleUpdateDisplayedValue, 
              // theme
              mergedTheme: themeRef, inputThemeOverrides: {
                  paddingSmall: '0 8px 0 10px',
                  paddingMedium: '0 8px 0 12px',
                  paddingLarge: '0 8px 0 14px'
              }, buttonThemeOverrides: computed(() => {
                  const { self: { iconColorDisabled } } = themeRef.value;
                  const [r, g, b, a] = rgba(iconColorDisabled);
                  return {
                      textColorTextDisabled: `rgb(${r}, ${g}, ${b})`,
                      opacityDisabled: `${a}`
                  };
              }) });
      },
      render() {
          const { mergedClsPrefix, $slots } = this;
          const renderMinusButton = () => {
              return (h(XButton, { text: true, disabled: !this.minusable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleMinusClick, onMousedown: this.handleMinusMousedown, ref: "minusButtonInstRef" }, {
                  icon: () => resolveSlot($slots['minus-icon'], () => [
                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                          default: () => h(RemoveIcon, null)
                      })
                  ])
              }));
          };
          const renderAddButton = () => {
              return (h(XButton, { text: true, disabled: !this.addable || this.mergedDisabled || this.readonly, focusable: false, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, builtinThemeOverrides: this.buttonThemeOverrides, onClick: this.handleAddClick, onMousedown: this.handleAddMousedown, ref: "addButtonInstRef" }, {
                  icon: () => resolveSlot($slots['add-icon'], () => [
                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                          default: () => h(AddIcon, null)
                      })
                  ])
              }));
          };
          return (h("div", { class: [
                  `${mergedClsPrefix}-input-number`,
                  this.rtlEnabled && `${mergedClsPrefix}-input-number--rtl`
              ] },
              h(NInput, { ref: "inputInstRef", autofocus: this.autofocus, status: this.mergedStatus, bordered: this.mergedBordered, loading: this.loading, value: this.displayedValue, onUpdateValue: this.handleUpdateDisplayedValue, theme: this.mergedTheme.peers.Input, themeOverrides: this.mergedTheme.peerOverrides.Input, builtinThemeOverrides: this.inputThemeOverrides, size: this.mergedSize, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, readonly: this.readonly, textDecoration: this.displayedValueInvalid ? 'line-through' : undefined, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeydown: this.handleKeyDown, onMousedown: this.handleMouseDown, onClear: this.handleClear, clearable: this.clearable, internalLoadingBeforeSuffix: true }, {
                  prefix: () => {
                      var _a;
                      return this.showButton && this.buttonPlacement === 'both'
                          ? [
                              renderMinusButton(),
                              resolveWrappedSlot($slots.prefix, (children) => {
                                  if (children) {
                                      return (h("span", { class: `${mergedClsPrefix}-input-number-prefix` }, children));
                                  }
                                  return null;
                              })
                          ]
                          : (_a = $slots.prefix) === null || _a === void 0 ? void 0 : _a.call($slots);
                  },
                  suffix: () => {
                      var _a;
                      return this.showButton
                          ? [
                              resolveWrappedSlot($slots.suffix, (children) => {
                                  if (children) {
                                      return (h("span", { class: `${mergedClsPrefix}-input-number-suffix` }, children));
                                  }
                                  return null;
                              }),
                              this.buttonPlacement === 'right'
                                  ? renderMinusButton()
                                  : null,
                              renderAddButton()
                          ]
                          : (_a = $slots.suffix) === null || _a === void 0 ? void 0 : _a.call($slots);
                  }
              })));
      }
  });

  const layoutSiderInjectionKey = createInjectionKey('n-layout-sider');
  const positionProp = {
      type: String,
      default: 'static'
  };

  // vars:
  // --n-bezier
  // --n-color
  // --n-text-color
  var style$E = cB('layout', `
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 flex: auto;
 overflow: hidden;
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
`, [cB('layout-scroll-container', `
 overflow-x: hidden;
 box-sizing: border-box;
 height: 100%;
 `), cM('absolute-positioned', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]);

  const layoutProps = {
      embedded: Boolean,
      position: positionProp,
      nativeScrollbar: {
          type: Boolean,
          default: true
      },
      scrollbarProps: Object,
      onScroll: Function,
      contentClass: String,
      contentStyle: {
          type: [String, Object],
          default: ''
      },
      hasSider: Boolean,
      siderPlacement: {
          type: String,
          default: 'left'
      }
  };
  const layoutInjectionKey = createInjectionKey('n-layout');
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function createLayoutComponent(isContent) {
      return defineComponent({
          name: isContent ? 'LayoutContent' : 'Layout',
          props: Object.assign(Object.assign({}, useTheme.props), layoutProps),
          setup(props) {
              const scrollableElRef = ref(null);
              const scrollbarInstRef = ref(null);
              const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
              const themeRef = useTheme('Layout', '-layout', style$E, layoutLight$1, props, mergedClsPrefixRef);
              function scrollTo(options, y) {
                  if (props.nativeScrollbar) {
                      const { value: scrollableEl } = scrollableElRef;
                      if (scrollableEl) {
                          if (y === undefined) {
                              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                              scrollableEl.scrollTo(options);
                          }
                          else {
                              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                              scrollableEl.scrollTo(options, y);
                          }
                      }
                  }
                  else {
                      const { value: scrollbarInst } = scrollbarInstRef;
                      if (scrollbarInst) {
                          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                          scrollbarInst.scrollTo(options, y);
                      }
                  }
              }
              provide(layoutInjectionKey, props);
              let scrollX = 0;
              let scrollY = 0;
              const handleNativeElScroll = (e) => {
                  var _a;
                  const target = e.target;
                  scrollX = target.scrollLeft;
                  scrollY = target.scrollTop;
                  (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
              };
              useReactivated(() => {
                  if (props.nativeScrollbar) {
                      const el = scrollableElRef.value;
                      if (el) {
                          el.scrollTop = scrollY;
                          el.scrollLeft = scrollX;
                      }
                  }
              });
              const hasSiderStyle = {
                  display: 'flex',
                  flexWrap: 'nowrap',
                  width: '100%',
                  flexDirection: 'row'
              };
              const exposedMethods = {
                  scrollTo
              };
              const cssVarsRef = computed(() => {
                  const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
                  return {
                      '--n-bezier': cubicBezierEaseInOut,
                      '--n-color': props.embedded ? self.colorEmbedded : self.color,
                      '--n-text-color': self.textColor
                  };
              });
              const themeClassHandle = inlineThemeDisabled
                  ? useThemeClass('layout', computed(() => {
                      return props.embedded ? 'e' : '';
                  }), cssVarsRef, props)
                  : undefined;
              return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, scrollableElRef,
                  scrollbarInstRef,
                  hasSiderStyle, mergedTheme: themeRef, handleNativeElScroll, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
          },
          render() {
              var _a;
              const { mergedClsPrefix, hasSider } = this;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              const hasSiderStyle = hasSider ? this.hasSiderStyle : undefined;
              const layoutClass = [
                  this.themeClass,
                  isContent && `${mergedClsPrefix}-layout-content`,
                  `${mergedClsPrefix}-layout`,
                  `${mergedClsPrefix}-layout--${this.position}-positioned`
              ];
              return (h("div", { class: layoutClass, style: this.cssVars }, this.nativeScrollbar ? (h("div", { ref: "scrollableElRef", class: [
                      `${mergedClsPrefix}-layout-scroll-container`,
                      this.contentClass
                  ], style: [this.contentStyle, hasSiderStyle], onScroll: this.handleNativeElScroll }, this.$slots)) : (h(NScrollbar, Object.assign({}, this.scrollbarProps, { onScroll: this.onScroll, ref: "scrollbarInstRef", theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, contentClass: this.contentClass, contentStyle: [this.contentStyle, hasSiderStyle] }), this.$slots))));
          }
      });
  }
  var Layout = createLayoutComponent(false);

  var LayoutContent = createLayoutComponent(true);

  // vars:
  // --n-bezier
  // --n-text-color
  // --n-color
  // --n-border-color
  var style$D = cB('layout-header', `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 width: 100%;
 background-color: var(--n-color);
 color: var(--n-text-color);
`, [cM('absolute-positioned', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 `), cM('bordered', `
 border-bottom: solid 1px var(--n-border-color);
 `)]);

  const headerProps$1 = {
      position: positionProp,
      inverted: Boolean,
      bordered: {
          type: Boolean,
          default: false
      }
  };
  var LayoutHeader = defineComponent({
      name: 'LayoutHeader',
      props: Object.assign(Object.assign({}, useTheme.props), headerProps$1),
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Layout', '-layout-header', style$D, layoutLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const vars = {
                  '--n-bezier': cubicBezierEaseInOut
              };
              if (props.inverted) {
                  vars['--n-color'] = self.headerColorInverted;
                  vars['--n-text-color'] = self.textColorInverted;
                  vars['--n-border-color'] = self.headerBorderColorInverted;
              }
              else {
                  vars['--n-color'] = self.headerColor;
                  vars['--n-text-color'] = self.textColor;
                  vars['--n-border-color'] = self.headerBorderColor;
              }
              return vars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('layout-header', computed(() => (props.inverted ? 'a' : 'b')), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [
                  `${mergedClsPrefix}-layout-header`,
                  this.themeClass,
                  this.position &&
                      `${mergedClsPrefix}-layout-header--${this.position}-positioned`,
                  this.bordered && `${mergedClsPrefix}-layout-header--bordered`
              ], style: this.cssVars }, this.$slots));
      }
  });

  // vars:
  // --n-bezier
  // --n-color
  // --n-border-color
  // --n-text-color
  var style$C = cB('layout-footer', `
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-sizing: border-box;
`, [cM('absolute-positioned', `
 position: absolute;
 left: 0;
 right: 0;
 bottom: 0;
 `), cM('bordered', `
 border-top: solid 1px var(--n-border-color);
 `)]);

  const layoutFooterProps = Object.assign(Object.assign({}, useTheme.props), { inverted: Boolean, position: positionProp, bordered: Boolean });
  var LayoutFooter = defineComponent({
      name: 'LayoutFooter',
      props: layoutFooterProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Layout', '-layout-footer', style$C, layoutLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const vars = {
                  '--n-bezier': cubicBezierEaseInOut
              };
              if (props.inverted) {
                  vars['--n-color'] = self.footerColorInverted;
                  vars['--n-text-color'] = self.textColorInverted;
                  vars['--n-border-color'] = self.footerBorderColorInverted;
              }
              else {
                  vars['--n-color'] = self.footerColor;
                  vars['--n-text-color'] = self.textColor;
                  vars['--n-border-color'] = self.footerBorderColor;
              }
              return vars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('layout-footer', computed(() => (props.inverted ? 'a' : 'b')), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [
                  `${mergedClsPrefix}-layout-footer`,
                  this.themeClass,
                  this.position &&
                      `${mergedClsPrefix}-layout-footer--${this.position}-positioned`,
                  this.bordered && `${mergedClsPrefix}-layout-footer--bordered`
              ], style: this.cssVars }, this.$slots));
      }
  });

  // vars:
  // --n-bezier
  // --n-color
  // --n-text-color
  // --n-border-color
  // --n-toggle-button-color
  // --n-toggle-bar-color
  // --n-toggle-bar-color-hover
  var style$B = cB('layout-sider', `
 flex-shrink: 0;
 box-sizing: border-box;
 position: relative;
 z-index: 1;
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 min-width .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-color);
 display: flex;
 justify-content: flex-end;
`, [cM('bordered', [cE('border', `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 width: 1px;
 background-color: var(--n-border-color);
 transition: background-color .3s var(--n-bezier);
 `)]), cE('left-placement', [cM('bordered', [cE('border', `
 right: 0;
 `)])]), cM('right-placement', `
 justify-content: flex-start;
 `, [cM('bordered', [cE('border', `
 left: 0;
 `)]), cM('collapsed', [cB('layout-toggle-button', [cB('base-icon', `
 transform: rotate(180deg);
 `)]), cB('layout-toggle-bar', [c$1('&:hover', [cE('top', {
    transform: 'rotate(-12deg) scale(1.15) translateY(-2px)'
  }), cE('bottom', {
    transform: 'rotate(12deg) scale(1.15) translateY(2px)'
  })])])]), cB('layout-toggle-button', `
 left: 0;
 transform: translateX(-50%) translateY(-50%);
 `, [cB('base-icon', `
 transform: rotate(0);
 `)]), cB('layout-toggle-bar', `
 left: -28px;
 transform: rotate(180deg);
 `, [c$1('&:hover', [cE('top', {
    transform: 'rotate(12deg) scale(1.15) translateY(-2px)'
  }), cE('bottom', {
    transform: 'rotate(-12deg) scale(1.15) translateY(2px)'
  })])])]), cM('collapsed', [cB('layout-toggle-bar', [c$1('&:hover', [cE('top', {
    transform: 'rotate(-12deg) scale(1.15) translateY(-2px)'
  }), cE('bottom', {
    transform: 'rotate(12deg) scale(1.15) translateY(2px)'
  })])]), cB('layout-toggle-button', [cB('base-icon', `
 transform: rotate(0);
 `)])]), cB('layout-toggle-button', `
 transition:
 color .3s var(--n-bezier),
 right .3s var(--n-bezier),
 left .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 cursor: pointer;
 width: 24px;
 height: 24px;
 position: absolute;
 top: 50%;
 right: 0;
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 font-size: 18px;
 color: var(--n-toggle-button-icon-color);
 border: var(--n-toggle-button-border);
 background-color: var(--n-toggle-button-color);
 box-shadow: 0 2px 4px 0px rgba(0, 0, 0, .06);
 transform: translateX(50%) translateY(-50%);
 z-index: 1;
 `, [cB('base-icon', `
 transition: transform .3s var(--n-bezier);
 transform: rotate(180deg);
 `)]), cB('layout-toggle-bar', `
 cursor: pointer;
 height: 72px;
 width: 32px;
 position: absolute;
 top: calc(50% - 36px);
 right: -28px;
 `, [cE('top, bottom', `
 position: absolute;
 width: 4px;
 border-radius: 2px;
 height: 38px;
 left: 14px;
 transition: 
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cE('bottom', `
 position: absolute;
 top: 34px;
 `), c$1('&:hover', [cE('top', {
    transform: 'rotate(12deg) scale(1.15) translateY(-2px)'
  }), cE('bottom', {
    transform: 'rotate(-12deg) scale(1.15) translateY(2px)'
  })]), cE('top, bottom', {
    backgroundColor: 'var(--n-toggle-bar-color)'
  }), c$1('&:hover', [cE('top, bottom', {
    backgroundColor: 'var(--n-toggle-bar-color-hover)'
  })])]), cE('border', `
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 width: 1px;
 transition: background-color .3s var(--n-bezier);
 `), cB('layout-sider-scroll-container', `
 flex-grow: 1;
 flex-shrink: 0;
 box-sizing: border-box;
 height: 100%;
 opacity: 0;
 transition: opacity .3s var(--n-bezier);
 max-width: 100%;
 `), cM('show-content', [cB('layout-sider-scroll-container', {
    opacity: 1
  })]), cM('absolute-positioned', `
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 `)]);

  var ToggleButton = defineComponent({
      name: 'LayoutToggleButton',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          onClick: Function
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-layout-toggle-button`, onClick: this.onClick },
              h(NBaseIcon, { clsPrefix: clsPrefix }, {
                  default: () => h(ChevronRightIcon, null)
              })));
      }
  });

  var ToggleBar = defineComponent({
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          onClick: Function
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { onClick: this.onClick, class: `${clsPrefix}-layout-toggle-bar` },
              h("div", { class: `${clsPrefix}-layout-toggle-bar__top` }),
              h("div", { class: `${clsPrefix}-layout-toggle-bar__bottom` })));
      }
  });

  const layoutSiderProps = {
      position: positionProp,
      bordered: Boolean,
      collapsedWidth: {
          type: Number,
          default: 48
      },
      width: {
          type: [Number, String],
          default: 272
      },
      contentClass: String,
      contentStyle: {
          type: [String, Object],
          default: ''
      },
      collapseMode: {
          type: String,
          default: 'transform'
      },
      collapsed: {
          type: Boolean,
          default: undefined
      },
      defaultCollapsed: Boolean,
      showCollapsedContent: {
          type: Boolean,
          default: true
      },
      showTrigger: {
          type: [Boolean, String],
          default: false
      },
      nativeScrollbar: {
          type: Boolean,
          default: true
      },
      inverted: Boolean,
      scrollbarProps: Object,
      triggerClass: String,
      triggerStyle: [String, Object],
      collapsedTriggerClass: String,
      collapsedTriggerStyle: [String, Object],
      'onUpdate:collapsed': [Function, Array],
      onUpdateCollapsed: [Function, Array],
      onAfterEnter: Function,
      onAfterLeave: Function,
      // deprecated
      onExpand: [Function, Array],
      onCollapse: [Function, Array],
      onScroll: Function
  };
  var LayoutSider = defineComponent({
      name: 'LayoutSider',
      props: Object.assign(Object.assign({}, useTheme.props), layoutSiderProps),
      setup(props) {
          const layoutProps = inject(layoutInjectionKey);
          const scrollableElRef = ref(null);
          const scrollbarInstRef = ref(null);
          const styleMaxWidthRef = computed(() => {
              return formatLength(mergedCollapsedRef.value ? props.collapsedWidth : props.width);
          });
          const scrollContainerStyleRef = computed(() => {
              if (props.collapseMode !== 'transform')
                  return {};
              return {
                  minWidth: formatLength(props.width)
              };
          });
          const siderPlacementRef = computed(() => {
              return layoutProps ? layoutProps.siderPlacement : 'left';
          });
          const uncontrolledCollapsedRef = ref(props.defaultCollapsed);
          const mergedCollapsedRef = useMergedState(toRef(props, 'collapsed'), uncontrolledCollapsedRef);
          function scrollTo(options, y) {
              if (props.nativeScrollbar) {
                  const { value: scrollableEl } = scrollableElRef;
                  if (scrollableEl) {
                      if (y === undefined) {
                          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                          scrollableEl.scrollTo(options);
                      }
                      else {
                          // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                          scrollableEl.scrollTo(options, y);
                      }
                  }
              }
              else {
                  const { value: scrollbarInst } = scrollbarInstRef;
                  if (scrollbarInst) {
                      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                      scrollbarInst.scrollTo(options, y);
                  }
              }
          }
          function handleTriggerClick() {
              const { 'onUpdate:collapsed': _onUpdateCollapsed, onUpdateCollapsed, 
              // deprecated
              onExpand, onCollapse } = props;
              const { value: collapsed } = mergedCollapsedRef;
              if (onUpdateCollapsed) {
                  call(onUpdateCollapsed, !collapsed);
              }
              if (_onUpdateCollapsed) {
                  call(_onUpdateCollapsed, !collapsed);
              }
              uncontrolledCollapsedRef.value = !collapsed;
              if (collapsed) {
                  if (onExpand)
                      call(onExpand);
              }
              else {
                  if (onCollapse)
                      call(onCollapse);
              }
          }
          let scrollX = 0;
          let scrollY = 0;
          const handleNativeElScroll = (e) => {
              var _a;
              const target = e.target;
              scrollX = target.scrollLeft;
              scrollY = target.scrollTop;
              (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          };
          useReactivated(() => {
              if (props.nativeScrollbar) {
                  const el = scrollableElRef.value;
                  if (el) {
                      el.scrollTop = scrollY;
                      el.scrollLeft = scrollX;
                  }
              }
          });
          provide(layoutSiderInjectionKey, {
              collapsedRef: mergedCollapsedRef,
              collapseModeRef: toRef(props, 'collapseMode')
          });
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Layout', '-layout-sider', style$B, layoutLight$1, props, mergedClsPrefixRef);
          function handleTransitionend(e) {
              var _a, _b;
              if (e.propertyName === 'max-width') {
                  if (mergedCollapsedRef.value) {
                      (_a = props.onAfterLeave) === null || _a === void 0 ? void 0 : _a.call(props);
                  }
                  else {
                      (_b = props.onAfterEnter) === null || _b === void 0 ? void 0 : _b.call(props);
                  }
              }
          }
          const exposedMethods = {
              scrollTo
          };
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { siderToggleButtonColor, siderToggleButtonBorder, siderToggleBarColor, siderToggleBarColorHover } = self;
              const vars = {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-toggle-button-color': siderToggleButtonColor,
                  '--n-toggle-button-border': siderToggleButtonBorder,
                  '--n-toggle-bar-color': siderToggleBarColor,
                  '--n-toggle-bar-color-hover': siderToggleBarColorHover
              };
              if (props.inverted) {
                  vars['--n-color'] = self.siderColorInverted;
                  vars['--n-text-color'] = self.textColorInverted;
                  vars['--n-border-color'] = self.siderBorderColorInverted;
                  vars['--n-toggle-button-icon-color'] =
                      self.siderToggleButtonIconColorInverted;
                  vars.__invertScrollbar = self.__invertScrollbar;
              }
              else {
                  vars['--n-color'] = self.siderColor;
                  vars['--n-text-color'] = self.textColor;
                  vars['--n-border-color'] = self.siderBorderColor;
                  vars['--n-toggle-button-icon-color'] = self.siderToggleButtonIconColor;
              }
              return vars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('layout-sider', computed(() => (props.inverted ? 'a' : 'b')), cssVarsRef, props)
              : undefined;
          return Object.assign({ scrollableElRef,
              scrollbarInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, styleMaxWidth: styleMaxWidthRef, mergedCollapsed: mergedCollapsedRef, scrollContainerStyle: scrollContainerStyleRef, siderPlacement: siderPlacementRef, handleNativeElScroll,
              handleTransitionend,
              handleTriggerClick,
              inlineThemeDisabled, cssVars: cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
      },
      render() {
          var _a;
          const { mergedClsPrefix, mergedCollapsed, showTrigger } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("aside", { class: [
                  `${mergedClsPrefix}-layout-sider`,
                  this.themeClass,
                  `${mergedClsPrefix}-layout-sider--${this.position}-positioned`,
                  `${mergedClsPrefix}-layout-sider--${this.siderPlacement}-placement`,
                  this.bordered && `${mergedClsPrefix}-layout-sider--bordered`,
                  mergedCollapsed && `${mergedClsPrefix}-layout-sider--collapsed`,
                  (!mergedCollapsed || this.showCollapsedContent) &&
                      `${mergedClsPrefix}-layout-sider--show-content`
              ], onTransitionend: this.handleTransitionend, style: [
                  this.inlineThemeDisabled ? undefined : this.cssVars,
                  {
                      maxWidth: this.styleMaxWidth,
                      width: formatLength(this.width)
                  }
              ] },
              !this.nativeScrollbar ? (h(NScrollbar, Object.assign({}, this.scrollbarProps, { onScroll: this.onScroll, ref: "scrollbarInstRef", style: this.scrollContainerStyle, contentStyle: this.contentStyle, contentClass: this.contentClass, theme: this.mergedTheme.peers.Scrollbar, themeOverrides: this.mergedTheme.peerOverrides.Scrollbar, 
                  // here is a hack, since in light theme the scrollbar color is dark,
                  // we need to invert it in light color...
                  builtinThemeOverrides: this.inverted && this.cssVars.__invertScrollbar === 'true'
                      ? {
                          colorHover: 'rgba(255, 255, 255, .4)',
                          color: 'rgba(255, 255, 255, .3)'
                      }
                      : undefined }), this.$slots)) : (h("div", { class: [
                      `${mergedClsPrefix}-layout-sider-scroll-container`,
                      this.contentClass
                  ], onScroll: this.handleNativeElScroll, style: [
                      this.scrollContainerStyle,
                      {
                          overflow: 'auto'
                      },
                      this.contentStyle
                  ], ref: "scrollableElRef" }, this.$slots)),
              showTrigger ? (showTrigger === 'bar' ? (h(ToggleBar, { clsPrefix: mergedClsPrefix, class: mergedCollapsed ? this.collapsedTriggerClass : this.triggerClass, style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle, onClick: this.handleTriggerClick })) : (h(ToggleButton, { clsPrefix: mergedClsPrefix, class: mergedCollapsed ? this.collapsedTriggerClass : this.triggerClass, style: mergedCollapsed ? this.collapsedTriggerStyle : this.triggerStyle, onClick: this.handleTriggerClick }))) : null,
              this.bordered ? (h("div", { class: `${mergedClsPrefix}-layout-sider__border` })) : null));
      }
  });

  var commonVariables = {
      extraFontSize: '12px',
      width: '440px'
  };

  const self$4 = (vars) => {
      const { fontWeight, iconColorDisabled, iconColor, fontSizeLarge, fontSizeMedium, fontSizeSmall, heightLarge, heightMedium, heightSmall, borderRadius, cardColor, tableHeaderColor, textColor1, textColorDisabled, textColor2, borderColor, hoverColor } = vars;
      return Object.assign(Object.assign({}, commonVariables), { itemHeightSmall: heightSmall, itemHeightMedium: heightMedium, itemHeightLarge: heightLarge, fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius,
          borderColor, listColor: cardColor, headerColor: composite(cardColor, tableHeaderColor), titleTextColor: textColor1, titleTextColorDisabled: textColorDisabled, extraTextColor: textColor2, filterDividerColor: borderColor, itemTextColor: textColor2, itemTextColorDisabled: textColorDisabled, itemColorPending: hoverColor, titleFontWeight: fontWeight, iconColor,
          iconColorDisabled });
  };
  const transferLight = createTheme({
      name: 'Transfer',
      common: commonLight,
      peers: {
          Checkbox: checkboxLight$1,
          Scrollbar: scrollbarLight$1,
          Input: inputLight$1,
          Empty: emptyLight$1,
          Button: buttonLight$1
      },
      self: self$4
  });
  var legacyTransferLight = transferLight;

  const transferInjectionKey$1 = createInjectionKey('n-transfer');

  var NTransferHeader$1 = defineComponent({
      name: 'TransferHeader',
      props: {
          source: {
              type: Boolean,
              default: false
          },
          onChange: {
              type: Function,
              required: true
          },
          title: String
      },
      setup(props) {
          const { srcOptsRef, tgtOptsRef, srcCheckedStatusRef, tgtCheckedStatusRef, srcCheckedValuesRef, tgtCheckedValuesRef, mergedThemeRef, disabledRef, mergedClsPrefixRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(transferInjectionKey$1);
          const checkboxPropsRef = computed(() => {
              const { source } = props;
              if (source) {
                  return srcCheckedStatusRef.value;
              }
              else {
                  return tgtCheckedStatusRef.value;
              }
          });
          return () => {
              const { source } = props;
              const { value: checkboxProps } = checkboxPropsRef;
              const { value: mergedTheme } = mergedThemeRef;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              return (h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-header` },
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-header__checkbox` },
                      h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, checked: checkboxProps.checked, indeterminate: checkboxProps.indeterminate, disabled: checkboxProps.disabled || disabledRef.value, onUpdateChecked: props.onChange })),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-header__header` }, props.title),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-header__extra` },
                      source
                          ? srcCheckedValuesRef.value.length
                          : tgtCheckedValuesRef.value.length,
                      "/",
                      source ? srcOptsRef.value.length : tgtOptsRef.value.length)));
          };
      }
  });

  var NTransferListItem$1 = defineComponent({
      name: 'NTransferListItem',
      props: {
          source: {
              type: Boolean,
              default: false
          },
          label: {
              type: String,
              required: true
          },
          value: {
              type: [String, Number],
              required: true
          },
          disabled: {
              type: Boolean,
              default: false
          }
      },
      setup(props) {
          const { source } = props;
          const { mergedClsPrefixRef, mergedThemeRef, srcCheckedValuesRef, tgtCheckedValuesRef, handleSrcCheckboxClick, handleTgtCheckboxClick
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(transferInjectionKey$1);
          const checkedRef = source
              ? useMemo(() => srcCheckedValuesRef.value.includes(props.value))
              : useMemo(() => tgtCheckedValuesRef.value.includes(props.value));
          const handleClick = source
              ? () => {
                  if (!props.disabled) {
                      handleSrcCheckboxClick(!checkedRef.value, props.value);
                  }
              }
              : () => {
                  if (!props.disabled) {
                      handleTgtCheckboxClick(!checkedRef.value, props.value);
                  }
              };
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef,
              checked: checkedRef,
              handleClick
          };
      },
      render() {
          const { disabled, mergedTheme, mergedClsPrefix, label, checked, source } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-legacy-transfer-list-item`,
                  disabled && `${mergedClsPrefix}-legacy-transfer-list-item--disabled`,
                  source
                      ? `${mergedClsPrefix}-legacy-transfer-list-item--source`
                      : `${mergedClsPrefix}-legacy-transfer-list-item--target`
              ], onClick: this.handleClick },
              h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-item__checkbox` },
                  h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, disabled: disabled, checked: checked })),
              h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-item__label`, title: getTitleAttribute(label) }, label)));
      }
  });

  var NTransferList$1 = defineComponent({
      name: 'TransferList',
      props: {
          virtualScroll: {
              type: Boolean,
              required: true
          },
          itemSize: {
              type: Number,
              required: true
          },
          options: {
              type: Array,
              required: true
          },
          disabled: {
              type: Boolean,
              required: true
          },
          isMounted: {
              type: Boolean,
              required: true
          },
          isInputing: {
              type: Boolean,
              required: true
          },
          source: {
              type: Boolean,
              default: false
          }
      },
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedThemeRef, mergedClsPrefixRef } = inject(transferInjectionKey$1);
          const scrollerInstRef = ref(null);
          const vlInstRef = ref(null);
          function syncVLScroller() {
              var _a;
              (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function scrollContainer() {
              const { value } = vlInstRef;
              if (!value)
                  return null;
              const { listElRef } = value;
              return listElRef;
          }
          function scrollContent() {
              const { value } = vlInstRef;
              if (!value)
                  return null;
              const { itemsElRef } = value;
              return itemsElRef;
          }
          return {
              mergedTheme: mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              scrollerInstRef,
              vlInstRef,
              syncVLScroller,
              scrollContainer,
              scrollContent
          };
      },
      render() {
          const { mergedTheme, mergedClsPrefix, virtualScroll, syncVLScroller } = this;
          return (h(Fragment, null,
              h(NScrollbar, { ref: "scrollerInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.scrollContainer : undefined, content: virtualScroll ? this.scrollContent : undefined }, {
                  default: () => virtualScroll ? (h(VVirtualList, { ref: "vlInstRef", style: { height: '100%' }, class: `${mergedClsPrefix}-legacy-transfer-list-content`, items: this.options, itemSize: this.itemSize, showScrollbar: false, onResize: syncVLScroller, onScroll: syncVLScroller, keyField: "value" }, {
                      default: ({ item }) => {
                          const { source, disabled } = this;
                          return (h(NTransferListItem$1, { source: source, key: item.value, value: item.value, disabled: item.disabled || disabled, label: item.label }));
                      }
                  })) : (h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-content` },
                      h(TransitionGroup, { name: "item", appear: this.isMounted, css: !this.isInputing }, {
                          default: () => {
                              const { source, disabled } = this;
                              return this.options.map((option) => (h(NTransferListItem$1, { source: source, key: option.value, value: option.value, disabled: option.disabled || disabled, label: option.label })));
                          }
                      })))
              }),
              h(Transition, { name: "fade-in-transition", appear: this.isMounted, css: !this.isInputing }, {
                  default: () => this.options.length ? null : (h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty }))
              })));
      }
  });

  var NTransferFilter$1 = defineComponent({
      name: 'TransferFilter',
      props: {
          value: String,
          placeholder: String,
          disabled: Boolean,
          onFocus: {
              type: Function,
              required: true
          },
          onBlur: {
              type: Function,
              required: true
          },
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedThemeRef, mergedClsPrefixRef } = inject(transferInjectionKey$1);
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef
          };
      },
      render() {
          const { mergedTheme, mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-legacy-transfer-filter` },
              h(NInput, { value: this.value, onUpdateValue: this.onUpdateValue, disabled: this.disabled, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, clearable: true, size: "small", placeholder: this.placeholder, onFocus: this.onFocus, onBlur: this.onBlur }, {
                  'clear-icon-placeholder': () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-legacy-transfer-icon` }, { default: () => h(SearchIcon, null) }))
              })));
      }
  });

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useTransferData$1(props, mergedDisabledRef) {
      const uncontrolledValueRef = ref(props.defaultValue);
      const controlledValueRef = toRef(props, 'value');
      const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
      const optMapRef = computed(() => {
          const map = new Map();
          (props.options || []).forEach((opt) => map.set(opt.value, opt));
          return map;
      });
      const tgtValueSetRef = computed(() => new Set(mergedValueRef.value || []));
      const srcOptsRef = computed(() => props.options.filter((option) => !tgtValueSetRef.value.has(option.value)));
      const tgtOptsRef = computed(() => {
          const optMap = optMapRef.value;
          return (mergedValueRef.value || []).map((v) => optMap.get(v));
      });
      const srcPatternRef = ref('');
      const tgtPatternRef = ref('');
      const filteredSrcOptsRef = computed(() => {
          if (!props.filterable)
              return srcOptsRef.value;
          const { filter } = props;
          return srcOptsRef.value.filter((opt) => filter(srcPatternRef.value, opt, 'source'));
      });
      const filteredTgtOptsRef = computed(() => {
          if (!props.filterable)
              return tgtOptsRef.value;
          const { filter } = props;
          return tgtOptsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, 'target'));
      });
      const avlSrcValueSetRef = computed(() => new Set(filteredSrcOptsRef.value
          .filter((opt) => !opt.disabled)
          .map((opt) => opt.value)));
      const avlTgtValueSetRef = computed(() => new Set(filteredTgtOptsRef.value
          .filter((opt) => !opt.disabled)
          .map((opt) => opt.value)));
      const srcCheckedValuesRef = ref([]);
      const tgtCheckedValuesRef = ref([]);
      const srcCheckedStatusRef = computed(() => {
          const srcCheckedLength = srcCheckedValuesRef.value.filter((v) => avlSrcValueSetRef.value.has(v)).length;
          const avlValueCount = avlSrcValueSetRef.value.size;
          if (avlValueCount === 0) {
              return {
                  checked: false,
                  indeterminate: false,
                  disabled: true
              };
          }
          else if (srcCheckedLength === 0) {
              return {
                  checked: false,
                  indeterminate: false
              };
          }
          else if (srcCheckedLength === avlValueCount) {
              return {
                  checked: true,
                  indeterminate: false
              };
          }
          else {
              return {
                  checked: false,
                  indeterminate: true
              };
          }
      });
      const tgtCheckedStatusRef = computed(() => {
          const tgtCheckedLength = tgtCheckedValuesRef.value.filter((v) => avlTgtValueSetRef.value.has(v)).length;
          const avlValueCount = avlTgtValueSetRef.value.size;
          if (avlValueCount === 0) {
              return {
                  checked: false,
                  indeterminate: false,
                  disabled: true
              };
          }
          else if (tgtCheckedLength === 0) {
              return {
                  checked: false,
                  indeterminate: false
              };
          }
          else if (tgtCheckedLength === avlValueCount) {
              return {
                  checked: true,
                  indeterminate: false
              };
          }
          else {
              return {
                  checked: false,
                  indeterminate: true
              };
          }
      });
      const fromButtonDisabledRef = useMemo(() => {
          if (mergedDisabledRef.value)
              return true;
          return tgtCheckedValuesRef.value.length === 0;
      });
      const toButtonDisabledRef = useMemo(() => {
          if (mergedDisabledRef.value)
              return true;
          return srcCheckedValuesRef.value.length === 0;
      });
      const isInputingRef = ref(false);
      function handleInputFocus() {
          isInputingRef.value = true;
      }
      function handleInputBlur() {
          isInputingRef.value = false;
      }
      function handleSrcFilterUpdateValue(value) {
          srcPatternRef.value = value !== null && value !== void 0 ? value : '';
      }
      function handleTgtFilterUpdateValue(value) {
          tgtPatternRef.value = value !== null && value !== void 0 ? value : '';
      }
      return {
          uncontrolledValue: uncontrolledValueRef,
          mergedValue: mergedValueRef,
          avlSrcValueSet: avlSrcValueSetRef,
          avlTgtValueSet: avlTgtValueSetRef,
          tgtOpts: tgtOptsRef,
          srcOpts: srcOptsRef,
          filteredSrcOpts: filteredSrcOptsRef,
          filteredTgtOpts: filteredTgtOptsRef,
          srcCheckedValues: srcCheckedValuesRef,
          tgtCheckedValues: tgtCheckedValuesRef,
          srcCheckedStatus: srcCheckedStatusRef,
          tgtCheckedStatus: tgtCheckedStatusRef,
          srcPattern: srcPatternRef,
          tgtPattern: tgtPatternRef,
          isInputing: isInputingRef,
          fromButtonDisabled: fromButtonDisabledRef,
          toButtonDisabled: toButtonDisabledRef,
          handleInputFocus,
          handleInputBlur,
          handleTgtFilterUpdateValue,
          handleSrcFilterUpdateValue
      };
  }

  const animation = c$1([c$1('@keyframes legacy-transfer-slide-in-from-left', `
 0% {
 transform: translateX(-150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1('@keyframes legacy-transfer-slide-out-to-right', `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(150%);
 }
 `), c$1('@keyframes legacy-transfer-slide-in-from-right', `
 0% {
 transform: translateX(150%);
 }
 100% {
 transform: translateX(0);
 }
 `), c$1('@keyframes legacy-transfer-slide-out-to-left', `
 0% {
 transform: translateX(0);
 }
 100% {
 transform: translateX(-150%);
 }
 `), c$1('@keyframes legacy-transfer-height-collapse', `
 0% {
 max-height: var(--n-item-height);
 }
 100% {
 max-height: 0;
 }
 `), c$1('@keyframes legacy-transfer-height-expand', `
 0% {
 max-height: 0;
 }
 100% {
 max-height: var(--n-item-height);
 }
 `)]);
  var style$A = c$1([cB('legacy-transfer', `
 display: flex;
 width: var(--n-width);
 font-size: var(--n-font-size);
 height: 240px;
 display: flex;
 flex-wrap: nowrap;
 `, [cB('legacy-transfer-icon', `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM('disabled', [cB('legacy-transfer-icon', {
    color: 'var(--n-icon-color-disabled)'
  })]), cB('legacy-transfer-list', `
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 width: calc(50% - 36px);
 position: relative;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 background-color: var(--n-list-color);
 `, [cE('border', `
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB('legacy-transfer-list-header', `
 height: calc(var(--n-item-height) + 4px);
 box-sizing: border-box;
 display: flex;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE('checkbox', `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cE('header', `
 flex: 1;
 line-height: 1;
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `, [cM('disabled', {
    color: 'var(--n-header-text-color-disabled)'
  })]), cE('extra', `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 justify-self: flex-end;
 margin-right: 14px;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB('legacy-transfer-list-body', `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB('legacy-transfer-filter', `
 padding: 0 8px 8px 8px;
 box-sizing: border-box;
 background-color: var(--n-header-color);
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-filter-divider-color);
 `), cB('legacy-transfer-list-flex-container', `
 flex: 1;
 position: relative;
 `, [cB('scrollbar', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `, [cB('scrollbar-content', {
    width: '100%'
  })]), cB('empty', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `, [fadeInTransition()]), cB('legacy-transfer-list-content', `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cM('transition-disabled', [cB('legacy-transfer-list-item', {
    animation: 'none !important'
  })]), cB('legacy-transfer-list-item', `
 height: var(--n-item-height);
 max-height: var(--n-item-height);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 cursor: pointer;
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 `, [cNotM('disabled', [c$1('&:hover', {
    backgroundColor: 'var(--n-item-color-pending)'
  })]), cE('extra', `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 padding-right: 4px;
 `), cE('checkbox', `
 display: flex;
 align-items: center;
 position: relative;
 padding: 0 9px 0 14px;
 `), cM('disabled', `
 cursor: not-allowed
 background-color: #0000;
 color: var(--n-item-text-color-disabled);
 `), cM('source', {
    animationFillMode: 'forwards'
  }, [c$1('&.item-enter-active', `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-right;
 `), c$1('&.item-leave-active', `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-right;
 `)]), cM('target', {
    animationFillMode: 'forwards'
  }, [c$1('&.item-enter-active', `
 transform: translateX(-150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-out);
 animation-delay: 0s, .25s;
 animation-name: legacy-transfer-height-expand, legacy-transfer-slide-in-from-left;
 `), c$1('&.item-leave-active', `
 transform: translateX(150%);
 animation-duration: .25s, .25s;
 animation-timing-function: var(--n-bezier), var(--n-bezier-ease-in);
 animation-delay: .25s, 0s;
 animation-name: legacy-transfer-height-collapse, legacy-transfer-slide-out-to-left;
 `)])])])])])]), cB('legacy-transfer-gap', {
    width: '72px',
    display: 'flex',
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'column'
  }), cB('button', [c$1('&:first-child', {
    marginBottom: '12px'
  })])]), animation]);

  const transferProps$1 = Object.assign(Object.assign({}, useTheme.props), { value: Array, defaultValue: {
          type: Array,
          default: null
      }, options: {
          type: Array,
          default: () => []
      }, disabled: {
          type: Boolean,
          default: undefined
      }, virtualScroll: Boolean, sourceTitle: String, targetTitle: String, filterable: Boolean, sourceFilterPlaceholder: String, targetFilterPlaceholder: String, filter: {
          type: Function,
          default: (pattern, option) => {
              if (!pattern)
                  return true;
              return ~('' + option.label)
                  .toLowerCase()
                  .indexOf(('' + pattern).toLowerCase());
          }
      }, size: String, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] });
  var Transfer$1 = defineComponent({
      name: 'LegacyTransfer',
      props: transferProps$1,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('LegacyTransfer', '-legacy-transfer', style$A, legacyTransferLight, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const itemSizeRef = computed(() => {
              const { value: size } = mergedSizeRef;
              const { self: { [createKey('itemHeight', size)]: itemSize } } = themeRef.value;
              return depx(itemSize);
          });
          const { uncontrolledValue: uncontrolledValueRef, mergedValue: mergedValueRef, avlSrcValueSet: avlSrcValueSetRef, avlTgtValueSet: avlTgtValueSetRef, tgtOpts: tgtOptsRef, srcOpts: srcOptsRef, filteredSrcOpts: filteredSrcOptsRef, filteredTgtOpts: filteredTgtOptsRef, srcCheckedValues: srcCheckedValuesRef, tgtCheckedValues: tgtCheckedValuesRef, srcCheckedStatus: srcCheckedStatusRef, tgtCheckedStatus: tgtCheckedStatusRef, srcPattern: srcPatternRef, tgtPattern: tgtPatternRef, isInputing: isInputingRef, fromButtonDisabled: fromButtonDisabledRef, toButtonDisabled: toButtonDisabledRef, handleInputFocus, handleInputBlur, handleTgtFilterUpdateValue, handleSrcFilterUpdateValue } = useTransferData$1(props, mergedDisabledRef);
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onChange)
                  call(onChange, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function handleSrcHeaderCheck(value) {
              const { value: { checked, indeterminate } } = srcCheckedStatusRef;
              if (indeterminate || checked) {
                  srcCheckedValuesRef.value = [];
              }
              else {
                  srcCheckedValuesRef.value = Array.from(avlSrcValueSetRef.value);
              }
          }
          function handleTgtHeaderCheck() {
              const { value: { checked, indeterminate } } = tgtCheckedStatusRef;
              if (indeterminate || checked) {
                  tgtCheckedValuesRef.value = [];
              }
              else {
                  tgtCheckedValuesRef.value = Array.from(avlTgtValueSetRef.value);
              }
          }
          function handleTgtCheckboxClick(checked, optionValue) {
              if (checked) {
                  tgtCheckedValuesRef.value.push(optionValue);
              }
              else {
                  const index = tgtCheckedValuesRef.value.findIndex((v) => v === optionValue);
                  if (~index) {
                      tgtCheckedValuesRef.value.splice(index, 1);
                  }
              }
          }
          function handleSrcCheckboxClick(checked, optionValue) {
              if (checked) {
                  srcCheckedValuesRef.value.push(optionValue);
              }
              else {
                  const index = srcCheckedValuesRef.value.findIndex((v) => v === optionValue);
                  if (~index) {
                      srcCheckedValuesRef.value.splice(index, 1);
                  }
              }
          }
          function handleToTgtClick() {
              doUpdateValue(srcCheckedValuesRef.value.concat(mergedValueRef.value || []));
              srcCheckedValuesRef.value = [];
          }
          function handleToSrcClick() {
              const tgtCheckedValueSet = new Set(tgtCheckedValuesRef.value);
              doUpdateValue((mergedValueRef.value || []).filter((v) => !tgtCheckedValueSet.has(v)));
              tgtCheckedValuesRef.value = [];
          }
          provide(transferInjectionKey$1, {
              mergedClsPrefixRef,
              mergedSizeRef,
              disabledRef: mergedDisabledRef,
              mergedThemeRef: themeRef,
              srcCheckedValuesRef,
              tgtCheckedValuesRef,
              srcOptsRef,
              tgtOptsRef,
              srcCheckedStatusRef,
              tgtCheckedStatusRef,
              handleSrcCheckboxClick,
              handleTgtCheckboxClick
          });
          const { localeRef } = useLocale('LegacyTransfer');
          return {
              locale: localeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedDisabled: mergedDisabledRef,
              itemSize: itemSizeRef,
              isMounted: isMounted(),
              isInputing: isInputingRef,
              mergedTheme: themeRef,
              filteredSrcOpts: filteredSrcOptsRef,
              filteredTgtOpts: filteredTgtOptsRef,
              srcPattern: srcPatternRef,
              tgtPattern: tgtPatternRef,
              toButtonDisabled: toButtonDisabledRef,
              fromButtonDisabled: fromButtonDisabledRef,
              handleSrcHeaderCheck,
              handleTgtHeaderCheck,
              handleToSrcClick,
              handleToTgtClick,
              handleInputFocus,
              handleInputBlur,
              handleTgtFilterUpdateValue,
              handleSrcFilterUpdateValue,
              cssVars: computed(() => {
                  const { value: size } = mergedSizeRef;
                  const { common: { cubicBezierEaseInOut, cubicBezierEaseIn, cubicBezierEaseOut }, self: { width, borderRadius, borderColor, listColor, headerColor, titleTextColor, titleTextColorDisabled, extraTextColor, filterDividerColor, itemTextColor, itemColorPending, itemTextColorDisabled, extraFontSize, titleFontWeight, iconColor, iconColorDisabled, [createKey('fontSize', size)]: fontSize, [createKey('itemHeight', size)]: itemHeight } } = themeRef.value;
                  return {
                      '--n-bezier': cubicBezierEaseInOut,
                      '--n-bezier-ease-in': cubicBezierEaseIn,
                      '--n-bezier-ease-out': cubicBezierEaseOut,
                      '--n-border-color': borderColor,
                      '--n-border-radius': borderRadius,
                      '--n-extra-font-size': extraFontSize,
                      '--n-filter-divider-color': filterDividerColor,
                      '--n-font-size': fontSize,
                      '--n-header-color': headerColor,
                      '--n-header-extra-text-color': extraTextColor,
                      '--n-header-font-weight': titleFontWeight,
                      '--n-header-text-color': titleTextColor,
                      '--n-header-text-color-disabled': titleTextColorDisabled,
                      '--n-item-color-pending': itemColorPending,
                      '--n-item-height': itemHeight,
                      '--n-item-text-color': itemTextColor,
                      '--n-item-text-color-disabled': itemTextColorDisabled,
                      '--n-list-color': listColor,
                      '--n-width': width,
                      '--n-icon-color': iconColor,
                      '--n-icon-color-disabled': iconColorDisabled
                  };
              })
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-legacy-transfer`,
                  this.mergedDisabled && `${mergedClsPrefix}-legacy-transfer--disabled`,
                  this.filterable && `${mergedClsPrefix}-legacy-transfer--filterable`
              ], style: this.cssVars },
              h("div", { class: `${mergedClsPrefix}-legacy-transfer-list` },
                  h(NTransferHeader$1, { source: true, onChange: this.handleSrcHeaderCheck, title: this.sourceTitle || this.locale.sourceTitle }),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-body` },
                      this.filterable ? (h(NTransferFilter$1, { onUpdateValue: this.handleSrcFilterUpdateValue, value: this.srcPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur })) : null,
                      h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-flex-container` },
                          h(NTransferList$1, { source: true, options: this.filteredSrcOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, isMounted: this.isMounted, isInputing: this.isInputing, itemSize: this.itemSize }))),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list__border` })),
              h("div", { class: `${mergedClsPrefix}-legacy-transfer-gap` },
                  h(NButton, { disabled: this.toButtonDisabled || this.mergedDisabled, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, onClick: this.handleToTgtClick }, {
                      icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ChevronRightIcon, null) }))
                  }),
                  h(NButton, { disabled: this.fromButtonDisabled || this.mergedDisabled, theme: this.mergedTheme.peers.Button, themeOverrides: this.mergedTheme.peerOverrides.Button, onClick: this.handleToSrcClick }, {
                      icon: () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(ChevronLeftIcon, null) }))
                  })),
              h("div", { class: `${mergedClsPrefix}-legacy-transfer-list` },
                  h(NTransferHeader$1, { onChange: this.handleTgtHeaderCheck, title: this.targetTitle || this.locale.targetTitle }),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-body` },
                      this.filterable ? (h(NTransferFilter$1, { onUpdateValue: this.handleTgtFilterUpdateValue, value: this.tgtPattern, disabled: this.mergedDisabled, placeholder: this.targetFilterPlaceholder, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur })) : null,
                      h("div", { class: `${mergedClsPrefix}-legacy-transfer-list-flex-container` },
                          h(NTransferList$1, { options: this.filteredTgtOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, isMounted: this.isMounted, isInputing: this.isInputing, itemSize: this.itemSize }))),
                  h("div", { class: `${mergedClsPrefix}-legacy-transfer-list__border` }))));
      }
  });

  // vars:
  // --n-font-size
  // --n-bezier
  // --n-text-color
  // --n-color
  // --n-color-hover
  // --n-border-radius
  // --n-border-color
  // --n-border-color-modal
  // --n-border-color-popover
  // --n-color-modal
  // --n-color-popover
  // --n-color-hover-modal
  // --n-color-hover-popover
  var style$z = c$1([cB('list', `
 --n-merged-border-color: var(--n-border-color);
 --n-merged-color: var(--n-color);
 --n-merged-color-hover: var(--n-color-hover);
 margin: 0;
 font-size: var(--n-font-size);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 padding: 0;
 list-style-type: none;
 color: var(--n-text-color);
 background-color: var(--n-merged-color);
 `, [cM('show-divider', [cB('list-item', [c$1('&:not(:last-child)', [cE('divider', `
 background-color: var(--n-merged-border-color);
 `)])])]), cM('clickable', [cB('list-item', `
 cursor: pointer;
 `)]), cM('bordered', `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `), cM('hoverable', [cB('list-item', `
 border-radius: var(--n-border-radius);
 `, [c$1('&:hover', `
 background-color: var(--n-merged-color-hover);
 `, [cE('divider', `
 background-color: transparent;
 `)])])]), cM('bordered, hoverable', [cB('list-item', `
 padding: 12px 20px;
 `), cE('header, footer', `
 padding: 12px 20px;
 `)]), cE('header, footer', `
 padding: 12px 0;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
 `, [c$1('&:not(:last-child)', `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)]), cB('list-item', `
 position: relative;
 padding: 12px 0; 
 box-sizing: border-box;
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cE('prefix', `
 margin-right: 20px;
 flex: 0;
 `), cE('suffix', `
 margin-left: 20px;
 flex: 0;
 `), cE('main', `
 flex: 1;
 `), cE('divider', `
 height: 1px;
 position: absolute;
 bottom: 0;
 left: 0;
 right: 0;
 background-color: transparent;
 transition: background-color .3s var(--n-bezier);
 pointer-events: none;
 `)])]), insideModal(cB('list', `
 --n-merged-color-hover: var(--n-color-hover-modal);
 --n-merged-color: var(--n-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `)), insidePopover(cB('list', `
 --n-merged-color-hover: var(--n-color-hover-popover);
 --n-merged-color: var(--n-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `))]);

  const listProps = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: String,
          default: 'medium'
      }, bordered: Boolean, clickable: Boolean, hoverable: Boolean, showDivider: {
          type: Boolean,
          default: true
      } });
  const listInjectionKey = createInjectionKey('n-list');
  var List = defineComponent({
      name: 'List',
      props: listProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('List', mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme('List', '-list', style$z, listLight$1, props, mergedClsPrefixRef);
          provide(listInjectionKey, {
              showDividerRef: toRef(props, 'showDivider'),
              mergedClsPrefixRef
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { fontSize, textColor, color, colorModal, colorPopover, borderColor, borderColorModal, borderColorPopover, borderRadius, colorHover, colorHoverModal, colorHoverPopover } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-color': color,
                  '--n-border-radius': borderRadius,
                  '--n-border-color': borderColor,
                  '--n-border-color-modal': borderColorModal,
                  '--n-border-color-popover': borderColorPopover,
                  '--n-color-modal': colorModal,
                  '--n-color-popover': colorPopover,
                  '--n-color-hover': colorHover,
                  '--n-color-hover-modal': colorHoverModal,
                  '--n-color-hover-popover': colorHoverPopover
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('list', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              rtlEnabled: rtlEnabledRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("ul", { class: [
                  `${mergedClsPrefix}-list`,
                  this.rtlEnabled && `${mergedClsPrefix}-list--rtl`,
                  this.bordered && `${mergedClsPrefix}-list--bordered`,
                  this.showDivider && `${mergedClsPrefix}-list--show-divider`,
                  this.hoverable && `${mergedClsPrefix}-list--hoverable`,
                  this.clickable && `${mergedClsPrefix}-list--clickable`,
                  this.themeClass
              ], style: this.cssVars },
              $slots.header ? (h("div", { class: `${mergedClsPrefix}-list__header` }, $slots.header())) : null, (_a = $slots.default) === null || _a === void 0 ? void 0 :
              _a.call($slots),
              $slots.footer ? (h("div", { class: `${mergedClsPrefix}-list__footer` }, $slots.footer())) : null));
      }
  });

  var ListItem = defineComponent({
      name: 'ListItem',
      setup() {
          const listInjection = inject(listInjectionKey, null);
          if (!listInjection) {
              throwError('list-item', '`n-list-item` must be placed in `n-list`.');
          }
          return {
              showDivider: listInjection.showDividerRef,
              mergedClsPrefix: listInjection.mergedClsPrefixRef
          };
      },
      render() {
          const { $slots, mergedClsPrefix } = this;
          return (h("li", { class: `${mergedClsPrefix}-list-item` },
              $slots.prefix ? (h("div", { class: `${mergedClsPrefix}-list-item__prefix` }, $slots.prefix())) : null,
              $slots.default ? (h("div", { class: `${mergedClsPrefix}-list-item__main` }, $slots)) : null,
              $slots.suffix ? (h("div", { class: `${mergedClsPrefix}-list-item__suffix` }, $slots.suffix())) : null,
              this.showDivider && (h("div", { class: `${mergedClsPrefix}-list-item__divider` }))));
      }
  });

  const loadingBarProviderInjectionKey = createInjectionKey('n-loading-bar');
  const loadingBarApiInjectionKey = createInjectionKey('n-loading-bar-api');

  // vars:
  // --n-height
  // --n-color-loading
  // --n-color-error
  var style$y = cB('loading-bar-container', `
 z-index: 5999;
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 height: 2px;
`, [fadeInTransition({
    enterDuration: '0.3s',
    leaveDuration: '0.8s'
  }), cB('loading-bar', `
 width: 100%;
 transition:
 max-width 4s linear,
 background .2s linear;
 height: var(--n-height);
 `, [cM('starting', `
 background: var(--n-color-loading);
 `), cM('finishing', `
 background: var(--n-color-loading);
 transition:
 max-width .2s linear,
 background .2s linear;
 `), cM('error', `
 background: var(--n-color-error);
 transition:
 max-width .2s linear,
 background .2s linear;
 `)])]);

  var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function createClassName(status, clsPrefix) {
      return `${clsPrefix}-loading-bar ${clsPrefix}-loading-bar--${status}`;
  }
  var NLoadingBar = defineComponent({
      name: 'LoadingBar',
      props: {
          containerClass: String,
          containerStyle: [String, Object]
      },
      setup() {
          const { inlineThemeDisabled } = useConfig();
          const { props: providerProps, mergedClsPrefixRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(loadingBarProviderInjectionKey);
          const loadingBarRef = ref(null);
          const enteringRef = ref(false);
          const startedRef = ref(false);
          const loadingRef = ref(false);
          const transitionDisabledRef = ref(false);
          let finishing = false;
          const erroringRef = ref(false);
          const mergedLoadingBarStyle = computed(() => {
              const { loadingBarStyle } = providerProps;
              if (!loadingBarStyle)
                  return '';
              return loadingBarStyle[erroringRef.value ? 'error' : 'loading'];
          });
          function init() {
              return __awaiter$3(this, void 0, void 0, function* () {
                  enteringRef.value = false;
                  loadingRef.value = false;
                  finishing = false;
                  erroringRef.value = false;
                  transitionDisabledRef.value = true;
                  yield nextTick();
                  transitionDisabledRef.value = false;
              });
          }
          function start(fromProgress = 0, toProgress = 80, status = 'starting') {
              return __awaiter$3(this, void 0, void 0, function* () {
                  startedRef.value = true;
                  yield init();
                  if (finishing)
                      return;
                  loadingRef.value = true;
                  yield nextTick();
                  const el = loadingBarRef.value;
                  if (!el)
                      return;
                  el.style.maxWidth = `${fromProgress}%`;
                  el.style.transition = 'none';
                  void el.offsetWidth;
                  el.className = createClassName(status, mergedClsPrefixRef.value);
                  el.style.transition = '';
                  el.style.maxWidth = `${toProgress}%`;
              });
          }
          function finish() {
              return __awaiter$3(this, void 0, void 0, function* () {
                  if (finishing || erroringRef.value)
                      return;
                  if (startedRef.value) {
                      yield nextTick();
                  }
                  finishing = true;
                  const el = loadingBarRef.value;
                  if (!el)
                      return;
                  el.className = createClassName('finishing', mergedClsPrefixRef.value);
                  el.style.maxWidth = '100%';
                  void el.offsetWidth;
                  loadingRef.value = false;
              });
          }
          function error() {
              if (finishing || erroringRef.value)
                  return;
              if (!loadingRef.value) {
                  void start(100, 100, 'error').then(() => {
                      erroringRef.value = true;
                      const el = loadingBarRef.value;
                      if (!el)
                          return;
                      el.className = createClassName('error', mergedClsPrefixRef.value);
                      void el.offsetWidth;
                      loadingRef.value = false;
                  });
              }
              else {
                  erroringRef.value = true;
                  const el = loadingBarRef.value;
                  if (!el)
                      return;
                  el.className = createClassName('error', mergedClsPrefixRef.value);
                  el.style.maxWidth = '100%';
                  void el.offsetWidth;
                  loadingRef.value = false;
              }
          }
          function handleEnter() {
              enteringRef.value = true;
          }
          function handleAfterEnter() {
              enteringRef.value = false;
          }
          function handleAfterLeave() {
              return __awaiter$3(this, void 0, void 0, function* () {
                  yield init();
              });
          }
          const themeRef = useTheme('LoadingBar', '-loading-bar', style$y, loadingBarLight$1, providerProps, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { height, colorError, colorLoading } } = themeRef.value;
              return {
                  '--n-height': height,
                  '--n-color-loading': colorLoading,
                  '--n-color-error': colorError
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('loading-bar', undefined, cssVarsRef, providerProps)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              loadingBarRef,
              started: startedRef,
              loading: loadingRef,
              entering: enteringRef,
              transitionDisabled: transitionDisabledRef,
              start,
              error,
              finish,
              handleEnter,
              handleAfterEnter,
              handleAfterLeave,
              mergedLoadingBarStyle,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          if (!this.started)
              return null;
          const { mergedClsPrefix } = this;
          return (h(Transition, { name: "fade-in-transition", appear: true, onEnter: this.handleEnter, onAfterEnter: this.handleAfterEnter, 
              // eslint-disable-next-line @typescript-eslint/no-misused-promises
              onAfterLeave: this.handleAfterLeave, css: !this.transitionDisabled }, {
              default: () => {
                  var _a;
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  return withDirectives(h("div", { class: [
                          `${mergedClsPrefix}-loading-bar-container`,
                          this.themeClass,
                          this.containerClass
                      ], style: this.containerStyle },
                      h("div", { ref: "loadingBarRef", class: [`${mergedClsPrefix}-loading-bar`], style: [
                              this.cssVars,
                              this.mergedLoadingBarStyle
                          ] })), [[vShow, this.loading || (!this.loading && this.entering)]]);
              }
          }));
      }
  });

  const loadingBarProviderProps = Object.assign(Object.assign({}, useTheme.props), { to: {
          type: [String, Object, Boolean],
          default: undefined
      }, containerClass: String, containerStyle: [String, Object], loadingBarStyle: {
          type: Object
      } });
  var NLoadingBarProvider = defineComponent({
      name: 'LoadingBarProvider',
      props: loadingBarProviderProps,
      setup(props) {
          const isMountedRef = isMounted();
          const loadingBarRef = ref(null);
          const methods = {
              start() {
                  var _a;
                  if (isMountedRef.value) {
                      (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.start();
                  }
                  else {
                      void nextTick(() => {
                          var _a;
                          (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.start();
                      });
                  }
              },
              error() {
                  var _a;
                  if (isMountedRef.value) {
                      (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.error();
                  }
                  else {
                      void nextTick(() => {
                          var _a;
                          (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.error();
                      });
                  }
              },
              finish() {
                  var _a;
                  if (isMountedRef.value) {
                      (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.finish();
                  }
                  else {
                      void nextTick(() => {
                          var _a;
                          (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.finish();
                      });
                  }
              }
          };
          const { mergedClsPrefixRef } = useConfig(props);
          provide(loadingBarApiInjectionKey, methods);
          provide(loadingBarProviderInjectionKey, {
              props,
              mergedClsPrefixRef
          });
          return Object.assign(methods, {
              loadingBarRef
          });
      },
      render() {
          var _a, _b;
          return (h(Fragment, null,
              h(Teleport, { disabled: this.to === false, to: this.to || 'body' },
                  h(NLoadingBar, { ref: "loadingBarRef", containerStyle: this.containerStyle, containerClass: this.containerClass })), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 :
              _b.call(_a)));
      }
  });

  function useLoadingBar() {
      const loadingBar = inject(loadingBarApiInjectionKey, null);
      if (loadingBar === null) {
          throwError('use-loading-bar', 'No outer <n-loading-bar-provider /> founded.');
      }
      return loadingBar;
  }

  var NLogLoader = defineComponent({
      name: 'LogLoader',
      props: {
          clsPrefix: {
              type: String,
              required: true
          }
      },
      setup() {
          return {
              locale: useLocale('Log').localeRef
          };
      },
      render() {
          const { clsPrefix } = this;
          return (h("div", { class: `${clsPrefix}-log-loader` },
              h(NBaseLoading, { clsPrefix: clsPrefix, strokeWidth: 24, scale: 0.85 }),
              h("span", { class: `${clsPrefix}-log-loader__content` }, this.locale.loading)));
      }
  });

  const logInjectionKey = createInjectionKey('n-log');

  var NLogLine = defineComponent({
      props: {
          line: {
              type: String,
              default: ''
          }
      },
      setup(props) {
          const { trimRef, highlightRef, languageRef, mergedHljsRef } = 
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(logInjectionKey);
          const selfRef = ref(null);
          const maybeTrimmedLinesRef = computed(() => {
              return trimRef.value ? props.line.trim() : props.line;
          });
          function setInnerHTML() {
              if (selfRef.value) {
                  selfRef.value.innerHTML = generateCodeHTML(languageRef.value, maybeTrimmedLinesRef.value);
              }
          }
          function generateCodeHTML(language, code) {
              const { value: hljs } = mergedHljsRef;
              if (hljs) {
                  if (language && hljs.getLanguage(language)) {
                      return hljs.highlight(code, { language }).value;
                  }
              }
              return code;
          }
          onMounted(() => {
              if (highlightRef.value) {
                  setInnerHTML();
              }
          });
          watch(toRef(props, 'line'), () => {
              if (highlightRef.value) {
                  setInnerHTML();
              }
          });
          return {
              highlight: highlightRef,
              selfRef,
              maybeTrimmedLines: maybeTrimmedLinesRef
          };
      },
      render() {
          const { highlight, maybeTrimmedLines } = this;
          return h("pre", { ref: "selfRef" }, highlight ? null : maybeTrimmedLines);
      }
  });

  // vars:
  // --n-bezier
  // --n-loading-color
  // --n-loader-border
  // --n-loader-color
  // --n-loader-text-color
  // --n-loader-font-size
  // --n-loading-color
  var style$x = cB('log', `
 position: relative;
 box-sizing: border-box;
 transition: border-color .3s var(--n-bezier);
`, [c$1('pre', `
 white-space: pre-wrap;
 word-break: break-word;
 margin: 0;
 `), cB('log-loader', `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 box-sizing: border-box;
 position: absolute;
 right: 16px;
 top: 8px;
 height: 34px;
 border-radius: 17px;
 line-height: 34px;
 white-space: nowrap;
 overflow: hidden;
 border: var(--n-loader-border);
 color: var(--n-loader-text-color);
 background-color: var(--n-loader-color);
 font-size: var(--n-loader-font-size);
 `, [fadeInScaleUpTransition(), cE('content', `
 display: inline-block;
 vertical-align: bottom;
 line-height: 34px;
 padding-left: 40px;
 padding-right: 20px;
 white-space: nowrap;
 `), cB('base-loading', `
 color: var(--n-loading-color);
 position: absolute;
 left: 12px;
 top: calc(50% - 10px);
 font-size: 20px;
 width: 20px;
 height: 20px;
 display: inline-block;
 `)])]);

  const logProps = Object.assign(Object.assign({}, useTheme.props), { loading: Boolean, trim: Boolean, log: String, fontSize: {
          type: Number,
          default: 14
      }, lines: {
          type: Array,
          default: () => []
      }, lineHeight: {
          type: Number,
          default: 1.25
      }, language: String, rows: {
          type: Number,
          default: 15
      }, offsetTop: {
          type: Number,
          default: 0
      }, offsetBottom: {
          type: Number,
          default: 0
      }, hljs: Object, onReachTop: Function, onReachBottom: Function, onRequireMore: Function });
  var Log = defineComponent({
      name: 'Log',
      props: logProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const silentRef = ref(false);
          const highlightRef = computed(() => {
              return props.language !== undefined;
          });
          const styleHeightRef = computed(() => {
              return `calc(${Math.round(props.rows * props.lineHeight * props.fontSize)}px)`;
          });
          const mergedLinesRef = computed(() => {
              const { log } = props;
              if (log) {
                  return log.split('\n');
              }
              return props.lines;
          });
          const scrollbarRef = ref(null);
          const themeRef = useTheme('Log', '-log', style$x, logLight$1, props, mergedClsPrefixRef);
          function handleScroll(e) {
              const container = e.target;
              const content = container.firstElementChild;
              if (silentRef.value) {
                  void nextTick(() => {
                      silentRef.value = false;
                  });
                  return;
              }
              const containerHeight = container.offsetHeight;
              const containerScrollTop = container.scrollTop;
              const contentHeight = content.offsetHeight;
              const scrollTop = containerScrollTop;
              const scrollBottom = contentHeight - containerScrollTop - containerHeight;
              if (scrollTop <= props.offsetTop) {
                  const { onReachTop, onRequireMore } = props;
                  if (onRequireMore)
                      onRequireMore('top');
                  if (onReachTop)
                      onReachTop();
              }
              if (scrollBottom <= props.offsetBottom) {
                  const { onReachBottom, onRequireMore } = props;
                  if (onRequireMore)
                      onRequireMore('bottom');
                  if (onReachBottom)
                      onReachBottom();
              }
          }
          const handleWheel = throttle(_handleWheel, 300);
          function _handleWheel(e) {
              if (silentRef.value) {
                  void nextTick(() => {
                      silentRef.value = false;
                  });
                  return;
              }
              if (scrollbarRef.value) {
                  const { containerRef, contentRef } = scrollbarRef.value;
                  if (containerRef && contentRef) {
                      const containerHeight = containerRef.offsetHeight;
                      const containerScrollTop = containerRef.scrollTop;
                      const contentHeight = contentRef.offsetHeight;
                      const scrollTop = containerScrollTop;
                      const scrollBottom = contentHeight - containerScrollTop - containerHeight;
                      const deltaY = e.deltaY;
                      if (scrollTop === 0 && deltaY < 0) {
                          const { onRequireMore } = props;
                          if (onRequireMore)
                              onRequireMore('top');
                      }
                      if (scrollBottom <= 0 && deltaY > 0) {
                          const { onRequireMore } = props;
                          if (onRequireMore)
                              onRequireMore('bottom');
                      }
                  }
              }
          }
          function scrollTo(options) {
              const { value: scrollbarInst } = scrollbarRef;
              if (!scrollbarInst)
                  return;
              const { silent, top, position } = options;
              if (silent) {
                  silentRef.value = true;
              }
              if (top !== undefined) {
                  scrollbarInst.scrollTo({ left: 0, top });
              }
              else if (position === 'bottom' || position === 'top') {
                  scrollbarInst.scrollTo({ position });
              }
          }
          // deprecated
          function scrollToTop(silent = false) {
              warn$2('log', "`scrollToTop` is deprecated, please use `scrollTo({ position: 'top'})` instead.");
              scrollTo({
                  position: 'top',
                  silent
              });
          }
          function scrollToBottom(silent = false) {
              warn$2('log', "`scrollToTop` is deprecated, please use `scrollTo({ position: 'bottom'})` instead.");
              scrollTo({
                  position: 'bottom',
                  silent
              });
          }
          provide(logInjectionKey, {
              languageRef: toRef(props, 'language'),
              mergedHljsRef: useHljs(props),
              trimRef: toRef(props, 'trim'),
              highlightRef
          });
          const exportedMethods = {
              scrollTo
          };
          const cssVarsRef = computed(() => {
              const { self: { loaderFontSize, loaderTextColor, loaderColor, loaderBorder, loadingColor }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-loader-font-size': loaderFontSize,
                  '--n-loader-border': loaderBorder,
                  '--n-loader-color': loaderColor,
                  '--n-loader-text-color': loaderTextColor,
                  '--n-loading-color': loadingColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('log', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exportedMethods), { mergedClsPrefix: mergedClsPrefixRef, scrollbarRef, mergedTheme: themeRef, styleHeight: styleHeightRef, mergedLines: mergedLinesRef, scrollToTop,
              scrollToBottom,
              handleWheel,
              handleScroll, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          const { mergedClsPrefix, mergedTheme, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return h('div', {
              class: [`${mergedClsPrefix}-log`, this.themeClass],
              style: [
                  {
                      lineHeight: this.lineHeight,
                      height: this.styleHeight
                  },
                  this.cssVars
              ],
              onWheelPassive: this.handleWheel
          }, [
              h(NScrollbar, { ref: "scrollbarRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, onScroll: this.handleScroll }, {
                  default: () => (h(NCode, { internalNoHighlight: true, internalFontSize: this.fontSize, theme: mergedTheme.peers.Code, themeOverrides: mergedTheme.peerOverrides.Code }, {
                      default: () => this.mergedLines.map((line, index) => {
                          return h(NLogLine, { key: index, line: line });
                      })
                  }))
              }),
              h(Transition, { name: "fade-in-scale-up-transition" }, {
                  default: () => this.loading ? h(NLogLoader, { clsPrefix: mergedClsPrefix }) : null
              })
          ]);
      }
  });

  const menuInjectionKey = createInjectionKey('n-menu');
  const submenuInjectionKey = createInjectionKey('n-submenu');
  const menuItemGroupInjectionKey = createInjectionKey('n-menu-item-group');

  const ICON_MARGIN_RIGHT = 8;
  function useMenuChild(props) {
      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      const NMenu = inject(menuInjectionKey);
      const { props: menuProps, mergedCollapsedRef } = NMenu;
      const NSubmenu = inject(submenuInjectionKey, null);
      const NMenuOptionGroup = inject(menuItemGroupInjectionKey, null);
      const horizontalRef = computed(() => {
          return menuProps.mode === 'horizontal';
      });
      const dropdownPlacementRef = computed(() => {
          if (horizontalRef.value) {
              return menuProps.dropdownPlacement;
          }
          if ('tmNodes' in props)
              return 'right-start';
          return 'right';
      });
      const maxIconSizeRef = computed(() => {
          var _a;
          return Math.max((_a = menuProps.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps.iconSize, menuProps.iconSize);
      });
      const activeIconSizeRef = computed(() => {
          var _a;
          if (!horizontalRef.value && props.root && mergedCollapsedRef.value) {
              return (_a = menuProps.collapsedIconSize) !== null && _a !== void 0 ? _a : menuProps.iconSize;
          }
          else {
              return menuProps.iconSize;
          }
      });
      const paddingLeftRef = computed(() => {
          if (horizontalRef.value)
              return undefined;
          const { collapsedWidth, indent, rootIndent } = menuProps;
          const { root, isGroup } = props;
          const mergedRootIndent = rootIndent === undefined ? indent : rootIndent;
          if (root) {
              if (mergedCollapsedRef.value) {
                  return collapsedWidth / 2 - maxIconSizeRef.value / 2;
              }
              return mergedRootIndent;
          }
          if (NMenuOptionGroup &&
              typeof NMenuOptionGroup.paddingLeftRef.value === 'number') {
              return indent / 2 + NMenuOptionGroup.paddingLeftRef.value;
          }
          if (NSubmenu && typeof NSubmenu.paddingLeftRef.value === 'number') {
              return (isGroup ? indent / 2 : indent) + NSubmenu.paddingLeftRef.value;
          }
          return 0;
      });
      const iconMarginRightRef = computed(() => {
          const { collapsedWidth, indent, rootIndent } = menuProps;
          const { value: maxIconSize } = maxIconSizeRef;
          const { root } = props;
          if (horizontalRef.value)
              return ICON_MARGIN_RIGHT;
          if (!root)
              return ICON_MARGIN_RIGHT;
          if (!mergedCollapsedRef.value)
              return ICON_MARGIN_RIGHT;
          const mergedRootIndent = rootIndent === undefined ? indent : rootIndent;
          return (mergedRootIndent +
              maxIconSize +
              ICON_MARGIN_RIGHT -
              (collapsedWidth + maxIconSize) / 2);
      });
      return {
          dropdownPlacement: dropdownPlacementRef,
          activeIconSize: activeIconSizeRef,
          maxIconSize: maxIconSizeRef,
          paddingLeft: paddingLeftRef,
          iconMarginRight: iconMarginRightRef,
          NMenu,
          NSubmenu
      };
  }

  const useMenuChildProps = {
      internalKey: {
          type: [String, Number],
          required: true
      },
      root: Boolean,
      isGroup: Boolean,
      level: {
          type: Number,
          required: true
      },
      title: [String, Function],
      extra: [String, Function]
  };

  const menuItemGroupProps = Object.assign(Object.assign({}, useMenuChildProps), { tmNode: {
          type: Object,
          required: true
      }, tmNodes: {
          type: Array,
          required: true
      } });
  const NMenuOptionGroup = defineComponent({
      name: 'MenuOptionGroup',
      props: menuItemGroupProps,
      setup(props) {
          provide(submenuInjectionKey, null);
          const MenuChild = useMenuChild(props);
          provide(menuItemGroupInjectionKey, {
              paddingLeftRef: MenuChild.paddingLeft
          });
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedClsPrefixRef, props: menuProps } = inject(menuInjectionKey);
          return function () {
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              const paddingLeft = MenuChild.paddingLeft.value;
              const { nodeProps } = menuProps;
              const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(props.tmNode.rawNode);
              return (h("div", { class: `${mergedClsPrefix}-menu-item-group`, role: "group" },
                  h("div", Object.assign({}, attrs, { class: [`${mergedClsPrefix}-menu-item-group-title`, attrs === null || attrs === void 0 ? void 0 : attrs.class], style: [
                          (attrs === null || attrs === void 0 ? void 0 : attrs.style) || '',
                          paddingLeft !== undefined ? `padding-left: ${paddingLeft}px;` : ''
                      ] }),
                      render$1(props.title),
                      props.extra ? h(Fragment, null,
                          " ",
                          render$1(props.extra)) : null),
                  h("div", null, props.tmNodes.map((tmNode) => itemRenderer(tmNode, menuProps)))));
          };
      }
  });

  var NMenuOptionContent = defineComponent({
      name: 'MenuOptionContent',
      props: {
          collapsed: Boolean,
          disabled: Boolean,
          title: [String, Function],
          icon: Function,
          extra: [String, Function],
          showArrow: Boolean,
          childActive: Boolean,
          hover: Boolean,
          paddingLeft: Number,
          selected: Boolean,
          maxIconSize: {
              type: Number,
              required: true
          },
          activeIconSize: {
              type: Number,
              required: true
          },
          iconMarginRight: {
              type: Number,
              required: true
          },
          clsPrefix: {
              type: String,
              required: true
          },
          onClick: Function,
          tmNode: {
              type: Object,
              required: true
          },
          isEllipsisPlaceholder: Boolean
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { props: menuProps } = inject(menuInjectionKey);
          return {
              menuProps,
              style: computed(() => {
                  const { paddingLeft } = props;
                  return { paddingLeft: paddingLeft && `${paddingLeft}px` };
              }),
              iconStyle: computed(() => {
                  const { maxIconSize, activeIconSize, iconMarginRight } = props;
                  return {
                      width: `${maxIconSize}px`,
                      height: `${maxIconSize}px`,
                      fontSize: `${activeIconSize}px`,
                      marginRight: `${iconMarginRight}px`
                  };
              })
          };
      },
      render() {
          const { clsPrefix, tmNode, menuProps: { renderIcon, renderLabel, renderExtra, expandIcon } } = this;
          const icon = renderIcon ? renderIcon(tmNode.rawNode) : render$1(this.icon);
          return (h("div", { onClick: (e) => {
                  var _a;
                  (_a = this.onClick) === null || _a === void 0 ? void 0 : _a.call(this, e);
              }, role: "none", class: [
                  `${clsPrefix}-menu-item-content`,
                  {
                      [`${clsPrefix}-menu-item-content--selected`]: this.selected,
                      [`${clsPrefix}-menu-item-content--collapsed`]: this.collapsed,
                      [`${clsPrefix}-menu-item-content--child-active`]: this.childActive,
                      [`${clsPrefix}-menu-item-content--disabled`]: this.disabled,
                      [`${clsPrefix}-menu-item-content--hover`]: this.hover
                  }
              ], style: this.style },
              icon && (h("div", { class: `${clsPrefix}-menu-item-content__icon`, style: this.iconStyle, role: "none" }, [icon])),
              h("div", { class: `${clsPrefix}-menu-item-content-header`, role: "none" },
                  this.isEllipsisPlaceholder
                      ? this.title
                      : renderLabel
                          ? renderLabel(tmNode.rawNode)
                          : render$1(this.title),
                  this.extra || renderExtra ? (h("span", { class: `${clsPrefix}-menu-item-content-header__extra` },
                      ' ',
                      renderExtra ? renderExtra(tmNode.rawNode) : render$1(this.extra))) : null),
              this.showArrow ? (h(NBaseIcon, { ariaHidden: true, class: `${clsPrefix}-menu-item-content__arrow`, clsPrefix: clsPrefix }, {
                  default: () => expandIcon ? (expandIcon(tmNode.rawNode)) : (h(ChevronDownFilledIcon, null))
              })) : null));
      }
  });

  const submenuProps = Object.assign(Object.assign({}, useMenuChildProps), { rawNodes: {
          type: Array,
          default: () => []
      }, tmNodes: {
          type: Array,
          default: () => []
      }, tmNode: {
          type: Object,
          required: true
      }, disabled: Boolean, icon: Function, onClick: Function, domId: String, virtualChildActive: {
          type: Boolean,
          default: undefined
      }, isEllipsisPlaceholder: Boolean });
  const NSubmenu = defineComponent({
      name: 'Submenu',
      props: submenuProps,
      setup(props) {
          const MenuChild = useMenuChild(props);
          const { NMenu, NSubmenu } = MenuChild;
          const { props: menuProps, mergedCollapsedRef, mergedThemeRef } = NMenu;
          const mergedDisabledRef = computed(() => {
              const { disabled } = props;
              if (NSubmenu === null || NSubmenu === void 0 ? void 0 : NSubmenu.mergedDisabledRef.value)
                  return true;
              if (menuProps.disabled)
                  return true;
              return disabled;
          });
          const dropdownShowRef = ref(false);
          provide(submenuInjectionKey, {
              paddingLeftRef: MenuChild.paddingLeft,
              mergedDisabledRef
          });
          provide(menuItemGroupInjectionKey, null);
          function doClick() {
              const { onClick } = props;
              if (onClick)
                  onClick();
          }
          function handleClick() {
              if (!mergedDisabledRef.value) {
                  if (!mergedCollapsedRef.value) {
                      NMenu.toggleExpand(props.internalKey);
                  }
                  doClick();
              }
          }
          function handlePopoverShowChange(value) {
              dropdownShowRef.value = value;
          }
          return {
              menuProps,
              mergedTheme: mergedThemeRef,
              doSelect: NMenu.doSelect,
              inverted: NMenu.invertedRef,
              isHorizontal: NMenu.isHorizontalRef,
              mergedClsPrefix: NMenu.mergedClsPrefixRef,
              maxIconSize: MenuChild.maxIconSize,
              activeIconSize: MenuChild.activeIconSize,
              iconMarginRight: MenuChild.iconMarginRight,
              dropdownPlacement: MenuChild.dropdownPlacement,
              dropdownShow: dropdownShowRef,
              paddingLeft: MenuChild.paddingLeft,
              mergedDisabled: mergedDisabledRef,
              mergedValue: NMenu.mergedValueRef,
              childActive: useMemo(() => {
                  var _a;
                  return ((_a = props.virtualChildActive) !== null && _a !== void 0 ? _a : NMenu.activePathRef.value.includes(props.internalKey));
              }),
              collapsed: computed(() => {
                  if (menuProps.mode === 'horizontal')
                      return false;
                  if (mergedCollapsedRef.value) {
                      return true;
                  }
                  return !NMenu.mergedExpandedKeysRef.value.includes(props.internalKey);
              }),
              dropdownEnabled: computed(() => {
                  return (!mergedDisabledRef.value &&
                      (menuProps.mode === 'horizontal' || mergedCollapsedRef.value));
              }),
              handlePopoverShowChange,
              handleClick
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix, menuProps: { renderIcon, renderLabel } } = this;
          const createSubmenuItem = () => {
              const { isHorizontal, paddingLeft, collapsed, mergedDisabled, maxIconSize, activeIconSize, title, childActive, icon, handleClick, menuProps: { nodeProps }, dropdownShow, iconMarginRight, tmNode, mergedClsPrefix, isEllipsisPlaceholder, extra } = this;
              const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
              return (h("div", Object.assign({}, attrs, { class: [`${mergedClsPrefix}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class], role: "menuitem" }),
                  h(NMenuOptionContent, { tmNode: tmNode, paddingLeft: paddingLeft, collapsed: collapsed, disabled: mergedDisabled, iconMarginRight: iconMarginRight, maxIconSize: maxIconSize, activeIconSize: activeIconSize, title: title, extra: extra, showArrow: !isHorizontal, childActive: childActive, clsPrefix: mergedClsPrefix, icon: icon, hover: dropdownShow, onClick: handleClick, isEllipsisPlaceholder: isEllipsisPlaceholder })));
          };
          const createSubmenuChildren = () => {
              return (h(NFadeInExpandTransition, null, {
                  default: () => {
                      const { tmNodes, collapsed } = this;
                      return !collapsed ? (h("div", { class: `${mergedClsPrefix}-submenu-children`, role: "menu" }, tmNodes.map((item) => itemRenderer(item, this.menuProps)))) : null;
                  }
              }));
          };
          return this.root ? (h(NDropdown, Object.assign({ size: "large", trigger: "hover" }, (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.dropdownProps, { themeOverrides: this.mergedTheme.peerOverrides.Dropdown, theme: this.mergedTheme.peers.Dropdown, builtinThemeOverrides: {
                  fontSizeLarge: '14px',
                  optionIconSizeLarge: '18px'
              }, value: this.mergedValue, disabled: !this.dropdownEnabled, placement: this.dropdownPlacement, keyField: this.menuProps.keyField, labelField: this.menuProps.labelField, childrenField: this.menuProps.childrenField, onUpdateShow: this.handlePopoverShowChange, options: this.rawNodes, onSelect: this.doSelect, inverted: this.inverted, renderIcon: renderIcon, renderLabel: renderLabel }), {
              default: () => (h("div", { class: `${mergedClsPrefix}-submenu`, role: "menuitem", "aria-expanded": !this.collapsed, id: this.domId },
                  createSubmenuItem(),
                  this.isHorizontal ? null : createSubmenuChildren()))
          })) : (h("div", { class: `${mergedClsPrefix}-submenu`, role: "menuitem", "aria-expanded": !this.collapsed, id: this.domId },
              createSubmenuItem(),
              createSubmenuChildren()));
      }
  });

  const menuItemProps = Object.assign(Object.assign({}, useMenuChildProps), { tmNode: {
          type: Object,
          required: true
      }, disabled: Boolean, icon: Function, onClick: Function });
  const NMenuOption = defineComponent({
      name: 'MenuOption',
      props: menuItemProps,
      setup(props) {
          const MenuChild = useMenuChild(props);
          const { NSubmenu, NMenu } = MenuChild;
          const { props: menuProps, mergedClsPrefixRef, mergedCollapsedRef } = NMenu;
          const submenuDisabledRef = NSubmenu
              ? NSubmenu.mergedDisabledRef
              : { value: false };
          const mergedDisabledRef = computed(() => {
              return submenuDisabledRef.value || props.disabled;
          });
          function doClick(e) {
              const { onClick } = props;
              if (onClick)
                  onClick(e);
          }
          function handleClick(e) {
              if (!mergedDisabledRef.value) {
                  NMenu.doSelect(props.internalKey, props.tmNode.rawNode);
                  doClick(e);
              }
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              dropdownPlacement: MenuChild.dropdownPlacement,
              paddingLeft: MenuChild.paddingLeft,
              iconMarginRight: MenuChild.iconMarginRight,
              maxIconSize: MenuChild.maxIconSize,
              activeIconSize: MenuChild.activeIconSize,
              mergedTheme: NMenu.mergedThemeRef,
              menuProps,
              dropdownEnabled: useMemo(() => {
                  return (props.root &&
                      mergedCollapsedRef.value &&
                      menuProps.mode !== 'horizontal' &&
                      !mergedDisabledRef.value);
              }),
              selected: useMemo(() => {
                  if (NMenu.mergedValueRef.value === props.internalKey)
                      return true;
                  return false;
              }),
              mergedDisabled: mergedDisabledRef,
              handleClick
          };
      },
      render() {
          const { mergedClsPrefix, mergedTheme, tmNode, menuProps: { renderLabel, nodeProps } } = this;
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(tmNode.rawNode);
          return (h("div", Object.assign({}, attrs, { role: "menuitem", class: [`${mergedClsPrefix}-menu-item`, attrs === null || attrs === void 0 ? void 0 : attrs.class] }),
              h(NTooltip, { theme: mergedTheme.peers.Tooltip, themeOverrides: mergedTheme.peerOverrides.Tooltip, trigger: "hover", placement: this.dropdownPlacement, disabled: !this.dropdownEnabled || this.title === undefined, internalExtraClass: ['menu-tooltip'] }, {
                  default: () => renderLabel ? renderLabel(tmNode.rawNode) : render$1(this.title),
                  trigger: () => (h(NMenuOptionContent, { tmNode: tmNode, clsPrefix: mergedClsPrefix, paddingLeft: this.paddingLeft, iconMarginRight: this.iconMarginRight, maxIconSize: this.maxIconSize, activeIconSize: this.activeIconSize, selected: this.selected, title: this.title, extra: this.extra, disabled: this.mergedDisabled, icon: this.icon, onClick: this.handleClick }))
              })));
      }
  });

  var NMenuDivider = defineComponent({
      name: 'MenuDivider',
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NMenu = inject(menuInjectionKey);
          const { mergedClsPrefixRef, isHorizontalRef } = NMenu;
          return () => isHorizontalRef.value ? null : (h("div", { class: `${mergedClsPrefixRef.value}-menu-divider` }));
      }
  });

  const groupPropKeys = keysOf(menuItemGroupProps);
  const itemPropKeys = keysOf(menuItemProps);
  const submenuPropKeys = keysOf(submenuProps);
  function isIgnoredNode(rawNode) {
      return rawNode.type === 'divider' || rawNode.type === 'render';
  }
  function isDividerNode(rawNode) {
      return rawNode.type === 'divider';
  }
  function itemRenderer(tmNode, menuProps) {
      const { rawNode } = tmNode;
      const { show } = rawNode;
      if (show === false) {
          return null;
      }
      if (isIgnoredNode(rawNode)) {
          if (isDividerNode(rawNode)) {
              return h(NMenuDivider, Object.assign({ key: tmNode.key }, rawNode.props));
          }
          return null;
      }
      const { labelField } = menuProps;
      const { key, level, isGroup } = tmNode;
      const props = Object.assign(Object.assign({}, rawNode), { title: (rawNode.title || rawNode[labelField]), extra: rawNode.titleExtra || rawNode.extra, key, internalKey: key, // since key can't be used as a prop
          level, root: level === 0, isGroup });
      if (tmNode.children) {
          if (tmNode.isGroup) {
              return h(NMenuOptionGroup, keep(props, groupPropKeys, { tmNode, tmNodes: tmNode.children, key }));
          }
          return h(NSubmenu, keep(props, submenuPropKeys, {
              key,
              rawNodes: rawNode[menuProps.childrenField],
              tmNodes: tmNode.children,
              tmNode
          }));
      }
      else {
          return h(NMenuOption, keep(props, itemPropKeys, {
              key,
              tmNode
          }));
      }
  }

  const hoverStyleChildren = [c$1('&::before', 'background-color: var(--n-item-color-hover);'), cE('arrow', `
 color: var(--n-arrow-color-hover);
 `), cE('icon', `
 color: var(--n-item-icon-color-hover);
 `), cB('menu-item-content-header', `
 color: var(--n-item-text-color-hover);
 `, [c$1('a', `
 color: var(--n-item-text-color-hover);
 `), cE('extra', `
 color: var(--n-item-text-color-hover);
 `)])];
  const horizontalHoverStyleChildren = [cE('icon', `
 color: var(--n-item-icon-color-hover-horizontal);
 `), cB('menu-item-content-header', `
 color: var(--n-item-text-color-hover-horizontal);
 `, [c$1('a', `
 color: var(--n-item-text-color-hover-horizontal);
 `), cE('extra', `
 color: var(--n-item-text-color-hover-horizontal);
 `)])];
  // vars:
  // --n-color
  // --n-group-text-color
  // --n-bezier
  // --n-font-size
  // --n-border-color-horizontal
  // --n-border-radius
  // --n-item-color-hover
  // --n-item-color-active
  // --n-item-color-active-hover
  // --n-item-color-active-collapsed
  // --n-arrow-color
  // --n-arrow-color-hover
  // --n-arrow-color-active
  // --n-arrow-color-active-hover
  // --n-arrow-color-child-active
  // --n-arrow-color-child-active-hover
  // --n-item-text-color
  // --n-item-text-color-hover
  // --n-item-text-color-active
  // --n-item-text-color-active-hover
  // --n-item-text-color-child-active
  // --n-item-text-color-child-active-hover
  // --n-item-text-color-horizontal
  // --n-item-text-color-hover-horizontal
  // --n-item-text-color-active-horizontal
  // --n-item-text-color-active-hover-horizontal
  // --n-item-text-color-child-active-horizontal
  // --n-item-text-color-child-active-hover-horizontal
  // --n-item-icon-color
  // --n-item-icon-color-hover
  // --n-item-icon-color-active
  // --n-item-icon-color-active-hover
  // --n-item-icon-color-child-active
  // --n-item-icon-color-child-active-hover
  // --n-item-icon-color-collapsed
  // --n-item-icon-color-horizontal
  // --n-item-icon-color-hover-horizontal
  // --n-item-icon-color-active-horizontal
  // --n-item-icon-color-active-hover-horizontal
  // --n-item-icon-color-child-active-horizontal
  // --n-item-icon-color-child-active-hover-horizontal
  // --n-item-height
  var style$w = c$1([cB('menu', `
 background-color: var(--n-color);
 color: var(--n-item-text-color);
 overflow: hidden;
 transition: background-color .3s var(--n-bezier);
 box-sizing: border-box;
 font-size: var(--n-font-size);
 padding-bottom: 6px;
 `, [cM('horizontal', `
 max-width: 100%;
 width: 100%;
 display: flex;
 overflow: hidden;
 padding-bottom: 0;
 `, [cB('submenu', 'margin: 0;'), cB('menu-item', 'margin: 0;'), cB('menu-item-content', `
 padding: 0 20px;
 border-bottom: 2px solid #0000;
 `, [c$1('&::before', 'display: none;'), cM('selected', 'border-bottom: 2px solid var(--n-border-color-horizontal)')]), cB('menu-item-content', [cM('selected', [cE('icon', 'color: var(--n-item-icon-color-active-horizontal);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-active-horizontal);
 `, [c$1('a', 'color: var(--n-item-text-color-active-horizontal);'), cE('extra', 'color: var(--n-item-text-color-active-horizontal);')])]), cM('child-active', `
 border-bottom: 2px solid var(--n-border-color-horizontal);
 `, [cB('menu-item-content-header', `
 color: var(--n-item-text-color-child-active-horizontal);
 `, [c$1('a', `
 color: var(--n-item-text-color-child-active-horizontal);
 `), cE('extra', `
 color: var(--n-item-text-color-child-active-horizontal);
 `)]), cE('icon', `
 color: var(--n-item-icon-color-child-active-horizontal);
 `)]), cNotM('disabled', [cNotM('selected, child-active', [c$1('&:focus-within', horizontalHoverStyleChildren)]), cM('selected', [hoverStyle(null, [cE('icon', 'color: var(--n-item-icon-color-active-hover-horizontal);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-active-hover-horizontal);
 `, [c$1('a', 'color: var(--n-item-text-color-active-hover-horizontal);'), cE('extra', 'color: var(--n-item-text-color-active-hover-horizontal);')])])]), cM('child-active', [hoverStyle(null, [cE('icon', 'color: var(--n-item-icon-color-child-active-hover-horizontal);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-child-active-hover-horizontal);
 `, [c$1('a', 'color: var(--n-item-text-color-child-active-hover-horizontal);'), cE('extra', 'color: var(--n-item-text-color-child-active-hover-horizontal);')])])]), hoverStyle('border-bottom: 2px solid var(--n-border-color-horizontal);', horizontalHoverStyleChildren)]), cB('menu-item-content-header', [c$1('a', 'color: var(--n-item-text-color-horizontal);')])])]), cNotM('responsive', [cB('menu-item-content-header', `
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cM('collapsed', [cB('menu-item-content', [cM('selected', [c$1('&::before', `
 background-color: var(--n-item-color-active-collapsed) !important;
 `)]), cB('menu-item-content-header', 'opacity: 0;'), cE('arrow', 'opacity: 0;'), cE('icon', 'color: var(--n-item-icon-color-collapsed);')])]), cB('menu-item', `
 height: var(--n-item-height);
 margin-top: 6px;
 position: relative;
 `), cB('menu-item-content', `
 box-sizing: border-box;
 line-height: 1.75;
 height: 100%;
 display: grid;
 grid-template-areas: "icon content arrow";
 grid-template-columns: auto 1fr auto;
 align-items: center;
 cursor: pointer;
 position: relative;
 padding-right: 18px;
 transition:
 background-color .3s var(--n-bezier),
 padding-left .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1('> *', 'z-index: 1;'), c$1('&::before', `
 z-index: auto;
 content: "";
 background-color: #0000;
 position: absolute;
 left: 8px;
 right: 8px;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cM('disabled', `
 opacity: .45;
 cursor: not-allowed;
 `), cM('collapsed', [cE('arrow', 'transform: rotate(0);')]), cM('selected', [c$1('&::before', 'background-color: var(--n-item-color-active);'), cE('arrow', 'color: var(--n-arrow-color-active);'), cE('icon', 'color: var(--n-item-icon-color-active);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-active);
 `, [c$1('a', 'color: var(--n-item-text-color-active);'), cE('extra', 'color: var(--n-item-text-color-active);')])]), cM('child-active', [cB('menu-item-content-header', `
 color: var(--n-item-text-color-child-active);
 `, [c$1('a', `
 color: var(--n-item-text-color-child-active);
 `), cE('extra', `
 color: var(--n-item-text-color-child-active);
 `)]), cE('arrow', `
 color: var(--n-arrow-color-child-active);
 `), cE('icon', `
 color: var(--n-item-icon-color-child-active);
 `)]), cNotM('disabled', [cNotM('selected, child-active', [c$1('&:focus-within', hoverStyleChildren)]), cM('selected', [hoverStyle(null, [cE('arrow', 'color: var(--n-arrow-color-active-hover);'), cE('icon', 'color: var(--n-item-icon-color-active-hover);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-active-hover);
 `, [c$1('a', 'color: var(--n-item-text-color-active-hover);'), cE('extra', 'color: var(--n-item-text-color-active-hover);')])])]), cM('child-active', [hoverStyle(null, [cE('arrow', 'color: var(--n-arrow-color-child-active-hover);'), cE('icon', 'color: var(--n-item-icon-color-child-active-hover);'), cB('menu-item-content-header', `
 color: var(--n-item-text-color-child-active-hover);
 `, [c$1('a', 'color: var(--n-item-text-color-child-active-hover);'), cE('extra', 'color: var(--n-item-text-color-child-active-hover);')])])]), cM('selected', [hoverStyle(null, [c$1('&::before', 'background-color: var(--n-item-color-active-hover);')])]), hoverStyle(null, hoverStyleChildren)]), cE('icon', `
 grid-area: icon;
 color: var(--n-item-icon-color);
 transition:
 color .3s var(--n-bezier),
 font-size .3s var(--n-bezier),
 margin-right .3s var(--n-bezier);
 box-sizing: content-box;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 `), cE('arrow', `
 grid-area: arrow;
 font-size: 16px;
 color: var(--n-arrow-color);
 transform: rotate(180deg);
 opacity: 1;
 transition:
 color .3s var(--n-bezier),
 transform 0.2s var(--n-bezier),
 opacity 0.2s var(--n-bezier);
 `), cB('menu-item-content-header', `
 grid-area: content;
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 opacity: 1;
 white-space: nowrap;
 color: var(--n-item-text-color);
 `, [c$1('a', `
 outline: none;
 text-decoration: none;
 transition: color .3s var(--n-bezier);
 color: var(--n-item-text-color);
 `, [c$1('&::before', `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cE('extra', `
 font-size: .93em;
 color: var(--n-group-text-color);
 transition: color .3s var(--n-bezier);
 `)])]), cB('submenu', `
 cursor: pointer;
 position: relative;
 margin-top: 6px;
 `, [cB('menu-item-content', `
 height: var(--n-item-height);
 `), cB('submenu-children', `
 overflow: hidden;
 padding: 0;
 `, [fadeInHeightExpandTransition({
    duration: '.2s'
  })])]), cB('menu-item-group', [cB('menu-item-group-title', `
 margin-top: 6px;
 color: var(--n-group-text-color);
 cursor: default;
 font-size: .93em;
 height: 36px;
 display: flex;
 align-items: center;
 transition:
 padding-left .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)])]), cB('menu-tooltip', [c$1('a', `
 color: inherit;
 text-decoration: none;
 `)]), cB('menu-divider', `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 6px 18px;
 `)]);
  function hoverStyle(props, children) {
    return [cM('hover', props, children), c$1('&:hover', props, children)];
  }

  const menuProps = Object.assign(Object.assign({}, useTheme.props), { options: {
          type: Array,
          default: () => []
      }, collapsed: {
          type: Boolean,
          default: undefined
      }, collapsedWidth: {
          type: Number,
          default: 48
      }, iconSize: {
          type: Number,
          default: 20
      }, collapsedIconSize: {
          type: Number,
          default: 24
      }, rootIndent: Number, indent: {
          type: Number,
          default: 32
      }, labelField: {
          type: String,
          default: 'label'
      }, keyField: {
          type: String,
          default: 'key'
      }, childrenField: {
          type: String,
          default: 'children'
      }, disabledField: {
          type: String,
          default: 'disabled'
      }, defaultExpandAll: Boolean, defaultExpandedKeys: Array, expandedKeys: Array, value: [String, Number], defaultValue: {
          type: [String, Number],
          default: null
      }, mode: {
          type: String,
          default: 'vertical'
      }, watchProps: {
          type: Array,
          default: undefined
      }, disabled: Boolean, show: {
          type: Boolean,
          default: true
      }, inverted: Boolean, 'onUpdate:expandedKeys': [Function, Array], onUpdateExpandedKeys: [Function, Array], onUpdateValue: [Function, Array], 'onUpdate:value': [Function, Array], expandIcon: Function, renderIcon: Function, renderLabel: Function, renderExtra: Function, dropdownProps: Object, accordion: Boolean, nodeProps: Function, dropdownPlacement: {
          type: String,
          default: 'bottom'
      }, responsive: Boolean, 
      // deprecated
      items: Array, onOpenNamesChange: [Function, Array], onSelect: [Function, Array], onExpandedNamesChange: [Function, Array], expandedNames: Array, defaultExpandedNames: Array });
  var Menu = defineComponent({
      name: 'Menu',
      props: menuProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Menu', '-menu', style$w, menuLight$1, props, mergedClsPrefixRef);
          const layoutSider = inject(layoutSiderInjectionKey, null);
          const mergedCollapsedRef = computed(() => {
              var _a;
              const { collapsed } = props;
              if (collapsed !== undefined)
                  return collapsed;
              if (layoutSider) {
                  const { collapseModeRef, collapsedRef } = layoutSider;
                  if (collapseModeRef.value === 'width') {
                      return (_a = collapsedRef.value) !== null && _a !== void 0 ? _a : false;
                  }
              }
              return false;
          });
          const treeMateRef = computed(() => {
              const { keyField, childrenField, disabledField } = props;
              return createTreeMate(props.items || props.options, {
                  getIgnored(node) {
                      return isIgnoredNode(node);
                  },
                  getChildren(node) {
                      return node[childrenField];
                  },
                  getDisabled(node) {
                      return node[disabledField];
                  },
                  getKey(node) {
                      var _a;
                      return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
                  }
              });
          });
          const treeKeysLevelOneRef = computed(() => new Set(treeMateRef.value.treeNodes.map((e) => e.key)));
          const { watchProps } = props;
          const uncontrolledValueRef = ref(null);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultValue')) {
              watchEffect(() => {
                  uncontrolledValueRef.value = props.defaultValue;
              });
          }
          else {
              uncontrolledValueRef.value = props.defaultValue;
          }
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const uncontrolledExpandedKeysRef = ref([]);
          const initUncontrolledExpandedKeys = () => {
              uncontrolledExpandedKeysRef.value = props.defaultExpandAll
                  ? treeMateRef.value.getNonLeafKeys()
                  : props.defaultExpandedNames ||
                      props.defaultExpandedKeys ||
                      treeMateRef.value.getPath(mergedValueRef.value, {
                          includeSelf: false
                      }).keyPath;
          };
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {
              watchEffect(initUncontrolledExpandedKeys);
          }
          else {
              initUncontrolledExpandedKeys();
          }
          const controlledExpandedKeysRef = useCompitable(props, [
              'expandedNames',
              'expandedKeys'
          ]);
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const tmNodesRef = computed(() => treeMateRef.value.treeNodes);
          const activePathRef = computed(() => {
              return treeMateRef.value.getPath(mergedValueRef.value).keyPath;
          });
          provide(menuInjectionKey, {
              props,
              mergedCollapsedRef,
              mergedThemeRef: themeRef,
              mergedValueRef,
              mergedExpandedKeysRef,
              activePathRef,
              mergedClsPrefixRef,
              isHorizontalRef: computed(() => props.mode === 'horizontal'),
              invertedRef: toRef(props, 'inverted'),
              doSelect,
              toggleExpand
          });
          function doSelect(value, item) {
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue, onSelect } = props;
              if (onUpdateValue) {
                  call(onUpdateValue, value, item);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, item);
              }
              if (onSelect) {
                  call(onSelect, value, item);
              }
              uncontrolledValueRef.value = value;
          }
          function doUpdateExpandedKeys(value) {
              const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys, onExpandedNamesChange, onOpenNamesChange } = props;
              if (_onUpdateExpandedKeys) {
                  call(_onUpdateExpandedKeys, value);
              }
              if (onUpdateExpandedKeys) {
                  call(onUpdateExpandedKeys, value);
              }
              // deprecated
              if (onExpandedNamesChange) {
                  call(onExpandedNamesChange, value);
              }
              if (onOpenNamesChange) {
                  call(onOpenNamesChange, value);
              }
              uncontrolledExpandedKeysRef.value = value;
          }
          function toggleExpand(key) {
              const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
              const index = currentExpandedKeys.findIndex((expanededKey) => expanededKey === key);
              if (~index) {
                  currentExpandedKeys.splice(index, 1);
              }
              else {
                  if (props.accordion) {
                      if (treeKeysLevelOneRef.value.has(key)) {
                          const closeKeyIndex = currentExpandedKeys.findIndex((e) => treeKeysLevelOneRef.value.has(e));
                          if (closeKeyIndex > -1) {
                              currentExpandedKeys.splice(closeKeyIndex, 1);
                          }
                      }
                  }
                  currentExpandedKeys.push(key);
              }
              doUpdateExpandedKeys(currentExpandedKeys);
          }
          const showOption = (key) => {
              const selectedKeyPath = treeMateRef.value.getPath(key !== null && key !== void 0 ? key : mergedValueRef.value, {
                  includeSelf: false
              }).keyPath;
              if (!selectedKeyPath.length)
                  return;
              const currentExpandedKeys = Array.from(mergedExpandedKeysRef.value);
              const nextExpandedKeys = new Set([
                  ...currentExpandedKeys,
                  ...selectedKeyPath
              ]);
              if (props.accordion) {
                  treeKeysLevelOneRef.value.forEach((firstLevelKey) => {
                      if (nextExpandedKeys.has(firstLevelKey) &&
                          !selectedKeyPath.includes(firstLevelKey)) {
                          nextExpandedKeys.delete(firstLevelKey);
                      }
                  });
              }
              doUpdateExpandedKeys(Array.from(nextExpandedKeys));
          };
          const cssVarsRef = computed(() => {
              const { inverted } = props;
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { borderRadius, borderColorHorizontal, fontSize, itemHeight, dividerColor } = self;
              const vars = {
                  '--n-divider-color': dividerColor,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-border-color-horizontal': borderColorHorizontal,
                  '--n-border-radius': borderRadius,
                  '--n-item-height': itemHeight
              };
              if (inverted) {
                  vars['--n-group-text-color'] = self.groupTextColorInverted;
                  vars['--n-color'] = self.colorInverted;
                  vars['--n-item-text-color'] = self.itemTextColorInverted;
                  vars['--n-item-text-color-hover'] = self.itemTextColorHoverInverted;
                  vars['--n-item-text-color-active'] = self.itemTextColorActiveInverted;
                  vars['--n-item-text-color-child-active'] =
                      self.itemTextColorChildActiveInverted;
                  vars['--n-item-text-color-child-active-hover'] =
                      self.itemTextColorChildActiveInverted;
                  vars['--n-item-text-color-active-hover'] =
                      self.itemTextColorActiveHoverInverted;
                  vars['--n-item-icon-color'] = self.itemIconColorInverted;
                  vars['--n-item-icon-color-hover'] = self.itemIconColorHoverInverted;
                  vars['--n-item-icon-color-active'] = self.itemIconColorActiveInverted;
                  vars['--n-item-icon-color-active-hover'] =
                      self.itemIconColorActiveHoverInverted;
                  vars['--n-item-icon-color-child-active'] =
                      self.itemIconColorChildActiveInverted;
                  vars['--n-item-icon-color-child-active-hover'] =
                      self.itemIconColorChildActiveHoverInverted;
                  vars['--n-item-icon-color-collapsed'] =
                      self.itemIconColorCollapsedInverted;
                  vars['--n-item-text-color-horizontal'] =
                      self.itemTextColorHorizontalInverted;
                  vars['--n-item-text-color-hover-horizontal'] =
                      self.itemTextColorHoverHorizontalInverted;
                  vars['--n-item-text-color-active-horizontal'] =
                      self.itemTextColorActiveHorizontalInverted;
                  vars['--n-item-text-color-child-active-horizontal'] =
                      self.itemTextColorChildActiveHorizontalInverted;
                  vars['--n-item-text-color-child-active-hover-horizontal'] =
                      self.itemTextColorChildActiveHoverHorizontalInverted;
                  vars['--n-item-text-color-active-hover-horizontal'] =
                      self.itemTextColorActiveHoverHorizontalInverted;
                  vars['--n-item-icon-color-horizontal'] =
                      self.itemIconColorHorizontalInverted;
                  vars['--n-item-icon-color-hover-horizontal'] =
                      self.itemIconColorHoverHorizontalInverted;
                  vars['--n-item-icon-color-active-horizontal'] =
                      self.itemIconColorActiveHorizontalInverted;
                  vars['--n-item-icon-color-active-hover-horizontal'] =
                      self.itemIconColorActiveHoverHorizontalInverted;
                  vars['--n-item-icon-color-child-active-horizontal'] =
                      self.itemIconColorChildActiveHorizontalInverted;
                  vars['--n-item-icon-color-child-active-hover-horizontal'] =
                      self.itemIconColorChildActiveHoverHorizontalInverted;
                  vars['--n-arrow-color'] = self.arrowColorInverted;
                  vars['--n-arrow-color-hover'] = self.arrowColorHoverInverted;
                  vars['--n-arrow-color-active'] = self.arrowColorActiveInverted;
                  vars['--n-arrow-color-active-hover'] =
                      self.arrowColorActiveHoverInverted;
                  vars['--n-arrow-color-child-active'] =
                      self.arrowColorChildActiveInverted;
                  vars['--n-arrow-color-child-active-hover'] =
                      self.arrowColorChildActiveHoverInverted;
                  vars['--n-item-color-hover'] = self.itemColorHoverInverted;
                  vars['--n-item-color-active'] = self.itemColorActiveInverted;
                  vars['--n-item-color-active-hover'] = self.itemColorActiveHoverInverted;
                  vars['--n-item-color-active-collapsed'] =
                      self.itemColorActiveCollapsedInverted;
              }
              else {
                  vars['--n-group-text-color'] = self.groupTextColor;
                  vars['--n-color'] = self.color;
                  vars['--n-item-text-color'] = self.itemTextColor;
                  vars['--n-item-text-color-hover'] = self.itemTextColorHover;
                  vars['--n-item-text-color-active'] = self.itemTextColorActive;
                  vars['--n-item-text-color-child-active'] = self.itemTextColorChildActive;
                  vars['--n-item-text-color-child-active-hover'] =
                      self.itemTextColorChildActiveHover;
                  vars['--n-item-text-color-active-hover'] = self.itemTextColorActiveHover;
                  vars['--n-item-icon-color'] = self.itemIconColor;
                  vars['--n-item-icon-color-hover'] = self.itemIconColorHover;
                  vars['--n-item-icon-color-active'] = self.itemIconColorActive;
                  vars['--n-item-icon-color-active-hover'] = self.itemIconColorActiveHover;
                  vars['--n-item-icon-color-child-active'] = self.itemIconColorChildActive;
                  vars['--n-item-icon-color-child-active-hover'] =
                      self.itemIconColorChildActiveHover;
                  vars['--n-item-icon-color-collapsed'] = self.itemIconColorCollapsed;
                  vars['--n-item-text-color-horizontal'] = self.itemTextColorHorizontal;
                  vars['--n-item-text-color-hover-horizontal'] =
                      self.itemTextColorHoverHorizontal;
                  vars['--n-item-text-color-active-horizontal'] =
                      self.itemTextColorActiveHorizontal;
                  vars['--n-item-text-color-child-active-horizontal'] =
                      self.itemTextColorChildActiveHorizontal;
                  vars['--n-item-text-color-child-active-hover-horizontal'] =
                      self.itemTextColorChildActiveHoverHorizontal;
                  vars['--n-item-text-color-active-hover-horizontal'] =
                      self.itemTextColorActiveHoverHorizontal;
                  vars['--n-item-icon-color-horizontal'] = self.itemIconColorHorizontal;
                  vars['--n-item-icon-color-hover-horizontal'] =
                      self.itemIconColorHoverHorizontal;
                  vars['--n-item-icon-color-active-horizontal'] =
                      self.itemIconColorActiveHorizontal;
                  vars['--n-item-icon-color-active-hover-horizontal'] =
                      self.itemIconColorActiveHoverHorizontal;
                  vars['--n-item-icon-color-child-active-horizontal'] =
                      self.itemIconColorChildActiveHorizontal;
                  vars['--n-item-icon-color-child-active-hover-horizontal'] =
                      self.itemIconColorChildActiveHoverHorizontal;
                  vars['--n-arrow-color'] = self.arrowColor;
                  vars['--n-arrow-color-hover'] = self.arrowColorHover;
                  vars['--n-arrow-color-active'] = self.arrowColorActive;
                  vars['--n-arrow-color-active-hover'] = self.arrowColorActiveHover;
                  vars['--n-arrow-color-child-active'] = self.arrowColorChildActive;
                  vars['--n-arrow-color-child-active-hover'] =
                      self.arrowColorChildActiveHover;
                  vars['--n-item-color-hover'] = self.itemColorHover;
                  vars['--n-item-color-active'] = self.itemColorActive;
                  vars['--n-item-color-active-hover'] = self.itemColorActiveHover;
                  vars['--n-item-color-active-collapsed'] = self.itemColorActiveCollapsed;
              }
              return vars;
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('menu', computed(() => (props.inverted ? 'a' : 'b')), cssVarsRef, props)
              : undefined;
          const ellipsisNodeId = createId();
          const overflowRef = ref(null);
          const counterRef = ref(null);
          let isFirstResize = true;
          const onResize = () => {
              var _a;
              if (isFirstResize) {
                  isFirstResize = false;
              }
              else {
                  (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
                      showAllItemsBeforeCalculate: true
                  });
              }
          };
          function getCounter() {
              return document.getElementById(ellipsisNodeId);
          }
          const ellipsisFromIndexRef = ref(-1);
          function onUpdateCount(count) {
              ellipsisFromIndexRef.value = props.options.length - count;
          }
          function onUpdateOverflow(overflow) {
              if (!overflow) {
                  ellipsisFromIndexRef.value = -1;
              }
          }
          const ellipsisOptionRef = computed(() => {
              const ellipsisFromIndex = ellipsisFromIndexRef.value;
              const option = {
                  children: ellipsisFromIndex === -1 ? [] : props.options.slice(ellipsisFromIndex)
              };
              return option;
          });
          const ellipsisTreeMateRef = computed(() => {
              const { childrenField, disabledField, keyField } = props;
              return createTreeMate([ellipsisOptionRef.value], {
                  getIgnored(node) {
                      return isIgnoredNode(node);
                  },
                  getChildren(node) {
                      return node[childrenField];
                  },
                  getDisabled(node) {
                      return node[disabledField];
                  },
                  getKey(node) {
                      var _a;
                      return (_a = node[keyField]) !== null && _a !== void 0 ? _a : node.name;
                  }
              });
          });
          const emptyTmNodeRef = computed(() => {
              return createTreeMate([
                  {}
              ]).treeNodes[0];
          });
          function renderCounter() {
              var _a;
              if (ellipsisFromIndexRef.value === -1) {
                  // Only a placeholder
                  return (h(NSubmenu, { root: true, level: 0, key: "__ellpisisGroupPlaceholder__", internalKey: "__ellpisisGroupPlaceholder__", title: "\u00B7\u00B7\u00B7", tmNode: emptyTmNodeRef.value, domId: ellipsisNodeId, isEllipsisPlaceholder: true }));
              }
              const tmNode = ellipsisTreeMateRef.value.treeNodes[0];
              const activePath = activePathRef.value;
              const childActive = !!((_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some((tmNode) => {
                  return activePath.includes(tmNode.key);
              }));
              return (h(NSubmenu, { level: 0, root: true, key: "__ellpisisGroup__", internalKey: "__ellpisisGroup__", title: "\u00B7\u00B7\u00B7", virtualChildActive: childActive, tmNode: tmNode, domId: ellipsisNodeId, rawNodes: tmNode.rawNode.children || [], tmNodes: tmNode.children || [], isEllipsisPlaceholder: true }));
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              controlledExpandedKeys: controlledExpandedKeysRef,
              uncontrolledExpanededKeys: uncontrolledExpandedKeysRef,
              mergedExpandedKeys: mergedExpandedKeysRef,
              uncontrolledValue: uncontrolledValueRef,
              mergedValue: mergedValueRef,
              activePath: activePathRef,
              tmNodes: tmNodesRef,
              mergedTheme: themeRef,
              mergedCollapsed: mergedCollapsedRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              overflowRef,
              counterRef,
              updateCounter: () => { },
              onResize,
              onUpdateOverflow,
              onUpdateCount,
              renderCounter,
              getCounter,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              showOption,
              deriveResponsiveState: onResize
          };
      },
      render() {
          const { mergedClsPrefix, mode, themeClass, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderMenuItemNodes = () => this.tmNodes.map((tmNode) => itemRenderer(tmNode, this.$props));
          const horizontal = mode === 'horizontal';
          const finalResponsive = horizontal && this.responsive;
          const renderMainNode = () => (h("div", { role: mode === 'horizontal' ? 'menubar' : 'menu', class: [
                  `${mergedClsPrefix}-menu`,
                  themeClass,
                  `${mergedClsPrefix}-menu--${mode}`,
                  finalResponsive && `${mergedClsPrefix}-menu--responsive`,
                  this.mergedCollapsed && `${mergedClsPrefix}-menu--collapsed`
              ], style: this.cssVars }, finalResponsive ? (h(VOverflow, { ref: "overflowRef", onUpdateOverflow: this.onUpdateOverflow, getCounter: this.getCounter, onUpdateCount: this.onUpdateCount, updateCounter: this.updateCounter, style: {
                  width: '100%',
                  display: 'flex',
                  overflow: 'hidden'
              } }, {
              default: renderMenuItemNodes,
              counter: this.renderCounter
          })) : (renderMenuItemNodes())));
          return finalResponsive ? (h(VResizeObserver, { onResize: this.onResize }, { default: renderMainNode })) : (renderMainNode());
      }
  });

  /**
   * The original package is https://www.npmjs.com/package/textarea-caret-ts
   * The original file is https://github.com/TheRealSyler/textarea-caret-position/blob/master/index.ts
   *
   * Here I modified it to make it works when input is scrolled.
   */
  /**
   * Returns the relative position of the caret in the given element.
   * @param element Input (has to be type='text') or Text Area.
   */
  function getRelativePosition(element, options = {
      debug: false,
      useSelectionEnd: false,
      checkWidthOverflow: true
  }) {
      const selectionStart = element.selectionStart !== null ? element.selectionStart : 0;
      const selectionEnd = element.selectionEnd !== null ? element.selectionEnd : 0;
      const position = options.useSelectionEnd ? selectionEnd : selectionStart;
      // We'll copy the properties below into the mirror div.
      // Note that some browsers, such as Firefox, do not concatenate properties
      // into their shorthand (e.g. padding-top, padding-bottom etc. -> padding),
      // so we have to list every single property explicitly.
      const properties = [
          'direction', // RTL support
          'boxSizing',
          'width', // on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does
          'height',
          'overflowX',
          'overflowY', // copy the scrollbar for IE
          'borderTopWidth',
          'borderRightWidth',
          'borderBottomWidth',
          'borderLeftWidth',
          'borderStyle',
          'paddingTop',
          'paddingRight',
          'paddingBottom',
          'paddingLeft',
          // https://developer.mozilla.org/en-US/docs/Web/CSS/font
          'fontStyle',
          'fontVariant',
          'fontWeight',
          'fontStretch',
          'fontSize',
          'fontSizeAdjust',
          'lineHeight',
          'fontFamily',
          'textAlign',
          'textTransform',
          'textIndent',
          'textDecoration', // might not make a difference, but better be safe
          'letterSpacing',
          'wordSpacing',
          'tabSize',
          'MozTabSize'
      ];
      // Firefox 1.0+
      const isFirefox = navigator.userAgent.toLowerCase().includes('firefox');
      if (!isBrowser$2) {
          throw new Error('textarea-caret-position#getCaretPosition should only be called in a browser');
      }
      const debug = options === null || options === void 0 ? void 0 : options.debug;
      if (debug) {
          const el = document.querySelector('#input-textarea-caret-position-mirror-div');
          if (el === null || el === void 0 ? void 0 : el.parentNode)
              el.parentNode.removeChild(el);
      }
      // The mirror div will replicate the textareas style
      const div = document.createElement('div');
      div.id = 'input-textarea-caret-position-mirror-div';
      document.body.appendChild(div);
      const style = div.style;
      const computed = window.getComputedStyle
          ? window.getComputedStyle(element)
          : element.currentStyle; // currentStyle for IE < 9
      const isInput = element.nodeName === 'INPUT';
      // Default textarea styles
      style.whiteSpace = isInput ? 'nowrap' : 'pre-wrap';
      if (!isInput)
          style.wordWrap = 'break-word'; // only for textarea-s
      // Position off-screen
      style.position = 'absolute'; // required to return coordinates properly
      if (!debug)
          style.visibility = 'hidden'; // not 'display: none' because we want rendering
      // Transfer the element's properties to the div
      properties.forEach((prop) => {
          if (isInput && prop === 'lineHeight') {
              // Special case for <input>s because text is rendered centered and line height may be != height
              if (computed.boxSizing === 'border-box') {
                  const height = parseInt(computed.height);
                  const outerHeight = parseInt(computed.paddingTop) +
                      parseInt(computed.paddingBottom) +
                      parseInt(computed.borderTopWidth) +
                      parseInt(computed.borderBottomWidth);
                  const targetHeight = outerHeight + parseInt(computed.lineHeight);
                  if (height > targetHeight) {
                      style.lineHeight = `${height - outerHeight}px`;
                  }
                  else if (height === targetHeight) {
                      style.lineHeight = computed.lineHeight;
                  }
                  else {
                      style.lineHeight = '0';
                  }
              }
              else {
                  style.lineHeight = computed.height;
              }
          }
          else {
              style[prop] = computed[prop];
          }
      });
      if (isFirefox) {
          // Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275
          if (element.scrollHeight > parseInt(computed.height)) {
              style.overflowY = 'scroll';
          }
      }
      else {
          style.overflow = 'hidden'; // for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'
      }
      div.textContent = element.value.substring(0, position);
      // The second special handling for input type="text" vs textarea:
      // spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037
      if (isInput && div.textContent) {
          div.textContent = div.textContent.replace(/\s/g, '\u00a0');
      }
      const span = document.createElement('span');
      // Wrapping must be replicated *exactly*, including when a long word gets
      // onto the next line, with whitespace at the end of the line before (#7).
      // The  *only* reliable way to do that is to copy the *entire* rest of the
      // textareas content into the <span> created at the caret position.
      // For inputs, just '.' would be enough, but no need to bother.
      span.textContent = element.value.substring(position) || '.'; // || because a completely empty faux span doesn't render at all
      span.style.position = 'relative';
      span.style.left = `${-element.scrollLeft}px`;
      span.style.top = `${-element.scrollTop}px`;
      div.appendChild(span);
      const relativePosition = {
          top: span.offsetTop + parseInt(computed.borderTopWidth),
          left: span.offsetLeft + parseInt(computed.borderLeftWidth),
          absolute: false,
          // We don't use line-height since it may be too large for position. Eg. 34px
          // for input
          height: parseInt(computed.fontSize) * 1.5
      };
      if (debug) {
          span.style.backgroundColor = '#aaa';
      }
      else {
          document.body.removeChild(div);
      }
      if (relativePosition.left >= element.clientWidth &&
          options.checkWidthOverflow) {
          relativePosition.left = element.clientWidth;
      }
      return relativePosition;
  }

  // --n-menu-box-shadow
  var style$v = c$1([cB('mention', 'width: 100%; z-index: auto; position: relative;'), cB('mention-menu', `
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
    originalTransition: 'background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)'
  })])]);

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const mentionProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, autosize: [Boolean, Object], options: {
          type: Array,
          default: []
      }, type: {
          type: String,
          default: 'text'
      }, separator: {
          type: String,
          validator: (separator) => {
              if (separator.length !== 1) {
                  warn$2('mention', "`separator`'s length must be 1.");
                  return false;
              }
              return true;
          },
          default: ' '
      }, bordered: {
          type: Boolean,
          default: undefined
      }, disabled: Boolean, value: String, defaultValue: {
          type: String,
          default: ''
      }, loading: Boolean, prefix: {
          type: [String, Array],
          default: '@'
      }, placeholder: {
          type: String,
          default: ''
      }, placement: {
          type: String,
          default: 'bottom-start'
      }, size: String, renderLabel: Function, status: String, 'onUpdate:show': [Array, Function], onUpdateShow: [Array, Function], 'onUpdate:value': [Array, Function], onUpdateValue: [Array, Function], onSearch: Function, onSelect: Function, onFocus: Function, onBlur: Function, 
      // private
      internalDebug: Boolean });
  var Mention = defineComponent({
      name: 'Mention',
      props: mentionProps,
      setup(props) {
          const { namespaceRef, mergedClsPrefixRef, mergedBorderedRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Mention', '-mention', style$v, mentionLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const inputInstRef = ref(null);
          const cursorRef = ref(null);
          const followerRef = ref(null);
          const partialPatternRef = ref('');
          let cachedPrefix = null;
          // cached pattern end is for partial pattern
          // for example @abc|def
          // end is after `c`
          let cachedPartialPatternStart = null;
          let cachedPartialPatternEnd = null;
          const filteredOptionsRef = computed(() => {
              const { value: pattern } = partialPatternRef;
              return props.options.filter((option) => {
                  if (!pattern)
                      return true;
                  if (typeof option.label === 'string') {
                      return option.label.startsWith(pattern);
                  }
                  if (typeof option.value === 'string') {
                      return option.value.startsWith(pattern);
                  }
                  return false;
              });
          });
          const treeMateRef = computed(() => {
              return createTreeMate(filteredOptionsRef.value, {
                  getKey: (v) => {
                      return v.value;
                  }
              });
          });
          const selectMenuInstRef = ref(null);
          const showMenuRef = ref(false);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const cssVarsRef = computed(() => {
              const { self: { menuBoxShadow } } = themeRef.value;
              return {
                  '--n-menu-box-shadow': menuBoxShadow
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('mention', undefined, cssVarsRef, props)
              : undefined;
          function doUpdateShowMenu(show) {
              if (props.disabled)
                  return;
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, show);
              if (_onUpdateShow)
                  call(_onUpdateShow, show);
              if (!show) {
                  cachedPrefix = null;
                  cachedPartialPatternStart = null;
                  cachedPartialPatternEnd = null;
              }
              showMenuRef.value = show;
          }
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              if (_onUpdateValue) {
                  call(_onUpdateValue, value);
              }
              if (onUpdateValue) {
                  call(onUpdateValue, value);
              }
              nTriggerFormInput();
              nTriggerFormChange();
              uncontrolledValueRef.value = value;
          }
          function getInputEl() {
              return props.type === 'text'
                  ? inputInstRef.value.inputElRef
                  : inputInstRef.value.textareaElRef;
          }
          function deriveShowMenu() {
              var _a;
              const inputEl = getInputEl();
              if (document.activeElement !== inputEl) {
                  doUpdateShowMenu(false);
                  return;
              }
              const { selectionEnd } = inputEl;
              if (selectionEnd === null) {
                  doUpdateShowMenu(false);
                  return;
              }
              const inputValue = inputEl.value;
              const { separator } = props;
              const { prefix } = props;
              const prefixArray = typeof prefix === 'string' ? [prefix] : prefix;
              for (let i = selectionEnd - 1; i >= 0; --i) {
                  const char = inputValue[i];
                  if (char === separator || char === '\n' || char === '\r') {
                      doUpdateShowMenu(false);
                      return;
                  }
                  if (prefixArray.includes(char)) {
                      const partialPattern = inputValue.slice(i + 1, selectionEnd);
                      doUpdateShowMenu(true);
                      (_a = props.onSearch) === null || _a === void 0 ? void 0 : _a.call(props, partialPattern, char);
                      partialPatternRef.value = partialPattern;
                      cachedPrefix = char;
                      cachedPartialPatternStart = i + 1;
                      cachedPartialPatternEnd = selectionEnd;
                      return;
                  }
              }
              doUpdateShowMenu(false);
          }
          function syncCursor() {
              const { value: cursorAnchor } = cursorRef;
              if (!cursorAnchor)
                  return;
              const inputEl = getInputEl();
              const cursorPos = getRelativePosition(inputEl);
              cursorPos.left += inputEl.parentElement.offsetLeft;
              cursorAnchor.style.left = `${cursorPos.left}px`;
              cursorAnchor.style.top = `${cursorPos.top + cursorPos.height}px`;
          }
          function syncPosition() {
              var _a;
              if (!showMenuRef.value)
                  return;
              (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleInputUpdateValue(value) {
              doUpdateValue(value);
              // Vue update is mirco task.
              // So DOM must have been done when sync start in marco task.
              // I can't use nextTick(), Chrome doesn't update scrollLeft of INPUT
              // element is immediatelly updated. The behavior is wired but that's what
              // happens.
              syncAfterCursorMove();
          }
          function syncAfterCursorMove() {
              setTimeout(() => {
                  syncCursor();
                  deriveShowMenu();
                  void nextTick().then(syncPosition);
              }, 0);
          }
          function handleInputKeyDown(e) {
              var _a, _b;
              if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                  if ((_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.isCompositing)
                      return;
                  syncAfterCursorMove();
              }
              else if (e.key === 'ArrowUp' ||
                  e.key === 'ArrowDown' ||
                  e.key === 'Enter') {
                  if ((_b = inputInstRef.value) === null || _b === void 0 ? void 0 : _b.isCompositing)
                      return;
                  const { value: selectMenuInst } = selectMenuInstRef;
                  if (showMenuRef.value) {
                      if (selectMenuInst) {
                          e.preventDefault();
                          if (e.key === 'ArrowUp') {
                              selectMenuInst.prev();
                          }
                          else if (e.key === 'ArrowDown') {
                              selectMenuInst.next();
                          }
                          else {
                              // Enter
                              const pendingOptionTmNode = selectMenuInst.getPendingTmNode();
                              if (pendingOptionTmNode) {
                                  handleSelect(pendingOptionTmNode);
                              }
                              else {
                                  doUpdateShowMenu(false);
                              }
                          }
                      }
                  }
                  else {
                      syncAfterCursorMove();
                  }
              }
          }
          function handleInputFocus(e) {
              const { onFocus } = props;
              onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
              const { nTriggerFormFocus } = formItem;
              nTriggerFormFocus();
              syncAfterCursorMove();
          }
          function focus() {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function blur() {
              var _a;
              (_a = inputInstRef.value) === null || _a === void 0 ? void 0 : _a.blur();
          }
          function handleInputBlur(e) {
              const { onBlur } = props;
              onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
              const { nTriggerFormBlur } = formItem;
              nTriggerFormBlur();
              doUpdateShowMenu(false);
          }
          function handleSelect(tmNode) {
              var _a;
              if (cachedPrefix === null ||
                  cachedPartialPatternStart === null ||
                  cachedPartialPatternEnd === null) {
                  return;
              }
              const { rawNode: { value = '' } } = tmNode;
              const inputEl = getInputEl();
              const inputValue = inputEl.value;
              const { separator } = props;
              const nextEndPart = inputValue.slice(cachedPartialPatternEnd);
              const alreadySeparated = nextEndPart.startsWith(separator);
              const nextMiddlePart = `${value}${alreadySeparated ? '' : separator}`;
              doUpdateValue(inputValue.slice(0, cachedPartialPatternStart) +
                  nextMiddlePart +
                  nextEndPart);
              (_a = props.onSelect) === null || _a === void 0 ? void 0 : _a.call(props, tmNode.rawNode, cachedPrefix);
              const nextSelectionEnd = cachedPartialPatternStart +
                  nextMiddlePart.length +
                  (alreadySeparated ? 1 : 0);
              void nextTick().then(() => {
                  // input value is updated
                  inputEl.selectionStart = nextSelectionEnd;
                  inputEl.selectionEnd = nextSelectionEnd;
                  deriveShowMenu();
              });
          }
          function handleInputMouseDown() {
              if (!props.disabled) {
                  syncAfterCursorMove();
              }
          }
          return {
              namespace: namespaceRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedBordered: mergedBorderedRef,
              mergedSize: formItem.mergedSizeRef,
              mergedStatus: formItem.mergedStatusRef,
              mergedTheme: themeRef,
              treeMate: treeMateRef,
              selectMenuInstRef,
              inputInstRef,
              cursorRef,
              followerRef,
              showMenu: showMenuRef,
              adjustedTo: useAdjustedTo(props),
              isMounted: isMounted(),
              mergedValue: mergedValueRef,
              handleInputFocus,
              handleInputBlur,
              handleInputUpdateValue,
              handleInputKeyDown,
              handleSelect,
              handleInputMouseDown,
              focus,
              blur,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedTheme, mergedClsPrefix, $slots } = this;
          return (h("div", { class: `${mergedClsPrefix}-mention` },
              h(NInput, { status: this.mergedStatus, themeOverrides: mergedTheme.peerOverrides.Input, theme: mergedTheme.peers.Input, size: this.mergedSize, autosize: this.autosize, type: this.type, ref: "inputInstRef", placeholder: this.placeholder, onMousedown: this.handleInputMouseDown, onUpdateValue: this.handleInputUpdateValue, onKeydown: this.handleInputKeyDown, onFocus: this.handleInputFocus, onBlur: this.handleInputBlur, bordered: this.mergedBordered, disabled: this.disabled, value: this.mergedValue }),
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => {
                              const style = {
                                  position: 'absolute',
                                  width: 0,
                                  height: 0
                              };
                              return h("div", { style: style, ref: "cursorRef" });
                          }
                      }),
                      h(VFollower, { ref: "followerRef", placement: this.placement, show: this.showMenu, containerClass: this.namespace, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted }, {
                              default: () => {
                                  const { mergedTheme, onRender } = this;
                                  onRender === null || onRender === void 0 ? void 0 : onRender();
                                  return this.showMenu ? (h(NInternalSelectMenu, { clsPrefix: mergedClsPrefix, theme: mergedTheme.peers.InternalSelectMenu, themeOverrides: mergedTheme.peerOverrides.InternalSelectMenu, autoPending: true, ref: "selectMenuInstRef", class: [
                                          `${mergedClsPrefix}-mention-menu`,
                                          this.themeClass
                                      ], loading: this.loading, treeMate: this.treeMate, virtualScroll: false, style: this.cssVars, onToggle: this.handleSelect, renderLabel: this.renderLabel }, $slots)) : null;
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  const messageProps = {
      icon: Function,
      type: {
          type: String,
          default: 'info'
      },
      content: [String, Number, Function],
      showIcon: {
          type: Boolean,
          default: true
      },
      closable: Boolean,
      keepAliveOnHover: Boolean,
      onClose: Function,
      onMouseenter: Function,
      onMouseleave: Function
  };

  const messageApiInjectionKey = createInjectionKey('n-message-api');
  const messageProviderInjectionKey = createInjectionKey('n-message-provider');

  // vars:
  // --n-margin
  // --n-bezier
  // --n-padding
  // --n-max-width
  // --n-font-size
  // --n-icon-margin
  // --n-icon-size
  // --n-text-color
  // --n-color
  // --n-box-shadow
  // --n-icon-color-default
  // --n-icon-color-info
  // --n-icon-color-success
  // --n-icon-color-warning
  // --n-icon-color-error
  // --n-icon-color-loading
  // --n-close-size
  // --n-close-icon-size
  // --n-close-margin
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-border-radius
  // --n-close-icon-color
  // --n-close-icon-color-pressed
  // --n-close-icon-color-hover
  // --n-border-radius
  var style$u = c$1([cB('message-wrapper', `
 margin: var(--n-margin);
 z-index: 0;
 transform-origin: top center;
 display: flex;
 `, [fadeInHeightExpandTransition({
    overflow: 'visible',
    originalTransition: 'transform .3s var(--n-bezier)',
    enterToProps: {
      transform: 'scale(1)'
    },
    leaveToProps: {
      transform: 'scale(0.85)'
    }
  })]), cB('message', `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 margin-bottom .3s var(--n-bezier);
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 flex-wrap: nowrap;
 overflow: hidden;
 max-width: var(--n-max-width);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-shadow: var(--n-box-shadow);
 `, [cE('content', `
 display: inline-block;
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 `), cE('icon', `
 position: relative;
 margin: var(--n-icon-margin);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 flex-shrink: 0;
 `, [['default', 'info', 'success', 'warning', 'error', 'loading'].map(type => cM(`${type}-type`, [c$1('> *', `
 color: var(--n-icon-color-${type});
 transition: color .3s var(--n-bezier);
 `)])), c$1('> *', `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cE('close', `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 flex-shrink: 0;
 `, [c$1('&:hover', `
 color: var(--n-close-icon-color-hover);
 `), c$1('&:active', `
 color: var(--n-close-icon-color-pressed);
 `)])]), cB('message-container', `
 z-index: 6000;
 position: fixed;
 height: 0;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: center;
 `, [cM('top', `
 top: 12px;
 left: 0;
 right: 0;
 `), cM('top-left', `
 top: 12px;
 left: 12px;
 right: 0;
 align-items: flex-start;
 `), cM('top-right', `
 top: 12px;
 left: 0;
 right: 12px;
 align-items: flex-end;
 `), cM('bottom', `
 bottom: 4px;
 left: 0;
 right: 0;
 justify-content: flex-end;
 `), cM('bottom-left', `
 bottom: 4px;
 left: 12px;
 right: 0;
 justify-content: flex-end;
 align-items: flex-start;
 `), cM('bottom-right', `
 bottom: 4px;
 left: 0;
 right: 12px;
 justify-content: flex-end;
 align-items: flex-end;
 `)])]);

  const iconRenderMap$1 = {
      info: () => h(InfoIcon, null),
      success: () => h(SuccessIcon, null),
      warning: () => h(WarningIcon, null),
      error: () => h(ErrorIcon, null),
      default: () => null
  };
  var NMessage = defineComponent({
      name: 'Message',
      props: Object.assign(Object.assign({}, messageProps), { render: Function }),
      setup(props) {
          const { inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const { props: messageProviderProps, mergedClsPrefixRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(messageProviderInjectionKey);
          const rtlEnabledRef = useRtl('Message', mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme('Message', '-message', style$u, messageLight$1, messageProviderProps, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type } = props;
              const { common: { cubicBezierEaseInOut }, self: { padding, margin, maxWidth, iconMargin, closeMargin, closeSize, iconSize, fontSize, lineHeight, borderRadius, iconColorInfo, iconColorSuccess, iconColorWarning, iconColorError, iconColorLoading, closeIconSize, closeBorderRadius, [createKey('textColor', type)]: textColor, [createKey('boxShadow', type)]: boxShadow, [createKey('color', type)]: color, [createKey('closeColorHover', type)]: closeColorHover, [createKey('closeColorPressed', type)]: closeColorPressed, [createKey('closeIconColor', type)]: closeIconColor, [createKey('closeIconColorPressed', type)]: closeIconColorPressed, [createKey('closeIconColorHover', type)]: closeIconColorHover } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-margin': margin,
                  '--n-padding': padding,
                  '--n-max-width': maxWidth,
                  '--n-font-size': fontSize,
                  '--n-icon-margin': iconMargin,
                  '--n-icon-size': iconSize,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-size': closeSize,
                  '--n-close-margin': closeMargin,
                  '--n-text-color': textColor,
                  '--n-color': color,
                  '--n-box-shadow': boxShadow,
                  '--n-icon-color-info': iconColorInfo,
                  '--n-icon-color-success': iconColorSuccess,
                  '--n-icon-color-warning': iconColorWarning,
                  '--n-icon-color-error': iconColorError,
                  '--n-icon-color-loading': iconColorLoading,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-line-height': lineHeight,
                  '--n-border-radius': borderRadius
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('message', computed(() => props.type[0]), cssVarsRef, {})
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              rtlEnabled: rtlEnabledRef,
              messageProviderProps,
              handleClose() {
                  var _a;
                  (_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props);
              },
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              placement: messageProviderProps.placement
          };
      },
      render() {
          const { render: renderMessage, type, closable, content, mergedClsPrefix, cssVars, themeClass, onRender, icon, handleClose, showIcon } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          let iconNode;
          return (h("div", { class: [`${mergedClsPrefix}-message-wrapper`, themeClass], onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave, style: [
                  {
                      alignItems: this.placement.startsWith('top')
                          ? 'flex-start'
                          : 'flex-end'
                  },
                  cssVars
              ] }, renderMessage ? (renderMessage(this.$props)) : (h("div", { class: [
                  `${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type}-type`,
                  this.rtlEnabled && `${mergedClsPrefix}-message--rtl`
              ] },
              (iconNode = createIconVNode(icon, type, mergedClsPrefix)) &&
                  showIcon ? (h("div", { class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type}-type` },
                  h(NIconSwitchTransition, null, {
                      default: () => iconNode
                  }))) : null,
              h("div", { class: `${mergedClsPrefix}-message__content` }, render$1(content)),
              closable ? (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-message__close`, onClick: handleClose, absolute: true })) : null))));
      }
  });
  function createIconVNode(icon, type, clsPrefix) {
      if (typeof icon === 'function') {
          return icon();
      }
      else {
          const innerIcon = type === 'loading' ? (h(NBaseLoading, { clsPrefix: clsPrefix, strokeWidth: 24, scale: 0.85 })) : (iconRenderMap$1[type]());
          if (!innerIcon)
              return null;
          return (h(NBaseIcon, { clsPrefix: clsPrefix, key: type }, {
              default: () => innerIcon
          }));
      }
  }

  var MessageEnvironment = defineComponent({
      name: 'MessageEnvironment',
      props: Object.assign(Object.assign({}, messageProps), { duration: {
              type: Number,
              default: 3000
          }, onAfterLeave: Function, onLeave: Function, internalKey: {
              type: String,
              required: true
          }, 
          // private
          onInternalAfterLeave: Function, 
          // deprecated
          onHide: Function, onAfterHide: Function }),
      setup(props) {
          let timerId = null;
          const showRef = ref(true);
          onMounted(() => {
              setHideTimeout();
          });
          function setHideTimeout() {
              const { duration } = props;
              if (duration) {
                  timerId = window.setTimeout(hide, duration);
              }
          }
          function handleMouseenter(e) {
              if (e.currentTarget !== e.target)
                  return;
              if (timerId !== null) {
                  window.clearTimeout(timerId);
                  timerId = null;
              }
          }
          function handleMouseleave(e) {
              if (e.currentTarget !== e.target)
                  return;
              setHideTimeout();
          }
          function hide() {
              const { onHide } = props;
              showRef.value = false;
              if (timerId) {
                  window.clearTimeout(timerId);
                  timerId = null;
              }
              // deprecated
              if (onHide)
                  onHide();
          }
          function handleClose() {
              const { onClose } = props;
              if (onClose)
                  onClose();
              hide();
          }
          function handleAfterLeave() {
              const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
              if (onAfterLeave)
                  onAfterLeave();
              if (onInternalAfterLeave)
                  onInternalAfterLeave(internalKey);
              // deprecated
              if (onAfterHide)
                  onAfterHide();
          }
          // deprecated
          function deactivate() {
              hide();
          }
          return {
              show: showRef,
              hide,
              handleClose,
              handleAfterLeave,
              handleMouseleave,
              handleMouseenter,
              deactivate
          };
      },
      render() {
          return (h(NFadeInExpandTransition, { appear: true, onAfterLeave: this.handleAfterLeave, onLeave: this.onLeave }, {
              default: () => [
                  this.show ? (h(NMessage, { content: this.content, type: this.type, icon: this.icon, showIcon: this.showIcon, closable: this.closable, onClose: this.handleClose, onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : undefined, onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : undefined })) : null
              ]
          }));
      }
  });

  const messageProviderProps = Object.assign(Object.assign({}, useTheme.props), { to: [String, Object], duration: {
          type: Number,
          default: 3000
      }, keepAliveOnHover: Boolean, max: Number, placement: {
          type: String,
          default: 'top'
      }, closable: Boolean, containerClass: String, containerStyle: [String, Object] });
  var NMessageProvider = defineComponent({
      name: 'MessageProvider',
      props: messageProviderProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const messageListRef = ref([]);
          const messageRefs = ref({});
          const api = {
              create(content, options) {
                  return create(content, Object.assign({ type: 'default' }, options));
              },
              info(content, options) {
                  return create(content, Object.assign(Object.assign({}, options), { type: 'info' }));
              },
              success(content, options) {
                  return create(content, Object.assign(Object.assign({}, options), { type: 'success' }));
              },
              warning(content, options) {
                  return create(content, Object.assign(Object.assign({}, options), { type: 'warning' }));
              },
              error(content, options) {
                  return create(content, Object.assign(Object.assign({}, options), { type: 'error' }));
              },
              loading(content, options) {
                  return create(content, Object.assign(Object.assign({}, options), { type: 'loading' }));
              },
              destroyAll
          };
          provide(messageProviderInjectionKey, {
              props,
              mergedClsPrefixRef
          });
          provide(messageApiInjectionKey, api);
          function create(content, options) {
              const key = createId();
              const messageReactive = reactive(Object.assign(Object.assign({}, options), { content,
                  key, destroy: () => {
                      var _a;
                      (_a = messageRefs.value[key]) === null || _a === void 0 ? void 0 : _a.hide();
                  } }));
              const { max } = props;
              if (max && messageListRef.value.length >= max) {
                  messageListRef.value.shift();
              }
              messageListRef.value.push(messageReactive);
              return messageReactive;
          }
          function handleAfterLeave(key) {
              messageListRef.value.splice(messageListRef.value.findIndex((message) => message.key === key), 1);
              // eslint-disable-next-line @typescript-eslint/no-dynamic-delete
              delete messageRefs.value[key];
          }
          function destroyAll() {
              Object.values(messageRefs.value).forEach((messageInstRef) => {
                  messageInstRef.hide();
              });
          }
          return Object.assign({
              mergedClsPrefix: mergedClsPrefixRef,
              messageRefs,
              messageList: messageListRef,
              handleAfterLeave
          }, api);
      },
      render() {
          var _a, _b, _c;
          return (h(Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 :
              _b.call(_a),
              this.messageList.length ? (h(Teleport, { to: (_c = this.to) !== null && _c !== void 0 ? _c : 'body' },
                  h("div", { class: [
                          `${this.mergedClsPrefix}-message-container`,
                          `${this.mergedClsPrefix}-message-container--${this.placement}`,
                          this.containerClass
                      ], key: "message-container", style: this.containerStyle }, this.messageList.map((message) => {
                      return (h(MessageEnvironment, Object.assign({ ref: ((inst) => {
                              if (inst) {
                                  this.messageRefs[message.key] = inst;
                              }
                          }), internalKey: message.key, onInternalAfterLeave: this.handleAfterLeave }, omit(message, ['destroy'], undefined), { duration: message.duration === undefined
                              ? this.duration
                              : message.duration, keepAliveOnHover: message.keepAliveOnHover === undefined
                              ? this.keepAliveOnHover
                              : message.keepAliveOnHover, closable: message.closable === undefined
                              ? this.closable
                              : message.closable })));
                  })))) : null));
      }
  });

  function useMessage() {
      const api = inject(messageApiInjectionKey, null);
      if (api === null) {
          throwError('use-message', 'No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.');
      }
      return api;
  }

  const notificationProviderInjectionKey = createInjectionKey('n-notification-provider');

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const NotificationContainer = defineComponent({
      name: 'NotificationContainer',
      props: {
          scrollable: {
              type: Boolean,
              required: true
          },
          placement: {
              type: String,
              required: true
          }
      },
      setup() {
          const { mergedThemeRef, mergedClsPrefixRef, wipTransitionCountRef } = inject(notificationProviderInjectionKey);
          const selfRef = ref(null);
          watchEffect(() => {
              var _a, _b;
              if (wipTransitionCountRef.value > 0) {
                  (_a = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _a === void 0 ? void 0 : _a.classList.add('transitioning');
              }
              else {
                  (_b = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _b === void 0 ? void 0 : _b.classList.remove('transitioning');
              }
          });
          return {
              selfRef,
              mergedTheme: mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              transitioning: wipTransitionCountRef
          };
      },
      render() {
          const { $slots, scrollable, mergedClsPrefix, mergedTheme, placement } = this;
          return (h("div", { ref: "selfRef", class: [
                  `${mergedClsPrefix}-notification-container`,
                  scrollable && `${mergedClsPrefix}-notification-container--scrollable`,
                  `${mergedClsPrefix}-notification-container--${placement}`
              ] }, scrollable ? (h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, contentStyle: { overflow: 'hidden' } }, $slots)) : ($slots)));
      }
  });

  const iconRenderMap = {
      info: () => h(InfoIcon, null),
      success: () => h(SuccessIcon, null),
      warning: () => h(WarningIcon, null),
      error: () => h(ErrorIcon, null),
      default: () => null
  };
  const notificationProps = {
      closable: {
          type: Boolean,
          default: true
      },
      type: {
          type: String,
          default: 'default'
      },
      avatar: Function,
      title: [String, Function],
      description: [String, Function],
      content: [String, Function],
      meta: [String, Function],
      action: [String, Function],
      onClose: {
          type: Function,
          required: true
      },
      keepAliveOnHover: Boolean,
      onMouseenter: Function,
      onMouseleave: Function
  };
  const notificationPropKeys = keysOf(notificationProps);
  const Notification = defineComponent({
      name: 'Notification',
      props: notificationProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedThemeRef, props: providerProps
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(notificationProviderInjectionKey);
          const { inlineThemeDisabled, mergedRtlRef } = useConfig();
          const rtlEnabledRef = useRtl('Notification', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type } = props;
              const { self: { color, textColor, closeIconColor, closeIconColorHover, closeIconColorPressed, headerTextColor, descriptionTextColor, actionTextColor, borderRadius, headerFontWeight, boxShadow, lineHeight, fontSize, closeMargin, closeSize, width, padding, closeIconSize, closeBorderRadius, closeColorHover, closeColorPressed, titleFontSize, metaFontSize, descriptionFontSize, [createKey('iconColor', type)]: iconColor }, common: { cubicBezierEaseOut, cubicBezierEaseIn, cubicBezierEaseInOut } } = mergedThemeRef.value;
              const { left, right, top, bottom } = getMargin(padding);
              return {
                  '--n-color': color,
                  '--n-font-size': fontSize,
                  '--n-text-color': textColor,
                  '--n-description-text-color': descriptionTextColor,
                  '--n-action-text-color': actionTextColor,
                  '--n-title-text-color': headerTextColor,
                  '--n-title-font-weight': headerFontWeight,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-bezier-ease-out': cubicBezierEaseOut,
                  '--n-bezier-ease-in': cubicBezierEaseIn,
                  '--n-border-radius': borderRadius,
                  '--n-box-shadow': boxShadow,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-line-height': lineHeight,
                  '--n-icon-color': iconColor,
                  '--n-close-margin': closeMargin,
                  '--n-close-size': closeSize,
                  '--n-close-icon-size': closeIconSize,
                  '--n-width': width,
                  '--n-padding-left': left,
                  '--n-padding-right': right,
                  '--n-padding-top': top,
                  '--n-padding-bottom': bottom,
                  '--n-title-font-size': titleFontSize,
                  '--n-meta-font-size': metaFontSize,
                  '--n-description-font-size': descriptionFontSize
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('notification', computed(() => props.type[0]), cssVarsRef, providerProps)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              showAvatar: computed(() => {
                  return props.avatar || props.type !== 'default';
              }),
              handleCloseClick() {
                  props.onClose();
              },
              rtlEnabled: rtlEnabledRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [`${mergedClsPrefix}-notification-wrapper`, this.themeClass], onMouseenter: this.onMouseenter, onMouseleave: this.onMouseleave, style: this.cssVars },
              h("div", { class: [
                      `${mergedClsPrefix}-notification`,
                      this.rtlEnabled && `${mergedClsPrefix}-notification--rtl`,
                      this.themeClass,
                      {
                          [`${mergedClsPrefix}-notification--closable`]: this.closable,
                          [`${mergedClsPrefix}-notification--show-avatar`]: this.showAvatar
                      }
                  ], style: this.cssVars },
                  this.showAvatar ? (h("div", { class: `${mergedClsPrefix}-notification__avatar` }, this.avatar ? (render$1(this.avatar)) : this.type !== 'default' ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => iconRenderMap[this.type]() })) : null)) : null,
                  this.closable ? (h(NBaseClose, { clsPrefix: mergedClsPrefix, class: `${mergedClsPrefix}-notification__close`, onClick: this.handleCloseClick })) : null,
                  h("div", { ref: "bodyRef", class: `${mergedClsPrefix}-notification-main` },
                      this.title ? (h("div", { class: `${mergedClsPrefix}-notification-main__header` }, render$1(this.title))) : null,
                      this.description ? (h("div", { class: `${mergedClsPrefix}-notification-main__description` }, render$1(this.description))) : null,
                      this.content ? (h("pre", { class: `${mergedClsPrefix}-notification-main__content` }, render$1(this.content))) : null,
                      this.meta || this.action ? (h("div", { class: `${mergedClsPrefix}-notification-main-footer` },
                          this.meta ? (h("div", { class: `${mergedClsPrefix}-notification-main-footer__meta` }, render$1(this.meta))) : null,
                          this.action ? (h("div", { class: `${mergedClsPrefix}-notification-main-footer__action` }, render$1(this.action))) : null)) : null))));
      }
  });

  const notificationEnvOptions = Object.assign(Object.assign({}, notificationProps), { duration: Number, onClose: Function, onLeave: Function, onAfterEnter: Function, onAfterLeave: Function, 
      /** @deprecated */
      onHide: Function, 
      /** @deprecated */
      onAfterShow: Function, 
      /** @deprecated */
      onAfterHide: Function });
  const NotificationEnvironment = defineComponent({
      name: 'NotificationEnvironment',
      props: Object.assign(Object.assign({}, notificationEnvOptions), { 
          // private
          internalKey: {
              type: String,
              required: true
          }, onInternalAfterLeave: {
              type: Function,
              required: true
          } }),
      setup(props) {
          const { wipTransitionCountRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(notificationProviderInjectionKey);
          const showRef = ref(true);
          let timerId = null;
          function hide() {
              showRef.value = false;
              if (timerId) {
                  window.clearTimeout(timerId);
              }
          }
          function handleBeforeEnter(el) {
              wipTransitionCountRef.value++;
              void nextTick(() => {
                  el.style.height = `${el.offsetHeight}px`;
                  el.style.maxHeight = '0';
                  el.style.transition = 'none';
                  void el.offsetHeight;
                  el.style.transition = '';
                  el.style.maxHeight = el.style.height;
              });
          }
          function handleAfterEnter(el) {
              wipTransitionCountRef.value--;
              el.style.height = '';
              el.style.maxHeight = '';
              const { onAfterEnter, onAfterShow } = props;
              if (onAfterEnter)
                  onAfterEnter();
              // deprecated
              if (onAfterShow)
                  onAfterShow();
          }
          function handleBeforeLeave(el) {
              wipTransitionCountRef.value++;
              el.style.maxHeight = `${el.offsetHeight}px`;
              el.style.height = `${el.offsetHeight}px`;
              void el.offsetHeight;
          }
          function handleLeave(el) {
              const { onHide } = props;
              if (onHide)
                  onHide();
              el.style.maxHeight = '0';
              void el.offsetHeight;
          }
          function handleAfterLeave() {
              wipTransitionCountRef.value--;
              const { onAfterLeave, onInternalAfterLeave, onAfterHide, internalKey } = props;
              if (onAfterLeave)
                  onAfterLeave();
              onInternalAfterLeave(internalKey);
              // deprecated
              if (onAfterHide)
                  onAfterHide();
          }
          function setHideTimeout() {
              const { duration } = props;
              if (duration) {
                  timerId = window.setTimeout(hide, duration);
              }
          }
          function handleMouseenter(e) {
              if (e.currentTarget !== e.target)
                  return;
              if (timerId !== null) {
                  window.clearTimeout(timerId);
                  timerId = null;
              }
          }
          function handleMouseleave(e) {
              if (e.currentTarget !== e.target)
                  return;
              setHideTimeout();
          }
          function handleClose() {
              const { onClose } = props;
              if (onClose) {
                  void Promise.resolve(onClose()).then((feedback) => {
                      if (feedback === false)
                          return;
                      hide();
                  });
              }
              else {
                  hide();
              }
          }
          onMounted(() => {
              if (props.duration) {
                  timerId = window.setTimeout(hide, props.duration);
              }
          });
          return {
              show: showRef,
              hide,
              handleClose,
              handleAfterLeave,
              handleLeave,
              handleBeforeLeave,
              handleAfterEnter,
              handleBeforeEnter,
              handleMouseenter,
              handleMouseleave
          };
      },
      render() {
          return (h(Transition, { name: "notification-transition", appear: true, 
              // convert to any since Element is not compatible with HTMLElement
              onBeforeEnter: this.handleBeforeEnter, onAfterEnter: this.handleAfterEnter, onBeforeLeave: this.handleBeforeLeave, onLeave: this.handleLeave, onAfterLeave: this.handleAfterLeave }, {
              default: () => {
                  return this.show ? (h(Notification, Object.assign({}, keep(this.$props, notificationPropKeys), { onClose: this.handleClose, onMouseenter: this.duration && this.keepAliveOnHover
                          ? this.handleMouseenter
                          : undefined, onMouseleave: this.duration && this.keepAliveOnHover
                          ? this.handleMouseleave
                          : undefined }))) : null;
              }
          }));
      }
  });

  // vars:
  // --n-color
  // --n-text-color
  // --n-description-text-color
  // --n-action-text-color
  // --n-title-text-color
  // --n-title-font-weight
  // --n-title-font-size
  // --n-meta-font-size
  // --n-description-font-size
  // --n-bezier
  // --n-bezier-ease-out
  // --n-bezier-ease-in
  // --n-border-radius
  // --n-box-shadow
  // --n-close-margin
  // --n-close-size
  // --n-close-icon-size
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-line-height
  // --n-icon-color
  // --n-width
  // --n-padding-top
  // --n-padding-bottom
  // --n-padding-left
  // --n-padding-right
  var style$t = c$1([cB('notification-container', `
 z-index: 4000;
 position: fixed;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: flex-end;
 `, [c$1('>', [cB('scrollbar', `
 width: initial;
 overflow: visible;
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [c$1('>', [cB('scrollbar-container', `
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [cB('scrollbar-content', `
 padding-top: 12px;
 padding-bottom: 33px;
 `)])])])]), cM('top, top-right, top-left', `
 top: 12px;
 `, [c$1('&.transitioning >', [cB('scrollbar', [c$1('>', [cB('scrollbar-container', `
 min-height: 100vh !important;
 `)])])])]), cM('bottom, bottom-right, bottom-left', `
 bottom: 12px;
 `, [c$1('>', [cB('scrollbar', [c$1('>', [cB('scrollbar-container', [cB('scrollbar-content', `
 padding-bottom: 12px;
 `)])])])]), cB('notification-wrapper', `
 display: flex;
 align-items: flex-end;
 margin-bottom: 0;
 margin-top: 12px;
 `)]), cM('top, bottom', `
 left: 50%;
 transform: translateX(-50%);
 `, [cB('notification-wrapper', [c$1('&.notification-transition-enter-from, &.notification-transition-leave-to', `
 transform: scale(0.85);
 `), c$1('&.notification-transition-leave-from, &.notification-transition-enter-to', `
 transform: scale(1);
 `)])]), cM('top', [cB('notification-wrapper', `
 transform-origin: top center;
 `)]), cM('bottom', [cB('notification-wrapper', `
 transform-origin: bottom center;
 `)]), cM('top-right, bottom-right', [cB('notification', `
 margin-left: 28px;
 margin-right: 16px;
 `)]), cM('top-left, bottom-left', [cB('notification', `
 margin-left: 16px;
 margin-right: 28px;
 `)]), cM('top-right', `
 right: 0;
 `, [placementTransformStyle('top-right')]), cM('top-left', `
 left: 0;
 `, [placementTransformStyle('top-left')]), cM('bottom-right', `
 right: 0;
 `, [placementTransformStyle('bottom-right')]), cM('bottom-left', `
 left: 0;
 `, [placementTransformStyle('bottom-left')]), cM('scrollable', [cM('top-right', `
 top: 0;
 `), cM('top-left', `
 top: 0;
 `), cM('bottom-right', `
 bottom: 0;
 `), cM('bottom-left', `
 bottom: 0;
 `)]), cB('notification-wrapper', `
 margin-bottom: 12px;
 `, [c$1('&.notification-transition-enter-from, &.notification-transition-leave-to', `
 opacity: 0;
 margin-top: 0 !important;
 margin-bottom: 0 !important;
 `), c$1('&.notification-transition-leave-from, &.notification-transition-enter-to', `
 opacity: 1;
 `), c$1('&.notification-transition-leave-active', `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-in),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `), c$1('&.notification-transition-enter-active', `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-out),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `)]), cB('notification', `
 background-color: var(--n-color);
 color: var(--n-text-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 font-family: inherit;
 font-size: var(--n-font-size);
 font-weight: 400;
 position: relative;
 display: flex;
 overflow: hidden;
 flex-shrink: 0;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 width: var(--n-width);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 box-sizing: border-box;
 opacity: 1;
 `, [cE('avatar', [cB('icon', {
    color: 'var(--n-icon-color)'
  }), cB('base-icon', {
    color: 'var(--n-icon-color)'
  })]), cM('show-avatar', [cB('notification-main', `
 margin-left: 40px;
 width: calc(100% - 40px); 
 `)]), cM('closable', [cB('notification-main', [c$1('> *:first-child', {
    paddingRight: '20px'
  })]), cE('close', `
 position: absolute;
 top: 0;
 right: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE('avatar', `
 position: absolute;
 top: var(--n-padding-top);
 left: var(--n-padding-left);
 width: 28px;
 height: 28px;
 font-size: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB('icon', 'transition: color .3s var(--n-bezier);')]), cB('notification-main', `
 padding-top: var(--n-padding-top);
 padding-bottom: var(--n-padding-bottom);
 box-sizing: border-box;
 display: flex;
 flex-direction: column;
 margin-left: 8px;
 width: calc(100% - 8px);
 `, [cB('notification-main-footer', `
 display: flex;
 align-items: center;
 justify-content: space-between;
 margin-top: 12px;
 `, [cE('meta', `
 font-size: var(--n-meta-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE('action', `
 cursor: pointer;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-action-text-color);
 `)]), cE('header', `
 font-weight: var(--n-title-font-weight);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-title-text-color);
 `), cE('description', `
 margin-top: 8px;
 font-size: var(--n-description-font-size);
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE('content', `
 line-height: var(--n-line-height);
 margin: 12px 0 0 0;
 font-family: inherit;
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-text-color);
 `, [c$1('&:first-child', {
    margin: 0
  })])])])])]);
  function placementTransformStyle(placement) {
    const direction = placement.split('-')[1];
    const transformXEnter = direction === 'left' ? 'calc(-100%)' : 'calc(100%)';
    const transformXLeave = '0';
    return cB('notification-wrapper', [c$1('&.notification-transition-enter-from, &.notification-transition-leave-to', `
 transform: translate(${transformXEnter}, 0);
 `), c$1('&.notification-transition-leave-from, &.notification-transition-enter-to', `
 transform: translate(${transformXLeave}, 0);
 `)]);
  }

  /* eslint-disable @typescript-eslint/no-dynamic-delete */
  const notificationApiInjectionKey = createInjectionKey('n-notification-api');
  const notificationProviderProps = Object.assign(Object.assign({}, useTheme.props), { containerClass: String, containerStyle: [String, Object], to: [String, Object], scrollable: {
          type: Boolean,
          default: true
      }, max: Number, placement: {
          type: String,
          default: 'top-right'
      }, keepAliveOnHover: Boolean });
  var NNotificationProvider = defineComponent({
      name: 'NotificationProvider',
      props: notificationProviderProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const notificationListRef = ref([]);
          const notificationRefs = {};
          const leavingKeySet = new Set();
          function create(options) {
              const key = createId();
              const destroy = () => {
                  leavingKeySet.add(key);
                  // If you push n + 1 message when max is n, notificationRefs[key] maybe not be set
                  if (notificationRefs[key]) {
                      notificationRefs[key].hide();
                  }
              };
              const notificationReactive = reactive(Object.assign(Object.assign({}, options), { key,
                  destroy, hide: destroy, deactivate: destroy }));
              const { max } = props;
              if (max && notificationListRef.value.length - leavingKeySet.size >= max) {
                  let someoneMountedRemoved = false;
                  let index = 0;
                  for (const notification of notificationListRef.value) {
                      if (!leavingKeySet.has(notification.key)) {
                          if (notificationRefs[notification.key]) {
                              notification.destroy();
                              someoneMountedRemoved = true;
                          }
                          break;
                      }
                      index++;
                  }
                  if (!someoneMountedRemoved) {
                      notificationListRef.value.splice(index, 1);
                  }
              }
              notificationListRef.value.push(notificationReactive);
              return notificationReactive;
          }
          const apis = ['info', 'success', 'warning', 'error'].map((type) => {
              return (options) => create(Object.assign(Object.assign({}, options), { type }));
          });
          function handleAfterLeave(key) {
              leavingKeySet.delete(key);
              notificationListRef.value.splice(notificationListRef.value.findIndex((notification) => notification.key === key), 1);
          }
          const themeRef = useTheme('Notification', '-notification', style$t, notificationLight$1, props, mergedClsPrefixRef);
          const api = {
              create,
              info: apis[0],
              success: apis[1],
              warning: apis[2],
              error: apis[3],
              open,
              destroyAll
          };
          const wipTransitionCountRef = ref(0);
          provide(notificationApiInjectionKey, api);
          provide(notificationProviderInjectionKey, {
              props,
              mergedClsPrefixRef,
              mergedThemeRef: themeRef,
              wipTransitionCountRef
          });
          // deprecated
          function open(options) {
              return create(options);
          }
          function destroyAll() {
              Object.values(notificationListRef.value).forEach((notification) => {
                  notification.hide();
              });
          }
          return Object.assign({
              mergedClsPrefix: mergedClsPrefixRef,
              notificationList: notificationListRef,
              notificationRefs,
              handleAfterLeave
          }, api);
      },
      render() {
          var _a, _b, _c;
          const { placement } = this;
          return (h(Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 :
              _b.call(_a),
              this.notificationList.length ? (h(Teleport, { to: (_c = this.to) !== null && _c !== void 0 ? _c : 'body' },
                  h(NotificationContainer, { class: this.containerClass, style: this.containerStyle, scrollable: this.scrollable && placement !== 'top' && placement !== 'bottom', placement: placement }, {
                      default: () => {
                          return this.notificationList.map((notification) => {
                              return (h(NotificationEnvironment, Object.assign({ ref: ((inst) => {
                                      const refKey = notification.key;
                                      if (inst === null) {
                                          delete this.notificationRefs[refKey];
                                      }
                                      else
                                          this.notificationRefs[refKey] = inst;
                                  }) }, omit(notification, [
                                  'destroy',
                                  'hide',
                                  'deactivate'
                              ]), { internalKey: notification.key, onInternalAfterLeave: this.handleAfterLeave, keepAliveOnHover: notification.keepAliveOnHover === undefined
                                      ? this.keepAliveOnHover
                                      : notification.keepAliveOnHover })));
                          });
                      }
                  }))) : null));
      }
  });

  function useNotification() {
      const api = inject(notificationApiInjectionKey, null);
      if (api === null) {
          throwError('use-notification', 'No outer `n-notification-provider` found.');
      }
      return api;
  }

  // vars:
  // --n-title-font-size
  // --n-title-text-color
  // --n-font-size
  // --n-subtitle-text-color
  // --n-back-color
  // --n-back-color-hover
  // --n-back-color-pressed
  // --n-back-size
  // --n-title-font-weight
  // --n-bezier
  var style$s = c$1([cB('page-header-header', `
 margin-bottom: 20px;
 `), cB('page-header', `
 display: flex;
 align-items: center;
 justify-content: space-between;
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cE('main', `
 display: flex;
 flex-wrap: nowrap;
 align-items: center;
 `), cE('back', `
 display: flex;
 margin-right: 16px;
 font-size: var(--n-back-size);
 cursor: pointer;
 color: var(--n-back-color);
 transition: color .3s var(--n-bezier);
 `, [c$1('&:hover', 'color: var(--n-back-color-hover);'), c$1('&:active', 'color: var(--n-back-color-pressed);')]), cE('avatar', `
 display: flex;
 margin-right: 12px
 `), cE('title', `
 margin-right: 16px;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE('subtitle', `
 font-size: 14px;
 transition: color .3s var(--n-bezier);
 color: var(--n-subtitle-text-color);
 `)]), cB('page-header-content', `
 font-size: var(--n-font-size);
 `, [c$1('&:not(:first-child)', 'margin-top: 20px;')]), cB('page-header-footer', `
 font-size: var(--n-font-size);
 `, [c$1('&:not(:first-child)', 'margin-top: 20px;')])]);

  /* eslint-disable @typescript-eslint/no-non-null-assertion */
  const pageHeaderProps = Object.assign(Object.assign({}, useTheme.props), { title: String, subtitle: String, extra: String, onBack: Function });
  var PageHeader = defineComponent({
      name: 'PageHeader',
      props: pageHeaderProps,
      setup(props) {
          const { mergedClsPrefixRef, mergedRtlRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('PageHeader', '-page-header', style$s, pageHeaderLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('PageHeader', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { titleTextColor, subtitleTextColor, backColor, fontSize, titleFontSize, backSize, titleFontWeight, backColorHover, backColorPressed }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-title-text-color': titleTextColor,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-font-size': fontSize,
                  '--n-back-size': backSize,
                  '--n-subtitle-text-color': subtitleTextColor,
                  '--n-back-color': backColor,
                  '--n-back-color-hover': backColorHover,
                  '--n-back-color-pressed': backColorPressed,
                  '--n-bezier': cubicBezierEaseInOut
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('page-header', undefined, cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { onBack, title, subtitle, extra, mergedClsPrefix, cssVars, $slots } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const { title: titleSlot, subtitle: subtitleSlot, extra: extraSlot, default: defaultSlot, header: headerSlot, avatar: avatarSlot, footer: footerSlot, back: backSlot } = $slots;
          const showBack = onBack;
          const showTitle = title || titleSlot;
          const showSubtitle = subtitle || subtitleSlot;
          const showExtra = extra || extraSlot;
          return (h("div", { style: cssVars, class: [
                  `${mergedClsPrefix}-page-header-wrapper`,
                  this.themeClass,
                  this.rtlEnabled && `${mergedClsPrefix}-page-header-wrapper--rtl`
              ] },
              headerSlot ? (h("div", { class: `${mergedClsPrefix}-page-header-header`, key: "breadcrumb" }, headerSlot())) : null,
              (showBack || avatarSlot || showTitle || showSubtitle || showExtra) && (h("div", { class: `${mergedClsPrefix}-page-header`, key: "header" },
                  h("div", { class: `${mergedClsPrefix}-page-header__main`, key: "back" },
                      showBack ? (h("div", { class: `${mergedClsPrefix}-page-header__back`, onClick: onBack }, backSlot ? (backSlot()) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, {
                          default: () => h(ArrowBackIcon, null)
                      })))) : null,
                      avatarSlot ? (h("div", { class: `${mergedClsPrefix}-page-header__avatar` }, avatarSlot())) : null,
                      showTitle ? (h("div", { class: `${mergedClsPrefix}-page-header__title`, key: "title" }, title || titleSlot())) : null,
                      showSubtitle ? (h("div", { class: `${mergedClsPrefix}-page-header__subtitle`, key: "subtitle" }, subtitle || subtitleSlot())) : null),
                  showExtra ? (h("div", { class: `${mergedClsPrefix}-page-header__extra` }, extra || extraSlot())) : null)),
              defaultSlot ? (h("div", { class: `${mergedClsPrefix}-page-header-content`, key: "content" }, defaultSlot())) : null,
              footerSlot ? (h("div", { class: `${mergedClsPrefix}-page-header-footer`, key: "footer" }, footerSlot())) : null));
      }
  });

  const popconfirmInjectionKey = createInjectionKey('n-popconfirm');

  const panelProps = {
      positiveText: String,
      negativeText: String,
      showIcon: {
          type: Boolean,
          default: true
      },
      onPositiveClick: {
          type: Function,
          required: true
      },
      onNegativeClick: {
          type: Function,
          required: true
      }
  };
  const panelPropKeys = keysOf(panelProps);
  var PopconfirmPanel = defineComponent({
      name: 'NPopconfirmPanel',
      props: panelProps,
      setup(props) {
          const { localeRef } = useLocale('Popconfirm');
          const { inlineThemeDisabled } = useConfig();
          const { mergedClsPrefixRef, mergedThemeRef, props: popconfirmProps
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(popconfirmInjectionKey);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { fontSize, iconSize, iconColor } } = mergedThemeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-icon-size': iconSize,
                  '--n-icon-color': iconColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('popconfirm-panel', undefined, cssVarsRef, popconfirmProps)
              : undefined;
          return Object.assign(Object.assign({}, useLocale('Popconfirm')), { mergedClsPrefix: mergedClsPrefixRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, localizedPositiveText: computed(() => {
                  return props.positiveText || localeRef.value.positiveText;
              }), localizedNegativeText: computed(() => {
                  return props.negativeText || localeRef.value.negativeText;
              }), positiveButtonProps: toRef(popconfirmProps, 'positiveButtonProps'), negativeButtonProps: toRef(popconfirmProps, 'negativeButtonProps'), handlePositiveClick(e) {
                  props.onPositiveClick(e);
              },
              handleNegativeClick(e) {
                  props.onNegativeClick(e);
              }, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a;
          const { mergedClsPrefix, showIcon, $slots } = this;
          const actionContentNode = resolveSlot($slots.action, () => this.negativeText === null && this.positiveText === null
              ? []
              : [
                  this.negativeText !== null && (h(NButton, Object.assign({ size: "small", onClick: this.handleNegativeClick }, this.negativeButtonProps), { default: () => this.localizedNegativeText })),
                  this.positiveText !== null && (h(NButton, Object.assign({ size: "small", type: "primary", onClick: this.handlePositiveClick }, this.positiveButtonProps), { default: () => this.localizedPositiveText }))
              ]);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [`${mergedClsPrefix}-popconfirm__panel`, this.themeClass], style: this.cssVars },
              resolveWrappedSlot($slots.default, (children) => showIcon || children ? (h("div", { class: `${mergedClsPrefix}-popconfirm__body` },
                  showIcon ? (h("div", { class: `${mergedClsPrefix}-popconfirm__icon` }, resolveSlot($slots.icon, () => [
                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(WarningIcon, null) })
                  ]))) : null,
                  children)) : null),
              actionContentNode ? (h("div", { class: [`${mergedClsPrefix}-popconfirm__action`] }, actionContentNode)) : null));
      }
  });

  // vars:
  // --n-font-size
  // --n-icon-size
  // --n-bezier
  // --n-icon-color
  var style$r = cB('popconfirm', [cE('body', `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [cE('icon', `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), cE('action', `
 display: flex;
 justify-content: flex-end;
 `, [c$1('&:not(:first-child)', 'margin-top: 8px'), cB('button', [c$1('&:not(:last-child)', 'margin-right: 8px;')])])]);

  const popconfirmProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), { positiveText: String, negativeText: String, showIcon: {
          type: Boolean,
          default: true
      }, trigger: {
          type: String,
          default: 'click'
      }, positiveButtonProps: Object, negativeButtonProps: Object, onPositiveClick: Function, onNegativeClick: Function });
  var Popconfirm = defineComponent({
      name: 'Popconfirm',
      props: popconfirmProps,
      __popover__: true,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig();
          const themeRef = useTheme('Popconfirm', '-popconfirm', style$r, popconfirmLight$1, props, mergedClsPrefixRef);
          const popoverInstRef = ref(null);
          function handlePositiveClick(e) {
              var _a;
              if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow()))
                  return;
              const { onPositiveClick, 'onUpdate:show': onUpdateShow } = props;
              void Promise.resolve(onPositiveClick ? onPositiveClick(e) : true).then((value) => {
                  var _a;
                  if (value === false)
                      return;
                  (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
                  if (onUpdateShow)
                      call(onUpdateShow, false);
              });
          }
          function handleNegativeClick(e) {
              var _a;
              if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow()))
                  return;
              const { onNegativeClick, 'onUpdate:show': onUpdateShow } = props;
              void Promise.resolve(onNegativeClick ? onNegativeClick(e) : true).then((value) => {
                  var _a;
                  if (value === false)
                      return;
                  (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
                  if (onUpdateShow)
                      call(onUpdateShow, false);
              });
          }
          provide(popconfirmInjectionKey, {
              mergedThemeRef: themeRef,
              mergedClsPrefixRef,
              props
          });
          const returned = {
              setShow(value) {
                  var _a;
                  (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
              },
              syncPosition() {
                  var _a;
                  (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
              },
              mergedTheme: themeRef,
              popoverInstRef,
              handlePositiveClick,
              handleNegativeClick
          };
          return returned;
      },
      render() {
          const { $slots: slots, $props: props, mergedTheme } = this;
          return h(NPopover, omit(props, panelPropKeys, {
              theme: mergedTheme.peers.Popover,
              themeOverrides: mergedTheme.peerOverrides.Popover,
              internalExtraClass: ['popconfirm'],
              ref: 'popoverInstRef'
          }), {
              trigger: slots.activator || slots.trigger,
              default: () => {
                  const panelProps = keep(props, panelPropKeys);
                  return h(PopconfirmPanel, Object.assign(Object.assign({}, panelProps), { onPositiveClick: this.handlePositiveClick, onNegativeClick: this.handleNegativeClick }), slots);
              }
          });
      }
  });

  // vars
  // --n-bezier
  // --n-fill-color
  // --n-font-size
  // --n-font-size-circle
  // --n-font-weight-circle
  // --n-icon-color
  // --n-icon-size-circle
  // --n-icon-size-line
  // --n-line-bg-processing
  // --n-rail-color
  // --n-rail-height
  // --n-text-color-circle
  // --n-text-color-line-inner
  // --n-text-color-line-outer
  var style$q = c$1([cB('progress', {
    display: 'inline-block'
  }, [cB('progress-icon', `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 `), cM('line', `
 width: 100%;
 display: block;
 `, [cB('progress-content', `
 display: flex;
 align-items: center;
 `, [cB('progress-graph', {
    flex: 1
  })]), cB('progress-custom-content', {
    marginLeft: '14px'
  }), cB('progress-icon', `
 width: 30px;
 padding-left: 14px;
 height: var(--n-icon-size-line);
 line-height: var(--n-icon-size-line);
 font-size: var(--n-icon-size-line);
 `, [cM('as-text', `
 color: var(--n-text-color-line-outer);
 text-align: center;
 width: 40px;
 font-size: var(--n-font-size);
 padding-left: 4px;
 transition: color .3s var(--n-bezier);
 `)])]), cM('circle, dashboard', {
    width: '120px'
  }, [cB('progress-custom-content', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cB('progress-text', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: inherit;
 font-size: var(--n-font-size-circle);
 color: var(--n-text-color-circle);
 font-weight: var(--n-font-weight-circle);
 transition: color .3s var(--n-bezier);
 white-space: nowrap;
 `), cB('progress-icon', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 color: var(--n-icon-color);
 font-size: var(--n-icon-size-circle);
 `)]), cM('multiple-circle', `
 width: 200px;
 color: inherit;
 `, [cB('progress-text', `
 font-weight: var(--n-font-weight-circle);
 color: var(--n-text-color-circle);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `)]), cB('progress-content', {
    position: 'relative'
  }), cB('progress-graph', {
    position: 'relative'
  }, [cB('progress-graph-circle', [c$1('svg', {
    verticalAlign: 'bottom'
  }), cB('progress-graph-circle-fill', `
 stroke: var(--n-fill-color);
 transition:
 opacity .3s var(--n-bezier),
 stroke .3s var(--n-bezier),
 stroke-dasharray .3s var(--n-bezier);
 `, [cM('empty', {
    opacity: 0
  })]), cB('progress-graph-circle-rail', `
 transition: stroke .3s var(--n-bezier);
 overflow: hidden;
 stroke: var(--n-rail-color);
 `)]), cB('progress-graph-line', [cM('indicator-inside', [cB('progress-graph-line-rail', `
 height: 16px;
 line-height: 16px;
 border-radius: 10px;
 `, [cB('progress-graph-line-fill', `
 height: inherit;
 border-radius: 10px;
 `), cB('progress-graph-line-indicator', `
 background: #0000;
 white-space: nowrap;
 text-align: right;
 margin-left: 14px;
 margin-right: 14px;
 height: inherit;
 font-size: 12px;
 color: var(--n-text-color-line-inner);
 transition: color .3s var(--n-bezier);
 `)])]), cM('indicator-inside-label', `
 height: 16px;
 display: flex;
 align-items: center;
 `, [cB('progress-graph-line-rail', `
 flex: 1;
 transition: background-color .3s var(--n-bezier);
 `), cB('progress-graph-line-indicator', `
 background: var(--n-fill-color);
 font-size: 12px;
 transform: translateZ(0);
 display: flex;
 vertical-align: middle;
 height: 16px;
 line-height: 16px;
 padding: 0 10px;
 border-radius: 10px;
 position: absolute;
 white-space: nowrap;
 color: var(--n-text-color-line-inner);
 transition:
 right .2s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB('progress-graph-line-rail', `
 position: relative;
 overflow: hidden;
 height: var(--n-rail-height);
 border-radius: 5px;
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 `, [cB('progress-graph-line-fill', `
 background: var(--n-fill-color);
 position: relative;
 border-radius: 5px;
 height: inherit;
 width: 100%;
 max-width: 0%;
 transition:
 background-color .3s var(--n-bezier),
 max-width .2s var(--n-bezier);
 `, [cM('processing', [c$1('&::after', `
 content: "";
 background-image: var(--n-line-bg-processing);
 animation: progress-processing-animation 2s var(--n-bezier) infinite;
 `)])])])])])]), c$1('@keyframes progress-processing-animation', `
 0% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 100%;
 opacity: 1;
 }
 66% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 100% {
 position: absolute;
 left: 0;
 top: 0;
 bottom: 0;
 right: 0;
 opacity: 0;
 }
 `)]);

  const iconMap$2 = {
      success: h(SuccessIcon, null),
      error: h(ErrorIcon, null),
      warning: h(WarningIcon, null),
      info: h(InfoIcon, null)
  };
  var Line = defineComponent({
      name: 'ProgressLine',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          percentage: {
              type: Number,
              default: 0
          },
          railColor: String,
          railStyle: [String, Object],
          fillColor: String,
          status: {
              type: String,
              required: true
          },
          indicatorPlacement: {
              type: String,
              required: true
          },
          indicatorTextColor: String,
          unit: {
              type: String,
              default: '%'
          },
          processing: {
              type: Boolean,
              required: true
          },
          showIndicator: {
              type: Boolean,
              required: true
          },
          height: [String, Number],
          railBorderRadius: [String, Number],
          fillBorderRadius: [String, Number]
      },
      setup(props, { slots }) {
          const styleHeightRef = computed(() => {
              return formatLength(props.height);
          });
          const styleRailBorderRadiusRef = computed(() => {
              if (props.railBorderRadius !== undefined) {
                  return formatLength(props.railBorderRadius);
              }
              if (props.height !== undefined) {
                  return formatLength(props.height, { c: 0.5 });
              }
              return '';
          });
          const styleFillBorderRadiusRef = computed(() => {
              if (props.fillBorderRadius !== undefined) {
                  return formatLength(props.fillBorderRadius);
              }
              if (props.railBorderRadius !== undefined) {
                  return formatLength(props.railBorderRadius);
              }
              if (props.height !== undefined) {
                  return formatLength(props.height, { c: 0.5 });
              }
              return '';
          });
          return () => {
              const { indicatorPlacement, railColor, railStyle, percentage, unit, indicatorTextColor, status, showIndicator, fillColor, processing, clsPrefix } = props;
              return (h("div", { class: `${clsPrefix}-progress-content`, role: "none" },
                  h("div", { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                      h("div", { class: [
                              `${clsPrefix}-progress-graph-line`,
                              {
                                  [`${clsPrefix}-progress-graph-line--indicator-${indicatorPlacement}`]: true
                              }
                          ] },
                          h("div", { class: `${clsPrefix}-progress-graph-line-rail`, style: [
                                  {
                                      backgroundColor: railColor,
                                      height: styleHeightRef.value,
                                      borderRadius: styleRailBorderRadiusRef.value
                                  },
                                  railStyle
                              ] },
                              h("div", { class: [
                                      `${clsPrefix}-progress-graph-line-fill`,
                                      processing &&
                                          `${clsPrefix}-progress-graph-line-fill--processing`
                                  ], style: {
                                      maxWidth: `${props.percentage}%`,
                                      backgroundColor: fillColor,
                                      height: styleHeightRef.value,
                                      lineHeight: styleHeightRef.value,
                                      borderRadius: styleFillBorderRadiusRef.value
                                  } }, indicatorPlacement === 'inside' ? (h("div", { class: `${clsPrefix}-progress-graph-line-indicator`, style: {
                                      color: indicatorTextColor
                                  } }, slots.default ? slots.default() : `${percentage}${unit}`)) : null)))),
                  showIndicator && indicatorPlacement === 'outside' ? (h("div", null, slots.default ? (h("div", { class: `${clsPrefix}-progress-custom-content`, style: {
                          color: indicatorTextColor
                      }, role: "none" }, slots.default())) : status === 'default' ? (h("div", { role: "none", class: `${clsPrefix}-progress-icon ${clsPrefix}-progress-icon--as-text`, style: {
                          color: indicatorTextColor
                      } },
                      percentage,
                      unit)) : (h("div", { class: `${clsPrefix}-progress-icon`, "aria-hidden": true },
                      h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => iconMap$2[status] }))))) : null));
          };
      }
  });

  const iconMap$1 = {
      success: h(SuccessIcon, null),
      error: h(ErrorIcon, null),
      warning: h(WarningIcon, null),
      info: h(InfoIcon, null)
  };
  var Circle = defineComponent({
      name: 'ProgressCircle',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          status: {
              type: String,
              required: true
          },
          strokeWidth: {
              type: Number,
              required: true
          },
          fillColor: String,
          railColor: String,
          railStyle: [String, Object],
          percentage: {
              type: Number,
              default: 0
          },
          offsetDegree: {
              type: Number,
              default: 0
          },
          showIndicator: {
              type: Boolean,
              required: true
          },
          indicatorTextColor: String,
          unit: String,
          viewBoxWidth: {
              type: Number,
              required: true
          },
          gapDegree: {
              type: Number,
              required: true
          },
          gapOffsetDegree: {
              type: Number,
              default: 0
          }
      },
      setup(props, { slots }) {
          function getPathStyles(percent, offsetDegree, strokeColor) {
              const { gapDegree, viewBoxWidth, strokeWidth } = props;
              const radius = 50;
              const beginPositionX = 0;
              const beginPositionY = radius;
              const endPositionX = 0;
              const endPositionY = 2 * radius;
              const centerX = 50 + strokeWidth / 2;
              const pathString = `M ${centerX},${centerX} m ${beginPositionX},${beginPositionY}
      a ${radius},${radius} 0 1 1 ${endPositionX},${-endPositionY}
      a ${radius},${radius} 0 1 1 ${-endPositionX},${endPositionY}`;
              const len = Math.PI * 2 * radius;
              const pathStyle = {
                  stroke: strokeColor,
                  strokeDasharray: `${(percent / 100) * (len - gapDegree)}px ${viewBoxWidth * 8}px`,
                  strokeDashoffset: `-${gapDegree / 2}px`,
                  transformOrigin: offsetDegree ? 'center' : undefined,
                  transform: offsetDegree ? `rotate(${offsetDegree}deg)` : undefined
              };
              return {
                  pathString,
                  pathStyle
              };
          }
          return () => {
              const { fillColor, railColor, strokeWidth, offsetDegree, status, percentage, showIndicator, indicatorTextColor, unit, gapOffsetDegree, clsPrefix } = props;
              const { pathString: railPathString, pathStyle: railPathStyle } = getPathStyles(100, 0, railColor);
              const { pathString: fillPathString, pathStyle: fillPathStyle } = getPathStyles(percentage, offsetDegree, fillColor);
              const viewBoxSize = 100 + strokeWidth;
              return (h("div", { class: `${clsPrefix}-progress-content`, role: "none" },
                  h("div", { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                      h("div", { class: `${clsPrefix}-progress-graph-circle`, style: {
                              transform: gapOffsetDegree
                                  ? `rotate(${gapOffsetDegree}deg)`
                                  : undefined
                          } },
                          h("svg", { viewBox: `0 0 ${viewBoxSize} ${viewBoxSize}` },
                              h("g", null,
                                  h("path", { class: `${clsPrefix}-progress-graph-circle-rail`, d: railPathString, "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: railPathStyle })),
                              h("g", null,
                                  h("path", { class: [
                                          `${clsPrefix}-progress-graph-circle-fill`,
                                          percentage === 0 &&
                                              `${clsPrefix}-progress-graph-circle-fill--empty`
                                      ], d: fillPathString, "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: fillPathStyle }))))),
                  showIndicator ? (h("div", null, slots.default ? (h("div", { class: `${clsPrefix}-progress-custom-content`, role: "none" }, slots.default())) : status !== 'default' ? (h("div", { class: `${clsPrefix}-progress-icon`, "aria-hidden": true },
                      h(NBaseIcon, { clsPrefix: clsPrefix }, {
                          default: () => iconMap$1[status]
                      }))) : (h("div", { class: `${clsPrefix}-progress-text`, style: {
                          color: indicatorTextColor
                      }, role: "none" },
                      h("span", { class: `${clsPrefix}-progress-text__percentage` }, percentage),
                      h("span", { class: `${clsPrefix}-progress-text__unit` }, unit))))) : null));
          };
      }
  });

  function circlePath(r, sw, vw = 100) {
      return `m ${vw / 2} ${vw / 2 - r} a ${r} ${r} 0 1 1 0 ${2 * r} a ${r} ${r} 0 1 1 0 -${2 * r}`;
  }
  var MultipleCircle = defineComponent({
      name: 'ProgressMultipleCircle',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          viewBoxWidth: {
              type: Number,
              required: true
          },
          percentage: {
              type: Array,
              default: [0]
          },
          strokeWidth: {
              type: Number,
              required: true
          },
          circleGap: {
              type: Number,
              required: true
          },
          showIndicator: {
              type: Boolean,
              required: true
          },
          fillColor: {
              type: Array,
              default: () => []
          },
          railColor: {
              type: Array,
              default: () => []
          },
          railStyle: {
              type: Array,
              default: () => []
          }
      },
      setup(props, { slots }) {
          const strokeDasharrayRef = computed(() => {
              const strokeDasharrays = props.percentage.map((v, i) => `${((Math.PI * v) / 100) *
                (props.viewBoxWidth / 2 -
                    (props.strokeWidth / 2) * (1 + 2 * i) -
                    props.circleGap * i) *
                2}, ${props.viewBoxWidth * 8}`);
              return strokeDasharrays;
          });
          return () => {
              const { viewBoxWidth, strokeWidth, circleGap, showIndicator, fillColor, railColor, railStyle, percentage, clsPrefix } = props;
              return (h("div", { class: `${clsPrefix}-progress-content`, role: "none" },
                  h("div", { class: `${clsPrefix}-progress-graph`, "aria-hidden": true },
                      h("div", { class: `${clsPrefix}-progress-graph-circle` },
                          h("svg", { viewBox: `0 0 ${viewBoxWidth} ${viewBoxWidth}` }, percentage.map((p, index) => {
                              return (h("g", { key: index },
                                  h("path", { class: `${clsPrefix}-progress-graph-circle-rail`, d: circlePath(viewBoxWidth / 2 -
                                          (strokeWidth / 2) * (1 + 2 * index) -
                                          circleGap * index, strokeWidth, viewBoxWidth), "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: [
                                          {
                                              strokeDashoffset: 0,
                                              stroke: railColor[index]
                                          },
                                          railStyle[index]
                                      ] }),
                                  h("path", { class: [
                                          `${clsPrefix}-progress-graph-circle-fill`,
                                          p === 0 &&
                                              `${clsPrefix}-progress-graph-circle-fill--empty`
                                      ], d: circlePath(viewBoxWidth / 2 -
                                          (strokeWidth / 2) * (1 + 2 * index) -
                                          circleGap * index, strokeWidth, viewBoxWidth), "stroke-width": strokeWidth, "stroke-linecap": "round", fill: "none", style: {
                                          strokeDasharray: strokeDasharrayRef.value[index],
                                          strokeDashoffset: 0,
                                          stroke: fillColor[index]
                                      } })));
                          })))),
                  showIndicator && slots.default ? (h("div", null,
                      h("div", { class: `${clsPrefix}-progress-text` }, slots.default()))) : null));
          };
      }
  });

  const progressProps = Object.assign(Object.assign({}, useTheme.props), { processing: Boolean, type: {
          type: String,
          default: 'line'
      }, gapDegree: Number, gapOffsetDegree: Number, status: {
          type: String,
          default: 'default'
      }, railColor: [String, Array], railStyle: [String, Array], color: [String, Array], viewBoxWidth: {
          type: Number,
          default: 100
      }, strokeWidth: {
          type: Number,
          default: 7
      }, percentage: [Number, Array], unit: {
          type: String,
          default: '%'
      }, showIndicator: {
          type: Boolean,
          default: true
      }, indicatorPosition: {
          type: String,
          default: 'outside'
      }, indicatorPlacement: {
          type: String,
          default: 'outside'
      }, indicatorTextColor: String, circleGap: {
          type: Number,
          default: 1
      }, height: Number, borderRadius: [String, Number], fillBorderRadius: [String, Number], offsetDegree: Number });
  var NProgress = defineComponent({
      name: 'Progress',
      props: progressProps,
      setup(props) {
          const mergedIndicatorPlacementRef = computed(() => {
              return props.indicatorPlacement || props.indicatorPosition;
          });
          const gapDeg = computed(() => {
              if (props.gapDegree || props.gapDegree === 0) {
                  return props.gapDegree;
              }
              if (props.type === 'dashboard') {
                  return 75;
              }
              return undefined;
          });
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Progress', '-progress', style$q, progressLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { status } = props;
              const { common: { cubicBezierEaseInOut }, self: { fontSize, fontSizeCircle, railColor, railHeight, iconSizeCircle, iconSizeLine, textColorCircle, textColorLineInner, textColorLineOuter, lineBgProcessing, fontWeightCircle, [createKey('iconColor', status)]: iconColor, [createKey('fillColor', status)]: fillColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-fill-color': fillColor,
                  '--n-font-size': fontSize,
                  '--n-font-size-circle': fontSizeCircle,
                  '--n-font-weight-circle': fontWeightCircle,
                  '--n-icon-color': iconColor,
                  '--n-icon-size-circle': iconSizeCircle,
                  '--n-icon-size-line': iconSizeLine,
                  '--n-line-bg-processing': lineBgProcessing,
                  '--n-rail-color': railColor,
                  '--n-rail-height': railHeight,
                  '--n-text-color-circle': textColorCircle,
                  '--n-text-color-line-inner': textColorLineInner,
                  '--n-text-color-line-outer': textColorLineOuter
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('progress', computed(() => props.status[0]), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedIndicatorPlacement: mergedIndicatorPlacementRef,
              gapDeg,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          // it's ok to expand all prop here since no slots' deps
          const { type, cssVars, indicatorTextColor, showIndicator, status, railColor, railStyle, color, percentage, viewBoxWidth, strokeWidth, mergedIndicatorPlacement, unit, borderRadius, fillBorderRadius, height, processing, circleGap, mergedClsPrefix, gapDeg, gapOffsetDegree, themeClass, $slots, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  themeClass,
                  `${mergedClsPrefix}-progress`,
                  `${mergedClsPrefix}-progress--${type}`,
                  `${mergedClsPrefix}-progress--${status}`
              ], style: cssVars, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": percentage, role: type === 'circle' || type === 'line' || type === 'dashboard'
                  ? 'progressbar'
                  : 'none' }, type === 'circle' || type === 'dashboard' ? (h(Circle, { clsPrefix: mergedClsPrefix, status: status, showIndicator: showIndicator, indicatorTextColor: indicatorTextColor, railColor: railColor, fillColor: color, railStyle: railStyle, offsetDegree: this.offsetDegree, percentage: percentage, viewBoxWidth: viewBoxWidth, strokeWidth: strokeWidth, gapDegree: gapDeg === undefined ? (type === 'dashboard' ? 75 : 0) : gapDeg, gapOffsetDegree: gapOffsetDegree, unit: unit }, $slots)) : type === 'line' ? (h(Line, { clsPrefix: mergedClsPrefix, status: status, showIndicator: showIndicator, indicatorTextColor: indicatorTextColor, railColor: railColor, fillColor: color, railStyle: railStyle, percentage: percentage, processing: processing, indicatorPlacement: mergedIndicatorPlacement, unit: unit, fillBorderRadius: fillBorderRadius, railBorderRadius: borderRadius, height: height }, $slots)) : type === 'multiple-circle' ? (h(MultipleCircle, { clsPrefix: mergedClsPrefix, strokeWidth: strokeWidth, railColor: railColor, fillColor: color, railStyle: railStyle, viewBoxWidth: viewBoxWidth, percentage: percentage, showIndicator: showIndicator, circleGap: circleGap }, $slots)) : null));
      }
  });

  // vars:
  // --n-border-radius
  var style$p = c$1([cB('qr-code', `
 background: #fff;
 border-radius: var(--n-border-radius);
 display: inline-flex;
 `)]);

  const self$3 = (vars) => {
      return {
          borderRadius: vars.borderRadius
      };
  };
  const themeLight$1 = {
      name: 'QrCode',
      common: commonLight,
      self: self$3
  };
  var qrcodeLight = themeLight$1;

  /*
   * QR Code generator library (TypeScript)
   *
   * Copyright (c) Project Nayuki. (MIT License)
   * https://www.nayuki.io/page/qr-code-generator-library
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy of
   * this software and associated documentation files (the "Software"), to deal in
   * the Software without restriction, including without limitation the rights to
   * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
   * the Software, and to permit persons to whom the Software is furnished to do so,
   * subject to the following conditions:
   * - The above copyright notice and this permission notice shall be included in
   *   all copies or substantial portions of the Software.
   * - The Software is provided "as is", without warranty of any kind, express or
   *   implied, including but not limited to the warranties of merchantability,
   *   fitness for a particular purpose and noninfringement. In no event shall the
   *   authors or copyright holders be liable for any claim, damages or other
   *   liability, whether in an action of contract, tort or otherwise, arising from,
   *   out of or in connection with the Software or the use or other dealings in the
   *   Software.
   */
  // eslint-disable-next-line @typescript-eslint/no-namespace
  var qrcodegen;
  (function (qrcodegen) {
      /* ---- QR Code symbol class ---- */
      /*
       * A QR Code symbol, which is a type of two-dimension barcode.
       * Invented by Denso Wave and described in the ISO/IEC 18004 standard.
       * Instances of this class represent an immutable square grid of dark and light cells.
       * The class provides static factory functions to create a QR Code from text or binary data.
       * The class covers the QR Code Model 2 specification, supporting all versions (sizes)
       * from 1 to 40, all 4 error correction levels, and 4 character encoding modes.
       *
       * Ways to create a QR Code object:
       * - High level: Take the payload data and call QrCode.encodeText() or QrCode.encodeBinary().
       * - Mid level: Custom-make the list of segments and call QrCode.encodeSegments().
       * - Low level: Custom-make the array of data codeword bytes (including
       *   segment headers and final padding, excluding error correction codewords),
       *   supply the appropriate version number, and call the QrCode() constructor.
       * (Note that all ways require supplying the desired error correction level.)
       */
      class QrCode {
          /* -- Static factory functions (high level) -- */
          // Returns a QR Code representing the given Unicode text string at the given error correction level.
          // As a conservative upper bound, this function is guaranteed to succeed for strings that have 738 or fewer
          // Unicode code points (not UTF-16 code units) if the low error correction level is used. The smallest possible
          // QR Code version is automatically chosen for the output. The ECC level of the result may be higher than the
          // ecl argument if it can be done without increasing the version.
          static encodeText(text, ecl) {
              const segs = qrcodegen.QrSegment.makeSegments(text);
              return QrCode.encodeSegments(segs, ecl);
          }
          // Returns a QR Code representing the given binary data at the given error correction level.
          // This function always encodes using the binary segment mode, not any text mode. The maximum number of
          // bytes allowed is 2953. The smallest possible QR Code version is automatically chosen for the output.
          // The ECC level of the result may be higher than the ecl argument if it can be done without increasing the version.
          static encodeBinary(data, ecl) {
              const seg = qrcodegen.QrSegment.makeBytes(data);
              return QrCode.encodeSegments([seg], ecl);
          }
          /* -- Static factory functions (mid level) -- */
          // Returns a QR Code representing the given segments with the given encoding parameters.
          // The smallest possible QR Code version within the given range is automatically
          // chosen for the output. Iff boostEcl is true, then the ECC level of the result
          // may be higher than the ecl argument if it can be done without increasing the
          // version. The mask number is either between 0 to 7 (inclusive) to force that
          // mask, or -1 to automatically choose an appropriate mask (which may be slow).
          // This function allows the user to create a custom sequence of segments that switches
          // between modes (such as alphanumeric and byte) to encode text in less space.
          // This is a mid-level API; the high-level API is encodeText() and encodeBinary().
          static encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
              if (!(QrCode.MIN_VERSION <= minVersion &&
                  minVersion <= maxVersion &&
                  maxVersion <= QrCode.MAX_VERSION) ||
                  mask < -1 ||
                  mask > 7) {
                  throw new RangeError('Invalid value');
              }
              // Find the minimal version number to use
              let version;
              let dataUsedBits;
              for (version = minVersion;; version++) {
                  const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8; // Number of data bits available
                  const usedBits = QrSegment.getTotalBits(segs, version);
                  if (usedBits <= dataCapacityBits) {
                      dataUsedBits = usedBits;
                      break; // This version number is found to be suitable
                  }
                  if (version >= maxVersion) {
                      // All versions in the range could not fit the given data
                      throw new RangeError('Data too long');
                  }
              }
              // Increase the error correction level while the data still fits in the current version number
              for (const newEcl of [
                  QrCode.Ecc.MEDIUM,
                  QrCode.Ecc.QUARTILE,
                  QrCode.Ecc.HIGH
              ]) {
                  // From low to high
                  if (boostEcl &&
                      dataUsedBits <= QrCode.getNumDataCodewords(version, newEcl) * 8) {
                      ecl = newEcl;
                  }
              }
              // Concatenate all segments to create the data bit string
              const bb = [];
              for (const seg of segs) {
                  appendBits(seg.mode.modeBits, 4, bb);
                  appendBits(seg.numChars, seg.mode.numCharCountBits(version), bb);
                  for (const b of seg.getData()) {
                      bb.push(b);
                  }
              }
              // Add terminator and pad up to a byte if applicable
              const dataCapacityBits = QrCode.getNumDataCodewords(version, ecl) * 8;
              appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
              appendBits(0, (8 - (bb.length % 8)) % 8, bb);
              // Pad with alternating bytes until data capacity is reached
              for (let padByte = 0xec; bb.length < dataCapacityBits; padByte ^= 0xec ^ 0x11) {
                  appendBits(padByte, 8, bb);
              }
              // Pack bits into bytes in big endian
              const dataCodewords = [];
              while (dataCodewords.length * 8 < bb.length) {
                  dataCodewords.push(0);
              }
              bb.forEach((b, i) => (dataCodewords[i >>> 3] |= b << (7 - (i & 7))));
              // Create the QR Code object
              return new QrCode(version, ecl, dataCodewords, mask);
          }
          /* -- Constructor (low level) and fields -- */
          // Creates a new QR Code with the given version number,
          // error correction level, data codeword bytes, and mask number.
          // This is a low-level API that most users should not use directly.
          // A mid-level API is the encodeSegments() function.
          constructor(
          // The version number of this QR Code, which is between 1 and 40 (inclusive).
          // This determines the size of this barcode.
          version, 
          // The error correction level used in this QR Code.
          errorCorrectionLevel, dataCodewords, msk) {
              this.version = version;
              this.errorCorrectionLevel = errorCorrectionLevel;
              // The modules of this QR Code (false = light, true = dark).
              // Immutable after constructor finishes. Accessed through getModule().
              this.modules = [];
              // Indicates function modules that are not subjected to masking. Discarded when constructor finishes.
              this.isFunction = [];
              // Check scalar arguments
              if (version < QrCode.MIN_VERSION || version > QrCode.MAX_VERSION) {
                  throw new RangeError('Version value out of range');
              }
              if (msk < -1 || msk > 7) {
                  throw new RangeError('Mask value out of range');
              }
              this.size = version * 4 + 17;
              // Initialize both grids to be size*size arrays of Boolean false
              const row = [];
              for (let i = 0; i < this.size; i++) {
                  row.push(false);
              }
              for (let i = 0; i < this.size; i++) {
                  this.modules.push(row.slice()); // Initially all light
                  this.isFunction.push(row.slice());
              }
              // Compute ECC, draw modules
              this.drawFunctionPatterns();
              const allCodewords = this.addEccAndInterleave(dataCodewords);
              this.drawCodewords(allCodewords);
              // Do masking
              if (msk === -1) {
                  // Automatically choose best mask
                  let minPenalty = 1000000000;
                  for (let i = 0; i < 8; i++) {
                      this.applyMask(i);
                      this.drawFormatBits(i);
                      const penalty = this.getPenaltyScore();
                      if (penalty < minPenalty) {
                          msk = i;
                          minPenalty = penalty;
                      }
                      this.applyMask(i); // Undoes the mask due to XOR
                  }
              }
              this.mask = msk;
              this.applyMask(msk); // Apply the final choice of mask
              this.drawFormatBits(msk); // Overwrite old format bits
              this.isFunction = [];
          }
          /* -- Accessor methods -- */
          // Returns the color of the module (pixel) at the given coordinates, which is false
          // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
          // If the given coordinates are out of bounds, then false (light) is returned.
          getModule(x, y) {
              return (x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x]);
          }
          /* -- Private helper methods for constructor: Drawing function modules -- */
          // Reads this object's version field, and draws and marks all function modules.
          drawFunctionPatterns() {
              // Draw horizontal and vertical timing patterns
              for (let i = 0; i < this.size; i++) {
                  this.setFunctionModule(6, i, i % 2 === 0);
                  this.setFunctionModule(i, 6, i % 2 === 0);
              }
              // Draw 3 finder patterns (all corners except bottom right; overwrites some timing modules)
              this.drawFinderPattern(3, 3);
              this.drawFinderPattern(this.size - 4, 3);
              this.drawFinderPattern(3, this.size - 4);
              // Draw numerous alignment patterns
              const alignPatPos = this.getAlignmentPatternPositions();
              const numAlign = alignPatPos.length;
              for (let i = 0; i < numAlign; i++) {
                  for (let j = 0; j < numAlign; j++) {
                      // Don't draw on the three finder corners
                      if (!((i === 0 && j === 0) ||
                          (i === 0 && j === numAlign - 1) ||
                          (i === numAlign - 1 && j === 0))) {
                          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
                      }
                  }
              }
              // Draw configuration data
              this.drawFormatBits(0); // Dummy mask value; overwritten later in the constructor
              this.drawVersion();
          }
          // Draws two copies of the format bits (with its own error correction code)
          // based on the given mask and this object's error correction level field.
          drawFormatBits(mask) {
              // Calculate error correction code and pack bits
              const data = (this.errorCorrectionLevel.formatBits << 3) | mask; // errCorrLvl is uint2, mask is uint3
              let rem = data;
              for (let i = 0; i < 10; i++) {
                  rem = (rem << 1) ^ ((rem >>> 9) * 0x537);
              }
              const bits = ((data << 10) | rem) ^ 0x5412; // uint15
              // Draw first copy
              for (let i = 0; i <= 5; i++) {
                  this.setFunctionModule(8, i, getBit(bits, i));
              }
              this.setFunctionModule(8, 7, getBit(bits, 6));
              this.setFunctionModule(8, 8, getBit(bits, 7));
              this.setFunctionModule(7, 8, getBit(bits, 8));
              for (let i = 9; i < 15; i++) {
                  this.setFunctionModule(14 - i, 8, getBit(bits, i));
              }
              // Draw second copy
              for (let i = 0; i < 8; i++) {
                  this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
              }
              for (let i = 8; i < 15; i++) {
                  this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
              }
              this.setFunctionModule(8, this.size - 8, true); // Always dark
          }
          // Draws two copies of the version bits (with its own error correction code),
          // based on this object's version field, iff 7 <= version <= 40.
          drawVersion() {
              if (this.version < 7) {
                  return;
              }
              // Calculate error correction code and pack bits
              let rem = this.version; // version is uint6, in the range [7, 40]
              for (let i = 0; i < 12; i++) {
                  rem = (rem << 1) ^ ((rem >>> 11) * 0x1f25);
              }
              const bits = (this.version << 12) | rem; // uint18
              // Draw two copies
              for (let i = 0; i < 18; i++) {
                  const color = getBit(bits, i);
                  const a = this.size - 11 + (i % 3);
                  const b = Math.floor(i / 3);
                  this.setFunctionModule(a, b, color);
                  this.setFunctionModule(b, a, color);
              }
          }
          // Draws a 9*9 finder pattern including the border separator,
          // with the center module at (x, y). Modules can be out of bounds.
          drawFinderPattern(x, y) {
              for (let dy = -4; dy <= 4; dy++) {
                  for (let dx = -4; dx <= 4; dx++) {
                      const dist = Math.max(Math.abs(dx), Math.abs(dy)); // Chebyshev/infinity norm
                      const xx = x + dx;
                      const yy = y + dy;
                      if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size) {
                          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4);
                      }
                  }
              }
          }
          // Draws a 5*5 alignment pattern, with the center module
          // at (x, y). All modules must be in bounds.
          drawAlignmentPattern(x, y) {
              for (let dy = -2; dy <= 2; dy++) {
                  for (let dx = -2; dx <= 2; dx++) {
                      this.setFunctionModule(x + dx, y + dy, Math.max(Math.abs(dx), Math.abs(dy)) !== 1);
                  }
              }
          }
          // Sets the color of a module and marks it as a function module.
          // Only used by the constructor. Coordinates must be in bounds.
          setFunctionModule(x, y, isDark) {
              this.modules[y][x] = isDark;
              this.isFunction[y][x] = true;
          }
          /* -- Private helper methods for constructor: Codewords and masking -- */
          // Returns a new byte string representing the given data with the appropriate error correction
          // codewords appended to it, based on this object's version and error correction level.
          addEccAndInterleave(data) {
              const ver = this.version;
              const ecl = this.errorCorrectionLevel;
              if (data.length !== QrCode.getNumDataCodewords(ver, ecl)) {
                  throw new RangeError('Invalid argument');
              }
              // Calculate parameter numbers
              const numBlocks = QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver];
              const blockEccLen = QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver];
              const rawCodewords = Math.floor(QrCode.getNumRawDataModules(ver) / 8);
              const numShortBlocks = numBlocks - (rawCodewords % numBlocks);
              const shortBlockLen = Math.floor(rawCodewords / numBlocks);
              // Split data into blocks and append ECC to each block
              const blocks = [];
              const rsDiv = QrCode.reedSolomonComputeDivisor(blockEccLen);
              for (let i = 0, k = 0; i < numBlocks; i++) {
                  const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
                  k += dat.length;
                  const ecc = QrCode.reedSolomonComputeRemainder(dat, rsDiv);
                  if (i < numShortBlocks) {
                      dat.push(0);
                  }
                  blocks.push(dat.concat(ecc));
              }
              // Interleave (not concatenate) the bytes from every block into a single sequence
              const result = [];
              for (let i = 0; i < blocks[0].length; i++) {
                  blocks.forEach((block, j) => {
                      // Skip the padding byte in short blocks
                      if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks) {
                          result.push(block[i]);
                      }
                  });
              }
              return result;
          }
          // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
          // data area of this QR Code. Function modules need to be marked off before this is called.
          drawCodewords(data) {
              if (data.length !==
                  Math.floor(QrCode.getNumRawDataModules(this.version) / 8)) {
                  throw new RangeError('Invalid argument');
              }
              let i = 0; // Bit index into the data
              // Do the funny zigzag scan
              for (let right = this.size - 1; right >= 1; right -= 2) {
                  // Index of right column in each column pair
                  if (right === 6) {
                      right = 5;
                  }
                  for (let vert = 0; vert < this.size; vert++) {
                      // Vertical counter
                      for (let j = 0; j < 2; j++) {
                          const x = right - j; // Actual x coordinate
                          const upward = ((right + 1) & 2) === 0;
                          const y = upward ? this.size - 1 - vert : vert; // Actual y coordinate
                          if (!this.isFunction[y][x] && i < data.length * 8) {
                              this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
                              i++;
                          }
                          // If this QR Code has any remainder bits (0 to 7), they were assigned as
                          // 0/false/light by the constructor and are left unchanged by this method
                      }
                  }
              }
          }
          // XORs the codeword modules in this QR Code with the given mask pattern.
          // The function modules must be marked and the codeword bits must be drawn
          // before masking. Due to the arithmetic of XOR, calling applyMask() with
          // the same mask value a second time will undo the mask. A final well-formed
          // QR Code needs exactly one (not zero, two, etc.) mask applied.
          applyMask(mask) {
              if (mask < 0 || mask > 7) {
                  throw new RangeError('Mask value out of range');
              }
              for (let y = 0; y < this.size; y++) {
                  for (let x = 0; x < this.size; x++) {
                      let invert;
                      switch (mask) {
                          case 0:
                              invert = (x + y) % 2 === 0;
                              break;
                          case 1:
                              invert = y % 2 === 0;
                              break;
                          case 2:
                              invert = x % 3 === 0;
                              break;
                          case 3:
                              invert = (x + y) % 3 === 0;
                              break;
                          case 4:
                              invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
                              break;
                          case 5:
                              invert = ((x * y) % 2) + ((x * y) % 3) === 0;
                              break;
                          case 6:
                              invert = (((x * y) % 2) + ((x * y) % 3)) % 2 === 0;
                              break;
                          case 7:
                              invert = (((x + y) % 2) + ((x * y) % 3)) % 2 === 0;
                              break;
                          default:
                              throw new Error('Unreachable');
                      }
                      if (!this.isFunction[y][x] && invert) {
                          this.modules[y][x] = !this.modules[y][x];
                      }
                  }
              }
          }
          // Calculates and returns the penalty score based on state of this QR Code's current modules.
          // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
          getPenaltyScore() {
              let result = 0;
              // Adjacent modules in row having same color, and finder-like patterns
              for (let y = 0; y < this.size; y++) {
                  let runColor = false;
                  let runX = 0;
                  const runHistory = [0, 0, 0, 0, 0, 0, 0];
                  for (let x = 0; x < this.size; x++) {
                      if (this.modules[y][x] === runColor) {
                          runX++;
                          if (runX === 5) {
                              result += QrCode.PENALTY_N1;
                          }
                          else if (runX > 5) {
                              result++;
                          }
                      }
                      else {
                          this.finderPenaltyAddHistory(runX, runHistory);
                          if (!runColor) {
                              result +=
                                  this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                          }
                          runColor = this.modules[y][x];
                          runX = 1;
                      }
                  }
                  result +=
                      this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) *
                          QrCode.PENALTY_N3;
              }
              // Adjacent modules in column having same color, and finder-like patterns
              for (let x = 0; x < this.size; x++) {
                  let runColor = false;
                  let runY = 0;
                  const runHistory = [0, 0, 0, 0, 0, 0, 0];
                  for (let y = 0; y < this.size; y++) {
                      if (this.modules[y][x] === runColor) {
                          runY++;
                          if (runY === 5) {
                              result += QrCode.PENALTY_N1;
                          }
                          else if (runY > 5) {
                              result++;
                          }
                      }
                      else {
                          this.finderPenaltyAddHistory(runY, runHistory);
                          if (!runColor) {
                              result +=
                                  this.finderPenaltyCountPatterns(runHistory) * QrCode.PENALTY_N3;
                          }
                          runColor = this.modules[y][x];
                          runY = 1;
                      }
                  }
                  result +=
                      this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) *
                          QrCode.PENALTY_N3;
              }
              // 2*2 blocks of modules having same color
              for (let y = 0; y < this.size - 1; y++) {
                  for (let x = 0; x < this.size - 1; x++) {
                      const color = this.modules[y][x];
                      if (color === this.modules[y][x + 1] &&
                          color === this.modules[y + 1][x] &&
                          color === this.modules[y + 1][x + 1]) {
                          result += QrCode.PENALTY_N2;
                      }
                  }
              }
              // Balance of dark and light modules
              let dark = 0;
              for (const row of this.modules) {
                  dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
              }
              const total = this.size * this.size; // Note that size is odd, so dark/total != 1/2
              // Compute the smallest integer k >= 0 such that (45-5k)% <= dark/total <= (55+5k)%
              const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
              result += k * QrCode.PENALTY_N4;
              return result;
          }
          /* -- Private helper functions -- */
          // Returns an ascending list of positions of alignment patterns for this version number.
          // Each position is in the range [0,177), and are used on both the x and y axes.
          // This could be implemented as lookup table of 40 variable-length lists of integers.
          getAlignmentPatternPositions() {
              if (this.version === 1) {
                  return [];
              }
              else {
                  const numAlign = Math.floor(this.version / 7) + 2;
                  const step = this.version === 32
                      ? 26
                      : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
                  const result = [6];
                  for (let pos = this.size - 7; result.length < numAlign; pos -= step) {
                      result.splice(1, 0, pos);
                  }
                  return result;
              }
          }
          // Returns the number of data bits that can be stored in a QR Code of the given version number, after
          // all function modules are excluded. This includes remainder bits, so it might not be a multiple of 8.
          // The result is in the range [208, 29648]. This could be implemented as a 40-entry lookup table.
          static getNumRawDataModules(ver) {
              if (ver < QrCode.MIN_VERSION || ver > QrCode.MAX_VERSION) {
                  throw new RangeError('Version number out of range');
              }
              let result = (16 * ver + 128) * ver + 64;
              if (ver >= 2) {
                  const numAlign = Math.floor(ver / 7) + 2;
                  result -= (25 * numAlign - 10) * numAlign - 55;
                  if (ver >= 7) {
                      result -= 36;
                  }
              }
              return result;
          }
          // Returns the number of 8-bit data (i.e. not error correction) codewords contained in any
          // QR Code of the given version number and error correction level, with remainder bits discarded.
          // This stateless pure function could be implemented as a (40*4)-cell lookup table.
          static getNumDataCodewords(ver, ecl) {
              return (Math.floor(QrCode.getNumRawDataModules(ver) / 8) -
                  QrCode.ECC_CODEWORDS_PER_BLOCK[ecl.ordinal][ver] *
                      QrCode.NUM_ERROR_CORRECTION_BLOCKS[ecl.ordinal][ver]);
          }
          // Returns a Reed-Solomon ECC generator polynomial for the given degree. This could be
          // implemented as a lookup table over all possible parameter values, instead of as an algorithm.
          static reedSolomonComputeDivisor(degree) {
              if (degree < 1 || degree > 255) {
                  throw new RangeError('Degree out of range');
              }
              // Polynomial coefficients are stored from highest to lowest power, excluding the leading term which is always 1.
              // For example the polynomial x^3 + 255x^2 + 8x + 93 is stored as the uint8 array [255, 8, 93].
              const result = [];
              for (let i = 0; i < degree - 1; i++) {
                  result.push(0);
              }
              result.push(1); // Start off with the monomial x^0
              // Compute the product polynomial (x - r^0) * (x - r^1) * (x - r^2) * ... * (x - r^{degree-1}),
              // and drop the highest monomial term which is always 1x^degree.
              // Note that r = 0x02, which is a generator element of this field GF(2^8/0x11D).
              let root = 1;
              for (let i = 0; i < degree; i++) {
                  // Multiply the current product by (x - r^i)
                  for (let j = 0; j < result.length; j++) {
                      result[j] = QrCode.reedSolomonMultiply(result[j], root);
                      if (j + 1 < result.length) {
                          result[j] ^= result[j + 1];
                      }
                  }
                  root = QrCode.reedSolomonMultiply(root, 0x02);
              }
              return result;
          }
          // Returns the Reed-Solomon error correction codeword for the given data and divisor polynomials.
          static reedSolomonComputeRemainder(data, divisor) {
              const result = divisor.map((_) => 0);
              for (const b of data) {
                  // Polynomial division
                  // eslint-disable-next-line @typescript-eslint/non-nullable-type-assertion-style
                  const factor = b ^ result.shift();
                  result.push(0);
                  divisor.forEach((coef, i) => (result[i] ^= QrCode.reedSolomonMultiply(coef, factor)));
              }
              return result;
          }
          // Returns the product of the two given field elements modulo GF(2^8/0x11D). The arguments and result
          // are unsigned 8-bit integers. This could be implemented as a lookup table of 256*256 entries of uint8.
          static reedSolomonMultiply(x, y) {
              if (x >>> 8 !== 0 || y >>> 8 !== 0) {
                  throw new RangeError('Byte out of range');
              }
              // Russian peasant multiplication
              let z = 0;
              for (let i = 7; i >= 0; i--) {
                  z = (z << 1) ^ ((z >>> 7) * 0x11d);
                  z ^= ((y >>> i) & 1) * x;
              }
              return z;
          }
          // Can only be called immediately after a light run is added, and
          // returns either 0, 1, or 2. A helper function for getPenaltyScore().
          finderPenaltyCountPatterns(runHistory) {
              const n = runHistory[1];
              const core = n > 0 &&
                  runHistory[2] === n &&
                  runHistory[3] === n * 3 &&
                  runHistory[4] === n &&
                  runHistory[5] === n;
              return ((core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) +
                  (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0));
          }
          // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
          finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
              if (currentRunColor) {
                  // Terminate dark run
                  this.finderPenaltyAddHistory(currentRunLength, runHistory);
                  currentRunLength = 0;
              }
              currentRunLength += this.size; // Add light border to final run
              this.finderPenaltyAddHistory(currentRunLength, runHistory);
              return this.finderPenaltyCountPatterns(runHistory);
          }
          // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
          finderPenaltyAddHistory(currentRunLength, runHistory) {
              if (runHistory[0] === 0) {
                  currentRunLength += this.size;
              } // Add light border to initial run
              runHistory.pop();
              runHistory.unshift(currentRunLength);
          }
      }
      /* -- Constants and tables -- */
      // The minimum version number supported in the QR Code Model 2 standard.
      QrCode.MIN_VERSION = 1;
      // The maximum version number supported in the QR Code Model 2 standard.
      QrCode.MAX_VERSION = 40;
      // For use in getPenaltyScore(), when evaluating which mask is best.
      QrCode.PENALTY_N1 = 3;
      QrCode.PENALTY_N2 = 3;
      QrCode.PENALTY_N3 = 40;
      QrCode.PENALTY_N4 = 10;
      QrCode.ECC_CODEWORDS_PER_BLOCK = [
          // Version: (note that index 0 is for padding, and is set to an illegal value)
          // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
          [
              -1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28,
              30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30,
              30, 30, 30, 30, 30
          ], // Low
          [
              -1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28,
              26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
              28, 28, 28, 28, 28
          ], // Medium
          [
              -1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28,
              28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30,
              30, 30, 30, 30, 30
          ], // Quartile
          [
              -1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28,
              28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30,
              30, 30, 30, 30, 30
          ] // High
      ];
      QrCode.NUM_ERROR_CORRECTION_BLOCKS = [
          // Version: (note that index 0 is for padding, and is set to an illegal value)
          // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
          [
              -1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9,
              10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25
          ], // Low
          [
              -1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16,
              17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45,
              47, 49
          ], // Medium
          [
              -1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20,
              23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62,
              65, 68
          ], // Quartile
          [
              -1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25,
              25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70,
              74, 77, 81
          ] // High
      ];
      qrcodegen.QrCode = QrCode;
      // Appends the given number of low-order bits of the given value
      // to the given buffer. Requires 0 <= len <= 31 and 0 <= val < 2^len.
      function appendBits(val, len, bb) {
          if (len < 0 || len > 31 || val >>> len !== 0) {
              throw new RangeError('Value out of range');
          }
          for (let i = len - 1; i >= 0; i-- // Append bit by bit
          ) {
              bb.push((val >>> i) & 1);
          }
      }
      // Returns true iff the i'th bit of x is set to 1.
      function getBit(x, i) {
          return ((x >>> i) & 1) !== 0;
      }
      /* ---- Data segment class ---- */
      /*
       * A segment of character/binary/control data in a QR Code symbol.
       * Instances of this class are immutable.
       * The mid-level way to create a segment is to take the payload data
       * and call a static factory function such as QrSegment.makeNumeric().
       * The low-level way to create a segment is to custom-make the bit buffer
       * and call the QrSegment() constructor with appropriate values.
       * This segment class imposes no length restrictions, but QR Codes have restrictions.
       * Even in the most favorable conditions, a QR Code can only hold 7089 characters of data.
       * Any segment longer than this is meaningless for the purpose of generating QR Codes.
       */
      class QrSegment {
          /* -- Static factory functions (mid level) -- */
          // Returns a segment representing the given binary data encoded in
          // byte mode. All input byte arrays are acceptable. Any text string
          // can be converted to UTF-8 bytes and encoded as a byte mode segment.
          static makeBytes(data) {
              const bb = [];
              for (const b of data) {
                  appendBits(b, 8, bb);
              }
              return new QrSegment(QrSegment.Mode.BYTE, data.length, bb);
          }
          // Returns a segment representing the given string of decimal digits encoded in numeric mode.
          static makeNumeric(digits) {
              if (!QrSegment.isNumeric(digits)) {
                  throw new RangeError('String contains non-numeric characters');
              }
              const bb = [];
              for (let i = 0; i < digits.length;) {
                  // Consume up to 3 digits per iteration
                  const n = Math.min(digits.length - i, 3);
                  appendBits(parseInt(digits.substr(i, n), 10), n * 3 + 1, bb);
                  i += n;
              }
              return new QrSegment(QrSegment.Mode.NUMERIC, digits.length, bb);
          }
          // Returns a segment representing the given text string encoded in alphanumeric mode.
          // The characters allowed are: 0 to 9, A to Z (uppercase only), space,
          // dollar, percent, asterisk, plus, hyphen, period, slash, colon.
          static makeAlphanumeric(text) {
              if (!QrSegment.isAlphanumeric(text)) {
                  throw new RangeError('String contains unencodable characters in alphanumeric mode');
              }
              const bb = [];
              let i;
              for (i = 0; i + 2 <= text.length; i += 2) {
                  // Process groups of 2
                  let temp = QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
                  temp += QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
                  appendBits(temp, 11, bb);
              }
              if (i < text.length) {
                  // 1 character remaining
                  appendBits(QrSegment.ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
              }
              return new QrSegment(QrSegment.Mode.ALPHANUMERIC, text.length, bb);
          }
          // Returns a new mutable list of zero or more segments to represent the given Unicode text string.
          // The result may use various segment modes and switch modes to optimize the length of the bit stream.
          static makeSegments(text) {
              // Select the most efficient segment encoding automatically
              if (text === '') {
                  return [];
              }
              else if (QrSegment.isNumeric(text)) {
                  return [QrSegment.makeNumeric(text)];
              }
              else if (QrSegment.isAlphanumeric(text)) {
                  return [QrSegment.makeAlphanumeric(text)];
              }
              else {
                  return [QrSegment.makeBytes(QrSegment.toUtf8ByteArray(text))];
              }
          }
          // Returns a segment representing an Extended Channel Interpretation
          // (ECI) designator with the given assignment value.
          static makeEci(assignVal) {
              const bb = [];
              if (assignVal < 0) {
                  throw new RangeError('ECI assignment value out of range');
              }
              else if (assignVal < 1 << 7) {
                  appendBits(assignVal, 8, bb);
              }
              else if (assignVal < 1 << 14) {
                  appendBits(0b10, 2, bb);
                  appendBits(assignVal, 14, bb);
              }
              else if (assignVal < 1000000) {
                  appendBits(0b110, 3, bb);
                  appendBits(assignVal, 21, bb);
              }
              else {
                  throw new RangeError('ECI assignment value out of range');
              }
              return new QrSegment(QrSegment.Mode.ECI, 0, bb);
          }
          // Tests whether the given string can be encoded as a segment in numeric mode.
          // A string is encodable iff each character is in the range 0 to 9.
          static isNumeric(text) {
              return QrSegment.NUMERIC_REGEX.test(text);
          }
          // Tests whether the given string can be encoded as a segment in alphanumeric mode.
          // A string is encodable iff each character is in the following set: 0 to 9, A to Z
          // (uppercase only), space, dollar, percent, asterisk, plus, hyphen, period, slash, colon.
          static isAlphanumeric(text) {
              return QrSegment.ALPHANUMERIC_REGEX.test(text);
          }
          /* -- Constructor (low level) and fields -- */
          // Creates a new QR Code segment with the given attributes and data.
          // The character count (numChars) must agree with the mode and the bit buffer length,
          // but the constraint isn't checked. The given bit buffer is cloned and stored.
          constructor(
          // The mode indicator of this segment.
          mode, 
          // The length of this segment's unencoded data. Measured in characters for
          // numeric/alphanumeric/kanji mode, bytes for byte mode, and 0 for ECI mode.
          // Always zero or positive. Not the same as the data's bit length.
          numChars, 
          // The data bits of this segment. Accessed through getData().
          bitData) {
              this.mode = mode;
              this.numChars = numChars;
              this.bitData = bitData;
              if (numChars < 0) {
                  throw new RangeError('Invalid argument');
              }
              this.bitData = bitData.slice(); // Make defensive copy
          }
          /* -- Methods -- */
          // Returns a new copy of the data bits of this segment.
          getData() {
              return this.bitData.slice(); // Make defensive copy
          }
          // (Package-private) Calculates and returns the number of bits needed to encode the given segments at
          // the given version. The result is infinity if a segment has too many characters to fit its length field.
          static getTotalBits(segs, version) {
              let result = 0;
              for (const seg of segs) {
                  const ccbits = seg.mode.numCharCountBits(version);
                  if (seg.numChars >= 1 << ccbits) {
                      return Infinity;
                  } // The segment's length doesn't fit the field's bit width
                  result += 4 + ccbits + seg.bitData.length;
              }
              return result;
          }
          // Returns a new array of bytes representing the given string encoded in UTF-8.
          static toUtf8ByteArray(str) {
              str = encodeURI(str);
              const result = [];
              for (let i = 0; i < str.length; i++) {
                  if (str.charAt(i) !== '%') {
                      result.push(str.charCodeAt(i));
                  }
                  else {
                      result.push(parseInt(str.substr(i + 1, 2), 16));
                      i += 2;
                  }
              }
              return result;
          }
      }
      /* -- Constants -- */
      // Describes precisely all strings that are encodable in numeric mode.
      QrSegment.NUMERIC_REGEX = /^[0-9]*$/;
      // Describes precisely all strings that are encodable in alphanumeric mode.
      QrSegment.ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+./:-]*$/;
      // The set of all legal characters in alphanumeric mode,
      // where each character value maps to the index in the string.
      QrSegment.ALPHANUMERIC_CHARSET = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:';
      qrcodegen.QrSegment = QrSegment;
  })(qrcodegen || (qrcodegen = {}));
  /* ---- Public helper enumeration ---- */
  // eslint-disable-next-line @typescript-eslint/no-namespace
  (function (qrcodegen) {
      (function (QrCode) {
          /*
           * The error correction level in a QR Code symbol. Immutable.
           */
          class Ecc {
              /* -- Constructor and fields -- */
              constructor(
              // In the range 0 to 3 (unsigned 2-bit integer).
              ordinal, 
              // (Package-private) In the range 0 to 3 (unsigned 2-bit integer).
              formatBits) {
                  this.ordinal = ordinal;
                  this.formatBits = formatBits;
              }
          }
          /* -- Constants -- */
          Ecc.LOW = new Ecc(0, 1); // The QR Code can tolerate about  7% erroneous codewords
          Ecc.MEDIUM = new Ecc(1, 0); // The QR Code can tolerate about 15% erroneous codewords
          Ecc.QUARTILE = new Ecc(2, 3); // The QR Code can tolerate about 25% erroneous codewords
          Ecc.HIGH = new Ecc(3, 2); // The QR Code can tolerate about 30% erroneous codewords
          QrCode.Ecc = Ecc;
      })(qrcodegen.QrCode || (qrcodegen.QrCode = {}));
  })(qrcodegen || (qrcodegen = {}));
  /* ---- Public helper enumeration ---- */
  // eslint-disable-next-line @typescript-eslint/no-namespace
  (function (qrcodegen) {
      (function (QrSegment) {
          /*
           * Describes how a segment's data bits are interpreted. Immutable.
           */
          class Mode {
              /* -- Constructor and fields -- */
              constructor(
              // The mode indicator bits, which is a uint4 value (range 0 to 15).
              modeBits, 
              // Number of character count bits for three different version ranges.
              numBitsCharCount) {
                  this.modeBits = modeBits;
                  this.numBitsCharCount = numBitsCharCount;
              }
              /* -- Method -- */
              // (Package-private) Returns the bit width of the character count field for a segment in
              // this mode in a QR Code at the given version number. The result is in the range [0, 16].
              numCharCountBits(ver) {
                  return this.numBitsCharCount[Math.floor((ver + 7) / 17)];
              }
          }
          /* -- Constants -- */
          Mode.NUMERIC = new Mode(0x1, [10, 12, 14]);
          Mode.ALPHANUMERIC = new Mode(0x2, [9, 11, 13]);
          Mode.BYTE = new Mode(0x4, [8, 16, 16]);
          Mode.KANJI = new Mode(0x8, [8, 10, 12]);
          Mode.ECI = new Mode(0x7, [0, 0, 0]);
          QrSegment.Mode = Mode;
      })(qrcodegen.QrSegment || (qrcodegen.QrSegment = {}));
  })(qrcodegen || (qrcodegen = {}));
  var qrcodegen$1 = qrcodegen;

  const ERROR_CORRECTION_LEVEL = {
      L: qrcodegen$1.QrCode.Ecc.LOW,
      M: qrcodegen$1.QrCode.Ecc.MEDIUM,
      Q: qrcodegen$1.QrCode.Ecc.QUARTILE,
      H: qrcodegen$1.QrCode.Ecc.HIGH
  };
  const qrCodeProps = Object.assign(Object.assign({}, useTheme.props), { value: String, color: {
          type: String,
          default: '#000'
      }, backgroundColor: {
          type: String,
          default: '#FFF'
      }, iconSrc: String, iconSize: {
          type: Number,
          default: 40
      }, iconBackgroundColor: {
          type: String,
          default: '#FFF'
      }, iconBorderRadius: {
          type: Number,
          default: 4
      }, size: {
          type: Number,
          default: 100
      }, padding: {
          type: [Number, String],
          default: 12
      }, errorCorrectionLevel: {
          type: String,
          default: 'M'
      } });
  // For retina display
  const UPSCALE_RATIO = 2;
  var QrCode = defineComponent({
      name: 'QrCode',
      props: qrCodeProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('QrCode', '-qr-code', style$p, qrcodeLight, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              return {
                  '--n-border-radius': themeRef.value.self.borderRadius
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('qr-code', undefined, cssVarsRef, props)
              : undefined;
          const canvasRef = ref();
          const qr = computed(() => {
              var _a;
              const errorCorrectionLevel = ERROR_CORRECTION_LEVEL[props.errorCorrectionLevel];
              return qrcodegen$1.QrCode.encodeText((_a = props.value) !== null && _a !== void 0 ? _a : '-', errorCorrectionLevel);
          });
          onMounted(() => {
              const imageLoadedTrigger = ref(0);
              let loadedIcon = null;
              watchEffect(() => {
                  void imageLoadedTrigger.value;
                  drawCanvas(qr.value, props.size, props.color, props.backgroundColor, loadedIcon
                      ? {
                          icon: loadedIcon,
                          iconBorderRadius: props.iconBorderRadius,
                          iconSize: props.iconSize,
                          iconBackgroundColor: props.iconBackgroundColor
                      }
                      : null);
              });
              watchEffect(() => {
                  const { iconSrc } = props;
                  if (iconSrc) {
                      let aborted = false;
                      const img = new Image();
                      img.src = iconSrc;
                      img.onload = () => {
                          if (aborted)
                              return;
                          loadedIcon = img;
                          imageLoadedTrigger.value++;
                      };
                      return () => {
                          aborted = true;
                      };
                  }
              });
          });
          function drawCanvas(qr, size, foregroundColor, backgroundColor, iconConfig) {
              const canvas = canvasRef.value;
              if (!canvas)
                  return;
              const canvasWidth = size * UPSCALE_RATIO;
              const width = qr.size;
              const scale = canvasWidth / width;
              canvas.width = canvasWidth;
              canvas.height = canvasWidth;
              const ctx = canvas.getContext('2d');
              if (!ctx)
                  return;
              ctx.clearRect(0, 0, canvas.width, canvas.height);
              for (let y = 0; y < qr.size; y++) {
                  for (let x = 0; x < qr.size; x++) {
                      ctx.fillStyle = qr.getModule(x, y) ? foregroundColor : backgroundColor;
                      const startX = Math.floor(x * scale);
                      const endX = Math.ceil((x + 1) * scale);
                      const startY = Math.floor(y * scale);
                      const endY = Math.ceil((y + 1) * scale);
                      ctx.fillRect(startX, startY, endX - startX, endY - startY);
                  }
              }
              if (iconConfig) {
                  const { icon, iconBackgroundColor, iconBorderRadius, iconSize } = iconConfig;
                  const finalIconSize = iconSize * UPSCALE_RATIO;
                  const centerX = (canvas.width - finalIconSize) / 2;
                  const centerY = (canvas.height - finalIconSize) / 2;
                  ctx.fillStyle = iconBackgroundColor;
                  ctx.beginPath();
                  ctx.roundRect(centerX, centerY, finalIconSize, finalIconSize, iconBorderRadius * UPSCALE_RATIO);
                  ctx.fill();
                  const aspectRatio = icon.width / icon.height;
                  const scaledWidth = aspectRatio >= 1 ? finalIconSize : finalIconSize * aspectRatio;
                  const scaledHeight = aspectRatio <= 1 ? finalIconSize : finalIconSize / aspectRatio;
                  const left = centerX + (finalIconSize - scaledWidth) / 2;
                  const top = centerY + (finalIconSize - scaledHeight) / 2;
                  ctx.drawImage(icon, left, top, scaledWidth, scaledHeight);
              }
          }
          return {
              canvasRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass
          };
      },
      render() {
          const { mergedClsPrefix, backgroundColor, padding, cssVars, themeClass, size } = this;
          return (h("div", { class: [`${mergedClsPrefix}-qr-code`, themeClass], style: Object.assign({ padding: typeof padding === 'number' ? `${padding}px` : padding, backgroundColor }, cssVars) },
              h("canvas", { ref: "canvasRef", style: {
                      width: `${size}px`,
                      height: `${size}px`
                  } })));
      }
  });

  var StarIcon = (h("svg", { viewBox: "0 0 512 512" },
      h("path", { d: "M394 480a16 16 0 01-9.39-3L256 383.76 127.39 477a16 16 0 01-24.55-18.08L153 310.35 23 221.2a16 16 0 019-29.2h160.38l48.4-148.95a16 16 0 0130.44 0l48.4 149H480a16 16 0 019.05 29.2L359 310.35l50.13 148.53A16 16 0 01394 480z" })));

  // vars:
  // --n-bezier
  // --n-item-color
  // --n-item-color-active
  var style$o = cB('rate', {
    display: 'inline-flex',
    flexWrap: 'nowrap'
  }, [c$1('&:hover', [cE('item', `
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE('item', `
 position: relative;
 display: flex;
 transition:
 transform .1s var(--n-bezier),
 color .3s var(--n-bezier);
 transform: scale(1);
 font-size: var(--n-item-size);
 color: var(--n-item-color);
 `, [c$1('&:not(:first-child)', `
 margin-left: 6px;
 `), cM('active', `
 color: var(--n-item-color-active);
 `)]), cNotM('readonly', `
 cursor: pointer;
 `, [cE('item', [c$1('&:hover', `
 transform: scale(1.05);
 `), c$1('&:active', `
 transform: scale(0.96);
 `)])]), cE('half', `
 display: flex;
 transition: inherit;
 position: absolute;
 top: 0;
 left: 0;
 bottom: 0;
 width: 50%;
 overflow: hidden;
 color: rgba(255, 255, 255, 0);
 `, [cM('active', `
 color: var(--n-item-color-active);
 `)])]);

  const rateProps = Object.assign(Object.assign({}, useTheme.props), { allowHalf: Boolean, count: {
          type: Number,
          default: 5
      }, value: Number, defaultValue: {
          type: Number,
          default: null
      }, readonly: Boolean, size: {
          type: [String, Number],
          default: 'medium'
      }, clearable: Boolean, color: String, onClear: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array] });
  var Rate = defineComponent({
      name: 'Rate',
      props: rateProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Rate', '-rate', style$o, rateLight, props, mergedClsPrefixRef);
          const controlledValueRef = toRef(props, 'value');
          const uncontrolledValueRef = ref(props.defaultValue);
          const hoverIndexRef = ref(null);
          const formItem = useFormItem(props);
          const mergedValue = useMergedState(controlledValueRef, uncontrolledValueRef);
          function doUpdateValue(value) {
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              const { nTriggerFormChange, nTriggerFormInput } = formItem;
              if (_onUpdateValue) {
                  call(_onUpdateValue, value);
              }
              if (onUpdateValue) {
                  call(onUpdateValue, value);
              }
              uncontrolledValueRef.value = value;
              nTriggerFormChange();
              nTriggerFormInput();
          }
          function getDerivedValue(index, e) {
              if (props.allowHalf) {
                  if (e.offsetX >=
                      Math.floor(e.currentTarget.offsetWidth / 2)) {
                      return index + 1;
                  }
                  else {
                      return index + 0.5;
                  }
              }
              else {
                  return index + 1;
              }
          }
          let cleared = false;
          function handleMouseMove(index, e) {
              if (cleared)
                  return;
              hoverIndexRef.value = getDerivedValue(index, e);
          }
          function handleMouseLeave() {
              hoverIndexRef.value = null;
          }
          function handleClick(index, e) {
              var _a;
              const { clearable } = props;
              const derivedValue = getDerivedValue(index, e);
              if (clearable && derivedValue === mergedValue.value) {
                  cleared = true;
                  (_a = props.onClear) === null || _a === void 0 ? void 0 : _a.call(props);
                  hoverIndexRef.value = null;
                  doUpdateValue(null);
              }
              else {
                  doUpdateValue(derivedValue);
              }
          }
          function handleMouseEnterSomeStar() {
              cleared = false;
          }
          const mergedSizeRef = computed(() => {
              const { size } = props;
              const { self } = themeRef.value;
              if (typeof size === 'number') {
                  return `${size}px`;
              }
              else {
                  return self[createKey('size', size)];
              }
          });
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { itemColor, itemColorActive } = self;
              const { color } = props;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-item-color': itemColor,
                  '--n-item-color-active': color || itemColorActive,
                  '--n-item-size': mergedSizeRef.value
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('rate', computed(() => {
                  const size = mergedSizeRef.value;
                  const { color } = props;
                  let hash = '';
                  if (size) {
                      hash += size[0];
                  }
                  if (color) {
                      hash += color2Class(color);
                  }
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedValue,
              hoverIndex: hoverIndexRef,
              handleMouseMove,
              handleClick,
              handleMouseLeave,
              handleMouseEnterSomeStar,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { readonly, hoverIndex, mergedValue, mergedClsPrefix, onRender, $slots: { default: defaultSlot } } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-rate`,
                  {
                      [`${mergedClsPrefix}-rate--readonly`]: readonly
                  },
                  this.themeClass
              ], style: this.cssVars, onMouseleave: this.handleMouseLeave }, renderList(this.count, (_, index) => {
              const icon = defaultSlot ? (defaultSlot({ index })) : (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => StarIcon }));
              const entireStarActive = hoverIndex !== null
                  ? index + 1 <= hoverIndex
                  : index + 1 <= (mergedValue || 0);
              return (h("div", { key: index, class: [
                      `${mergedClsPrefix}-rate__item`,
                      entireStarActive && `${mergedClsPrefix}-rate__item--active`
                  ], onClick: readonly
                      ? undefined
                      : (e) => {
                          this.handleClick(index, e);
                      }, onMouseenter: this.handleMouseEnterSomeStar, onMousemove: readonly
                      ? undefined
                      : (e) => {
                          this.handleMouseMove(index, e);
                      } },
                  icon,
                  this.allowHalf ? (h("div", { class: [
                          `${mergedClsPrefix}-rate__half`,
                          {
                              [`${mergedClsPrefix}-rate__half--active`]: !entireStarActive && hoverIndex !== null
                                  ? index + 0.5 <= hoverIndex
                                  : index + 0.5 <= (mergedValue || 0)
                          }
                      ] }, icon)) : null));
          })));
      }
  });

  var image404 = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
      h("circle", { fill: "#FFCB4C", cx: "18", cy: "17.018", r: "17" }),
      h("path", { fill: "#65471B", d: "M14.524 21.036c-.145-.116-.258-.274-.312-.464-.134-.46.13-.918.59-1.021 4.528-1.021 7.577 1.363 7.706 1.465.384.306.459.845.173 1.205-.286.358-.828.401-1.211.097-.11-.084-2.523-1.923-6.182-1.098-.274.061-.554-.016-.764-.184z" }),
      h("ellipse", { fill: "#65471B", cx: "13.119", cy: "11.174", rx: "2.125", ry: "2.656" }),
      h("ellipse", { fill: "#65471B", cx: "24.375", cy: "12.236", rx: "2.125", ry: "2.656" }),
      h("path", { fill: "#F19020", d: "M17.276 35.149s1.265-.411 1.429-1.352c.173-.972-.624-1.167-.624-1.167s1.041-.208 1.172-1.376c.123-1.101-.861-1.363-.861-1.363s.97-.4 1.016-1.539c.038-.959-.995-1.428-.995-1.428s5.038-1.221 5.556-1.341c.516-.12 1.32-.615 1.069-1.694-.249-1.08-1.204-1.118-1.697-1.003-.494.115-6.744 1.566-8.9 2.068l-1.439.334c-.54.127-.785-.11-.404-.512.508-.536.833-1.129.946-2.113.119-1.035-.232-2.313-.433-2.809-.374-.921-1.005-1.649-1.734-1.899-1.137-.39-1.945.321-1.542 1.561.604 1.854.208 3.375-.833 4.293-2.449 2.157-3.588 3.695-2.83 6.973.828 3.575 4.377 5.876 7.952 5.048l3.152-.681z" }),
      h("path", { fill: "#65471B", d: "M9.296 6.351c-.164-.088-.303-.224-.391-.399-.216-.428-.04-.927.393-1.112 4.266-1.831 7.699-.043 7.843.034.433.231.608.747.391 1.154-.216.405-.74.546-1.173.318-.123-.063-2.832-1.432-6.278.047-.257.109-.547.085-.785-.042zm12.135 3.75c-.156-.098-.286-.243-.362-.424-.187-.442.023-.927.468-1.084 4.381-1.536 7.685.48 7.823.567.415.26.555.787.312 1.178-.242.39-.776.495-1.191.238-.12-.072-2.727-1.621-6.267-.379-.266.091-.553.046-.783-.096z" })));

  var image500 = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
      h("path", { fill: "#FFCC4D", d: "M36 18c0 9.941-8.059 18-18 18-9.94 0-18-8.059-18-18C0 8.06 8.06 0 18 0c9.941 0 18 8.06 18 18" }),
      h("ellipse", { fill: "#664500", cx: "18", cy: "27", rx: "5", ry: "6" }),
      h("path", { fill: "#664500", d: "M5.999 11c-.208 0-.419-.065-.599-.2-.442-.331-.531-.958-.2-1.4C8.462 5.05 12.816 5 13 5c.552 0 1 .448 1 1 0 .551-.445.998-.996 1-.155.002-3.568.086-6.204 3.6-.196.262-.497.4-.801.4zm24.002 0c-.305 0-.604-.138-.801-.4-2.64-3.521-6.061-3.598-6.206-3.6-.55-.006-.994-.456-.991-1.005C22.006 5.444 22.45 5 23 5c.184 0 4.537.05 7.8 4.4.332.442.242 1.069-.2 1.4-.18.135-.39.2-.599.2zm-16.087 4.5l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L12.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L13.914 15.5zm11 0l1.793-1.793c.391-.391.391-1.023 0-1.414s-1.023-.391-1.414 0L23.5 14.086l-1.793-1.793c-.391-.391-1.023-.391-1.414 0s-.391 1.023 0 1.414l1.793 1.793-1.793 1.793c-.391.391-.391 1.023 0 1.414.195.195.451.293.707.293s.512-.098.707-.293l1.793-1.793 1.793 1.793c.195.195.451.293.707.293s.512-.098.707-.293c.391-.391.391-1.023 0-1.414L24.914 15.5z" })));

  var image418 = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
      h("ellipse", { fill: "#292F33", cx: "18", cy: "26", rx: "18", ry: "10" }),
      h("ellipse", { fill: "#66757F", cx: "18", cy: "24", rx: "18", ry: "10" }),
      h("path", { fill: "#E1E8ED", d: "M18 31C3.042 31 1 16 1 12h34c0 2-1.958 19-17 19z" }),
      h("path", { fill: "#77B255", d: "M35 12.056c0 5.216-7.611 9.444-17 9.444S1 17.271 1 12.056C1 6.84 8.611 3.611 18 3.611s17 3.229 17 8.445z" }),
      h("ellipse", { fill: "#A6D388", cx: "18", cy: "13", rx: "15", ry: "7" }),
      h("path", { d: "M21 17c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.739-1.109.9-2.246.478-3.377-.461-1.236-1.438-1.996-1.731-2.077-.553 0-.958-.443-.958-.996 0-.552.491-.995 1.043-.995.997 0 2.395 1.153 3.183 2.625 1.034 1.933.91 4.039-.351 5.929-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.196-.451.294-.707.294zm-6-2c-.256 0-.512-.098-.707-.293-2.337-2.337-2.376-4.885-.125-8.262.727-1.091.893-2.083.494-2.947-.444-.961-1.431-1.469-1.684-1.499-.552 0-.989-.447-.989-1 0-.552.458-1 1.011-1 .997 0 2.585.974 3.36 2.423.481.899 1.052 2.761-.528 5.131-1.961 2.942-1.531 4.332-.125 5.738.391.391.391 1.023 0 1.414-.195.197-.451.295-.707.295z", fill: "#5C913B" })));

  var image403 = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 36 36" },
      h("path", { fill: "#EF9645", d: "M15.5 2.965c1.381 0 2.5 1.119 2.5 2.5v.005L20.5.465c1.381 0 2.5 1.119 2.5 2.5V4.25l2.5-1.535c1.381 0 2.5 1.119 2.5 2.5V8.75L29 18H15.458L15.5 2.965z" }),
      h("path", { fill: "#FFDC5D", d: "M4.625 16.219c1.381-.611 3.354.208 4.75 2.188.917 1.3 1.187 3.151 2.391 3.344.46.073 1.234-.313 1.234-1.397V4.5s0-2 2-2 2 2 2 2v11.633c0-.029 1-.064 1-.082V2s0-2 2-2 2 2 2 2v14.053c0 .017 1 .041 1 .069V4.25s0-2 2-2 2 2 2 2v12.638c0 .118 1 .251 1 .398V8.75s0-2 2-2 2 2 2 2V24c0 6.627-5.373 12-12 12-4.775 0-8.06-2.598-9.896-5.292C8.547 28.423 8.096 26.051 8 25.334c0 0-.123-1.479-1.156-2.865-1.469-1.969-2.5-3.156-3.125-3.866-.317-.359-.625-1.707.906-2.384z" })));

  // --n-bezier
  // --n-font-size
  // --n-icon-size
  // --n-line-height
  // --n-text-color
  // --n-title-font-size
  // --n-title-font-weight
  // --n-title-text-color
  var style$n = cB('result', `
 color: var(--n-text-color);
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier);
`, [cB('result-icon', `
 display: flex;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `, [cE('status-image', `
 font-size: var(--n-icon-size);
 width: 1em;
 height: 1em;
 `), cB('base-icon', `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB('result-content', {
    marginTop: '24px'
  }), cB('result-footer', `
 margin-top: 24px;
 text-align: center;
 `), cB('result-header', [cE('title', `
 margin-top: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 text-align: center;
 color: var(--n-title-text-color);
 font-size: var(--n-title-font-size);
 `), cE('description', `
 margin-top: 4px;
 text-align: center;
 font-size: var(--n-font-size);
 `)])]);

  const iconMap = {
      403: image403,
      404: image404,
      418: image418,
      500: image500,
      info: h(InfoIcon, null),
      success: h(SuccessIcon, null),
      warning: h(WarningIcon, null),
      error: h(ErrorIcon, null)
  };
  const resultProps = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: String,
          default: 'medium'
      }, status: {
          type: String,
          default: 'info'
      }, title: String, description: String });
  var Result = defineComponent({
      name: 'Result',
      props: resultProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Result', '-result', style$n, resultLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size, status } = props;
              const { common: { cubicBezierEaseInOut }, self: { textColor, lineHeight, titleTextColor, titleFontWeight, [createKey('iconColor', status)]: iconColor, [createKey('fontSize', size)]: fontSize, [createKey('titleFontSize', size)]: titleFontSize, [createKey('iconSize', size)]: iconSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-icon-size': iconSize,
                  '--n-line-height': lineHeight,
                  '--n-text-color': textColor,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-title-text-color': titleTextColor,
                  '--n-icon-color': iconColor || ''
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('result', computed(() => {
                  const { size, status } = props;
                  let hash = '';
                  if (size) {
                      hash += size[0];
                  }
                  if (status) {
                      hash += status[0];
                  }
                  return hash;
              }), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { status, $slots, mergedClsPrefix, onRender } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [`${mergedClsPrefix}-result`, this.themeClass], style: this.cssVars },
              h("div", { class: `${mergedClsPrefix}-result-icon` }, ((_a = $slots.icon) === null || _a === void 0 ? void 0 : _a.call($slots)) || (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => iconMap[status] }))),
              h("div", { class: `${mergedClsPrefix}-result-header` },
                  this.title ? (h("div", { class: `${mergedClsPrefix}-result-header__title` }, this.title)) : null,
                  this.description ? (h("div", { class: `${mergedClsPrefix}-result-header__description` }, this.description)) : null),
              $slots.default && (h("div", { class: `${mergedClsPrefix}-result-content` }, $slots)),
              $slots.footer && (h("div", { class: `${mergedClsPrefix}-result-footer` }, $slots.footer()))));
      }
  });

  const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), { trigger: String, xScrollable: Boolean, onScroll: Function, size: Number });
  const Scrollbar = defineComponent({
      name: 'Scrollbar',
      props: scrollbarProps,
      setup() {
          const scrollbarInstRef = ref(null);
          const exposedMethods = {
              scrollTo: (...args) => {
                  var _a;
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(args[0], args[1]);
              },
              scrollBy: (...args) => {
                  var _a;
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollBy(args[0], args[1]);
              }
          };
          return Object.assign(Object.assign({}, exposedMethods), { scrollbarInstRef });
      },
      render() {
          return (h(NScrollbar, Object.assign({ ref: "scrollbarInstRef" }, this.$props), this.$slots));
      }
  });
  var Scrollbar$1 = Scrollbar;

  const self$2 = (vars) => {
      const { heightSmall, heightMedium, heightLarge, borderRadius } = vars;
      return {
          color: '#eee',
          colorEnd: '#ddd',
          borderRadius,
          heightSmall,
          heightMedium,
          heightLarge
      };
  };
  const skeletonLight = {
      name: 'Skeleton',
      common: commonLight,
      self: self$2
  };

  // vars:
  // --n-color-start
  // --n-color-end
  // --n-bezier
  var style$m = c$1([cB('skeleton', `
 height: 1em;
 width: 100%;
 transition: background-color .3s var(--n-bezier);
 transition:
 --n-color-start .3s var(--n-bezier),
 --n-color-end .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 animation: 2s skeleton-loading infinite cubic-bezier(0.36, 0, 0.64, 1);
 background-color: var(--n-color-start);
 `), c$1('@keyframes skeleton-loading', `
 0% {
 background: var(--n-color-start);
 }
 40% {
 background: var(--n-color-end);
 }
 80% {
 background: var(--n-color-start);
 }
 100% {
 background: var(--n-color-start);
 }
 `)]);

  const skeletonProps = Object.assign(Object.assign({}, useTheme.props), { text: Boolean, round: Boolean, circle: Boolean, height: [String, Number], width: [String, Number], size: String, repeat: {
          type: Number,
          default: 1
      }, animated: {
          type: Boolean,
          default: true
      }, sharp: {
          type: Boolean,
          default: true
      } });
  var Skeleton = defineComponent({
      name: 'Skeleton',
      inheritAttrs: false,
      props: skeletonProps,
      setup(props) {
          useHoudini();
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Skeleton', '-skeleton', style$m, skeletonLight, props, mergedClsPrefixRef);
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              style: computed(() => {
                  var _a, _b;
                  const theme = themeRef.value;
                  const { common: { cubicBezierEaseInOut } } = theme;
                  const selfThemeVars = theme.self;
                  const { color, colorEnd, borderRadius } = selfThemeVars;
                  let sizeHeight;
                  const { circle, sharp, round, width, height, size, text, animated } = props;
                  if (size !== undefined) {
                      sizeHeight = selfThemeVars[createKey('height', size)];
                  }
                  const mergedWidth = circle ? (_a = width !== null && width !== void 0 ? width : height) !== null && _a !== void 0 ? _a : sizeHeight : width;
                  const mergedHeight = (_b = (circle ? width !== null && width !== void 0 ? width : height : height)) !== null && _b !== void 0 ? _b : sizeHeight;
                  return {
                      display: text ? 'inline-block' : '',
                      verticalAlign: text ? '-0.125em' : '',
                      borderRadius: circle
                          ? '50%'
                          : round
                              ? '4096px'
                              : sharp
                                  ? ''
                                  : borderRadius,
                      width: typeof mergedWidth === 'number' ? pxfy(mergedWidth) : mergedWidth,
                      height: typeof mergedHeight === 'number'
                          ? pxfy(mergedHeight)
                          : mergedHeight,
                      animation: !animated ? 'none' : '',
                      '--n-bezier': cubicBezierEaseInOut,
                      '--n-color-start': color,
                      '--n-color-end': colorEnd
                  };
              })
          };
      },
      render() {
          const { repeat: repeatProp, style, mergedClsPrefix, $attrs } = this;
          // BUG:
          // Chrome devtools can't read the element
          // Maybe it's a bug of chrome
          const child = h('div', mergeProps({
              class: `${mergedClsPrefix}-skeleton`,
              style
          }, $attrs));
          if (repeatProp > 1) {
              return h(Fragment, null, repeat(repeatProp, null).map((_) => [child, '\n']));
          }
          return child;
      }
  });

  function isTouchEvent(e) {
      return window.TouchEvent && e instanceof window.TouchEvent;
  }
  function useRefs() {
      const refs = new Map();
      const setRefs = (index) => (el) => {
          refs.set(index, el);
      };
      onBeforeUpdate(() => {
          refs.clear();
      });
      return [refs, setRefs];
  }

  // vars:
  // --n-bezier
  // --n-dot-border
  // --n-dot-border-active
  // --n-dot-border-radius
  // --n-dot-box-shadow
  // --n-dot-color
  // --n-dot-color-modal
  // --n-dot-color-popover
  // --n-dot-height
  // --n-dot-width
  // --n-fill-color
  // --n-fill-color-hover
  // --n-font-size
  // --n-handle-box-shadow
  // --n-handle-box-shadow-active
  // --n-handle-box-shadow-focus
  // --n-handle-box-shadow-hover
  // --n-handle-color
  // --n-handle-size
  // --n-indicator-border-radius
  // --n-indicator-box-shadow
  // --n-indicator-color
  // --n-indicator-text-color
  // --n-rail-color
  // --n-rail-color-hover
  // --n-rail-height
  // --n-rail-width-vertical
  // --n-mark-font-size
  var style$l = c$1([cB('slider', `
 display: block;
 padding: calc((var(--n-handle-size) - var(--n-rail-height)) / 2) 0;
 position: relative;
 z-index: 0;
 width: 100%;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 `, [cM('reverse', [cB('slider-handles', [cB('slider-handle-wrapper', `
 transform: translate(50%, -50%);
 `)]), cB('slider-dots', [cB('slider-dot', `
 transform: translateX(50%, -50%);
 `)]), cM('vertical', [cB('slider-handles', [cB('slider-handle-wrapper', `
 transform: translate(-50%, -50%);
 `)]), cB('slider-marks', [cB('slider-mark', `
 transform: translateY(calc(-50% + var(--n-dot-height) / 2));
 `)]), cB('slider-dots', [cB('slider-dot', `
 transform: translateX(-50%) translateY(0);
 `)])])]), cM('vertical', `
 padding: 0 calc((var(--n-handle-size) - var(--n-rail-height)) / 2);
 width: var(--n-rail-width-vertical);
 height: 100%;
 `, [cB('slider-handles', `
 top: calc(var(--n-handle-size) / 2);
 right: 0;
 bottom: calc(var(--n-handle-size) / 2);
 left: 0;
 `, [cB('slider-handle-wrapper', `
 top: unset;
 left: 50%;
 transform: translate(-50%, 50%);
 `)]), cB('slider-rail', `
 height: 100%;
 `, [cE('fill', `
 top: unset;
 right: 0;
 bottom: unset;
 left: 0;
 `)]), cM('with-mark', `
 width: var(--n-rail-width-vertical);
 margin: 0 32px 0 8px;
 `), cB('slider-marks', `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 22px;
 font-size: var(--n-mark-font-size);
 `, [cB('slider-mark', `
 transform: translateY(50%);
 white-space: nowrap;
 `)]), cB('slider-dots', `
 top: calc(var(--n-handle-size) / 2);
 right: unset;
 bottom: calc(var(--n-handle-size) / 2);
 left: 50%;
 `, [cB('slider-dot', `
 transform: translateX(-50%) translateY(50%);
 `)])]), cM('disabled', `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `, [cB('slider-handle', `
 cursor: not-allowed;
 `)]), cM('with-mark', `
 width: 100%;
 margin: 8px 0 32px 0;
 `), c$1('&:hover', [cB('slider-rail', {
    backgroundColor: 'var(--n-rail-color-hover)'
  }, [cE('fill', {
    backgroundColor: 'var(--n-fill-color-hover)'
  })]), cB('slider-handle', {
    boxShadow: 'var(--n-handle-box-shadow-hover)'
  })]), cM('active', [cB('slider-rail', {
    backgroundColor: 'var(--n-rail-color-hover)'
  }, [cE('fill', {
    backgroundColor: 'var(--n-fill-color-hover)'
  })]), cB('slider-handle', {
    boxShadow: 'var(--n-handle-box-shadow-hover)'
  })]), cB('slider-marks', `
 position: absolute;
 top: 18px;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cB('slider-mark', `
 position: absolute;
 transform: translateX(-50%);
 white-space: nowrap;
 `)]), cB('slider-rail', `
 width: 100%;
 position: relative;
 height: var(--n-rail-height);
 background-color: var(--n-rail-color);
 transition: background-color .3s var(--n-bezier);
 border-radius: calc(var(--n-rail-height) / 2);
 `, [cE('fill', `
 position: absolute;
 top: 0;
 bottom: 0;
 border-radius: calc(var(--n-rail-height) / 2);
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-fill-color);
 `)]), cB('slider-handles', `
 position: absolute;
 top: 0;
 right: calc(var(--n-handle-size) / 2);
 bottom: 0;
 left: calc(var(--n-handle-size) / 2);
 `, [cB('slider-handle-wrapper', `
 outline: none;
 position: absolute;
 top: 50%;
 transform: translate(-50%, -50%);
 cursor: pointer;
 display: flex;
 `, [cB('slider-handle', `
 height: var(--n-handle-size);
 width: var(--n-handle-size);
 border-radius: 50%;
 overflow: hidden;
 transition: box-shadow .2s var(--n-bezier), background-color .3s var(--n-bezier);
 background-color: var(--n-handle-color);
 box-shadow: var(--n-handle-box-shadow);
 `, [c$1('&:hover', `
 box-shadow: var(--n-handle-box-shadow-hover);
 `)]), c$1('&:focus', [cB('slider-handle', `
 box-shadow: var(--n-handle-box-shadow-focus);
 `, [c$1('&:hover', `
 box-shadow: var(--n-handle-box-shadow-active);
 `)])])])]), cB('slider-dots', `
 position: absolute;
 top: 50%;
 left: calc(var(--n-handle-size) / 2);
 right: calc(var(--n-handle-size) / 2);
 `, [cM('transition-disabled', [cB('slider-dot', 'transition: none;')]), cB('slider-dot', `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 position: absolute;
 transform: translate(-50%, -50%);
 height: var(--n-dot-height);
 width: var(--n-dot-width);
 border-radius: var(--n-dot-border-radius);
 overflow: hidden;
 box-sizing: border-box;
 border: var(--n-dot-border);
 background-color: var(--n-dot-color);
 `, [cM('active', 'border: var(--n-dot-border-active);')])])]), cB('slider-handle-indicator', `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [fadeInScaleUpTransition()]), cB('slider-handle-indicator', `
 font-size: var(--n-font-size);
 padding: 6px 10px;
 border-radius: var(--n-indicator-border-radius);
 color: var(--n-indicator-text-color);
 background-color: var(--n-indicator-color);
 box-shadow: var(--n-indicator-box-shadow);
 `, [cM('top', `
 margin-bottom: 12px;
 `), cM('right', `
 margin-left: 12px;
 `), cM('bottom', `
 margin-top: 12px;
 `), cM('left', `
 margin-right: 12px;
 `), fadeInScaleUpTransition()]), insideModal(cB('slider', [cB('slider-dot', 'background-color: var(--n-dot-color-modal);')])), insidePopover(cB('slider', [cB('slider-dot', 'background-color: var(--n-dot-color-popover);')]))]);

  /* eslint-disable @typescript-eslint/space-before-function-paren */
  // ref: https://developer.mozilla.org/zh-CN/docs/Web/API/MouseEvent/button
  const eventButtonLeft = 0;
  const sliderProps = Object.assign(Object.assign({}, useTheme.props), { to: useAdjustedTo.propTo, defaultValue: {
          type: [Number, Array],
          default: 0
      }, marks: Object, disabled: {
          type: Boolean,
          default: undefined
      }, formatTooltip: Function, keyboard: {
          type: Boolean,
          default: true
      }, min: {
          type: Number,
          default: 0
      }, max: {
          type: Number,
          default: 100
      }, step: {
          type: [Number, String],
          default: 1
      }, range: Boolean, value: [Number, Array], placement: String, showTooltip: {
          type: Boolean,
          default: undefined
      }, tooltip: {
          type: Boolean,
          default: true
      }, vertical: Boolean, reverse: Boolean, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onDragstart: [Function], onDragend: [Function] });
  var Slider = defineComponent({
      name: 'Slider',
      props: sliderProps,
      setup(props) {
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Slider', '-slider', style$l, sliderLight$1, props, mergedClsPrefixRef);
          // dom ref
          const handleRailRef = ref(null);
          const [handleRefs, setHandleRefs] = useRefs();
          const [followerRefs, setFollowerRefs] = useRefs();
          const followerEnabledIndexSetRef = ref(new Set());
          // data ref
          const formItem = useFormItem(props);
          const { mergedDisabledRef } = formItem;
          const precisionRef = computed(() => {
              const { step } = props;
              if (Number(step) <= 0 || step === 'mark')
                  return 0;
              const stepString = step.toString();
              let precision = 0;
              if (stepString.includes('.')) {
                  precision = stepString.length - stepString.indexOf('.') - 1;
              }
              return precision;
          });
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const arrifiedValueRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              return (props.range ? mergedValue : [mergedValue]).map(clampValue);
          });
          const handleCountExceeds2Ref = computed(() => arrifiedValueRef.value.length > 2);
          const mergedPlacementRef = computed(() => {
              return props.placement === undefined
                  ? props.vertical
                      ? 'right'
                      : 'top'
                  : props.placement;
          });
          const markValuesRef = computed(() => {
              const { marks } = props;
              return marks ? Object.keys(marks).map(parseFloat) : null;
          });
          // status ref
          const activeIndexRef = ref(-1);
          const previousIndexRef = ref(-1);
          const hoverIndexRef = ref(-1);
          const draggingRef = ref(false);
          // style ref
          const dotTransitionDisabledRef = ref(false);
          const styleDirectionRef = computed(() => {
              const { vertical, reverse } = props;
              const left = reverse ? 'right' : 'left';
              const bottom = reverse ? 'top' : 'bottom';
              return vertical ? bottom : left;
          });
          const fillStyleRef = computed(() => {
              if (handleCountExceeds2Ref.value)
                  return;
              const values = arrifiedValueRef.value;
              const start = valueToPercentage(props.range ? Math.min(...values) : props.min);
              const end = valueToPercentage(props.range ? Math.max(...values) : values[0]);
              const { value: styleDirection } = styleDirectionRef;
              return props.vertical
                  ? {
                      [styleDirection]: `${start}%`,
                      height: `${end - start}%`
                  }
                  : {
                      [styleDirection]: `${start}%`,
                      width: `${end - start}%`
                  };
          });
          const markInfosRef = computed(() => {
              const mergedMarks = [];
              const { marks } = props;
              if (marks) {
                  const orderValues = arrifiedValueRef.value.slice();
                  orderValues.sort((a, b) => a - b);
                  const { value: styleDirection } = styleDirectionRef;
                  const { value: handleCountExceeds2 } = handleCountExceeds2Ref;
                  const { range } = props;
                  const isActive = handleCountExceeds2
                      ? () => false
                      : (num) => range
                          ? num >= orderValues[0] &&
                              num <= orderValues[orderValues.length - 1]
                          : num <= orderValues[0];
                  for (const key of Object.keys(marks)) {
                      const num = Number(key);
                      mergedMarks.push({
                          active: isActive(num),
                          label: marks[key],
                          style: {
                              [styleDirection]: `${valueToPercentage(num)}%`
                          }
                      });
                  }
              }
              return mergedMarks;
          });
          function getHandleStyle(value, index) {
              const percentage = valueToPercentage(value);
              const { value: styleDirection } = styleDirectionRef;
              return {
                  [styleDirection]: `${percentage}%`,
                  zIndex: index === activeIndexRef.value ? 1 : 0
              };
          }
          function isShowTooltip(index) {
              return (props.showTooltip ||
                  hoverIndexRef.value === index ||
                  (activeIndexRef.value === index && draggingRef.value));
          }
          function shouldKeepTooltipTransition(index) {
              if (!draggingRef.value)
                  return true;
              return !(activeIndexRef.value === index && previousIndexRef.value === index);
          }
          function focusActiveHandle(index) {
              var _a;
              if (~index) {
                  activeIndexRef.value = index;
                  (_a = handleRefs.get(index)) === null || _a === void 0 ? void 0 : _a.focus();
              }
          }
          function syncPosition() {
              followerRefs.forEach((inst, index) => {
                  if (isShowTooltip(index))
                      inst.syncPosition();
              });
          }
          function doUpdateValue(value) {
              const { 'onUpdate:value': _onUpdateValue, onUpdateValue } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function dispatchValueUpdate(value) {
              const { range } = props;
              if (range) {
                  if (Array.isArray(value)) {
                      const { value: oldValues } = arrifiedValueRef;
                      if (value.join() !== oldValues.join()) {
                          doUpdateValue(value);
                      }
                  }
              }
              else if (!Array.isArray(value)) {
                  const oldValue = arrifiedValueRef.value[0];
                  if (oldValue !== value) {
                      doUpdateValue(value);
                  }
              }
          }
          function doDispatchValue(value, index) {
              if (props.range) {
                  const values = arrifiedValueRef.value.slice();
                  values.splice(index, 1, value);
                  dispatchValueUpdate(values);
              }
              else {
                  dispatchValueUpdate(value);
              }
          }
          // value conversion
          function sanitizeValue(value, currentValue, stepBuffer) {
              const stepping = stepBuffer !== undefined;
              if (!stepBuffer) {
                  stepBuffer = value - currentValue > 0 ? 1 : -1;
              }
              const markValues = markValuesRef.value || [];
              const { step } = props;
              if (step === 'mark') {
                  const closestMark = getClosestMark(value, markValues.concat(currentValue), stepping ? stepBuffer : undefined);
                  return closestMark ? closestMark.value : currentValue;
              }
              if (step <= 0)
                  return currentValue;
              const { value: precision } = precisionRef;
              let closestMark;
              // if it is a stepping, priority will be given to the marks
              // on the rail, otherwise take the nearest one
              if (stepping) {
                  const currentStep = Number((currentValue / step).toFixed(precision));
                  const actualStep = Math.floor(currentStep);
                  const leftStep = currentStep > actualStep ? actualStep : actualStep - 1;
                  const rightStep = currentStep < actualStep ? actualStep : actualStep + 1;
                  closestMark = getClosestMark(currentValue, [
                      Number((leftStep * step).toFixed(precision)),
                      Number((rightStep * step).toFixed(precision)),
                      ...markValues
                  ], stepBuffer);
              }
              else {
                  const roundValue = getRoundValue(value);
                  closestMark = getClosestMark(value, [...markValues, roundValue]);
              }
              return closestMark ? clampValue(closestMark.value) : currentValue;
          }
          function clampValue(value) {
              return Math.min(props.max, Math.max(props.min, value));
          }
          function valueToPercentage(value) {
              const { max, min } = props;
              return ((value - min) / (max - min)) * 100;
          }
          function percentageToValue(percentage) {
              const { max, min } = props;
              return min + (max - min) * percentage;
          }
          function getRoundValue(value) {
              const { step, min } = props;
              if (Number(step) <= 0 || step === 'mark')
                  return value;
              const newValue = Math.round((value - min) / step) * step + min;
              return Number(newValue.toFixed(precisionRef.value));
          }
          function getClosestMark(currentValue, markValues = markValuesRef.value, buffer) {
              if (!(markValues === null || markValues === void 0 ? void 0 : markValues.length))
                  return null;
              let closestMark = null;
              let index = -1;
              while (++index < markValues.length) {
                  const diff = markValues[index] - currentValue;
                  const distance = Math.abs(diff);
                  if (
                  // find marks in the same direction
                  (buffer === undefined || diff * buffer > 0) &&
                      (closestMark === null || distance < closestMark.distance)) {
                      closestMark = {
                          index,
                          distance,
                          value: markValues[index]
                      };
                  }
              }
              return closestMark;
          }
          function getPointValue(event) {
              const railEl = handleRailRef.value;
              if (!railEl)
                  return;
              const touchEvent = isTouchEvent(event) ? event.touches[0] : event;
              const railRect = railEl.getBoundingClientRect();
              let percentage;
              if (props.vertical) {
                  percentage = (railRect.bottom - touchEvent.clientY) / railRect.height;
              }
              else {
                  percentage = (touchEvent.clientX - railRect.left) / railRect.width;
              }
              if (props.reverse) {
                  percentage = 1 - percentage;
              }
              return percentageToValue(percentage);
          }
          // dom event handle
          function handleRailKeyDown(e) {
              if (mergedDisabledRef.value || !props.keyboard)
                  return;
              const { vertical, reverse } = props;
              switch (e.key) {
                  case 'ArrowUp':
                      e.preventDefault();
                      handleStepValue(vertical && reverse ? -1 : 1);
                      break;
                  case 'ArrowRight':
                      e.preventDefault();
                      handleStepValue(!vertical && reverse ? -1 : 1);
                      break;
                  case 'ArrowDown':
                      e.preventDefault();
                      handleStepValue(vertical && reverse ? 1 : -1);
                      break;
                  case 'ArrowLeft':
                      e.preventDefault();
                      handleStepValue(!vertical && reverse ? 1 : -1);
                      break;
              }
          }
          function handleStepValue(ratio) {
              const activeIndex = activeIndexRef.value;
              if (activeIndex === -1)
                  return;
              const { step } = props;
              const currentValue = arrifiedValueRef.value[activeIndex];
              const nextValue = Number(step) <= 0 || step === 'mark'
                  ? currentValue
                  : currentValue + step * ratio;
              doDispatchValue(
              // Avoid the number of value does not change when `step` is null
              sanitizeValue(nextValue, currentValue, ratio > 0 ? 1 : -1), activeIndex);
          }
          function handleRailMouseDown(event) {
              var _a, _b;
              if (mergedDisabledRef.value)
                  return;
              if (!isTouchEvent(event) && event.button !== eventButtonLeft) {
                  return;
              }
              const pointValue = getPointValue(event);
              if (pointValue === undefined)
                  return;
              const values = arrifiedValueRef.value.slice();
              const activeIndex = props.range
                  ? (_b = (_a = getClosestMark(pointValue, values)) === null || _a === void 0 ? void 0 : _a.index) !== null && _b !== void 0 ? _b : -1
                  : 0;
              if (activeIndex !== -1) {
                  // avoid triggering scrolling on touch
                  event.preventDefault();
                  focusActiveHandle(activeIndex);
                  startDragging();
                  doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
              }
          }
          function startDragging() {
              if (!draggingRef.value) {
                  draggingRef.value = true;
                  if (props.onDragstart)
                      call(props.onDragstart);
                  on('touchend', document, handleMouseUp);
                  on('mouseup', document, handleMouseUp);
                  on('touchmove', document, handleMouseMove);
                  on('mousemove', document, handleMouseMove);
              }
          }
          function stopDragging() {
              if (draggingRef.value) {
                  draggingRef.value = false;
                  if (props.onDragend)
                      call(props.onDragend);
                  off('touchend', document, handleMouseUp);
                  off('mouseup', document, handleMouseUp);
                  off('touchmove', document, handleMouseMove);
                  off('mousemove', document, handleMouseMove);
              }
          }
          function handleMouseMove(event) {
              const { value: activeIndex } = activeIndexRef;
              if (!draggingRef.value || activeIndex === -1) {
                  stopDragging();
                  return;
              }
              const pointValue = getPointValue(event);
              if (pointValue === undefined)
                  return;
              doDispatchValue(sanitizeValue(pointValue, arrifiedValueRef.value[activeIndex]), activeIndex);
          }
          function handleMouseUp() {
              stopDragging();
          }
          function handleHandleFocus(index) {
              activeIndexRef.value = index;
              // Wake focus style
              if (!mergedDisabledRef.value) {
                  hoverIndexRef.value = index;
              }
          }
          function handleHandleBlur(index) {
              if (activeIndexRef.value === index) {
                  activeIndexRef.value = -1;
                  stopDragging();
              }
              if (hoverIndexRef.value === index) {
                  hoverIndexRef.value = -1;
              }
          }
          function handleHandleMouseEnter(index) {
              hoverIndexRef.value = index;
          }
          function handleHandleMouseLeave(index) {
              if (hoverIndexRef.value === index) {
                  hoverIndexRef.value = -1;
              }
          }
          watch(activeIndexRef, (_, previous) => void nextTick(() => (previousIndexRef.value = previous)));
          watch(mergedValueRef, () => {
              if (props.marks) {
                  if (dotTransitionDisabledRef.value)
                      return;
                  dotTransitionDisabledRef.value = true;
                  void nextTick(() => {
                      dotTransitionDisabledRef.value = false;
                  });
              }
              void nextTick(syncPosition);
          });
          onBeforeUnmount(() => {
              stopDragging();
          });
          const cssVarsRef = computed(() => {
              const { self: { markFontSize, railColor, railColorHover, fillColor, fillColorHover, handleColor, opacityDisabled, dotColor, dotColorModal, handleBoxShadow, handleBoxShadowHover, handleBoxShadowActive, handleBoxShadowFocus, dotBorder, dotBoxShadow, railHeight, railWidthVertical, handleSize, dotHeight, dotWidth, dotBorderRadius, fontSize, dotBorderActive, dotColorPopover }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-dot-border': dotBorder,
                  '--n-dot-border-active': dotBorderActive,
                  '--n-dot-border-radius': dotBorderRadius,
                  '--n-dot-box-shadow': dotBoxShadow,
                  '--n-dot-color': dotColor,
                  '--n-dot-color-modal': dotColorModal,
                  '--n-dot-color-popover': dotColorPopover,
                  '--n-dot-height': dotHeight,
                  '--n-dot-width': dotWidth,
                  '--n-fill-color': fillColor,
                  '--n-fill-color-hover': fillColorHover,
                  '--n-font-size': fontSize,
                  '--n-handle-box-shadow': handleBoxShadow,
                  '--n-handle-box-shadow-active': handleBoxShadowActive,
                  '--n-handle-box-shadow-focus': handleBoxShadowFocus,
                  '--n-handle-box-shadow-hover': handleBoxShadowHover,
                  '--n-handle-color': handleColor,
                  '--n-handle-size': handleSize,
                  '--n-opacity-disabled': opacityDisabled,
                  '--n-rail-color': railColor,
                  '--n-rail-color-hover': railColorHover,
                  '--n-rail-height': railHeight,
                  '--n-rail-width-vertical': railWidthVertical,
                  '--n-mark-font-size': markFontSize
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('slider', undefined, cssVarsRef, props)
              : undefined;
          const indicatorCssVarsRef = computed(() => {
              const { self: { fontSize, indicatorColor, indicatorBoxShadow, indicatorTextColor, indicatorBorderRadius } } = themeRef.value;
              return {
                  '--n-font-size': fontSize,
                  '--n-indicator-border-radius': indicatorBorderRadius,
                  '--n-indicator-box-shadow': indicatorBoxShadow,
                  '--n-indicator-color': indicatorColor,
                  '--n-indicator-text-color': indicatorTextColor
              };
          });
          const indicatorThemeClassHandle = inlineThemeDisabled
              ? useThemeClass('slider-indicator', undefined, indicatorCssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              namespace: namespaceRef,
              uncontrolledValue: uncontrolledValueRef,
              mergedValue: mergedValueRef,
              mergedDisabled: mergedDisabledRef,
              mergedPlacement: mergedPlacementRef,
              isMounted: isMounted(),
              adjustedTo: useAdjustedTo(props),
              dotTransitionDisabled: dotTransitionDisabledRef,
              markInfos: markInfosRef,
              isShowTooltip,
              shouldKeepTooltipTransition,
              handleRailRef,
              setHandleRefs,
              setFollowerRefs,
              fillStyle: fillStyleRef,
              getHandleStyle,
              activeIndex: activeIndexRef,
              arrifiedValues: arrifiedValueRef,
              followerEnabledIndexSet: followerEnabledIndexSetRef,
              handleRailMouseDown,
              handleHandleFocus,
              handleHandleBlur,
              handleHandleMouseEnter,
              handleHandleMouseLeave,
              handleRailKeyDown,
              indicatorCssVars: inlineThemeDisabled ? undefined : indicatorCssVarsRef,
              indicatorThemeClass: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.themeClass,
              indicatorOnRender: indicatorThemeClassHandle === null || indicatorThemeClassHandle === void 0 ? void 0 : indicatorThemeClassHandle.onRender,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix, themeClass, formatTooltip } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [
                  `${mergedClsPrefix}-slider`,
                  themeClass,
                  {
                      [`${mergedClsPrefix}-slider--disabled`]: this.mergedDisabled,
                      [`${mergedClsPrefix}-slider--active`]: this.activeIndex !== -1,
                      [`${mergedClsPrefix}-slider--with-mark`]: this.marks,
                      [`${mergedClsPrefix}-slider--vertical`]: this.vertical,
                      [`${mergedClsPrefix}-slider--reverse`]: this.reverse
                  }
              ], style: this.cssVars, onKeydown: this.handleRailKeyDown, onMousedown: this.handleRailMouseDown, onTouchstart: this.handleRailMouseDown },
              h("div", { class: `${mergedClsPrefix}-slider-rail` },
                  h("div", { class: `${mergedClsPrefix}-slider-rail__fill`, style: this.fillStyle }),
                  this.marks ? (h("div", { class: [
                          `${mergedClsPrefix}-slider-dots`,
                          this.dotTransitionDisabled &&
                              `${mergedClsPrefix}-slider-dots--transition-disabled`
                      ] }, this.markInfos.map((mark) => (h("div", { key: mark.label, class: [
                          `${mergedClsPrefix}-slider-dot`,
                          {
                              [`${mergedClsPrefix}-slider-dot--active`]: mark.active
                          }
                      ], style: mark.style }))))) : null,
                  h("div", { ref: "handleRailRef", class: `${mergedClsPrefix}-slider-handles` }, this.arrifiedValues.map((value, index) => {
                      const showTooltip = this.isShowTooltip(index);
                      return (h(VBinder, null, {
                          default: () => [
                              h(VTarget, null, {
                                  default: () => (h("div", { ref: this.setHandleRefs(index), class: `${mergedClsPrefix}-slider-handle-wrapper`, tabindex: this.mergedDisabled ? -1 : 0, style: this.getHandleStyle(value, index), onFocus: () => {
                                          this.handleHandleFocus(index);
                                      }, onBlur: () => {
                                          this.handleHandleBlur(index);
                                      }, onMouseenter: () => {
                                          this.handleHandleMouseEnter(index);
                                      }, onMouseleave: () => {
                                          this.handleHandleMouseLeave(index);
                                      } }, resolveSlot(this.$slots.thumb, () => [
                                      h("div", { class: `${mergedClsPrefix}-slider-handle` })
                                  ])))
                              }),
                              this.tooltip && (h(VFollower, { ref: this.setFollowerRefs(index), show: showTooltip, to: this.adjustedTo, enabled: (this.showTooltip && !this.range) ||
                                      this.followerEnabledIndexSet.has(index), teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, placement: this.mergedPlacement, containerClass: this.namespace }, {
                                  default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, css: this.shouldKeepTooltipTransition(index), onEnter: () => {
                                          this.followerEnabledIndexSet.add(index);
                                      }, onAfterLeave: () => {
                                          this.followerEnabledIndexSet.delete(index);
                                      } }, {
                                      default: () => {
                                          var _a;
                                          if (showTooltip) {
                                              (_a = this.indicatorOnRender) === null || _a === void 0 ? void 0 : _a.call(this);
                                              return (h("div", { class: [
                                                      `${mergedClsPrefix}-slider-handle-indicator`,
                                                      this.indicatorThemeClass,
                                                      `${mergedClsPrefix}-slider-handle-indicator--${this.mergedPlacement}`
                                                  ], style: this
                                                      .indicatorCssVars }, typeof formatTooltip === 'function'
                                                  ? formatTooltip(value)
                                                  : value));
                                          }
                                          return null;
                                      }
                                  }))
                              }))
                          ]
                      }));
                  })),
                  this.marks ? (h("div", { class: `${mergedClsPrefix}-slider-marks` }, this.markInfos.map((mark) => (h("div", { key: mark.label, class: `${mergedClsPrefix}-slider-mark`, style: mark.style }, mark.label))))) : null)));
      }
  });

  // vars:
  // --n-bezier
  // --n-opacity-spinning
  // --n-size
  // --n-color
  // --n-text-color
  // --n-font-size
  var style$k = c$1([c$1('@keyframes spin-rotate', `
 from {
 transform: rotate(0);
 }
 to {
 transform: rotate(360deg);
 }
 `), cB('spin-container', {
    position: 'relative'
  }, [cB('spin-body', `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [fadeInTransition()])]), cB('spin-body', `
 display: inline-flex;
 align-items: center;
 justify-content: center;
 flex-direction: column;
 `), cB('spin', `
 display: inline-flex;
 height: var(--n-size);
 width: var(--n-size);
 font-size: var(--n-size);
 color: var(--n-color);
 `, [cM('rotate', `
 animation: spin-rotate 2s linear infinite;
 `)]), cB('spin-description', `
 display: inline-block;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 margin-top: 8px;
 `), cB('spin-content', `
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 pointer-events: all;
 `, [cM('spinning', `
 user-select: none;
 -webkit-user-select: none;
 pointer-events: none;
 opacity: var(--n-opacity-spinning);
 `)])]);

  const STROKE_WIDTH = {
      small: 20,
      medium: 18,
      large: 16
  };
  const spinProps = Object.assign(Object.assign({}, useTheme.props), { contentClass: String, contentStyle: [Object, String], description: String, stroke: String, size: {
          type: [String, Number],
          default: 'medium'
      }, show: {
          type: Boolean,
          default: true
      }, strokeWidth: Number, rotate: {
          type: Boolean,
          default: true
      }, spinning: {
          type: Boolean,
          validator: () => {
              return true;
          },
          default: undefined
      }, delay: Number });
  var Spin = defineComponent({
      name: 'Spin',
      props: spinProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Spin', '-spin', style$k, spinLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size: spinSize } = props;
              const { common: { cubicBezierEaseInOut }, self } = themeRef.value;
              const { opacitySpinning, color, textColor } = self;
              const size = typeof spinSize === 'number'
                  ? pxfy(spinSize)
                  : self[createKey('size', spinSize)];
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-opacity-spinning': opacitySpinning,
                  '--n-size': size,
                  '--n-color': color,
                  '--n-text-color': textColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('spin', computed(() => {
                  const { size } = props;
                  return typeof size === 'number' ? String(size) : size[0];
              }), cssVarsRef, props)
              : undefined;
          const compitableShow = useCompitable(props, ['spinning', 'show']);
          const activeRef = ref(false);
          watchEffect((onCleanup) => {
              let timerId;
              if (compitableShow.value) {
                  const { delay } = props;
                  if (delay) {
                      timerId = window.setTimeout(() => {
                          activeRef.value = true;
                      }, delay);
                      onCleanup(() => {
                          clearTimeout(timerId);
                      });
                      return;
                  }
              }
              activeRef.value = compitableShow.value;
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              active: activeRef,
              mergedStrokeWidth: computed(() => {
                  const { strokeWidth } = props;
                  if (strokeWidth !== undefined)
                      return strokeWidth;
                  const { size } = props;
                  return STROKE_WIDTH[typeof size === 'number' ? 'medium' : size];
              }),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a, _b;
          const { $slots, mergedClsPrefix, description } = this;
          const rotate = $slots.icon && this.rotate;
          const descriptionNode = (description || $slots.description) && (h("div", { class: `${mergedClsPrefix}-spin-description` }, description || ((_a = $slots.description) === null || _a === void 0 ? void 0 : _a.call($slots))));
          const icon = $slots.icon ? (h("div", { class: [`${mergedClsPrefix}-spin-body`, this.themeClass] },
              h("div", { class: [
                      `${mergedClsPrefix}-spin`,
                      rotate && `${mergedClsPrefix}-spin--rotate`
                  ], style: $slots.default ? '' : this.cssVars }, $slots.icon()),
              descriptionNode)) : (h("div", { class: [`${mergedClsPrefix}-spin-body`, this.themeClass] },
              h(NBaseLoading, { clsPrefix: mergedClsPrefix, style: $slots.default ? '' : this.cssVars, stroke: this.stroke, "stroke-width": this.mergedStrokeWidth, class: `${mergedClsPrefix}-spin` }),
              descriptionNode));
          (_b = this.onRender) === null || _b === void 0 ? void 0 : _b.call(this);
          return $slots.default ? (h("div", { class: [`${mergedClsPrefix}-spin-container`, this.themeClass], style: this.cssVars },
              h("div", { class: [
                      `${mergedClsPrefix}-spin-content`,
                      this.active && `${mergedClsPrefix}-spin-content--spinning`,
                      this.contentClass
                  ], style: this.contentStyle }, $slots),
              h(Transition, { name: "fade-in-transition" }, {
                  default: () => (this.active ? icon : null)
              }))) : (icon);
      }
  });

  // vars:
  // --n-border-color
  // --n-color
  var style$j = cB('split', `
 display: flex;
 width: 100%;
 height: 100%;
`, [cM('horizontal', `
 flex-direction: row;
 `), cM('vertical', `
 flex-direction: column;
 `), cB('split-pane-1', `
 overflow: hidden;
 `), cB('split-pane-2', `
 overflow: hidden;
 flex: 1;
 `), cE('resize-trigger', `
 background-color: var(--n-border-color);
 transition: background-color .3s var(--n-bezier);
 `, [cM('hover', `
 background-color: var(--n-resize-trigger-color-hover);
 `), c$1('&:hover', `
 background-color: var(--n-resize-trigger-color-hover);
 `)])]);

  const self$1 = (vars) => {
      const { primaryColorHover } = vars;
      return {
          resizableTriggerColorHover: primaryColorHover
      };
  };
  const themeLight = {
      name: 'Split',
      common: commonLight,
      self: self$1
  };
  var splitLight = themeLight;

  const splitProps = Object.assign(Object.assign({}, useTheme.props), { direction: {
          type: String,
          default: 'horizontal'
      }, resizeTriggerSize: {
          type: Number,
          default: 3
      }, disabled: Boolean, defaultSize: {
          type: Number,
          default: 0.5
      }, min: {
          type: Number,
          default: 0
      }, max: {
          type: Number,
          default: 1
      }, onDragStart: Function, onDragMove: Function, onDragEnd: Function });
  var Split = defineComponent({
      name: 'Split',
      props: splitProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Split', '-split', style$j, splitLight, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { resizableTriggerColorHover } } = themeRef.value;
              return {
                  '--n-resize-trigger-color-hover': resizableTriggerColorHover
              };
          });
          const resizeTriggerElRef = ref(null);
          const isDraggingRef = ref(false);
          const currentSize = ref(props.defaultSize);
          const firstPaneStyle = computed(() => {
              const size = currentSize.value * 100;
              return {
                  flex: `0 0 calc(${size}% - ${(props.resizeTriggerSize * size) / 100}px)`
              };
          });
          const resizeTriggerStyle = computed(() => {
              return props.direction === 'horizontal'
                  ? {
                      width: `${props.resizeTriggerSize}px`,
                      height: '100%'
                  }
                  : {
                      width: '100%',
                      height: `${props.resizeTriggerSize}px`
                  };
          });
          const resizeTriggerWrapperStyle = computed(() => {
              const horizontal = props.direction === 'horizontal';
              return {
                  width: horizontal ? `${props.resizeTriggerSize}px` : '',
                  height: horizontal ? '' : `${props.resizeTriggerSize}px`,
                  cursor: props.direction === 'horizontal' ? 'col-resize' : 'row-resize'
              };
          });
          let offset = 0;
          const handleMouseDown = (e) => {
              e.preventDefault();
              isDraggingRef.value = true;
              if (props.onDragStart)
                  props.onDragStart(e);
              const mouseMoveEvent = 'mousemove';
              const mouseUpEvent = 'mouseup';
              const onMouseMove = (e) => {
                  updateSize(e);
                  if (props.onDragMove)
                      props.onDragMove(e);
              };
              const onMouseUp = () => {
                  off(mouseMoveEvent, document, onMouseMove);
                  off(mouseUpEvent, document, onMouseUp);
                  isDraggingRef.value = false;
                  if (props.onDragEnd)
                      props.onDragEnd(e);
                  document.body.style.cursor = '';
              };
              document.body.style.cursor = resizeTriggerWrapperStyle.value.cursor;
              on(mouseMoveEvent, document, onMouseMove);
              on(mouseUpEvent, document, onMouseUp);
              const resizeTriggerEl = resizeTriggerElRef.value;
              if (resizeTriggerEl) {
                  const elRect = resizeTriggerEl.getBoundingClientRect();
                  if (props.direction === 'horizontal') {
                      offset = e.clientX - elRect.left;
                  }
                  else {
                      offset = elRect.top - e.clientY;
                  }
              }
              updateSize(e);
          };
          const updateSize = (event) => {
              var _a, _b;
              const parentRect = (_b = (_a = resizeTriggerElRef.value) === null || _a === void 0 ? void 0 : _a.parentElement) === null || _b === void 0 ? void 0 : _b.getBoundingClientRect();
              if (!parentRect)
                  return;
              const newSize = props.direction === 'horizontal'
                  ? (event.clientX - parentRect.left - offset) /
                      (parentRect.width - props.resizeTriggerSize)
                  : (event.clientY - parentRect.top + offset) /
                      (parentRect.height - props.resizeTriggerSize);
              currentSize.value = newSize;
              if (props.min) {
                  currentSize.value = Math.max(newSize, props.min);
              }
              if (props.max) {
                  currentSize.value = Math.min(currentSize.value, props.max);
              }
          };
          return {
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              resizeTriggerElRef,
              isDragging: isDraggingRef,
              mergedClsPrefix: mergedClsPrefixRef,
              resizeTriggerWrapperStyle,
              resizeTriggerStyle,
              handleMouseDown,
              firstPaneStyle
          };
      },
      render() {
          var _a, _b, _c, _d;
          return (h("div", { class: [
                  `${this.mergedClsPrefix}-split`,
                  `${this.mergedClsPrefix}-split--${this.direction}`
              ], style: this.cssVars },
              h("div", { class: `${this.mergedClsPrefix}-split-pane-1`, style: this.firstPaneStyle }, (_b = (_a = this.$slots)[1]) === null || _b === void 0 ? void 0 : _b.call(_a)),
              !this.disabled && (h("div", { ref: "resizeTriggerElRef", class: `${this.mergedClsPrefix}-split__resize-trigger-wrapper`, style: this.resizeTriggerWrapperStyle, onMousedown: this.handleMouseDown }, resolveSlot(this.$slots['resize-trigger'], () => [
                  h("div", { style: this.resizeTriggerStyle, class: [
                          `${this.mergedClsPrefix}-split__resize-trigger`,
                          this.isDragging &&
                              `${this.mergedClsPrefix}-split__resize-trigger--hover`
                      ] })
              ]))),
              h("div", { class: `${this.mergedClsPrefix}-split-pane-2` }, (_d = (_c = this.$slots)[2]) === null || _d === void 0 ? void 0 : _d.call(_c))));
      }
  });

  // vars:
  // --n-bezier
  // --n-label-font-size
  // --n-label-font-weight
  // --n-label-text-color
  // --n-value-font-weight
  // --n-value-font-size
  // --n-value-prefix-text-color
  // --n-value-suffix-text-color
  // --n-value-text-color
  var style$i = cB('statistic', [cE('label', `
 font-weight: var(--n-label-font-weight);
 transition: .3s color var(--n-bezier);
 font-size: var(--n-label-font-size);
 color: var(--n-label-text-color);
 `), cB('statistic-value', `
 margin-top: 4px;
 font-weight: var(--n-value-font-weight);
 `, [cE('prefix', `
 margin: 0 4px 0 0;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-prefix-text-color);
 `, [cB('icon', {
    verticalAlign: '-0.125em'
  })]), cE('content', `
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-text-color);
 `), cE('suffix', `
 margin: 0 0 0 4px;
 font-size: var(--n-value-font-size);
 transition: .3s color var(--n-bezier);
 color: var(--n-value-suffix-text-color);
 `, [cB('icon', {
    verticalAlign: '-0.125em'
  })])])]);

  const statisticProps = Object.assign(Object.assign({}, useTheme.props), { tabularNums: Boolean, label: String, value: [String, Number] });
  var Statistic = defineComponent({
      name: 'Statistic',
      props: statisticProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Statistic', '-statistic', style$i, statisticLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Statistic', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { labelFontWeight, valueFontSize, valueFontWeight, valuePrefixTextColor, labelTextColor, valueSuffixTextColor, valueTextColor, labelFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-label-font-size': labelFontSize,
                  '--n-label-font-weight': labelFontWeight,
                  '--n-label-text-color': labelTextColor,
                  '--n-value-font-weight': valueFontWeight,
                  '--n-value-font-size': valueFontSize,
                  '--n-value-prefix-text-color': valuePrefixTextColor,
                  '--n-value-suffix-text-color': valueSuffixTextColor,
                  '--n-value-text-color': valueTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('statistic', undefined, cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix, $slots: { default: defaultSlot, label: labelSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("div", { class: [
                  `${mergedClsPrefix}-statistic`,
                  this.themeClass,
                  this.rtlEnabled && `${mergedClsPrefix}-statistic--rtl`
              ], style: this.cssVars },
              resolveWrappedSlot(labelSlot, (children) => (h("div", { class: `${mergedClsPrefix}-statistic__label` }, this.label || children))),
              h("div", { class: `${mergedClsPrefix}-statistic-value`, style: {
                      fontVariantNumeric: this.tabularNums ? 'tabular-nums' : ''
                  } },
                  resolveWrappedSlot(prefixSlot, (children) => children && (h("span", { class: `${mergedClsPrefix}-statistic-value__prefix` }, children))),
                  this.value !== undefined ? (h("span", { class: `${mergedClsPrefix}-statistic-value__content` }, this.value)) : (resolveWrappedSlot(defaultSlot, (children) => children && (h("span", { class: `${mergedClsPrefix}-statistic-value__content` }, children)))),
                  resolveWrappedSlot(suffixSlot, (children) => children && (h("span", { class: `${mergedClsPrefix}-statistic-value__suffix` }, children))))));
      }
  });

  // vars:
  // --n-bezier
  // --n-description-text-color
  // --n-header-text-color
  // --n-indicator-border-color
  // --n-indicator-color
  // --n-indicator-icon-size
  // --n-indicator-index-font-size
  // --n-indicator-size
  // --n-indicator-text-color
  // --n-splitor-color
  // --n-step-header-font-size
  // --n-step-header-font-weight
  var style$h = cB('steps', `
 width: 100%;
 display: flex;
`, [cB('step', `
 position: relative;
 display: flex;
 flex: 1;
 `, [cM('disabled', 'cursor: not-allowed'), cM('clickable', `
 cursor: pointer;
 `), c$1('&:last-child', [cB('step-splitor', 'display: none;')])]), cB('step-splitor', `
 background-color: var(--n-splitor-color);
 margin-top: calc(var(--n-step-header-font-size) / 2);
 height: 1px;
 flex: 1;
 align-self: flex-start;
 margin-left: 12px;
 margin-right: 12px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB('step-content', 'flex: 1;', [cB('step-content-header', `
 color: var(--n-header-text-color);
 margin-top: calc(var(--n-indicator-size) / 2 - var(--n-step-header-font-size) / 2);
 line-height: var(--n-step-header-font-size);
 font-size: var(--n-step-header-font-size);
 position: relative;
 display: flex;
 font-weight: var(--n-step-header-font-weight);
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [cE('title', `
 white-space: nowrap;
 flex: 0;
 `)]), cE('description', `
 color: var(--n-description-text-color);
 margin-top: 12px;
 margin-left: 9px;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `)]), cB('step-indicator', `
 background-color: var(--n-indicator-color);
 box-shadow: 0 0 0 1px var(--n-indicator-border-color);
 height: var(--n-indicator-size);
 width: var(--n-indicator-size);
 border-radius: 50%;
 display: flex;
 align-items: center;
 justify-content: center;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [cB('step-indicator-slot', `
 position: relative;
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 font-size: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 `, [cE('index', `
 display: inline-block;
 text-align: center;
 position: absolute;
 left: 0;
 top: 0;
 white-space: nowrap;
 font-size: var(--n-indicator-index-font-size);
 width: var(--n-indicator-icon-size);
 height: var(--n-indicator-icon-size);
 line-height: var(--n-indicator-icon-size);
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB('icon', `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()]), cB('base-icon', `
 color: var(--n-indicator-text-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition()])])]), cM('vertical', 'flex-direction: column;', [cNotM('show-description', [c$1('>', [cB('step', 'padding-bottom: 8px;')])]), c$1('>', [cB('step', 'margin-bottom: 16px;', [c$1('&:last-child', 'margin-bottom: 0;'), c$1('>', [cB('step-indicator', [c$1('>', [cB('step-splitor', `
 position: absolute;
 bottom: -8px;
 width: 1px;
 margin: 0 !important;
 left: calc(var(--n-indicator-size) / 2);
 height: calc(100% - var(--n-indicator-size));
 `)])]), cB('step-content', [cE('description', 'margin-top: 8px;')])])])])])]);

  function stepWithIndex(step, i) {
      if (typeof step !== 'object' || step === null || Array.isArray(step)) {
          return null;
      }
      if (!step.props)
          step.props = {};
      step.props.internalIndex = i + 1;
      return step;
  }
  function stepsWithIndex(steps) {
      return steps.map((step, i) => stepWithIndex(step, i));
  }
  const stepsProps = Object.assign(Object.assign({}, useTheme.props), { current: Number, status: {
          type: String,
          default: 'process'
      }, size: {
          type: String,
          default: 'medium'
      }, vertical: Boolean, 'onUpdate:current': [Function, Array], onUpdateCurrent: [Function, Array] });
  const stepsInjectionKey = createInjectionKey('n-steps');
  var Steps = defineComponent({
      name: 'Steps',
      props: stepsProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('Steps', mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme('Steps', '-steps', style$h, stepsLight$1, props, mergedClsPrefixRef);
          provide(stepsInjectionKey, {
              props,
              mergedThemeRef: themeRef,
              mergedClsPrefixRef,
              stepsSlots: slots
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              rtlEnabled: rtlEnabledRef
          };
      },
      render() {
          const { mergedClsPrefix } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-steps`,
                  this.rtlEnabled && `${mergedClsPrefix}-steps--rtl`,
                  this.vertical && `${mergedClsPrefix}-steps--vertical`
              ] }, stepsWithIndex(flatten$3(getSlot$1(this)))));
      }
  });

  const stepProps = {
      status: String,
      title: String,
      description: String,
      disabled: Boolean,
      // index will be filled by parent steps, not user
      internalIndex: {
          type: Number,
          default: 0
      }
  };
  var Step = defineComponent({
      name: 'Step',
      props: stepProps,
      setup(props) {
          const NSteps = inject(stepsInjectionKey, null);
          if (!NSteps)
              throwError('step', '`n-step` must be placed inside `n-steps`.');
          const { inlineThemeDisabled } = useConfig();
          const { props: stepsProps, mergedThemeRef, mergedClsPrefixRef, stepsSlots } = NSteps;
          const verticalRef = computed(() => {
              return stepsProps.vertical;
          });
          const mergedStatusRef = computed(() => {
              const { status } = props;
              if (status) {
                  return status;
              }
              else {
                  const { internalIndex } = props;
                  const { current } = stepsProps;
                  if (current === undefined)
                      return 'process';
                  if (internalIndex < current) {
                      return 'finish';
                  }
                  else if (internalIndex === current) {
                      return stepsProps.status || 'process';
                  }
                  else if (internalIndex > current) {
                      return 'wait';
                  }
              }
              return 'process';
          });
          const cssVarsRef = computed(() => {
              const { value: status } = mergedStatusRef;
              const { size } = stepsProps;
              const { common: { cubicBezierEaseInOut }, self: { stepHeaderFontWeight, [createKey('stepHeaderFontSize', size)]: stepHeaderFontSize, [createKey('indicatorIndexFontSize', size)]: indicatorIndexFontSize, [createKey('indicatorSize', size)]: indicatorSize, [createKey('indicatorIconSize', size)]: indicatorIconSize, [createKey('indicatorTextColor', status)]: indicatorTextColor, [createKey('indicatorBorderColor', status)]: indicatorBorderColor, [createKey('headerTextColor', status)]: headerTextColor, [createKey('splitorColor', status)]: splitorColor, [createKey('indicatorColor', status)]: indicatorColor, [createKey('descriptionTextColor', status)]: descriptionTextColor } } = mergedThemeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-description-text-color': descriptionTextColor,
                  '--n-header-text-color': headerTextColor,
                  '--n-indicator-border-color': indicatorBorderColor,
                  '--n-indicator-color': indicatorColor,
                  '--n-indicator-icon-size': indicatorIconSize,
                  '--n-indicator-index-font-size': indicatorIndexFontSize,
                  '--n-indicator-size': indicatorSize,
                  '--n-indicator-text-color': indicatorTextColor,
                  '--n-splitor-color': splitorColor,
                  '--n-step-header-font-size': stepHeaderFontSize,
                  '--n-step-header-font-weight': stepHeaderFontWeight
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('step', computed(() => {
                  const { value: status } = mergedStatusRef;
                  const { size } = stepsProps;
                  return `${status[0]}${size[0]}`;
              }), cssVarsRef, stepsProps)
              : undefined;
          const handleStepClick = computed(() => {
              if (props.disabled)
                  return undefined;
              const { onUpdateCurrent, 'onUpdate:current': _onUpdateCurrent } = stepsProps;
              return onUpdateCurrent || _onUpdateCurrent
                  ? () => {
                      if (onUpdateCurrent) {
                          call(onUpdateCurrent, props.internalIndex);
                      }
                      if (_onUpdateCurrent) {
                          call(_onUpdateCurrent, props.internalIndex);
                      }
                  }
                  : undefined;
          });
          return {
              stepsSlots,
              mergedClsPrefix: mergedClsPrefixRef,
              vertical: verticalRef,
              mergedStatus: mergedStatusRef,
              handleStepClick,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, onRender, handleStepClick, disabled } = this;
          const descriptionNode = resolveWrappedSlot(this.$slots.default, (children) => {
              const mergedDescription = children || this.description;
              if (mergedDescription) {
                  return (h("div", { class: `${mergedClsPrefix}-step-content__description` }, mergedDescription));
              }
              return null;
          });
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-step`,
                  disabled && `${mergedClsPrefix}-step--disabled`,
                  !disabled && handleStepClick && `${mergedClsPrefix}-step--clickable`,
                  this.themeClass,
                  descriptionNode && `${mergedClsPrefix}-step--show-description`,
                  `${mergedClsPrefix}-step--${this.mergedStatus}-status`
              ], style: this.cssVars, onClick: handleStepClick },
              h("div", { class: `${mergedClsPrefix}-step-indicator` },
                  h("div", { class: `${mergedClsPrefix}-step-indicator-slot` },
                      h(NIconSwitchTransition, null, {
                          default: () => {
                              return resolveWrappedSlot(this.$slots.icon, (icon) => {
                                  const { mergedStatus, stepsSlots } = this;
                                  return !(mergedStatus === 'finish' || mergedStatus === 'error') ? (icon || (h("div", { key: this.internalIndex, class: `${mergedClsPrefix}-step-indicator-slot__index` }, this.internalIndex))) : mergedStatus === 'finish' ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "finish" }, {
                                      default: () => resolveSlot(stepsSlots['finish-icon'], () => [
                                          h(FinishedIcon, null)
                                      ])
                                  })) : mergedStatus === 'error' ? (h(NBaseIcon, { clsPrefix: mergedClsPrefix, key: "error" }, {
                                      default: () => resolveSlot(stepsSlots['error-icon'], () => [
                                          h(ErrorIcon$1, null)
                                      ])
                                  })) : null;
                              });
                          }
                      })),
                  this.vertical ? (h("div", { class: `${mergedClsPrefix}-step-splitor` })) : null),
              h("div", { class: `${mergedClsPrefix}-step-content` },
                  h("div", { class: `${mergedClsPrefix}-step-content-header` },
                      h("div", { class: `${mergedClsPrefix}-step-content-header__title` }, resolveSlot(this.$slots.title, () => [this.title])),
                      !this.vertical ? (h("div", { class: `${mergedClsPrefix}-step-splitor` })) : null),
                  descriptionNode)));
      }
  });

  // vars:
  // --n-bezier
  // --n-button-border-radius
  // --n-button-box-shadow
  // --n-button-color
  // --n-button-width
  // --n-button-width-pressed
  // --n-height
  // --n-offset
  // --n-rail-border-radius
  // --n-rail-color
  // --n-rail-color-active
  // --n-rail-height
  // --n-rail-width
  // --n-width
  // --n-box-shadow-focus
  // --n-loading-color
  // --n-text-color
  // --n-icon-color
  var style$g = cB('switch', `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE('children-placeholder', `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE('rail-placeholder', `
 display: flex;
 flex-wrap: none;
 `), cE('button-placeholder', `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB('base-loading', `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
    left: '50%',
    top: '50%',
    originalTransform: 'translateX(-50%) translateY(-50%)'
  })]), cE('checked, unchecked', `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE('checked', `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE('unchecked', `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c$1('&:focus', [cE('rail', `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM('round', [cE('rail', 'border-radius: calc(var(--n-rail-height) / 2);', [cE('button', 'border-radius: calc(var(--n-button-height) / 2);')])]), cNotM('disabled', [cNotM('icon', [cM('rubber-band', [cM('pressed', [cE('rail', [cE('button', 'max-width: var(--n-button-width-pressed);')])]), cE('rail', [c$1('&:active', [cE('button', 'max-width: var(--n-button-width-pressed);')])]), cM('active', [cM('pressed', [cE('rail', [cE('button', 'left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));')])]), cE('rail', [c$1('&:active', [cE('button', 'left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));')])])])])])]), cM('active', [cE('rail', [cE('button', 'left: calc(100% - var(--n-button-width) - var(--n-offset))')])]), cE('rail', `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE('button-icon', `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE('button', `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM('active', [cE('rail', 'background-color: var(--n-rail-color-active);')]), cM('loading', [cE('rail', `
 cursor: wait;
 `)]), cM('disabled', [cE('rail', `
 cursor: not-allowed;
 opacity: .5;
 `)])]);

  const switchProps = Object.assign(Object.assign({}, useTheme.props), { size: {
          type: String,
          default: 'medium'
      }, value: {
          type: [String, Number, Boolean],
          default: undefined
      }, loading: Boolean, defaultValue: {
          type: [String, Number, Boolean],
          default: false
      }, disabled: {
          type: Boolean,
          default: undefined
      }, round: {
          type: Boolean,
          default: true
      }, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], checkedValue: {
          type: [String, Number, Boolean],
          default: true
      }, uncheckedValue: {
          type: [String, Number, Boolean],
          default: false
      }, railStyle: Function, rubberBand: {
          type: Boolean,
          default: true
      }, 
      /** @deprecated */
      onChange: [Function, Array] });
  let supportCssMax;
  var Switch = defineComponent({
      name: 'Switch',
      props: switchProps,
      setup(props) {
          if (supportCssMax === undefined) {
              if (typeof CSS !== 'undefined') {
                  if (typeof CSS.supports !== 'undefined') {
                      supportCssMax = CSS.supports('width', 'max(1px)');
                  }
                  else {
                      supportCssMax = false;
                  }
              }
              else {
                  // If you are using SSR, we assume that you are targeting browsers with
                  // recent versions
                  supportCssMax = true;
              }
          }
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Switch', '-switch', style$g, switchLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedRef = computed(() => {
              return mergedValueRef.value === props.checkedValue;
          });
          const pressedRef = ref(false);
          const focusedRef = ref(false);
          const mergedRailStyleRef = computed(() => {
              const { railStyle } = props;
              if (!railStyle)
                  return undefined;
              return railStyle({ focused: focusedRef.value, checked: checkedRef.value });
          });
          function doUpdateValue(value) {
              const { 'onUpdate:value': _onUpdateValue, onChange, onUpdateValue } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (onChange)
                  call(onChange, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function doFocus() {
              const { nTriggerFormFocus } = formItem;
              nTriggerFormFocus();
          }
          function doBlur() {
              const { nTriggerFormBlur } = formItem;
              nTriggerFormBlur();
          }
          function handleClick() {
              if (props.loading || mergedDisabledRef.value)
                  return;
              if (mergedValueRef.value !== props.checkedValue) {
                  doUpdateValue(props.checkedValue);
              }
              else {
                  doUpdateValue(props.uncheckedValue);
              }
          }
          function handleFocus() {
              focusedRef.value = true;
              doFocus();
          }
          function handleBlur() {
              focusedRef.value = false;
              doBlur();
              pressedRef.value = false;
          }
          function handleKeyup(e) {
              if (props.loading || mergedDisabledRef.value)
                  return;
              if (e.key === ' ') {
                  if (mergedValueRef.value !== props.checkedValue) {
                      doUpdateValue(props.checkedValue);
                  }
                  else {
                      doUpdateValue(props.uncheckedValue);
                  }
                  pressedRef.value = false;
              }
          }
          function handleKeydown(e) {
              if (props.loading || mergedDisabledRef.value)
                  return;
              if (e.key === ' ') {
                  e.preventDefault();
                  pressedRef.value = true;
              }
          }
          const cssVarsRef = computed(() => {
              const { value: size } = mergedSizeRef;
              const { self: { opacityDisabled, railColor, railColorActive, buttonBoxShadow, buttonColor, boxShadowFocus, loadingColor, textColor, iconColor, [createKey('buttonHeight', size)]: buttonHeight, [createKey('buttonWidth', size)]: buttonWidth, [createKey('buttonWidthPressed', size)]: buttonWidthPressed, [createKey('railHeight', size)]: railHeight, [createKey('railWidth', size)]: railWidth, [createKey('railBorderRadius', size)]: railBorderRadius, [createKey('buttonBorderRadius', size)]: buttonBorderRadius }, common: { cubicBezierEaseInOut } } = themeRef.value;
              let offset;
              let height;
              let width;
              if (supportCssMax) {
                  offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
                  height = `max(${railHeight}, ${buttonHeight})`;
                  width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
              }
              else {
                  offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
                  height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
                  width =
                      depx(railHeight) > depx(buttonHeight)
                          ? railWidth
                          : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
              }
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-button-border-radius': buttonBorderRadius,
                  '--n-button-box-shadow': buttonBoxShadow,
                  '--n-button-color': buttonColor,
                  '--n-button-width': buttonWidth,
                  '--n-button-width-pressed': buttonWidthPressed,
                  '--n-button-height': buttonHeight,
                  '--n-height': height,
                  '--n-offset': offset,
                  '--n-opacity-disabled': opacityDisabled,
                  '--n-rail-border-radius': railBorderRadius,
                  '--n-rail-color': railColor,
                  '--n-rail-color-active': railColorActive,
                  '--n-rail-height': railHeight,
                  '--n-rail-width': railWidth,
                  '--n-width': width,
                  '--n-box-shadow-focus': boxShadowFocus,
                  '--n-loading-color': loadingColor,
                  '--n-text-color': textColor,
                  '--n-icon-color': iconColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('switch', computed(() => {
                  return mergedSizeRef.value[0];
              }), cssVarsRef, props)
              : undefined;
          return {
              handleClick,
              handleBlur,
              handleFocus,
              handleKeyup,
              handleKeydown,
              mergedRailStyle: mergedRailStyleRef,
              pressed: pressedRef,
              mergedClsPrefix: mergedClsPrefixRef,
              mergedValue: mergedValueRef,
              checked: checkedRef,
              mergedDisabled: mergedDisabledRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, mergedDisabled, checked, mergedRailStyle, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const { checked: checkedSlot, unchecked: uncheckedSlot, icon: iconSlot, 'checked-icon': checkedIconSlot, 'unchecked-icon': uncheckedIconSlot } = $slots;
          const hasIcon = !(isSlotEmpty(iconSlot) &&
              isSlotEmpty(checkedIconSlot) &&
              isSlotEmpty(uncheckedIconSlot));
          return (h("div", { role: "switch", "aria-checked": checked, class: [
                  `${mergedClsPrefix}-switch`,
                  this.themeClass,
                  hasIcon && `${mergedClsPrefix}-switch--icon`,
                  checked && `${mergedClsPrefix}-switch--active`,
                  mergedDisabled && `${mergedClsPrefix}-switch--disabled`,
                  this.round && `${mergedClsPrefix}-switch--round`,
                  this.loading && `${mergedClsPrefix}-switch--loading`,
                  this.pressed && `${mergedClsPrefix}-switch--pressed`,
                  this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`
              ], tabindex: !this.mergedDisabled ? 0 : undefined, style: this.cssVars, onClick: this.handleClick, onFocus: this.handleFocus, onBlur: this.handleBlur, onKeyup: this.handleKeyup, onKeydown: this.handleKeydown },
              h("div", { class: `${mergedClsPrefix}-switch__rail`, "aria-hidden": "true", style: mergedRailStyle },
                  resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
                      if (checkedSlotChildren || uncheckedSlotChildren) {
                          return (h("div", { "aria-hidden": true, class: `${mergedClsPrefix}-switch__children-placeholder` },
                              h("div", { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                                  h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                                  checkedSlotChildren),
                              h("div", { class: `${mergedClsPrefix}-switch__rail-placeholder` },
                                  h("div", { class: `${mergedClsPrefix}-switch__button-placeholder` }),
                                  uncheckedSlotChildren)));
                      }
                      return null;
                  })),
                  h("div", { class: `${mergedClsPrefix}-switch__button` },
                      resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
                          return (h(NIconSwitchTransition, null, {
                              default: () => this.loading ? (h(NBaseLoading, { key: "loading", clsPrefix: mergedClsPrefix, strokeWidth: 20 })) : this.checked && (checkedIcon || icon) ? (h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: checkedIcon ? 'checked-icon' : 'icon' }, checkedIcon || icon)) : !this.checked && (uncheckedIcon || icon) ? (h("div", { class: `${mergedClsPrefix}-switch__button-icon`, key: uncheckedIcon ? 'unchecked-icon' : 'icon' }, uncheckedIcon || icon)) : null
                          }));
                      }))),
                      resolveWrappedSlot(checkedSlot, (children) => children && (h("div", { key: "checked", class: `${mergedClsPrefix}-switch__checked` }, children))),
                      resolveWrappedSlot(uncheckedSlot, (children) => children && (h("div", { key: "unchecked", class: `${mergedClsPrefix}-switch__unchecked` }, children)))))));
      }
  });

  // vars:
  // --n-bezier
  // --n-td-color
  // --n-td-color-modal
  // --n-td-color-popover
  // --n-td-text-color
  // --n-border-color
  // --n-border-color-modal
  // --n-border-color-popover
  // --n-border-radius
  // --n-font-size
  // --n-th-color
  // --n-th-color-modal
  // --n-th-color-popover
  // --n-th-font-weight
  // --n-th-text-color
  // --n-line-height
  // --n-td-padding
  // --n-th-padding
  var style$f = c$1([cB('table', `
 font-size: var(--n-font-size);
 font-variant-numeric: tabular-nums;
 line-height: var(--n-line-height);
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 text-align: left;
 border-collapse: separate;
 border-spacing: 0;
 overflow: hidden;
 background-color: var(--n-td-color);
 border-color: var(--n-merged-border-color);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 --n-merged-border-color: var(--n-border-color);
 `, [c$1('th', `
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 text-align: inherit;
 padding: var(--n-th-padding);
 vertical-align: inherit;
 text-transform: none;
 border: 0px solid var(--n-merged-border-color);
 font-weight: var(--n-th-font-weight);
 color: var(--n-th-text-color);
 background-color: var(--n-th-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 `, [c$1('&:last-child', `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), c$1('td', `
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 padding: var(--n-td-padding);
 color: var(--n-td-text-color);
 background-color: var(--n-td-color);
 border: 0px solid var(--n-merged-border-color);
 border-right: 1px solid var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 `, [c$1('&:last-child', `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM('bordered', `
 border: 1px solid var(--n-merged-border-color);
 border-radius: var(--n-border-radius);
 `, [c$1('tr', [c$1('&:last-child', [c$1('td', `
 border-bottom: 0 solid var(--n-merged-border-color);
 `)])])]), cM('single-line', [c$1('th', `
 border-right: 0px solid var(--n-merged-border-color);
 `), c$1('td', `
 border-right: 0px solid var(--n-merged-border-color);
 `)]), cM('single-column', [c$1('tr', [c$1('&:not(:last-child)', [c$1('td', `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])]), cM('striped', [c$1('tr:nth-of-type(even)', [c$1('td', 'background-color: var(--n-td-color-striped)')])]), cNotM('bottom-bordered', [c$1('tr', [c$1('&:last-child', [c$1('td', `
 border-bottom: 0px solid var(--n-merged-border-color);
 `)])])])]), insideModal(cB('table', `
 background-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 `, [c$1('th', `
 background-color: var(--n-th-color-modal);
 `), c$1('td', `
 background-color: var(--n-td-color-modal);
 `)])), insidePopover(cB('table', `
 background-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 `, [c$1('th', `
 background-color: var(--n-th-color-popover);
 `), c$1('td', `
 background-color: var(--n-td-color-popover);
 `)]))]);

  const tableProps = Object.assign(Object.assign({}, useTheme.props), { bordered: {
          type: Boolean,
          default: true
      }, bottomBordered: {
          type: Boolean,
          default: true
      }, singleLine: {
          type: Boolean,
          default: true
      }, striped: Boolean, singleColumn: Boolean, size: {
          type: String,
          default: 'medium'
      } });
  var Table = defineComponent({
      name: 'Table',
      props: tableProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Table', '-table', style$f, tableLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Table', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { size } = props;
              const { self: { borderColor, tdColor, tdColorModal, tdColorPopover, thColor, thColorModal, thColorPopover, thTextColor, tdTextColor, borderRadius, thFontWeight, lineHeight, borderColorModal, borderColorPopover, tdColorStriped, tdColorStripedModal, tdColorStripedPopover, [createKey('fontSize', size)]: fontSize, [createKey('tdPadding', size)]: tdPadding, [createKey('thPadding', size)]: thPadding }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-td-color': tdColor,
                  '--n-td-color-modal': tdColorModal,
                  '--n-td-color-popover': tdColorPopover,
                  '--n-td-text-color': tdTextColor,
                  '--n-border-color': borderColor,
                  '--n-border-color-modal': borderColorModal,
                  '--n-border-color-popover': borderColorPopover,
                  '--n-border-radius': borderRadius,
                  '--n-font-size': fontSize,
                  '--n-th-color': thColor,
                  '--n-th-color-modal': thColorModal,
                  '--n-th-color-popover': thColorPopover,
                  '--n-th-font-weight': thFontWeight,
                  '--n-th-text-color': thTextColor,
                  '--n-line-height': lineHeight,
                  '--n-td-padding': tdPadding,
                  '--n-th-padding': thPadding,
                  '--n-td-color-striped': tdColorStriped,
                  '--n-td-color-striped-modal': tdColorStripedModal,
                  '--n-td-color-striped-popover': tdColorStripedPopover
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('table', computed(() => {
                  return props.size[0];
              }), cssVarsRef, props)
              : undefined;
          return {
              rtlEnabled: rtlEnabledRef,
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("table", { class: [
                  `${mergedClsPrefix}-table`,
                  this.themeClass,
                  {
                      [`${mergedClsPrefix}-table--rtl`]: this.rtlEnabled,
                      [`${mergedClsPrefix}-table--bottom-bordered`]: this.bottomBordered,
                      [`${mergedClsPrefix}-table--bordered`]: this.bordered,
                      [`${mergedClsPrefix}-table--single-line`]: this.singleLine,
                      [`${mergedClsPrefix}-table--single-column`]: this.singleColumn,
                      [`${mergedClsPrefix}-table--striped`]: this.striped
                  }
              ], style: this.cssVars }, this.$slots));
      }
  });

  var Th = defineComponent({
      name: 'Th',
      render() {
          return h("th", null, this.$slots);
      }
  });

  var Tr = defineComponent({
      name: 'Tr',
      render() {
          return h("tr", null, this.$slots);
      }
  });

  var Td = defineComponent({
      name: 'Td',
      render() {
          return h("td", null, this.$slots);
      }
  });

  var Thead = defineComponent({
      name: 'Thead',
      render() {
          return h("thead", null, this.$slots);
      }
  });

  var Tbody = defineComponent({
      name: 'Tbody',
      render() {
          return h("tbody", null, this.$slots);
      }
  });

  const tabsInjectionKey = createInjectionKey('n-tabs');

  const tabPaneProps = {
      tab: [String, Number, Object, Function],
      name: {
          type: [String, Number],
          required: true
      },
      disabled: Boolean,
      displayDirective: {
          type: String,
          default: 'if'
      },
      closable: {
          type: Boolean,
          default: undefined
      },
      tabProps: Object,
      /** @deprecated */
      label: [String, Number, Object, Function]
  };
  var TabPane = defineComponent({
      __TAB_PANE__: true,
      name: 'TabPane',
      alias: ['TabPanel'],
      props: tabPaneProps,
      setup(props) {
          const NTab = inject(tabsInjectionKey, null);
          if (!NTab) {
              throwError('tab-pane', '`n-tab-pane` must be placed inside `n-tabs`.');
          }
          return {
              style: NTab.paneStyleRef,
              class: NTab.paneClassRef,
              mergedClsPrefix: NTab.mergedClsPrefixRef
          };
      },
      render() {
          return (h("div", { class: [`${this.mergedClsPrefix}-tab-pane`, this.class], style: this.style }, this.$slots));
      }
  });

  const tabProps = Object.assign({ internalLeftPadded: Boolean, internalAddable: Boolean, internalCreatedByPane: Boolean }, omit(tabPaneProps, ['displayDirective']));
  var Tab = defineComponent({
      __TAB__: true,
      inheritAttrs: false,
      name: 'Tab',
      props: tabProps,
      setup(props) {
          const { mergedClsPrefixRef, valueRef, typeRef, closableRef, tabStyleRef, tabChangeIdRef, onBeforeLeaveRef, triggerRef, handleAdd, activateTab, handleClose
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(tabsInjectionKey);
          return {
              trigger: triggerRef,
              mergedClosable: computed(() => {
                  if (props.internalAddable)
                      return false;
                  const { closable } = props;
                  if (closable === undefined)
                      return closableRef.value;
                  return closable;
              }),
              style: tabStyleRef,
              clsPrefix: mergedClsPrefixRef,
              value: valueRef,
              type: typeRef,
              handleClose(e) {
                  e.stopPropagation();
                  if (props.disabled)
                      return;
                  handleClose(props.name);
              },
              activateTab() {
                  if (props.disabled)
                      return;
                  if (props.internalAddable) {
                      handleAdd();
                      return;
                  }
                  const { name: nameProp } = props;
                  const id = ++tabChangeIdRef.id;
                  if (nameProp !== valueRef.value) {
                      const { value: onBeforeLeave } = onBeforeLeaveRef;
                      if (!onBeforeLeave) {
                          activateTab(nameProp);
                      }
                      else {
                          void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
                              if (allowLeave && tabChangeIdRef.id === id) {
                                  activateTab(nameProp);
                              }
                          });
                      }
                  }
              }
          };
      },
      render() {
          const { internalAddable, clsPrefix, name, disabled, label, tab, value, mergedClosable, style, trigger, $slots: { default: defaultSlot } } = this;
          const mergedTab = label !== null && label !== void 0 ? label : tab;
          return (h("div", { class: `${clsPrefix}-tabs-tab-wrapper` },
              this.internalLeftPadded ? (h("div", { class: `${clsPrefix}-tabs-tab-pad` })) : null,
              h("div", Object.assign({ key: name, "data-name": name, "data-disabled": disabled ? true : undefined }, mergeProps({
                  class: [
                      `${clsPrefix}-tabs-tab`,
                      value === name && `${clsPrefix}-tabs-tab--active`,
                      disabled && `${clsPrefix}-tabs-tab--disabled`,
                      mergedClosable && `${clsPrefix}-tabs-tab--closable`,
                      internalAddable && `${clsPrefix}-tabs-tab--addable`
                  ],
                  onClick: trigger === 'click' ? this.activateTab : undefined,
                  onMouseenter: trigger === 'hover' ? this.activateTab : undefined,
                  style: internalAddable ? undefined : style
              }, 
              // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
              this.internalCreatedByPane
                  ? (this.tabProps || {})
                  : this.$attrs)),
                  h("span", { class: `${clsPrefix}-tabs-tab__label` }, internalAddable ? (h(Fragment, null,
                      h("div", { class: `${clsPrefix}-tabs-tab__height-placeholder` }, "\u00A0"),
                      h(NBaseIcon, { clsPrefix: clsPrefix }, {
                          default: () => h(AddIcon, null)
                      }))) : defaultSlot ? (defaultSlot()) : typeof mergedTab === 'object' ? (mergedTab // VNode
                  ) : (render$1(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name))),
                  mergedClosable && this.type === 'card' ? (h(NBaseClose, { clsPrefix: clsPrefix, class: `${clsPrefix}-tabs-tab__close`, onClick: this.handleClose, disabled: disabled })) : null)));
      }
  });

  // vars:
  // --n-bezier
  // --n-close-size
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-size
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  // --n-bar-color
  // --n-tab-font-size
  // --n-tab-text-color
  // --n-tab-text-color-active
  // --n-tab-text-color-disabled
  // --n-tab-text-color-hover
  // --n-pane-text-color
  // --n-tab-border-color
  // --n-tab-border-radius
  // --n-tab-color
  // --n-tab-font-weight
  // --n-tab-font-weight-active
  // --n-tab-gap
  // --n-tab-gap-vertical
  // --n-tab-padding
  // --n-pane-padding-left
  // --n-pane-padding-right
  // --n-pane-padding-top
  // --n-pane-padding-bottom
  // --n-color-segment
  // --n-font-weight-strong
  // --n-tab-color-segment
  var style$e = cB('tabs', `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM('segment-type', [cB('tabs-rail', [c$1('&.transition-disabled', 'color: red;', [cB('tabs-tab', `
 transition: none;
 `)])])]), cM('top', [cB('tab-pane', `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), cM('left', [cB('tab-pane', `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), cM('left, right', `
 flex-direction: row;
 `, [cB('tabs-bar', `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB('tabs-tab', `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM('right', `
 flex-direction: row-reverse;
 `, [cB('tab-pane', `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), cB('tabs-bar', `
 left: 0;
 `)]), cM('bottom', `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB('tab-pane', `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), cB('tabs-bar', `
 top: 0;
 `)]), cB('tabs-rail', `
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB('tabs-tab-wrapper', `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB('tabs-tab', `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM('active', `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 `), c$1('&:hover', `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM('flex', [cB('tabs-nav', {
    width: '100%'
  }, [cB('tabs-wrapper', {
    width: '100%'
  }, [cB('tabs-tab', {
    marginRight: 0
  })])])]), cB('tabs-nav', `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE('prefix, suffix', `
 display: flex;
 align-items: center;
 `), cE('prefix', 'padding-right: 16px;'), cE('suffix', 'padding-left: 16px;')]), cM('top, bottom', [cB('tabs-nav-scroll-wrapper', [c$1('&::before', `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), c$1('&::after', `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), cM('shadow-start', [c$1('&::before', `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM('shadow-end', [c$1('&::after', `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cM('left, right', [cB('tabs-nav-scroll-content', `
 flex-direction: column;
 `), cB('tabs-nav-scroll-wrapper', [c$1('&::before', `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), c$1('&::after', `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), cM('shadow-start', [c$1('&::before', `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), cM('shadow-end', [c$1('&::after', `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])]), cB('tabs-nav-scroll-wrapper', `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cB('tabs-nav-y-scroll', `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1('&::-webkit-scrollbar', `
 width: 0;
 height: 0;
 `)]), c$1('&::before, &::after', `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), cB('tabs-nav-scroll-content', `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), cB('tabs-wrapper', `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB('tabs-tab-wrapper', `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB('tabs-tab', `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM('disabled', {
    cursor: 'not-allowed'
  }), cE('close', `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE('label', `
 display: flex;
 align-items: center;
 `)]), cB('tabs-bar', `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1('&.transition-disabled', `
 transition: none;
 `), cM('disabled', `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB('tabs-pane-wrapper', `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB('tab-pane', `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1('&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active', `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1('&.next-transition-leave-active, &.prev-transition-leave-active', `
 position: absolute;
 `), c$1('&.next-transition-enter-from, &.prev-transition-leave-to', `
 transform: translateX(32px);
 opacity: 0;
 `), c$1('&.next-transition-leave-to, &.prev-transition-enter-from', `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1('&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to', `
 transform: translateX(0);
 opacity: 1;
 `)]), cB('tabs-tab-pad', `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM('line-type, bar-type', [cB('tabs-tab', `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1('&:hover', {
    color: 'var(--n-tab-text-color-hover)'
  }), cM('active', `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM('disabled', {
    color: 'var(--n-tab-text-color-disabled)'
  })])]), cB('tabs-nav', [cM('line-type', [cM('top', [cE('prefix, suffix', `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB('tabs-nav-scroll-content', `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB('tabs-bar', `
 bottom: -1px;
 `)]), cM('left', [cE('prefix, suffix', `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB('tabs-nav-scroll-content', `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB('tabs-bar', `
 right: -1px;
 `)]), cM('right', [cE('prefix, suffix', `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB('tabs-nav-scroll-content', `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB('tabs-bar', `
 left: -1px;
 `)]), cM('bottom', [cE('prefix, suffix', `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB('tabs-nav-scroll-content', `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB('tabs-bar', `
 top: -1px;
 `)]), cE('prefix, suffix', `
 transition: border-color .3s var(--n-bezier);
 `), cB('tabs-nav-scroll-content', `
 transition: border-color .3s var(--n-bezier);
 `), cB('tabs-bar', `
 border-radius: 0;
 `)]), cM('card-type', [cE('prefix, suffix', `
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB('tabs-pad', `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), cB('tabs-tab-pad', `
 transition: border-color .3s var(--n-bezier);
 `), cB('tabs-tab', `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM('addable', `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 `, [cE('height-placeholder', `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM('disabled', [c$1('&:hover', `
 color: var(--n-tab-text-color-hover);
 `)])]), cM('closable', 'padding-right: 8px;'), cM('active', `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM('disabled', 'color: var(--n-tab-text-color-disabled);')]), cB('tabs-scroll-padding', 'border-bottom: 1px solid var(--n-tab-border-color);')]), cM('left, right', [cB('tabs-wrapper', `
 flex-direction: column;
 `, [cB('tabs-tab-wrapper', `
 flex-direction: column;
 `, [cB('tabs-tab-pad', `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])])]), cM('top', [cM('card-type', [cB('tabs-tab', `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [cM('active', `
 border-bottom: 1px solid #0000;
 `)]), cB('tabs-tab-pad', `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB('tabs-pad', `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), cM('left', [cM('card-type', [cB('tabs-tab', `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [cM('active', `
 border-right: 1px solid #0000;
 `)]), cB('tabs-tab-pad', `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB('tabs-pad', `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), cM('right', [cM('card-type', [cB('tabs-tab', `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM('active', `
 border-left: 1px solid #0000;
 `)]), cB('tabs-tab-pad', `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB('tabs-pad', `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), cM('bottom', [cM('card-type', [cB('tabs-tab', `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM('active', `
 border-top: 1px solid #0000;
 `)]), cB('tabs-tab-pad', `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB('tabs-pad', `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]);

  const tabsProps = Object.assign(Object.assign({}, useTheme.props), { value: [String, Number], defaultValue: [String, Number], trigger: {
          type: String,
          default: 'click'
      }, type: {
          type: String,
          default: 'bar'
      }, closable: Boolean, justifyContent: String, size: {
          type: String,
          default: 'medium'
      }, placement: {
          type: String,
          default: 'top'
      }, tabStyle: [String, Object], barWidth: Number, paneClass: String, paneStyle: [String, Object], paneWrapperClass: String, paneWrapperStyle: [String, Object], addable: [Boolean, Object], tabsPadding: {
          type: Number,
          default: 0
      }, animated: Boolean, onBeforeLeave: Function, onAdd: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onClose: [Function, Array], 
      // deprecated
      labelSize: String, activeName: [String, Number], onActiveNameChange: [Function, Array] });
  var Tabs = defineComponent({
      name: 'Tabs',
      props: tabsProps,
      setup(props, { slots }) {
          var _a, _b, _c, _d;
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Tabs', '-tabs', style$e, tabsLight$1, props, mergedClsPrefixRef);
          const tabsElRef = ref(null);
          const barElRef = ref(null);
          const scrollWrapperElRef = ref(null);
          const addTabInstRef = ref(null);
          const xScrollInstRef = ref(null);
          const startReachedRef = ref(true);
          const endReachedRef = ref(true);
          const compitableSizeRef = useCompitable(props, ['labelSize', 'size']);
          const compitableValueRef = useCompitable(props, ['activeName', 'value']);
          const uncontrolledValueRef = ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : (slots.default
              ? (_d = (_c = flatten$3(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name
              : null));
          const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
          const tabChangeIdRef = { id: 0 };
          const tabWrapperStyleRef = computed(() => {
              if (!props.justifyContent || props.type === 'card')
                  return undefined;
              return {
                  display: 'flex',
                  justifyContent: props.justifyContent
              };
          });
          watch(mergedValueRef, () => {
              tabChangeIdRef.id = 0;
              updateCurrentBarStyle();
              updateCurrentScrollPosition();
          });
          function getCurrentEl() {
              var _a;
              const { value } = mergedValueRef;
              if (value === null)
                  return null;
              const tabEl = (_a = tabsElRef.value) === null || _a === void 0 ? void 0 : _a.querySelector(`[data-name="${value}"]`);
              return tabEl;
          }
          function updateBarStyle(tabEl) {
              if (props.type === 'card')
                  return;
              const { value: barEl } = barElRef;
              if (!barEl)
                  return;
              if (tabEl) {
                  const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
                  const { barWidth, placement } = props;
                  if (tabEl.dataset.disabled === 'true') {
                      barEl.classList.add(disabledClassName);
                  }
                  else {
                      barEl.classList.remove(disabledClassName);
                  }
                  if (['top', 'bottom'].includes(placement)) {
                      clearBarStyle(['top', 'maxHeight', 'height']);
                      if (typeof barWidth === 'number' && tabEl.offsetWidth >= barWidth) {
                          const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
                          barEl.style.left = `${offsetDiffLeft}px`;
                          barEl.style.maxWidth = `${barWidth}px`;
                      }
                      else {
                          barEl.style.left = `${tabEl.offsetLeft}px`;
                          barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
                      }
                      barEl.style.width = '8192px';
                      void barEl.offsetWidth;
                  }
                  else {
                      clearBarStyle(['left', 'maxWidth', 'width']);
                      if (typeof barWidth === 'number' && tabEl.offsetHeight >= barWidth) {
                          const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
                          barEl.style.top = `${offsetDiffTop}px`;
                          barEl.style.maxHeight = `${barWidth}px`;
                      }
                      else {
                          barEl.style.top = `${tabEl.offsetTop}px`;
                          barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
                      }
                      barEl.style.height = '8192px';
                      void barEl.offsetHeight;
                  }
              }
          }
          function clearBarStyle(styleProps) {
              const { value: barEl } = barElRef;
              if (!barEl)
                  return;
              for (const prop of styleProps) {
                  barEl.style[prop] = '';
              }
          }
          function updateCurrentBarStyle() {
              if (props.type === 'card')
                  return;
              const tabEl = getCurrentEl();
              if (tabEl) {
                  updateBarStyle(tabEl);
              }
          }
          function updateCurrentScrollPosition(smooth) {
              var _a;
              const scrollWrapperEl = (_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el;
              if (!scrollWrapperEl)
                  return;
              const tabEl = getCurrentEl();
              if (!tabEl)
                  return;
              const { scrollLeft: scrollWrapperElScrollLeft, offsetWidth: scrollWrapperElOffsetWidth } = scrollWrapperEl;
              const { offsetLeft: tabElOffsetLeft, offsetWidth: tabElOffsetWidth } = tabEl;
              if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
                  scrollWrapperEl.scrollTo({
                      top: 0,
                      left: tabElOffsetLeft,
                      behavior: 'smooth'
                  });
              }
              else if (tabElOffsetLeft + tabElOffsetWidth >
                  scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
                  scrollWrapperEl.scrollTo({
                      top: 0,
                      left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
                      behavior: 'smooth'
                  });
              }
          }
          const tabsPaneWrapperRef = ref(null);
          let fromHeight = 0;
          let hangingTransition = null;
          function onAnimationBeforeLeave(el) {
              const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
              if (tabsPaneWrapperEl) {
                  fromHeight = el.getBoundingClientRect().height;
                  const fromHeightPx = `${fromHeight}px`;
                  const applyFromStyle = () => {
                      tabsPaneWrapperEl.style.height = fromHeightPx;
                      tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
                  };
                  if (!hangingTransition) {
                      hangingTransition = applyFromStyle;
                  }
                  else {
                      applyFromStyle();
                      hangingTransition();
                      hangingTransition = null;
                  }
              }
          }
          function onAnimationEnter(el) {
              const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
              if (tabsPaneWrapperEl) {
                  const targetHeight = el.getBoundingClientRect().height;
                  const applyTargetStyle = () => {
                      void document.body.offsetHeight;
                      tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
                      tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
                  };
                  if (!hangingTransition) {
                      hangingTransition = applyTargetStyle;
                  }
                  else {
                      hangingTransition();
                      hangingTransition = null;
                      applyTargetStyle();
                  }
              }
          }
          function onAnimationAfterEnter() {
              const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
              if (tabsPaneWrapperEl) {
                  tabsPaneWrapperEl.style.maxHeight = '';
                  tabsPaneWrapperEl.style.height = '';
                  const { paneWrapperStyle } = props;
                  if (typeof paneWrapperStyle === 'string') {
                      tabsPaneWrapperEl.style.cssText = paneWrapperStyle;
                  }
                  else if (paneWrapperStyle) {
                      const { maxHeight, height } = paneWrapperStyle;
                      if (maxHeight !== undefined) {
                          tabsPaneWrapperEl.style.maxHeight = maxHeight;
                      }
                      if (height !== undefined) {
                          tabsPaneWrapperEl.style.height = height;
                      }
                  }
              }
          }
          const renderNameListRef = { value: [] };
          const animationDirectionRef = ref('next');
          function activateTab(panelName) {
              const currentValue = mergedValueRef.value;
              let dir = 'next';
              for (const name of renderNameListRef.value) {
                  if (name === currentValue) {
                      break;
                  }
                  if (name === panelName) {
                      dir = 'prev';
                      break;
                  }
              }
              animationDirectionRef.value = dir;
              doUpdateValue(panelName);
          }
          function doUpdateValue(panelName) {
              const { onActiveNameChange, onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              if (onActiveNameChange) {
                  call(onActiveNameChange, panelName);
              }
              if (onUpdateValue)
                  call(onUpdateValue, panelName);
              if (_onUpdateValue)
                  call(_onUpdateValue, panelName);
              uncontrolledValueRef.value = panelName;
          }
          function handleClose(panelName) {
              const { onClose } = props;
              if (onClose)
                  call(onClose, panelName);
          }
          function updateBarPositionInstantly() {
              const { value: barEl } = barElRef;
              if (!barEl)
                  return;
              const disableTransitionClassName = 'transition-disabled';
              barEl.classList.add(disableTransitionClassName);
              updateCurrentBarStyle();
              // here we don't need to force layout after update bar style
              // since deriveScrollShadow will force layout
              barEl.classList.remove(disableTransitionClassName);
          }
          let memorizedWidth = 0;
          function _handleNavResize(entry) {
              var _b;
              if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
                  return;
              }
              if (memorizedWidth === entry.contentRect.width) {
                  return;
              }
              memorizedWidth = entry.contentRect.width;
              const { type } = props;
              if (type === 'line' || type === 'bar') {
                  {
                      updateBarPositionInstantly();
                  }
              }
              if (type !== 'segment') {
                  deriveScrollShadow(((_b = xScrollInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) || null);
              }
          }
          const handleNavResize = throttle(_handleNavResize, 64);
          watch([() => props.justifyContent, () => props.size], () => {
              void nextTick(() => {
                  const { type } = props;
                  if (type === 'line' || type === 'bar') {
                      updateBarPositionInstantly();
                  }
              });
          });
          const addTabFixedRef = ref(false);
          function _handleTabsResize(entry) {
              var _a;
              const { target, contentRect: { width } } = entry;
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              const containerWidth = target.parentElement.offsetWidth;
              if (!addTabFixedRef.value) {
                  if (containerWidth < width) {
                      addTabFixedRef.value = true;
                  }
              }
              else {
                  const { value: addTabInst } = addTabInstRef;
                  if (!addTabInst)
                      return;
                  if (containerWidth - width > addTabInst.$el.offsetWidth) {
                      addTabFixedRef.value = false;
                  }
              }
              deriveScrollShadow(((_a = xScrollInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) || null);
          }
          const handleTabsResize = throttle(_handleTabsResize, 64);
          function handleAdd() {
              const { onAdd } = props;
              if (onAdd)
                  onAdd();
              void nextTick(() => {
                  const currentEl = getCurrentEl();
                  const { value: xScrollInst } = xScrollInstRef;
                  if (!currentEl || !xScrollInst)
                      return;
                  xScrollInst.scrollTo({
                      left: currentEl.offsetLeft,
                      top: 0,
                      behavior: 'smooth'
                  });
              });
          }
          function deriveScrollShadow(el) {
              if (!el)
                  return;
              const { placement } = props;
              if (placement === 'top' || placement === 'bottom') {
                  const { scrollLeft, scrollWidth, offsetWidth } = el;
                  startReachedRef.value = scrollLeft <= 0;
                  endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
              }
              else {
                  const { scrollTop, scrollHeight, offsetHeight } = el;
                  startReachedRef.value = scrollTop <= 0;
                  endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;
              }
          }
          const handleScroll = throttle((e) => {
              deriveScrollShadow(e.target);
          }, 64);
          provide(tabsInjectionKey, {
              triggerRef: toRef(props, 'trigger'),
              tabStyleRef: toRef(props, 'tabStyle'),
              paneClassRef: toRef(props, 'paneClass'),
              paneStyleRef: toRef(props, 'paneStyle'),
              mergedClsPrefixRef,
              typeRef: toRef(props, 'type'),
              closableRef: toRef(props, 'closable'),
              valueRef: mergedValueRef,
              tabChangeIdRef,
              onBeforeLeaveRef: toRef(props, 'onBeforeLeave'),
              activateTab,
              handleClose,
              handleAdd
          });
          onFontsReady(() => {
              updateCurrentBarStyle();
              updateCurrentScrollPosition();
          });
          // avoid useless rerender
          watchEffect(() => {
              const { value: el } = scrollWrapperElRef;
              if (!el)
                  return;
              const { value: clsPrefix } = mergedClsPrefixRef;
              const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;
              const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;
              if (startReachedRef.value) {
                  el.classList.remove(shadowStartClass);
              }
              else {
                  el.classList.add(shadowStartClass);
              }
              if (endReachedRef.value) {
                  el.classList.remove(shadowEndClass);
              }
              else {
                  el.classList.add(shadowEndClass);
              }
          });
          const tabsRailElRef = ref(null);
          watch(mergedValueRef, () => {
              if (props.type === 'segment') {
                  const tabsRailEl = tabsRailElRef.value;
                  if (tabsRailEl) {
                      void nextTick(() => {
                          tabsRailEl.classList.add('transition-disabled');
                          void tabsRailEl.offsetWidth;
                          tabsRailEl.classList.remove('transition-disabled');
                      });
                  }
              }
          });
          const exposedMethods = {
              syncBarPosition: () => {
                  updateCurrentBarStyle();
              }
          };
          const cssVarsRef = computed(() => {
              const { value: size } = compitableSizeRef;
              const { type } = props;
              const typeSuffix = {
                  card: 'Card',
                  bar: 'Bar',
                  line: 'Line',
                  segment: 'Segment'
              }[type];
              const sizeType = `${size}${typeSuffix}`;
              const { self: { barColor, closeIconColor, closeIconColorHover, closeIconColorPressed, tabColor, tabBorderColor, paneTextColor, tabFontWeight, tabBorderRadius, tabFontWeightActive, colorSegment, fontWeightStrong, tabColorSegment, closeSize, closeIconSize, closeColorHover, closeColorPressed, closeBorderRadius, [createKey('panePadding', size)]: panePadding, [createKey('tabPadding', sizeType)]: tabPadding, [createKey('tabPaddingVertical', sizeType)]: tabPaddingVertical, [createKey('tabGap', sizeType)]: tabGap, [createKey('tabGap', `${sizeType}Vertical`)]: tabGapVertical, [createKey('tabTextColor', type)]: tabTextColor, [createKey('tabTextColorActive', type)]: tabTextColorActive, [createKey('tabTextColorHover', type)]: tabTextColorHover, [createKey('tabTextColorDisabled', type)]: tabTextColorDisabled, [createKey('tabFontSize', size)]: tabFontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color-segment': colorSegment,
                  '--n-bar-color': barColor,
                  '--n-tab-font-size': tabFontSize,
                  '--n-tab-text-color': tabTextColor,
                  '--n-tab-text-color-active': tabTextColorActive,
                  '--n-tab-text-color-disabled': tabTextColorDisabled,
                  '--n-tab-text-color-hover': tabTextColorHover,
                  '--n-pane-text-color': paneTextColor,
                  '--n-tab-border-color': tabBorderColor,
                  '--n-tab-border-radius': tabBorderRadius,
                  '--n-close-size': closeSize,
                  '--n-close-icon-size': closeIconSize,
                  '--n-close-color-hover': closeColorHover,
                  '--n-close-color-pressed': closeColorPressed,
                  '--n-close-border-radius': closeBorderRadius,
                  '--n-close-icon-color': closeIconColor,
                  '--n-close-icon-color-hover': closeIconColorHover,
                  '--n-close-icon-color-pressed': closeIconColorPressed,
                  '--n-tab-color': tabColor,
                  '--n-tab-font-weight': tabFontWeight,
                  '--n-tab-font-weight-active': tabFontWeightActive,
                  '--n-tab-padding': tabPadding,
                  '--n-tab-padding-vertical': tabPaddingVertical,
                  '--n-tab-gap': tabGap,
                  '--n-tab-gap-vertical': tabGapVertical,
                  '--n-pane-padding-left': getMargin(panePadding, 'left'),
                  '--n-pane-padding-right': getMargin(panePadding, 'right'),
                  '--n-pane-padding-top': getMargin(panePadding, 'top'),
                  '--n-pane-padding-bottom': getMargin(panePadding, 'bottom'),
                  '--n-font-weight-strong': fontWeightStrong,
                  '--n-tab-color-segment': tabColorSegment
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('tabs', computed(() => {
                  return `${compitableSizeRef.value[0]}${props.type[0]}`;
              }), cssVarsRef, props)
              : undefined;
          return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, mergedValue: mergedValueRef, renderedNames: new Set(), tabsRailElRef,
              tabsPaneWrapperRef,
              tabsElRef,
              barElRef,
              addTabInstRef,
              xScrollInstRef,
              scrollWrapperElRef, addTabFixed: addTabFixedRef, tabWrapperStyle: tabWrapperStyleRef, handleNavResize, mergedSize: compitableSizeRef, handleScroll,
              handleTabsResize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, animationDirection: animationDirectionRef, renderNameListRef,
              onAnimationBeforeLeave,
              onAnimationEnter,
              onAnimationAfterEnter, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender }, exposedMethods);
      },
      render() {
          const { mergedClsPrefix, type, placement, addTabFixed, addable, mergedSize, renderNameListRef, onRender, paneWrapperClass, paneWrapperStyle, $slots: { default: defaultSlot, prefix: prefixSlot, suffix: suffixSlot } } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const tabPaneChildren = defaultSlot
              ? flatten$3(defaultSlot()).filter((v) => {
                  return v.type.__TAB_PANE__ === true;
              })
              : [];
          const tabChildren = defaultSlot
              ? flatten$3(defaultSlot()).filter((v) => {
                  return v.type.__TAB__ === true;
              })
              : [];
          const showPane = !tabChildren.length;
          const isCard = type === 'card';
          const isSegment = type === 'segment';
          const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
          renderNameListRef.value = [];
          const scrollContent = () => {
              const tabs = (h("div", { style: this.tabWrapperStyle, class: [`${mergedClsPrefix}-tabs-wrapper`] },
                  mergedJustifyContent ? null : (h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } })),
                  showPane
                      ? tabPaneChildren.map((tabPaneVNode, index) => {
                          renderNameListRef.value.push(tabPaneVNode.props.name);
                          return justifyTabDynamicProps(h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 &&
                                  (!mergedJustifyContent ||
                                      mergedJustifyContent === 'center' ||
                                      mergedJustifyContent === 'start' ||
                                      mergedJustifyContent === 'end') }), tabPaneVNode.children
                              ? {
                                  default: tabPaneVNode.children.tab
                              }
                              : undefined));
                      })
                      : tabChildren.map((tabVNode, index) => {
                          renderNameListRef.value.push(tabVNode.props.name);
                          if (index !== 0 && !mergedJustifyContent) {
                              return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
                          }
                          else {
                              return justifyTabDynamicProps(tabVNode);
                          }
                      }),
                  !addTabFixed && addable && isCard
                      ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0)
                      : null,
                  mergedJustifyContent ? null : (h("div", { class: `${mergedClsPrefix}-tabs-scroll-padding`, style: { width: `${this.tabsPadding}px` } }))));
              return (h("div", { ref: "tabsElRef", class: `${mergedClsPrefix}-tabs-nav-scroll-content` },
                  isCard && addable ? (h(VResizeObserver, { onResize: this.handleTabsResize }, {
                      default: () => tabs
                  })) : (tabs),
                  isCard ? h("div", { class: `${mergedClsPrefix}-tabs-pad` }) : null,
                  isCard ? null : (h("div", { ref: "barElRef", class: `${mergedClsPrefix}-tabs-bar` }))));
          };
          const resolvedPlacement = isSegment ? 'top' : placement;
          return (h("div", { class: [
                  `${mergedClsPrefix}-tabs`,
                  this.themeClass,
                  `${mergedClsPrefix}-tabs--${type}-type`,
                  `${mergedClsPrefix}-tabs--${mergedSize}-size`,
                  mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`,
                  `${mergedClsPrefix}-tabs--${resolvedPlacement}`
              ], style: this.cssVars },
              h("div", { class: [
                      // the class should be applied here since it's possible
                      // to make tabs nested in tabs, style may influence each
                      // other. adding a class will make it easy to write the
                      // style.
                      `${mergedClsPrefix}-tabs-nav--${type}-type`,
                      `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`,
                      `${mergedClsPrefix}-tabs-nav`
                  ] },
                  resolveWrappedSlot(prefixSlot, (children) => children && (h("div", { class: `${mergedClsPrefix}-tabs-nav__prefix` }, children))),
                  isSegment ? (h("div", { class: `${mergedClsPrefix}-tabs-rail`, ref: "tabsRailElRef" }, showPane
                      ? tabPaneChildren.map((tabPaneVNode, index) => {
                          renderNameListRef.value.push(tabPaneVNode.props.name);
                          return (h(Tab, Object.assign({}, tabPaneVNode.props, { internalCreatedByPane: true, internalLeftPadded: index !== 0 }), tabPaneVNode.children
                              ? {
                                  default: tabPaneVNode.children.tab
                              }
                              : undefined));
                      })
                      : tabChildren.map((tabVNode, index) => {
                          renderNameListRef.value.push(tabVNode.props.name);
                          if (index === 0) {
                              return tabVNode;
                          }
                          else {
                              return createLeftPaddedTabVNode(tabVNode);
                          }
                      }))) : (h(VResizeObserver, { onResize: this.handleNavResize }, {
                      default: () => (h("div", { class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`, ref: "scrollWrapperElRef" }, ['top', 'bottom'].includes(resolvedPlacement) ? (h(VXScroll, { ref: "xScrollInstRef", onScroll: this.handleScroll }, {
                          default: scrollContent
                      })) : (h("div", { class: `${mergedClsPrefix}-tabs-nav-y-scroll`, onScroll: this.handleScroll }, scrollContent()))))
                  })),
                  addTabFixed && addable && isCard
                      ? createAddTag(addable, true)
                      : null,
                  resolveWrappedSlot(suffixSlot, (children) => children && (h("div", { class: `${mergedClsPrefix}-tabs-nav__suffix` }, children)))),
              showPane &&
                  (this.animated &&
                      (resolvedPlacement === 'top' || resolvedPlacement === 'bottom') ? (h("div", { ref: "tabsPaneWrapperRef", style: paneWrapperStyle, class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass] }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection))) : (filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)))));
      }
  });
  function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
      const children = [];
      tabPaneVNodes.forEach((vNode) => {
          const { name, displayDirective, 'display-directive': _displayDirective } = vNode.props;
          const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
          const show = value === name;
          if (vNode.key !== undefined) {
              vNode.key = name;
          }
          if (show ||
              matchDisplayDirective('show') ||
              (matchDisplayDirective('show:lazy') && renderedNames.has(name))) {
              if (!renderedNames.has(name)) {
                  renderedNames.add(name);
              }
              const useVShow = !matchDisplayDirective('if');
              children.push(useVShow ? withDirectives(vNode, [[vShow, show]]) : vNode);
          }
      });
      if (!animationDirection) {
          return children;
      }
      return (h(TransitionGroup, { name: `${animationDirection}-transition`, onBeforeLeave: onBeforeLeave, onEnter: onEnter, onAfterEnter: onAfterEnter }, { default: () => children }));
  }
  function createAddTag(addable, internalLeftPadded) {
      return (h(Tab, { ref: "addTabInstRef", key: "__addable", name: "__addable", internalCreatedByPane: true, internalAddable: true, internalLeftPadded: internalLeftPadded, disabled: typeof addable === 'object' && addable.disabled }));
  }
  function createLeftPaddedTabVNode(tabVNode) {
      const modifiedVNode = cloneVNode(tabVNode);
      if (modifiedVNode.props) {
          modifiedVNode.props.internalLeftPadded = true;
      }
      else {
          modifiedVNode.props = {
              internalLeftPadded: true
          };
      }
      return modifiedVNode;
  }
  function justifyTabDynamicProps(tabVNode) {
      if (Array.isArray(tabVNode.dynamicProps)) {
          if (!tabVNode.dynamicProps.includes('internalLeftPadded')) {
              tabVNode.dynamicProps.push('internalLeftPadded');
          }
      }
      else {
          tabVNode.dynamicProps = ['internalLeftPadded'];
      }
      return tabVNode;
  }

  // vars:
  // --n-bezier
  // --n-font-size
  // --n-text-color
  // --n-title-font-weight
  // --n-title-text-color
  var style$d = cB('thing', `
 display: flex;
 transition: color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 color: var(--n-text-color);
`, [cB('thing-avatar', `
 margin-right: 12px;
 margin-top: 2px;
 `), cB('thing-avatar-header-wrapper', `
 display: flex;
 flex-wrap: nowrap;
 `, [cB('thing-header-wrapper', `
 flex: 1;
 `)]), cB('thing-main', `
 flex-grow: 1;
 `, [cB('thing-header', `
 display: flex;
 margin-bottom: 4px;
 justify-content: space-between;
 align-items: center;
 `, [cE('title', `
 font-size: 16px;
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-title-text-color);
 `)]), cE('description', [c$1('&:not(:last-child)', `
 margin-bottom: 4px;
 `)]), cE('content', [c$1('&:not(:first-child)', `
 margin-top: 12px;
 `)]), cE('footer', [c$1('&:not(:first-child)', `
 margin-top: 12px;
 `)]), cE('action', [c$1('&:not(:first-child)', `
 margin-top: 12px;
 `)])])]);

  const thingProps = Object.assign(Object.assign({}, useTheme.props), { title: String, titleExtra: String, description: String, descriptionClass: String, descriptionStyle: [String, Object], content: String, contentClass: String, contentStyle: [String, Object], contentIndented: Boolean });
  var Thing = defineComponent({
      name: 'Thing',
      props: thingProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const themeRef = useTheme('Thing', '-thing', style$d, thingLight$1, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl('Thing', mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { self: { titleTextColor, textColor, titleFontWeight, fontSize }, common: { cubicBezierEaseInOut } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-text-color': textColor,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-title-text-color': titleTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('thing', undefined, cssVarsRef, props)
              : undefined;
          return () => {
              var _a;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              const rtlEnabled = rtlEnabledRef ? rtlEnabledRef.value : false;
              (_a = themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender) === null || _a === void 0 ? void 0 : _a.call(themeClassHandle);
              return (h("div", { class: [
                      `${mergedClsPrefix}-thing`,
                      themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
                      rtlEnabled && `${mergedClsPrefix}-thing--rtl`
                  ], style: inlineThemeDisabled
                      ? undefined
                      : cssVarsRef.value },
                  slots.avatar && props.contentIndented ? (h("div", { class: `${mergedClsPrefix}-thing-avatar` }, slots.avatar())) : null,
                  h("div", { class: `${mergedClsPrefix}-thing-main` },
                      !props.contentIndented &&
                          (slots.header ||
                              props.title ||
                              slots['header-extra'] ||
                              props.titleExtra ||
                              slots.avatar) ? (h("div", { class: `${mergedClsPrefix}-thing-avatar-header-wrapper` },
                          slots.avatar ? (h("div", { class: `${mergedClsPrefix}-thing-avatar` }, slots.avatar())) : null,
                          slots.header ||
                              props.title ||
                              slots['header-extra'] ||
                              props.titleExtra ? (h("div", { class: `${mergedClsPrefix}-thing-header-wrapper` },
                              h("div", { class: `${mergedClsPrefix}-thing-header` },
                                  slots.header || props.title ? (h("div", { class: `${mergedClsPrefix}-thing-header__title` }, slots.header ? slots.header() : props.title)) : null,
                                  slots['header-extra'] || props.titleExtra ? (h("div", { class: `${mergedClsPrefix}-thing-header__extra` }, slots['header-extra']
                                      ? slots['header-extra']()
                                      : props.titleExtra)) : null),
                              slots.description || props.description ? (h("div", { class: [
                                      `${mergedClsPrefix}-thing-main__description`,
                                      props.descriptionClass
                                  ], style: props.descriptionStyle }, slots.description
                                  ? slots.description()
                                  : props.description)) : null)) : null)) : (h(Fragment, null,
                          slots.header ||
                              props.title ||
                              slots['header-extra'] ||
                              props.titleExtra ? (h("div", { class: `${mergedClsPrefix}-thing-header` },
                              slots.header || props.title ? (h("div", { class: `${mergedClsPrefix}-thing-header__title` }, slots.header ? slots.header() : props.title)) : null,
                              slots['header-extra'] || props.titleExtra ? (h("div", { class: `${mergedClsPrefix}-thing-header__extra` }, slots['header-extra']
                                  ? slots['header-extra']()
                                  : props.titleExtra)) : null)) : null,
                          slots.description || props.description ? (h("div", { class: [
                                  `${mergedClsPrefix}-thing-main__description`,
                                  props.descriptionClass
                              ], style: props.descriptionStyle }, slots.description
                              ? slots.description()
                              : props.description)) : null)),
                      slots.default || props.content ? (h("div", { class: [
                              `${mergedClsPrefix}-thing-main__content`,
                              props.contentClass
                          ], style: props.contentStyle }, slots.default ? slots.default() : props.content)) : null,
                      slots.footer ? (h("div", { class: `${mergedClsPrefix}-thing-main__footer` }, slots.footer())) : null,
                      slots.action ? (h("div", { class: `${mergedClsPrefix}-thing-main__action` }, slots.action())) : null)));
          };
      }
  });

  const timeProps = {
      time: {
          type: [Number, Date],
          default: undefined // For unix or non unix mode, it should be different default value
      },
      type: {
          type: String,
          default: 'datetime'
      },
      to: {
          type: [Number, Date],
          default: undefined // the same as `time` prop
      },
      unix: Boolean,
      format: String,
      text: Boolean,
      timeZone: String
  };
  var Time = defineComponent({
      name: 'Time',
      props: timeProps,
      setup(props) {
          const now = Date.now();
          const { localeRef, dateLocaleRef } = useLocale('Time');
          const mergedFormatRef = computed(() => {
              const { timeZone } = props;
              if (timeZone) {
                  return (time, _format, options) => {
                      return formatInTimeZone(time, timeZone, _format, options);
                  };
              }
              return format$4;
          });
          const dateFnsOptionsRef = computed(() => {
              return {
                  locale: dateLocaleRef.value.locale
              };
          });
          const mergedTimeRef = computed(() => {
              const { time } = props;
              if (props.unix) {
                  if (time === undefined)
                      return now;
                  return fromUnixTime(typeof time === 'number' ? time : time.valueOf());
              }
              return time !== null && time !== void 0 ? time : now;
          });
          const mergedToRef = computed(() => {
              const { to } = props;
              if (props.unix) {
                  if (to === undefined)
                      return now;
                  return fromUnixTime(typeof to === 'number' ? to : to.valueOf());
              }
              return to !== null && to !== void 0 ? to : now;
          });
          const renderedTimeRef = computed(() => {
              if (props.format) {
                  return mergedFormatRef.value(mergedTimeRef.value, props.format, dateFnsOptionsRef.value);
              }
              else if (props.type === 'date') {
                  return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateFormat, dateFnsOptionsRef.value);
              }
              else if (props.type === 'datetime') {
                  return mergedFormatRef.value(mergedTimeRef.value, localeRef.value.dateTimeFormat, dateFnsOptionsRef.value);
              }
              else {
                  return formatDistanceStrict(mergedTimeRef.value, mergedToRef.value, {
                      addSuffix: true,
                      locale: dateLocaleRef.value.locale
                  });
              }
          });
          return {
              renderedTime: renderedTimeRef
          };
      },
      render() {
          return this.text
              ? createTextVNode(this.renderedTime)
              : h('time', [this.renderedTime]);
      }
  });

  const lineHeight = 1.25;
  // vars:
  // --n-bezier
  // --n-circle-border
  // --n-content-font-size
  // --n-content-text-color
  // --n-line-color
  // --n-meta-text-color
  // --n-title-font-size
  // --n-title-font-weight
  // --n-title-margin
  // --n-title-text-color
  // --n-icon-size
  var style$c = cB('timeline', `
 position: relative;
 width: 100%;
 display: flex;
 flex-direction: column;
 line-height: ${lineHeight};
`, [cM('horizontal', `
 flex-direction: row;
 `, [c$1('>', [cB('timeline-item', `
 flex-shrink: 0;
 padding-right: 40px;
 `, [cM('dashed-line-type', [c$1('>', [cB('timeline-item-timeline', [cE('line', `
 background-image: linear-gradient(90deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 10px 1px;
 `)])])]), c$1('>', [cB('timeline-item-content', `
 margin-top: calc(var(--n-icon-size) + 12px);
 `, [c$1('>', [cE('meta', `
 margin-top: 6px;
 margin-bottom: unset;
 `)])]), cB('timeline-item-timeline', `
 width: 100%;
 height: calc(var(--n-icon-size) + 12px);
 `, [cE('line', `
 left: var(--n-icon-size);
 top: calc(var(--n-icon-size) / 2 - 1px);
 right: 0px;
 width: unset;
 height: 2px;
 `)])])])])]), cM('right-placement', [cB('timeline-item', [cB('timeline-item-content', `
 text-align: right;
 margin-right: calc(var(--n-icon-size) + 12px);
 `), cB('timeline-item-timeline', `
 width: var(--n-icon-size);
 right: 0;
 `)])]), cM('left-placement', [cB('timeline-item', [cB('timeline-item-content', `
 margin-left: calc(var(--n-icon-size) + 12px);
 `), cB('timeline-item-timeline', `
 left: 0;
 `)])]), cB('timeline-item', `
 position: relative;
 `, [c$1('&:last-child', [cB('timeline-item-timeline', [cE('line', `
 display: none;
 `)]), cB('timeline-item-content', [cE('meta', `
 margin-bottom: 0;
 `)])]), cB('timeline-item-content', [cE('title', `
 margin: var(--n-title-margin);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cE('content', `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-content-font-size);
 color: var(--n-content-text-color);
 `), cE('meta', `
 transition: color .3s var(--n-bezier);
 font-size: 12px;
 margin-top: 6px;
 margin-bottom: 20px;
 color: var(--n-meta-text-color);
 `)]), cM('dashed-line-type', [cB('timeline-item-timeline', [cE('line', `
 --n-color-start: var(--n-line-color);
 transition: --n-color-start .3s var(--n-bezier);
 background-color: transparent;
 background-image: linear-gradient(180deg, var(--n-color-start), var(--n-color-start) 50%, transparent 50%, transparent 100%);
 background-size: 1px 10px;
 `)])]), cB('timeline-item-timeline', `
 width: calc(var(--n-icon-size) + 12px);
 position: absolute;
 top: calc(var(--n-title-font-size) * ${lineHeight} / 2 - var(--n-icon-size) / 2);
 height: 100%;
 `, [cE('circle', `
 border: var(--n-circle-border);
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 border-radius: var(--n-icon-size);
 box-sizing: border-box;
 `), cE('icon', `
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 display: flex;
 align-items: center;
 justify-content: center;
 `), cE('line', `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 top: var(--n-icon-size);
 left: calc(var(--n-icon-size) / 2 - 1px);
 bottom: 0px;
 width: 2px;
 background-color: var(--n-line-color);
 `)])])]);

  const timelineProps = Object.assign(Object.assign({}, useTheme.props), { horizontal: Boolean, itemPlacement: {
          type: String,
          default: 'left'
      }, size: {
          type: String,
          default: 'medium'
      }, iconSize: Number });
  const timelineInjectionKey = createInjectionKey('n-timeline');
  var Timeline = defineComponent({
      name: 'Timeline',
      props: timelineProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Timeline', '-timeline', style$c, timelineLight$1, props, mergedClsPrefixRef);
          provide(timelineInjectionKey, {
              props,
              mergedThemeRef: themeRef,
              mergedClsPrefixRef
          });
          return () => {
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              return (h("div", { class: [
                      `${mergedClsPrefix}-timeline`,
                      props.horizontal && `${mergedClsPrefix}-timeline--horizontal`,
                      `${mergedClsPrefix}-timeline--${props.size}-size`,
                      !props.horizontal &&
                          `${mergedClsPrefix}-timeline--${props.itemPlacement}-placement`
                  ] }, slots));
          };
      }
  });

  const timelineItemProps = {
      time: [String, Number],
      title: String,
      content: String,
      color: String,
      lineType: {
          type: String,
          default: 'default'
      },
      type: {
          type: String,
          default: 'default'
      }
  };
  var TimelineItem = defineComponent({
      name: 'TimelineItem',
      props: timelineItemProps,
      setup(props) {
          const NTimeline = inject(timelineInjectionKey);
          if (!NTimeline) {
              throwError('timeline-item', '`n-timeline-item` must be placed inside `n-timeline`.');
          }
          useHoudini();
          const { inlineThemeDisabled } = useConfig();
          const cssVarsRef = computed(() => {
              const { props: { size, iconSize: iconSizeProp }, mergedThemeRef } = NTimeline;
              const { type } = props;
              const { self: { titleTextColor, contentTextColor, metaTextColor, lineColor, titleFontWeight, contentFontSize, [createKey('iconSize', size)]: iconSize, [createKey('titleMargin', size)]: titleMargin, [createKey('titleFontSize', size)]: titleFontSize, [createKey('circleBorder', type)]: circleBorder, [createKey('iconColor', type)]: iconColor }, common: { cubicBezierEaseInOut } } = mergedThemeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-circle-border': circleBorder,
                  '--n-icon-color': iconColor,
                  '--n-content-font-size': contentFontSize,
                  '--n-content-text-color': contentTextColor,
                  '--n-line-color': lineColor,
                  '--n-meta-text-color': metaTextColor,
                  '--n-title-font-size': titleFontSize,
                  '--n-title-font-weight': titleFontWeight,
                  '--n-title-margin': titleMargin,
                  '--n-title-text-color': titleTextColor,
                  '--n-icon-size': formatLength(iconSizeProp) || iconSize
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('timeline-item', computed(() => {
                  const { props: { size, iconSize: iconSizeProp } } = NTimeline;
                  const { type } = props;
                  return `${size[0]}${iconSizeProp || 'a'}${type[0]}`;
              }), cssVarsRef, NTimeline.props)
              : undefined;
          return {
              mergedClsPrefix: NTimeline.mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          const { mergedClsPrefix, color, onRender, $slots } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-timeline-item`,
                  this.themeClass,
                  `${mergedClsPrefix}-timeline-item--${this.type}-type`,
                  `${mergedClsPrefix}-timeline-item--${this.lineType}-line-type`
              ], style: this.cssVars },
              h("div", { class: `${mergedClsPrefix}-timeline-item-timeline` },
                  h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__line` }),
                  resolveWrappedSlot($slots.icon, (children) => {
                      return children ? (h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__icon`, style: { color } }, children)) : (h("div", { class: `${mergedClsPrefix}-timeline-item-timeline__circle`, style: { borderColor: color } }));
                  })),
              h("div", { class: `${mergedClsPrefix}-timeline-item-content` },
                  resolveWrappedSlot($slots.header, (children) => {
                      const mergedChildren = children || this.title;
                      if (mergedChildren) {
                          return (h("div", { class: `${mergedClsPrefix}-timeline-item-content__title` }, children || this.title));
                      }
                      return null;
                  }),
                  h("div", { class: `${mergedClsPrefix}-timeline-item-content__content` }, resolveSlot($slots.default, () => [this.content])),
                  h("div", { class: `${mergedClsPrefix}-timeline-item-content__meta` }, resolveSlot($slots.footer, () => [this.time])))));
      }
  });

  const transferInjectionKey = createInjectionKey('n-transfer');

  var NTransferHeader = defineComponent({
      name: 'TransferHeader',
      props: {
          size: {
              type: String,
              required: true
          },
          selectAllText: String,
          clearText: String,
          source: Boolean,
          onCheckedAll: Function,
          onClearAll: Function,
          title: String
      },
      setup(props) {
          const { targetOptionsRef, canNotSelectAnythingRef, canBeClearedRef, allCheckedRef, mergedThemeRef, disabledRef, mergedClsPrefixRef, srcOptionsLengthRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(transferInjectionKey);
          const { localeRef } = useLocale('Transfer');
          return () => {
              const { source, onClearAll, onCheckedAll, selectAllText, clearText } = props;
              const { value: mergedTheme } = mergedThemeRef;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              const { value: locale } = localeRef;
              const buttonSize = props.size === 'large' ? 'small' : 'tiny';
              const { title } = props;
              return (h("div", { class: `${mergedClsPrefix}-transfer-list-header` },
                  title && (h("div", { class: `${mergedClsPrefix}-transfer-list-header__title` }, title)),
                  source && (h(NButton, { class: `${mergedClsPrefix}-transfer-list-header__button`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: buttonSize, tertiary: true, onClick: allCheckedRef.value ? onClearAll : onCheckedAll, disabled: canNotSelectAnythingRef.value || disabledRef.value }, {
                      default: () => allCheckedRef.value
                          ? clearText || locale.unselectAll
                          : selectAllText || locale.selectAll
                  })),
                  !source && canBeClearedRef.value && (h(NButton, { class: `${mergedClsPrefix}-transfer-list-header__button`, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, size: buttonSize, tertiary: true, onClick: onClearAll, disabled: disabledRef.value }, {
                      default: () => locale.clearAll
                  })),
                  h("div", { class: `${mergedClsPrefix}-transfer-list-header__extra` }, source
                      ? locale.total(srcOptionsLengthRef.value)
                      : locale.selected(targetOptionsRef.value.length))));
          };
      }
  });

  var NTransferListItem = defineComponent({
      name: 'NTransferListItem',
      props: {
          source: Boolean,
          label: {
              type: String,
              required: true
          },
          value: {
              type: [String, Number],
              required: true
          },
          disabled: Boolean,
          option: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          const { targetValueSetRef, mergedClsPrefixRef, mergedThemeRef, handleItemCheck, renderSourceLabelRef, renderTargetLabelRef, showSelectedRef
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
           } = inject(transferInjectionKey);
          const checkedRef = useMemo(() => targetValueSetRef.value.has(props.value));
          function handleClick() {
              if (!props.disabled) {
                  handleItemCheck(!checkedRef.value, props.value);
              }
          }
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef,
              checked: checkedRef,
              showSelected: showSelectedRef,
              renderSourceLabel: renderSourceLabelRef,
              renderTargetLabel: renderTargetLabelRef,
              handleClick
          };
      },
      render() {
          const { disabled, mergedTheme, mergedClsPrefix, label, checked, source, renderSourceLabel, renderTargetLabel } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-transfer-list-item`,
                  disabled && `${mergedClsPrefix}-transfer-list-item--disabled`,
                  source
                      ? `${mergedClsPrefix}-transfer-list-item--source`
                      : `${mergedClsPrefix}-transfer-list-item--target`
              ], onClick: source ? this.handleClick : undefined },
              h("div", { class: `${mergedClsPrefix}-transfer-list-item__background` }),
              source && this.showSelected && (h("div", { class: `${mergedClsPrefix}-transfer-list-item__checkbox` },
                  h(NCheckbox, { theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, disabled: disabled, checked: checked }))),
              h("div", { class: `${mergedClsPrefix}-transfer-list-item__label`, title: getTitleAttribute(label) }, source
                  ? renderSourceLabel
                      ? renderSourceLabel({
                          option: this.option
                      })
                      : label
                  : renderTargetLabel
                      ? renderTargetLabel({
                          option: this.option
                      })
                      : label),
              !source && !disabled && (h(NBaseClose, { focusable: false, class: `${mergedClsPrefix}-transfer-list-item__close`, clsPrefix: mergedClsPrefix, onClick: this.handleClick }))));
      }
  });

  var NTransferList = defineComponent({
      name: 'TransferList',
      props: {
          virtualScroll: {
              type: Boolean,
              required: true
          },
          itemSize: {
              type: Number,
              required: true
          },
          options: {
              type: Array,
              required: true
          },
          disabled: {
              type: Boolean,
              required: true
          },
          source: Boolean
      },
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedThemeRef, mergedClsPrefixRef } = inject(transferInjectionKey);
          const scrollerInstRef = ref(null);
          const vlInstRef = ref(null);
          function syncVLScroller() {
              var _a;
              (_a = scrollerInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function scrollContainer() {
              const { value } = vlInstRef;
              if (!value)
                  return null;
              const { listElRef } = value;
              return listElRef;
          }
          function scrollContent() {
              const { value } = vlInstRef;
              if (!value)
                  return null;
              const { itemsElRef } = value;
              return itemsElRef;
          }
          return {
              mergedTheme: mergedThemeRef,
              mergedClsPrefix: mergedClsPrefixRef,
              scrollerInstRef,
              vlInstRef,
              syncVLScroller,
              scrollContainer,
              scrollContent
          };
      },
      render() {
          const { mergedTheme, options } = this;
          if (options.length === 0) {
              return (h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty }));
          }
          const { mergedClsPrefix, virtualScroll, source, disabled, syncVLScroller } = this;
          return (h(NScrollbar, { ref: "scrollerInstRef", theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, container: virtualScroll ? this.scrollContainer : undefined, content: virtualScroll ? this.scrollContent : undefined }, {
              default: () => virtualScroll ? (h(VVirtualList, { ref: "vlInstRef", style: { height: '100%' }, class: `${mergedClsPrefix}-transfer-list-content`, items: this.options, itemSize: this.itemSize, showScrollbar: false, onResize: syncVLScroller, onScroll: syncVLScroller, keyField: "value" }, {
                  default: ({ item }) => {
                      const { source, disabled } = this;
                      return (h(NTransferListItem, { source: source, key: item.value, value: item.value, disabled: item.disabled || disabled, label: item.label, option: item }));
                  }
              })) : (h("div", { class: `${mergedClsPrefix}-transfer-list-content` }, options.map((option) => (h(NTransferListItem, { source: source, key: option.value, value: option.value, disabled: option.disabled || disabled, label: option.label, option: option })))))
          }));
      }
  });

  var NTransferFilter = defineComponent({
      name: 'TransferFilter',
      props: {
          value: String,
          placeholder: String,
          disabled: Boolean,
          onUpdateValue: {
              type: Function,
              required: true
          }
      },
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { mergedThemeRef, mergedClsPrefixRef } = inject(transferInjectionKey);
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedTheme: mergedThemeRef
          };
      },
      render() {
          const { mergedTheme, mergedClsPrefix } = this;
          return (h("div", { class: `${mergedClsPrefix}-transfer-filter` },
              h(NInput, { value: this.value, onUpdateValue: this.onUpdateValue, disabled: this.disabled, placeholder: this.placeholder, theme: mergedTheme.peers.Input, themeOverrides: mergedTheme.peerOverrides.Input, clearable: true, size: "small" }, {
                  'clear-icon-placeholder': () => (h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(SearchIcon, null) }))
              })));
      }
  });

  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  function useTransferData(props) {
      const uncontrolledValueRef = ref(props.defaultValue);
      const mergedValueRef = useMergedState(toRef(props, 'value'), uncontrolledValueRef);
      const optionsMapRef = computed(() => {
          const map = new Map();
          (props.options || []).forEach((opt) => map.set(opt.value, opt));
          return map;
      });
      const targetValueSetRef = computed(() => new Set(mergedValueRef.value || []));
      const targetOptionsRef = computed(() => {
          const optionMap = optionsMapRef.value;
          const targetOptions = [];
          (mergedValueRef.value || []).forEach((v) => {
              const option = optionMap.get(v);
              if (option) {
                  targetOptions.push(option);
              }
          });
          return targetOptions;
      });
      const srcPatternRef = ref('');
      const tgtPatternRef = ref('');
      const mergedSrcFilterableRef = computed(() => {
          return props.sourceFilterable || !!props.filterable;
      });
      const filteredSrcOptionsRef = computed(() => {
          const { showSelected, options, filter } = props;
          if (!mergedSrcFilterableRef.value) {
              if (showSelected) {
                  return options;
              }
              else {
                  return options.filter((option) => !targetValueSetRef.value.has(option.value));
              }
          }
          return options.filter((option) => {
              return (filter(srcPatternRef.value, option, 'source') &&
                  (showSelected || !targetValueSetRef.value.has(option.value)));
          });
      });
      const filteredTgtOptionsRef = computed(() => {
          if (!props.targetFilterable)
              return targetOptionsRef.value;
          const { filter } = props;
          return targetOptionsRef.value.filter((opt) => filter(tgtPatternRef.value, opt, 'target'));
      });
      const mergedValueSetRef = computed(() => {
          const { value } = mergedValueRef;
          if (value === null)
              return new Set();
          return new Set(value);
      });
      const valueSetForCheckAllRef = computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredSrcOptionsRef.value.forEach((option) => {
              if (!option.disabled && !values.has(option.value)) {
                  values.add(option.value);
              }
          });
          return values;
      });
      const valueSetForUncheckAllRef = computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredSrcOptionsRef.value.forEach((option) => {
              if (!option.disabled && values.has(option.value)) {
                  values.delete(option.value);
              }
          });
          return values;
      });
      const valueSetForClearRef = computed(() => {
          const values = new Set(mergedValueSetRef.value);
          filteredTgtOptionsRef.value.forEach((option) => {
              if (!option.disabled) {
                  values.delete(option.value);
              }
          });
          return values;
      });
      const canNotSelectAnythingRef = computed(() => {
          return filteredSrcOptionsRef.value.every((option) => option.disabled);
      });
      const allCheckedRef = computed(() => {
          if (!filteredSrcOptionsRef.value.length) {
              return false;
          }
          const mergedValueSet = mergedValueSetRef.value;
          return filteredSrcOptionsRef.value.every((option) => option.disabled || mergedValueSet.has(option.value));
      });
      const canBeClearedRef = computed(() => {
          return filteredTgtOptionsRef.value.some((option) => !option.disabled);
      });
      function handleSrcFilterUpdateValue(value) {
          srcPatternRef.value = value !== null && value !== void 0 ? value : '';
      }
      function handleTgtFilterUpdateValue(value) {
          tgtPatternRef.value = value !== null && value !== void 0 ? value : '';
      }
      return {
          uncontrolledValueRef,
          mergedValueRef,
          targetValueSetRef,
          valueSetForCheckAllRef,
          valueSetForUncheckAllRef,
          valueSetForClearRef,
          filteredTgtOptionsRef,
          filteredSrcOptionsRef,
          targetOptionsRef,
          canNotSelectAnythingRef,
          canBeClearedRef,
          allCheckedRef,
          srcPatternRef,
          tgtPatternRef,
          mergedSrcFilterableRef,
          handleSrcFilterUpdateValue,
          handleTgtFilterUpdateValue
      };
  }

  // --n-close-size
  // --n-close-icon-size
  // --n-close-color-hover
  // --n-close-color-pressed
  // --n-close-icon-color
  // --n-close-icon-color-hover
  // --n-close-icon-color-pressed
  var style$b = cB('transfer', `
 width: 100%;
 font-size: var(--n-font-size);
 height: 300px;
 display: flex;
 flex-wrap: nowrap;
 word-break: break-word;
`, [cM('disabled', [cB('transfer-list', [cB('transfer-list-header', [cE('title', `
 color: var(--n-header-text-color-disabled);
 `), cE('extra', `
 color: var(--n-header-extra-text-color-disabled);
 `)])])]), cB('transfer-list', `
 flex: 1;
 min-width: 0;
 height: inherit;
 display: flex;
 flex-direction: column;
 background-clip: padding-box;
 position: relative;
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-list-color);
 `, [cM('source', `
 border-top-left-radius: var(--n-border-radius);
 border-bottom-left-radius: var(--n-border-radius);
 `, [cE('border', 'border-right: 1px solid var(--n-divider-color);')]), cM('target', `
 border-top-right-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `, [cE('border', 'border-left: none;')]), cE('border', `
 padding: 0 12px;
 border: 1px solid var(--n-border-color);
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `), cB('transfer-list-header', `
 min-height: var(--n-header-height);
 box-sizing: border-box;
 display: flex;
 padding: 12px 12px 10px 12px;
 align-items: center;
 background-clip: padding-box;
 border-radius: inherit;
 border-bottom-left-radius: 0;
 border-bottom-right-radius: 0;
 line-height: 1.5;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1('> *:not(:first-child)', `
 margin-left: 8px;
 `), cE('title', `
 flex: 1;
 min-width: 0;
 line-height: 1.5;
 font-size: var(--n-header-font-size);
 font-weight: var(--n-header-font-weight);
 transition: color .3s var(--n-bezier);
 color: var(--n-header-text-color);
 `), cE('button', `
 position: relative;
 `), cE('extra', `
 transition: color .3s var(--n-bezier);
 font-size: var(--n-extra-font-size);
 margin-right: 0;
 white-space: nowrap;
 color: var(--n-header-extra-text-color);
 `)]), cB('transfer-list-body', `
 flex-basis: 0;
 flex-grow: 1;
 box-sizing: border-box;
 position: relative;
 display: flex;
 flex-direction: column;
 border-radius: inherit;
 border-top-left-radius: 0;
 border-top-right-radius: 0;
 `, [cB('transfer-filter', `
 padding: 4px 12px 8px 12px;
 box-sizing: border-box;
 transition:
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB('transfer-list-flex-container', `
 flex: 1;
 position: relative;
 `, [cB('scrollbar', `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 height: unset;
 `), cB('empty', `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 `), cB('transfer-list-content', `
 padding: 0;
 margin: 0;
 position: relative;
 `, [cB('transfer-list-item', `
 padding: 0 12px;
 min-height: var(--n-item-height);
 display: flex;
 align-items: center;
 color: var(--n-item-text-color);
 position: relative;
 transition: color .3s var(--n-bezier);
 `, [cE('background', `
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), cE('checkbox', `
 position: relative;
 margin-right: 8px;
 `), cE('close', `
 opacity: 0;
 pointer-events: none;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE('label', `
 position: relative;
 min-width: 0;
 flex-grow: 1;
 `), cM('source', 'cursor: pointer;'), cM('disabled', `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `), cNotM('disabled', [c$1('&:hover', [cE('background', 'background-color: var(--n-item-color-pending);'), cE('close', `
 opacity: 1;
 pointer-events: all;
 `)])])])])])])])]);

  const transferProps = Object.assign(Object.assign({}, useTheme.props), { value: Array, defaultValue: {
          type: Array,
          default: null
      }, options: {
          type: Array,
          default: () => []
      }, disabled: {
          type: Boolean,
          default: undefined
      }, virtualScroll: Boolean, sourceTitle: String, selectAllText: String, clearText: String, targetTitle: String, filterable: {
          type: Boolean,
          default: undefined
      }, sourceFilterable: Boolean, targetFilterable: Boolean, showSelected: {
          type: Boolean,
          default: true
      }, sourceFilterPlaceholder: String, targetFilterPlaceholder: String, filter: {
          type: Function,
          default: (pattern, option) => {
              if (!pattern)
                  return true;
              return ~('' + option.label)
                  .toLowerCase()
                  .indexOf(('' + pattern).toLowerCase());
          }
      }, size: String, renderSourceLabel: Function, renderTargetLabel: Function, renderSourceList: Function, renderTargetList: Function, 'onUpdate:value': [Function, Array], onUpdateValue: [Function, Array], onChange: [Function, Array] });
  var Transfer = defineComponent({
      name: 'Transfer',
      props: transferProps,
      setup(props) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Transfer', '-transfer', style$b, transferLight$2, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const { mergedSizeRef, mergedDisabledRef } = formItem;
          const itemSizeRef = computed(() => {
              const { value: size } = mergedSizeRef;
              const { self: { [createKey('itemHeight', size)]: itemSize } } = themeRef.value;
              return depx(itemSize);
          });
          const { uncontrolledValueRef, mergedValueRef, targetValueSetRef, valueSetForCheckAllRef, valueSetForUncheckAllRef, valueSetForClearRef, filteredTgtOptionsRef, filteredSrcOptionsRef, targetOptionsRef, canNotSelectAnythingRef, canBeClearedRef, allCheckedRef, srcPatternRef, tgtPatternRef, mergedSrcFilterableRef, handleSrcFilterUpdateValue, handleTgtFilterUpdateValue } = useTransferData(props);
          function doUpdateValue(value) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue, onChange } = props;
              const { nTriggerFormInput, nTriggerFormChange } = formItem;
              if (onUpdateValue)
                  call(onUpdateValue, value);
              if (_onUpdateValue)
                  call(_onUpdateValue, value);
              if (onChange)
                  call(onChange, value);
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function handleSourceCheckAll() {
              doUpdateValue([...valueSetForCheckAllRef.value]);
          }
          function handleSourceUncheckAll() {
              doUpdateValue([...valueSetForUncheckAllRef.value]);
          }
          function handleTargetClearAll() {
              doUpdateValue([...valueSetForClearRef.value]);
          }
          function handleItemCheck(checked, optionValue) {
              if (checked) {
                  doUpdateValue((mergedValueRef.value || []).concat(optionValue));
              }
              else {
                  doUpdateValue((mergedValueRef.value || []).filter((v) => v !== optionValue));
              }
          }
          function handleChecked(optionValueList) {
              doUpdateValue(optionValueList);
          }
          provide(transferInjectionKey, {
              targetValueSetRef,
              mergedClsPrefixRef,
              disabledRef: mergedDisabledRef,
              mergedThemeRef: themeRef,
              targetOptionsRef,
              canNotSelectAnythingRef,
              canBeClearedRef,
              allCheckedRef,
              srcOptionsLengthRef: computed(() => props.options.length),
              handleItemCheck,
              renderSourceLabelRef: toRef(props, 'renderSourceLabel'),
              renderTargetLabelRef: toRef(props, 'renderTargetLabel'),
              showSelectedRef: toRef(props, 'showSelected')
          });
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              mergedDisabled: mergedDisabledRef,
              itemSize: itemSizeRef,
              isMounted: isMounted(),
              mergedTheme: themeRef,
              filteredSrcOpts: filteredSrcOptionsRef,
              filteredTgtOpts: filteredTgtOptionsRef,
              srcPattern: srcPatternRef,
              tgtPattern: tgtPatternRef,
              mergedSize: mergedSizeRef,
              mergedSrcFilterable: mergedSrcFilterableRef,
              handleSrcFilterUpdateValue,
              handleTgtFilterUpdateValue,
              handleSourceCheckAll,
              handleSourceUncheckAll,
              handleTargetClearAll,
              handleItemCheck,
              handleChecked,
              cssVars: computed(() => {
                  const { value: size } = mergedSizeRef;
                  const { common: { cubicBezierEaseInOut }, self: { borderRadius, borderColor, listColor, titleTextColor, titleTextColorDisabled, extraTextColor, itemTextColor, itemColorPending, itemTextColorDisabled, titleFontWeight, closeColorHover, closeColorPressed, closeIconColor, closeIconColorHover, closeIconColorPressed, closeIconSize, closeSize, dividerColor, extraTextColorDisabled, [createKey('extraFontSize', size)]: extraFontSize, [createKey('fontSize', size)]: fontSize, [createKey('titleFontSize', size)]: titleFontSize, [createKey('itemHeight', size)]: itemHeight, [createKey('headerHeight', size)]: headerHeight } } = themeRef.value;
                  return {
                      '--n-bezier': cubicBezierEaseInOut,
                      '--n-border-color': borderColor,
                      '--n-border-radius': borderRadius,
                      '--n-extra-font-size': extraFontSize,
                      '--n-font-size': fontSize,
                      '--n-header-font-size': titleFontSize,
                      '--n-header-extra-text-color': extraTextColor,
                      '--n-header-extra-text-color-disabled': extraTextColorDisabled,
                      '--n-header-font-weight': titleFontWeight,
                      '--n-header-text-color': titleTextColor,
                      '--n-header-text-color-disabled': titleTextColorDisabled,
                      '--n-item-color-pending': itemColorPending,
                      '--n-item-height': itemHeight,
                      '--n-item-text-color': itemTextColor,
                      '--n-item-text-color-disabled': itemTextColorDisabled,
                      '--n-list-color': listColor,
                      '--n-header-height': headerHeight,
                      '--n-close-size': closeSize,
                      '--n-close-icon-size': closeIconSize,
                      '--n-close-color-hover': closeColorHover,
                      '--n-close-color-pressed': closeColorPressed,
                      '--n-close-icon-color': closeIconColor,
                      '--n-close-icon-color-hover': closeIconColorHover,
                      '--n-close-icon-color-pressed': closeIconColorPressed,
                      '--n-divider-color': dividerColor
                  };
              })
          };
      },
      render() {
          const { mergedClsPrefix, renderSourceList, renderTargetList, mergedTheme, mergedSrcFilterable, targetFilterable } = this;
          return (h("div", { class: [
                  `${mergedClsPrefix}-transfer`,
                  this.mergedDisabled && `${mergedClsPrefix}-transfer--disabled`
              ], style: this.cssVars },
              h("div", { class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--source` },
                  h(NTransferHeader, { source: true, selectAllText: this.selectAllText, clearText: this.clearText, title: this.sourceTitle, onCheckedAll: this.handleSourceCheckAll, onClearAll: this.handleSourceUncheckAll, size: this.mergedSize }),
                  h("div", { class: `${mergedClsPrefix}-transfer-list-body` },
                      mergedSrcFilterable ? (h(NTransferFilter, { onUpdateValue: this.handleSrcFilterUpdateValue, value: this.srcPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder })) : null,
                      h("div", { class: `${mergedClsPrefix}-transfer-list-flex-container` }, renderSourceList ? (h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => renderSourceList({
                              onCheck: this.handleChecked,
                              checkedOptions: this.filteredTgtOpts,
                              pattern: this.srcPattern
                          })
                      })) : (h(NTransferList, { source: true, options: this.filteredSrcOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, itemSize: this.itemSize })))),
                  h("div", { class: `${mergedClsPrefix}-transfer-list__border` })),
              h("div", { class: `${mergedClsPrefix}-transfer-list ${mergedClsPrefix}-transfer-list--target` },
                  h(NTransferHeader, { onClearAll: this.handleTargetClearAll, size: this.mergedSize, title: this.targetTitle }),
                  h("div", { class: `${mergedClsPrefix}-transfer-list-body` },
                      targetFilterable ? (h(NTransferFilter, { onUpdateValue: this.handleTgtFilterUpdateValue, value: this.tgtPattern, disabled: this.mergedDisabled, placeholder: this.sourceFilterPlaceholder })) : null,
                      h("div", { class: `${mergedClsPrefix}-transfer-list-flex-container` }, renderTargetList ? (h(NScrollbar, { theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar }, {
                          default: () => renderTargetList({
                              onCheck: this.handleChecked,
                              checkedOptions: this.filteredTgtOpts,
                              pattern: this.tgtPattern
                          })
                      })) : (h(NTransferList, { options: this.filteredTgtOpts, disabled: this.mergedDisabled, virtualScroll: this.virtualScroll, itemSize: this.itemSize })))),
                  h("div", { class: `${mergedClsPrefix}-transfer-list__border` }))));
      }
  });

  const treeSelectInjectionKey = createInjectionKey('n-tree-select');

  const treeInjectionKey = createInjectionKey('n-tree');

  var NTreeNodeSwitcher = defineComponent({
      name: 'NTreeSwitcher',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          indent: { type: Number, required: true },
          expanded: Boolean,
          selected: Boolean,
          hide: Boolean,
          loading: Boolean,
          onClick: Function,
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const { renderSwitcherIconRef } = inject(treeInjectionKey, null);
          return () => {
              const { clsPrefix, expanded, hide, indent, onClick } = props;
              return (h("span", { "data-switcher": true, class: [
                      `${clsPrefix}-tree-node-switcher`,
                      expanded && `${clsPrefix}-tree-node-switcher--expanded`,
                      hide && `${clsPrefix}-tree-node-switcher--hide`
                  ], style: { width: `${indent}px` }, onClick: onClick },
                  h("div", { class: `${clsPrefix}-tree-node-switcher__icon` },
                      h(NIconSwitchTransition, null, {
                          default: () => {
                              if (props.loading) {
                                  return (h(NBaseLoading, { clsPrefix: clsPrefix, key: "loading", radius: 85, strokeWidth: 20 }));
                              }
                              const { value: renderSwitcherIcon } = renderSwitcherIconRef;
                              return renderSwitcherIcon ? (renderSwitcherIcon({
                                  expanded: props.expanded,
                                  selected: props.selected,
                                  option: props.tmNode.rawNode
                              })) : (h(NBaseIcon, { clsPrefix: clsPrefix, key: "switcher" }, { default: () => h(SwitcherIcon, null) }));
                          }
                      }))));
          };
      }
  });

  var NTreeNodeCheckbox = defineComponent({
      name: 'NTreeNodeCheckbox',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          indent: {
              type: Number,
              required: true
          },
          right: Boolean,
          focusable: Boolean,
          disabled: Boolean,
          checked: Boolean,
          indeterminate: Boolean,
          onCheck: Function
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NTree = inject(treeInjectionKey);
          function doCheck(value) {
              const { onCheck } = props;
              if (onCheck) {
                  onCheck(value);
              }
          }
          function handleUpdateValue(value) {
              doCheck(value);
          }
          return {
              handleUpdateValue,
              mergedTheme: NTree.mergedThemeRef
          };
      },
      render() {
          const { clsPrefix, mergedTheme, checked, indeterminate, disabled, focusable, indent, handleUpdateValue } = this;
          return (h("span", { class: [
                  `${clsPrefix}-tree-node-checkbox`,
                  this.right && `${clsPrefix}-tree-node-checkbox--right`
              ], style: {
                  width: `${indent}px`
              }, "data-checkbox": true },
              h(NCheckbox, { focusable: focusable, disabled: disabled, theme: mergedTheme.peers.Checkbox, themeOverrides: mergedTheme.peerOverrides.Checkbox, checked: checked, indeterminate: indeterminate, onUpdateChecked: handleUpdateValue })));
      }
  });

  var NTreeNodeContent = defineComponent({
      name: 'TreeNodeContent',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          disabled: Boolean,
          checked: Boolean,
          selected: Boolean,
          onClick: Function,
          onDragstart: Function,
          tmNode: {
              type: Object,
              required: true
          },
          nodeProps: Object
      },
      setup(props) {
          const { renderLabelRef, renderPrefixRef, renderSuffixRef, labelFieldRef } = 
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          inject(treeInjectionKey);
          const selfRef = ref(null);
          function doClick(e) {
              const { onClick } = props;
              if (onClick)
                  onClick(e);
          }
          function handleClick(e) {
              doClick(e);
          }
          return {
              selfRef,
              renderLabel: renderLabelRef,
              renderPrefix: renderPrefixRef,
              renderSuffix: renderSuffixRef,
              labelField: labelFieldRef,
              handleClick
          };
      },
      render() {
          const { clsPrefix, labelField, nodeProps, checked = false, selected = false, renderLabel, renderPrefix, renderSuffix, handleClick, onDragstart, tmNode: { rawNode, rawNode: { prefix, suffix, [labelField]: label } } } = this;
          return (h("span", Object.assign({}, nodeProps, { ref: "selfRef", class: [`${clsPrefix}-tree-node-content`, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class], onClick: handleClick, draggable: onDragstart === undefined ? undefined : true, onDragstart: onDragstart }),
              renderPrefix || prefix ? (h("div", { class: `${clsPrefix}-tree-node-content__prefix` }, renderPrefix
                  ? renderPrefix({
                      option: rawNode,
                      selected,
                      checked
                  })
                  : render$1(prefix))) : null,
              h("div", { class: `${clsPrefix}-tree-node-content__text` }, renderLabel
                  ? renderLabel({
                      option: rawNode,
                      selected,
                      checked
                  })
                  : render$1(label)),
              renderSuffix || suffix ? (h("div", { class: `${clsPrefix}-tree-node-content__suffix` }, renderSuffix
                  ? renderSuffix({
                      option: rawNode,
                      selected,
                      checked
                  })
                  : render$1(suffix))) : null));
      }
  });

  function renderDropMark({ position, offsetLevel, indent, el }) {
      const style = {
          position: 'absolute',
          boxSizing: 'border-box',
          right: 0
      };
      if (position === 'inside') {
          style.left = 0;
          style.top = 0;
          style.bottom = 0;
          style.borderRadius = 'inherit';
          style.boxShadow = 'inset 0 0 0 2px var(--n-drop-mark-color)';
      }
      else {
          const cssPosition = position === 'before' ? 'top' : 'bottom';
          style[cssPosition] = 0;
          // The left prop should be modified when tree's style is changed
          // Maybe it is possible to use content left
          style.left = `${el.offsetLeft + 6 - offsetLevel * indent}px`;
          style.height = '2px';
          style.backgroundColor = 'var(--n-drop-mark-color)';
          style.transformOrigin = cssPosition;
          style.borderRadius = '1px';
          style.transform =
              position === 'before' ? 'translateY(-4px)' : 'translateY(4px)';
      }
      return h("div", { style: style });
  }
  function defaultAllowDrop({ dropPosition, node }) {
      if (node.isLeaf === false)
          return true;
      if (node.children) {
          return true;
      }
      return dropPosition !== 'inside';
  }

  function useMergedCheckStrategy(props) {
      return computed(() => (props.leafOnly ? 'child' : props.checkStrategy));
  }
  function isNodeDisabled(node, disabledField) {
      return !!node.rawNode[disabledField];
  }
  function traverse(nodes, childrenField, callback, callbackAfter) {
      nodes === null || nodes === void 0 ? void 0 : nodes.forEach((node) => {
          callback(node);
          traverse(node[childrenField], childrenField, callback, callbackAfter);
          callbackAfter(node);
      });
  }
  function keysWithFilter(nodes, pattern, keyField, childrenField, filter) {
      const keys = new Set();
      const highlightKeySet = new Set();
      const path = [];
      traverse(nodes, childrenField, (node) => {
          path.push(node);
          if (filter(pattern, node)) {
              highlightKeySet.add(node[keyField]);
              for (let i = path.length - 2; i >= 0; --i) {
                  if (!keys.has(path[i][keyField])) {
                      keys.add(path[i][keyField]);
                  }
                  else {
                      return;
                  }
              }
          }
      }, () => {
          path.pop();
      });
      return {
          expandedKeys: Array.from(keys),
          highlightKeySet
      };
  }
  if (isBrowser$2 && Image) {
      const emptyImage = new Image();
      emptyImage.src =
          'data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==';
  }
  function filterTree(tree, filter, pattern, keyField, childrenField) {
      const visitedTailKeys = new Set();
      const visitedNonTailKeys = new Set();
      const highlightKeySet = new Set();
      const expandedKeys = [];
      const filteredTree = [];
      const path = [];
      function visit(t) {
          t.forEach((n) => {
              path.push(n);
              if (filter(pattern, n)) {
                  visitedTailKeys.add(n[keyField]);
                  highlightKeySet.add(n[keyField]);
                  for (let i = path.length - 2; i >= 0; --i) {
                      const key = path[i][keyField];
                      if (!visitedNonTailKeys.has(key)) {
                          visitedNonTailKeys.add(key);
                          if (visitedTailKeys.has(key)) {
                              visitedTailKeys.delete(key);
                          }
                      }
                      else {
                          break;
                      }
                  }
              }
              const children = n[childrenField];
              if (children) {
                  visit(children);
              }
              path.pop();
          });
      }
      visit(tree);
      function build(t, sibs) {
          t.forEach((n) => {
              const key = n[keyField];
              const isVisitedTail = visitedTailKeys.has(key);
              const isVisitedNonTail = visitedNonTailKeys.has(key);
              if (!isVisitedTail && !isVisitedNonTail)
                  return;
              const children = n[childrenField];
              if (children) {
                  if (isVisitedTail) {
                      // If it is visited path tail, use origin node
                      sibs.push(n);
                  }
                  else {
                      // It it is not visited path tail, use cloned node
                      expandedKeys.push(key);
                      const clonedNode = Object.assign(Object.assign({}, n), { [childrenField]: [] });
                      sibs.push(clonedNode);
                      build(children, clonedNode[childrenField]);
                  }
              }
              else {
                  sibs.push(n);
              }
          });
      }
      build(tree, filteredTree);
      return {
          filteredTree,
          highlightKeySet,
          expandedKeys
      };
  }
  function treeGetClickTarget(e) {
      if (happensIn(e, 'checkbox')) {
          return 'checkbox';
      }
      else if (happensIn(e, 'switcher')) {
          return 'switcher';
      }
      else {
          return 'node';
      }
  }

  const TreeNode = defineComponent({
      name: 'TreeNode',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          tmNode: {
              type: Object,
              required: true
          }
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NTree = inject(treeInjectionKey);
          const { droppingNodeParentRef, droppingMouseNodeRef, draggingNodeRef, droppingPositionRef, droppingOffsetLevelRef, nodePropsRef, indentRef, blockLineRef, checkboxPlacementRef, checkOnClickRef, disabledFieldRef, showLineRef, renderSwitcherIconRef } = NTree;
          const checkboxDisabledRef = useMemo(() => !!props.tmNode.rawNode.checkboxDisabled);
          const nodeIsDisabledRef = useMemo(() => {
              return isNodeDisabled(props.tmNode, disabledFieldRef.value);
          });
          const disabledRef = useMemo(() => NTree.disabledRef.value || nodeIsDisabledRef.value);
          const resolvedNodePropsRef = computed(() => {
              const { value: nodeProps } = nodePropsRef;
              if (!nodeProps)
                  return undefined;
              return nodeProps({ option: props.tmNode.rawNode });
          });
          // used for drag and drop
          const contentInstRef = ref(null);
          // must be non-reactive
          const contentElRef = { value: null };
          onMounted(() => {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              contentElRef.value = contentInstRef.value.$el;
          });
          function handleSwitcherClick() {
              const callback = () => {
                  const { tmNode } = props;
                  if (!tmNode.isLeaf && !tmNode.shallowLoaded) {
                      if (!NTree.loadingKeysRef.value.has(tmNode.key)) {
                          NTree.loadingKeysRef.value.add(tmNode.key);
                      }
                      else {
                          return;
                      }
                      const { onLoadRef: { value: onLoad } } = NTree;
                      if (onLoad) {
                          void onLoad(tmNode.rawNode)
                              .then((value) => {
                              if (value !== false) {
                                  NTree.handleSwitcherClick(tmNode);
                              }
                          })
                              .finally(() => {
                              NTree.loadingKeysRef.value.delete(tmNode.key);
                          });
                      }
                  }
                  else {
                      NTree.handleSwitcherClick(tmNode);
                  }
              };
              if (renderSwitcherIconRef.value) {
                  // if renderSwitcherIcon is set, icon dom may be altered before event
                  // bubbles to parent dom, so that target check fails. Call it in next
                  // event loop so that event bubble phase is finishes.
                  setTimeout(callback, 0);
              }
              else {
                  callback();
              }
          }
          const selectableRef = useMemo(() => !nodeIsDisabledRef.value &&
              NTree.selectableRef.value &&
              (NTree.internalTreeSelect
                  ? NTree.mergedCheckStrategyRef.value !== 'child' ||
                      (NTree.multipleRef.value && NTree.cascadeRef.value) ||
                      props.tmNode.isLeaf
                  : true));
          const checkableRef = useMemo(() => NTree.checkableRef.value &&
              (NTree.cascadeRef.value ||
                  NTree.mergedCheckStrategyRef.value !== 'child' ||
                  props.tmNode.isLeaf));
          const checkedRef = useMemo(() => NTree.displayedCheckedKeysRef.value.includes(props.tmNode.key));
          const mergedCheckOnClickRef = useMemo(() => {
              const { value: checkable } = checkableRef;
              if (!checkable)
                  return false;
              const { value: checkOnClick } = checkOnClickRef;
              const { tmNode } = props;
              if (typeof checkOnClick === 'boolean') {
                  return !tmNode.disabled && checkOnClick;
              }
              return checkOnClick(props.tmNode.rawNode);
          });
          function _handleClick(e) {
              const { value: expandOnClick } = NTree.expandOnClickRef;
              const { value: selectable } = selectableRef;
              const { value: mergedCheckOnClick } = mergedCheckOnClickRef;
              if (!selectable && !expandOnClick && !mergedCheckOnClick)
                  return;
              if (happensIn(e, 'checkbox') || happensIn(e, 'switcher'))
                  return;
              const { tmNode } = props;
              if (selectable) {
                  NTree.handleSelect(tmNode);
              }
              if (expandOnClick && !tmNode.isLeaf) {
                  handleSwitcherClick();
              }
              if (mergedCheckOnClick) {
                  handleCheck(!checkedRef.value);
              }
          }
          function handleContentClick(e) {
              var _a, _b;
              if (blockLineRef.value)
                  return;
              if (!disabledRef.value)
                  _handleClick(e);
              (_b = (_a = resolvedNodePropsRef.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          }
          function handleLineClick(e) {
              var _a, _b;
              if (!blockLineRef.value)
                  return;
              if (!disabledRef.value) {
                  _handleClick(e);
              }
              (_b = (_a = resolvedNodePropsRef.value) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
          }
          function handleCheck(checked) {
              NTree.handleCheck(props.tmNode, checked);
          }
          // Dnd
          function handleDragStart(e) {
              NTree.handleDragStart({
                  event: e,
                  node: props.tmNode
              });
          }
          function handleDragEnter(e) {
              if (e.currentTarget !== e.target) {
                  return;
              }
              NTree.handleDragEnter({
                  event: e,
                  node: props.tmNode
              });
          }
          function handleDragOver(e) {
              e.preventDefault(); // if not prevent, drop event won't be fired...
              NTree.handleDragOver({
                  event: e,
                  node: props.tmNode
              });
          }
          function handleDragEnd(e) {
              NTree.handleDragEnd({
                  event: e,
                  node: props.tmNode
              });
          }
          function handleDragLeave(e) {
              if (e.currentTarget !== e.target) {
                  return;
              }
              NTree.handleDragLeave({
                  event: e,
                  node: props.tmNode
              });
          }
          function handleDrop(e) {
              e.preventDefault();
              if (droppingPositionRef.value !== null) {
                  NTree.handleDrop({
                      event: e,
                      node: props.tmNode,
                      dropPosition: droppingPositionRef.value
                  });
              }
          }
          const indentNodes = computed(() => {
              const { clsPrefix } = props;
              const { value: indent } = indentRef;
              if (showLineRef.value) {
                  const indentNodes = [];
                  let cursor = props.tmNode.parent;
                  while (cursor) {
                      if (cursor.isLastChild) {
                          indentNodes.push(h("div", { class: `${clsPrefix}-tree-node-indent` },
                              h("div", { style: { width: `${indent}px` } })));
                      }
                      else {
                          indentNodes.push(h("div", { class: [
                                  `${clsPrefix}-tree-node-indent`,
                                  `${clsPrefix}-tree-node-indent--show-line`
                              ] },
                              h("div", { style: { width: `${indent}px` } })));
                      }
                      cursor = cursor.parent;
                  }
                  return indentNodes.reverse();
              }
              else {
                  return repeat(props.tmNode.level, h("div", { class: `${props.clsPrefix}-tree-node-indent` },
                      h("div", { style: { width: `${indent}px` } })));
              }
          });
          return {
              showDropMark: useMemo(() => {
                  const { value: draggingNode } = draggingNodeRef;
                  if (!draggingNode)
                      return;
                  const { value: droppingPosition } = droppingPositionRef;
                  if (!droppingPosition)
                      return;
                  const { value: droppingMouseNode } = droppingMouseNodeRef;
                  if (!droppingMouseNode) {
                      return;
                  }
                  const { tmNode } = props;
                  if (tmNode.key === droppingMouseNode.key)
                      return true;
                  return false;
              }),
              showDropMarkAsParent: useMemo(() => {
                  const { value: droppingNodeParent } = droppingNodeParentRef;
                  if (!droppingNodeParent)
                      return false;
                  const { tmNode } = props;
                  const { value: droppingPosition } = droppingPositionRef;
                  if (droppingPosition === 'before' || droppingPosition === 'after') {
                      return droppingNodeParent.key === tmNode.key;
                  }
                  return false;
              }),
              pending: useMemo(() => NTree.pendingNodeKeyRef.value === props.tmNode.key),
              loading: useMemo(() => NTree.loadingKeysRef.value.has(props.tmNode.key)),
              highlight: useMemo(() => {
                  var _a;
                  return (_a = NTree.highlightKeySetRef.value) === null || _a === void 0 ? void 0 : _a.has(props.tmNode.key);
              }),
              checked: checkedRef,
              indeterminate: useMemo(() => NTree.displayedIndeterminateKeysRef.value.includes(props.tmNode.key)),
              selected: useMemo(() => NTree.mergedSelectedKeysRef.value.includes(props.tmNode.key)),
              expanded: useMemo(() => NTree.mergedExpandedKeysRef.value.includes(props.tmNode.key)),
              disabled: disabledRef,
              checkable: checkableRef,
              mergedCheckOnClick: mergedCheckOnClickRef,
              checkboxDisabled: checkboxDisabledRef,
              selectable: selectableRef,
              expandOnClick: NTree.expandOnClickRef,
              internalScrollable: NTree.internalScrollableRef,
              draggable: NTree.draggableRef,
              blockLine: blockLineRef,
              nodeProps: resolvedNodePropsRef,
              checkboxFocusable: NTree.internalCheckboxFocusableRef,
              droppingPosition: droppingPositionRef,
              droppingOffsetLevel: droppingOffsetLevelRef,
              indent: indentRef,
              checkboxPlacement: checkboxPlacementRef,
              showLine: showLineRef,
              contentInstRef,
              contentElRef,
              indentNodes,
              handleCheck,
              handleDrop,
              handleDragStart,
              handleDragEnter,
              handleDragOver,
              handleDragEnd,
              handleDragLeave,
              handleLineClick,
              handleContentClick,
              handleSwitcherClick
          };
      },
      render() {
          const { tmNode, clsPrefix, checkable, expandOnClick, selectable, selected, checked, highlight, draggable, blockLine, indent, indentNodes, disabled, pending, internalScrollable, nodeProps, checkboxPlacement } = this;
          // drag start not inside
          // it need to be append to node itself, not wrapper
          const dragEventHandlers = draggable && !disabled
              ? {
                  onDragenter: this.handleDragEnter,
                  onDragleave: this.handleDragLeave,
                  onDragend: this.handleDragEnd,
                  onDrop: this.handleDrop,
                  onDragover: this.handleDragOver
              }
              : undefined;
          // In non virtual mode, there's no evidence that which element should be
          // scrolled to, so we need data-key to query the target element.
          const dataKey = internalScrollable ? createDataKey(tmNode.key) : undefined;
          const checkboxOnRight = checkboxPlacement === 'right';
          const checkboxNode = checkable ? (h(NTreeNodeCheckbox, { indent: indent, right: checkboxOnRight, focusable: this.checkboxFocusable, disabled: disabled || this.checkboxDisabled, clsPrefix: clsPrefix, checked: this.checked, indeterminate: this.indeterminate, onCheck: this.handleCheck })) : null;
          return (h("div", Object.assign({ class: `${clsPrefix}-tree-node-wrapper` }, dragEventHandlers),
              h("div", Object.assign({}, (blockLine ? nodeProps : undefined), { class: [
                      `${clsPrefix}-tree-node`,
                      {
                          [`${clsPrefix}-tree-node--selected`]: selected,
                          [`${clsPrefix}-tree-node--checkable`]: checkable,
                          [`${clsPrefix}-tree-node--highlight`]: highlight,
                          [`${clsPrefix}-tree-node--pending`]: pending,
                          [`${clsPrefix}-tree-node--disabled`]: disabled,
                          [`${clsPrefix}-tree-node--selectable`]: selectable,
                          [`${clsPrefix}-tree-node--clickable`]: selectable || expandOnClick || this.mergedCheckOnClick
                      },
                      nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps.class
                  ], "data-key": dataKey, draggable: draggable && blockLine, onClick: this.handleLineClick, onDragstart: draggable && blockLine && !disabled
                      ? this.handleDragStart
                      : undefined }),
                  indentNodes,
                  tmNode.isLeaf && this.showLine ? (h("div", { class: [
                          `${clsPrefix}-tree-node-indent`,
                          `${clsPrefix}-tree-node-indent--show-line`,
                          tmNode.isLeaf && `${clsPrefix}-tree-node-indent--is-leaf`,
                          tmNode.isLastChild &&
                              `${clsPrefix}-tree-node-indent--last-child`
                      ] },
                      h("div", { style: { width: `${indent}px` } }))) : (h(NTreeNodeSwitcher, { clsPrefix: clsPrefix, expanded: this.expanded, selected: selected, loading: this.loading, hide: tmNode.isLeaf, tmNode: this.tmNode, indent: indent, onClick: this.handleSwitcherClick })),
                  !checkboxOnRight ? checkboxNode : null,
                  h(NTreeNodeContent, { ref: "contentInstRef", clsPrefix: clsPrefix, checked: checked, selected: selected, onClick: this.handleContentClick, nodeProps: blockLine ? undefined : nodeProps, onDragstart: draggable && !blockLine && !disabled
                          ? this.handleDragStart
                          : undefined, tmNode: tmNode }),
                  draggable
                      ? this.showDropMark
                          ? renderDropMark({
                              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                              el: this.contentElRef.value,
                              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                              position: this.droppingPosition,
                              offsetLevel: this.droppingOffsetLevel,
                              indent
                          })
                          : this.showDropMarkAsParent
                              ? renderDropMark({
                                  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                                  el: this.contentElRef.value,
                                  position: 'inside',
                                  offsetLevel: this.droppingOffsetLevel,
                                  indent
                              })
                              : null
                      : null,
                  checkboxOnRight ? checkboxNode : null)));
      }
  });
  var NTreeNode = TreeNode;

  function useKeyboard({ props, fNodesRef, mergedExpandedKeysRef, mergedSelectedKeysRef, handleSelect, handleSwitcherClick }) {
      const { value: mergedSelectedKeys } = mergedSelectedKeysRef;
      // If it's used in tree-select, make it take over pending state
      const treeSelectInjection = inject(treeSelectInjectionKey, null);
      const pendingNodeKeyRef = treeSelectInjection
          ? treeSelectInjection.pendingNodeKeyRef
          : ref(mergedSelectedKeys.length
              ? mergedSelectedKeys[mergedSelectedKeys.length - 1]
              : null);
      function handleKeydown(e) {
          if (!props.keyboard)
              return;
          const { value: pendingNodeKey } = pendingNodeKeyRef;
          if (pendingNodeKey === null) {
              if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {
                  e.preventDefault();
              }
              if (['ArrowDown', 'ArrowUp', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                  if (pendingNodeKey === null) {
                      const { value: fNodes } = fNodesRef;
                      let fIndex = 0;
                      while (fIndex < fNodes.length) {
                          if (!fNodes[fIndex].disabled) {
                              pendingNodeKeyRef.value = fNodes[fIndex].key;
                              break;
                          }
                          fIndex += 1;
                      }
                  }
              }
          }
          else {
              const { value: fNodes } = fNodesRef;
              let fIndex = fNodes.findIndex((tmNode) => tmNode.key === pendingNodeKey);
              if (!~fIndex)
                  return;
              if (e.key === 'Enter') {
                  handleSelect(fNodes[fIndex]);
              }
              else if (e.key === 'ArrowDown') {
                  e.preventDefault();
                  fIndex += 1;
                  while (fIndex < fNodes.length) {
                      if (!fNodes[fIndex].disabled) {
                          pendingNodeKeyRef.value = fNodes[fIndex].key;
                          break;
                      }
                      fIndex += 1;
                  }
              }
              else if (e.key === 'ArrowUp') {
                  e.preventDefault();
                  fIndex -= 1;
                  while (fIndex >= 0) {
                      if (!fNodes[fIndex].disabled) {
                          pendingNodeKeyRef.value = fNodes[fIndex].key;
                          break;
                      }
                      fIndex -= 1;
                  }
              }
              else if (e.key === 'ArrowLeft') {
                  const pendingNode = fNodes[fIndex];
                  if (pendingNode.isLeaf ||
                      !mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
                      const parentTmNode = pendingNode.getParent();
                      if (parentTmNode) {
                          pendingNodeKeyRef.value = parentTmNode.key;
                      }
                  }
                  else {
                      handleSwitcherClick(pendingNode);
                  }
              }
              else if (e.key === 'ArrowRight') {
                  const pendingNode = fNodes[fIndex];
                  if (pendingNode.isLeaf)
                      return;
                  if (!mergedExpandedKeysRef.value.includes(pendingNodeKey)) {
                      handleSwitcherClick(pendingNode);
                  }
                  else {
                      // Tha same as ArrowDown
                      fIndex += 1;
                      while (fIndex < fNodes.length) {
                          if (!fNodes[fIndex].disabled) {
                              pendingNodeKeyRef.value = fNodes[fIndex].key;
                              break;
                          }
                          fIndex += 1;
                      }
                  }
              }
          }
      }
      return {
          pendingNodeKeyRef,
          handleKeydown
      };
  }

  var MotionWrapper = defineComponent({
      name: 'TreeMotionWrapper',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          height: Number,
          nodes: {
              type: Array,
              required: true
          },
          mode: {
              type: String,
              required: true
          },
          onAfterEnter: {
              type: Function,
              required: true
          }
      },
      render() {
          const { clsPrefix } = this;
          return (h(NFadeInExpandTransition, { onAfterEnter: this.onAfterEnter, appear: true, reverse: this.mode === 'collapse' }, {
              default: () => (h("div", { class: [
                      `${clsPrefix}-tree-motion-wrapper`,
                      `${clsPrefix}-tree-motion-wrapper--${this.mode}`
                  ], style: {
                      height: pxfy(this.height)
                  } }, this.nodes.map((node) => (h(NTreeNode, { clsPrefix: clsPrefix, tmNode: node })))))
          }));
      }
  });

  const iconSwitchTransitionNode = iconSwitchTransition();
  // vars:
  // --n-arrow-color
  // --n-bezier
  // --n-font-size
  // --n-node-border-radius
  // --n-node-color-active
  // --n-node-color-hover
  // --n-node-color-pressed
  // --n-node-text-color
  // --n-node-text-color-disabled
  // --n-node-wrapper-padding
  // --n-line-offset-top
  // --n-line-offset-bottom
  // --n-node-content-height
  // --n-line-height
  // --n-line-color
  var style$a = cB('tree', `
 font-size: var(--n-font-size);
 outline: none;
`, [c$1('ul, li', `
 margin: 0;
 padding: 0;
 list-style: none;
 `), c$1('>', [cB('tree-node', [c$1('&:first-child', 'margin-top: 0;')])]), cB('tree-motion-wrapper', [cM('expand', [fadeInHeightExpandTransition({
    duration: '0.2s'
  })]), cM('collapse', [fadeInHeightExpandTransition({
    duration: '0.2s',
    reverse: true
  })])]), cB('tree-node-wrapper', `
 box-sizing: border-box;
 padding: var(--n-node-wrapper-padding);
 `), cB('tree-node', `
 transform: translate3d(0,0,0);
 position: relative;
 display: flex;
 border-radius: var(--n-node-border-radius);
 transition: background-color .3s var(--n-bezier);
 `, [cM('highlight', [cB('tree-node-content', [cE('text', 'border-bottom-color: var(--n-node-text-color-disabled);')])]), cM('disabled', [cB('tree-node-content', `
 color: var(--n-node-text-color-disabled);
 cursor: not-allowed;
 `)]), cNotM('disabled', [cM('clickable', [cB('tree-node-content', `
 cursor: pointer;
 `)])])]), cM('block-node', [cB('tree-node-content', `
 flex: 1;
 min-width: 0;
 `)]), cNotM('block-line', [cB('tree-node', [cNotM('disabled', [cB('tree-node-content', [c$1('&:hover', 'background: var(--n-node-color-hover);')]), cM('selectable', [cB('tree-node-content', [c$1('&:active', 'background: var(--n-node-color-pressed);')])]), cM('pending', [cB('tree-node-content', `
 background: var(--n-node-color-hover);
 `)])]), cM('selected', [cB('tree-node-content', 'background: var(--n-node-color-active);')])])]), cM('block-line', [cB('tree-node', [cNotM('disabled', [c$1('&:hover', 'background: var(--n-node-color-hover);'), cM('pending', `
 background: var(--n-node-color-hover);
 `), cM('selectable', [cNotM('selected', [c$1('&:active', 'background: var(--n-node-color-pressed);')])]), cM('selected', 'background: var(--n-node-color-active);')]), cM('selected', 'background: var(--n-node-color-active);'), cM('disabled', `
 cursor: not-allowed;
 `)])]), cB('tree-node-indent', `
 flex-grow: 0;
 flex-shrink: 0;
 `, [cM('show-line', 'position: relative', [c$1('&::before', `
 position: absolute;
 left: 50%;
 border-left: 1px solid var(--n-line-color);
 transition: border-color .3s var(--n-bezier);
 transform: translate(-50%);
 content: "";
 top: var(--n-line-offset-top);
 bottom: var(--n-line-offset-bottom);
 `), cM('last-child', [c$1('&::before', `
 bottom: 50%;
 `)]), cM('is-leaf', [c$1('&::after', `
 position: absolute;
 content: "";
 left: calc(50% + 0.5px);
 right: 0;
 bottom: 50%;
 transition: border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-border-color);
 `)])]), cNotM('show-line', 'height: 0;')]), cB('tree-node-switcher', `
 cursor: pointer;
 display: inline-flex;
 flex-shrink: 0;
 height: var(--n-node-content-height);
 align-items: center;
 justify-content: center;
 transition: transform .15s var(--n-bezier);
 vertical-align: bottom;
 `, [cE('icon', `
 position: relative;
 height: 14px;
 width: 14px;
 display: flex;
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 font-size: 14px;
 `, [cB('icon', [iconSwitchTransitionNode]), cB('base-loading', `
 color: var(--n-loading-color);
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransitionNode]), cB('base-icon', [iconSwitchTransitionNode])]), cM('hide', 'visibility: hidden;'), cM('expanded', 'transform: rotate(90deg);')]), cB('tree-node-checkbox', `
 display: inline-flex;
 height: var(--n-node-content-height);
 vertical-align: bottom;
 align-items: center;
 justify-content: center;
 `), cB('tree-node-content', `
 user-select: none;
 position: relative;
 display: inline-flex;
 align-items: center;
 min-height: var(--n-node-content-height);
 box-sizing: border-box;
 line-height: var(--n-line-height);
 vertical-align: bottom;
 padding: 0 6px 0 4px;
 cursor: default;
 border-radius: var(--n-node-border-radius);
 color: var(--n-node-text-color);
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [c$1('&:last-child', 'margin-bottom: 0;'), cE('prefix', `
 display: inline-flex;
 margin-right: 8px;
 `), cE('text', `
 border-bottom: 1px solid #0000;
 transition: border-color .3s var(--n-bezier);
 flex-grow: 1;
 max-width: 100%;
 `), cE('suffix', `
 display: inline-flex;
 `)]), cE('empty', 'margin: auto;')]);

  var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  function createTreeMateOptions(keyField, childrenField, disabledField, getChildren) {
      const settledGetChildren = getChildren ||
          ((node) => {
              return node[childrenField];
          });
      return {
          getIsGroup() {
              return false;
          },
          getKey(node) {
              return node[keyField];
          },
          getChildren: settledGetChildren,
          getDisabled(node) {
              return !!(node[disabledField] || node.checkboxDisabled);
          }
      };
  }
  const treeSharedProps = {
      allowCheckingNotLoaded: Boolean,
      filter: Function,
      defaultExpandAll: Boolean,
      expandedKeys: Array,
      keyField: {
          type: String,
          default: 'key'
      },
      labelField: {
          type: String,
          default: 'label'
      },
      childrenField: {
          type: String,
          default: 'children'
      },
      disabledField: {
          type: String,
          default: 'disabled'
      },
      defaultExpandedKeys: {
          type: Array,
          default: () => []
      },
      indeterminateKeys: Array,
      renderSwitcherIcon: Function,
      onUpdateIndeterminateKeys: [Function, Array],
      'onUpdate:indeterminateKeys': [Function, Array],
      onUpdateExpandedKeys: [Function, Array],
      'onUpdate:expandedKeys': [Function, Array]
  };
  const treeProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { accordion: Boolean, showIrrelevantNodes: { type: Boolean, default: true }, data: {
          type: Array,
          default: () => []
      }, expandOnDragenter: {
          type: Boolean,
          default: true
      }, expandOnClick: Boolean, checkOnClick: {
          type: [Boolean, Function],
          default: false
      }, cancelable: {
          type: Boolean,
          default: true
      }, checkable: Boolean, draggable: Boolean, blockNode: Boolean, blockLine: Boolean, showLine: Boolean, disabled: Boolean, checkedKeys: Array, defaultCheckedKeys: {
          type: Array,
          default: () => []
      }, selectedKeys: Array, defaultSelectedKeys: {
          type: Array,
          default: () => []
      }, multiple: Boolean, pattern: {
          type: String,
          default: ''
      }, onLoad: Function, cascade: Boolean, selectable: {
          type: Boolean,
          default: true
      }, scrollbarProps: Object, indent: {
          type: Number,
          default: 24
      }, allowDrop: {
          type: Function,
          default: defaultAllowDrop
      }, animated: {
          type: Boolean,
          default: true
      }, checkboxPlacement: {
          type: String,
          default: 'left'
      }, virtualScroll: Boolean, watchProps: Array, renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, keyboard: {
          type: Boolean,
          default: true
      }, getChildren: Function, onDragenter: [Function, Array], onDragleave: [Function, Array], onDragend: [Function, Array], onDragstart: [Function, Array], onDragover: [Function, Array], onDrop: [Function, Array], onUpdateCheckedKeys: [Function, Array], 'onUpdate:checkedKeys': [Function, Array], onUpdateSelectedKeys: [Function, Array], 'onUpdate:selectedKeys': [Function, Array] }), treeSharedProps), { 
      // internal props for tree-select
      internalTreeSelect: Boolean, internalScrollable: Boolean, internalScrollablePadding: String, 
      // use it to display
      internalRenderEmpty: Function, internalHighlightKeySet: Object, internalUnifySelectCheck: Boolean, internalCheckboxFocusable: {
          type: Boolean,
          default: true
      }, internalFocusable: {
          // Make tree-select take over keyboard operations
          type: Boolean,
          default: true
      }, checkStrategy: {
          type: String,
          default: 'all'
      }, 
      /**
       * @deprecated
       */
      leafOnly: Boolean });
  var NTree = defineComponent({
      name: 'Tree',
      props: treeProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled, mergedRtlRef } = useConfig(props);
          const rtlEnabledRef = useRtl('Tree', mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme('Tree', '-tree', style$a, treeLight$1, props, mergedClsPrefixRef);
          const selfElRef = ref(null);
          const scrollbarInstRef = ref(null);
          const virtualListInstRef = ref(null);
          function getScrollContainer() {
              var _a;
              return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
          }
          function getScrollContent() {
              var _a;
              return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
          }
          const mergedFilterRef = computed(() => {
              const { filter } = props;
              if (filter)
                  return filter;
              const { labelField } = props;
              return (pattern, node) => {
                  if (!pattern.length)
                      return true;
                  const label = node[labelField];
                  if (typeof label === 'string') {
                      return label.toLowerCase().includes(pattern.toLowerCase());
                  }
                  return false;
              };
          });
          const filteredTreeInfoRef = computed(() => {
              const { pattern } = props;
              if (!pattern) {
                  return {
                      filteredTree: props.data,
                      highlightKeySet: null,
                      expandedKeys: undefined
                  };
              }
              if (!pattern.length || !mergedFilterRef.value) {
                  return {
                      filteredTree: props.data,
                      highlightKeySet: null,
                      expandedKeys: undefined
                  };
              }
              return filterTree(props.data, mergedFilterRef.value, pattern, props.keyField, props.childrenField);
          });
          // We don't expect data source to change so we just determine it once
          const displayTreeMateRef = computed(() => createTreeMate(props.showIrrelevantNodes
              ? props.data
              : filteredTreeInfoRef.value.filteredTree, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, props.getChildren)));
          const treeSelectInjection = inject(treeSelectInjectionKey, null);
          const dataTreeMateRef = props.internalTreeSelect
              ? treeSelectInjection.dataTreeMate
              : displayTreeMateRef;
          const { watchProps } = props;
          const uncontrolledCheckedKeysRef = ref([]);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultCheckedKeys')) {
              watchEffect(() => {
                  uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
              });
          }
          else {
              uncontrolledCheckedKeysRef.value = props.defaultCheckedKeys;
          }
          const controlledCheckedKeysRef = toRef(props, 'checkedKeys');
          const mergedCheckedKeysRef = useMergedState(controlledCheckedKeysRef, uncontrolledCheckedKeysRef);
          const checkedStatusRef = computed(() => {
              const value = dataTreeMateRef.value.getCheckedKeys(mergedCheckedKeysRef.value, {
                  cascade: props.cascade,
                  allowNotLoaded: props.allowCheckingNotLoaded
              });
              return value;
          });
          const mergedCheckStrategyRef = useMergedCheckStrategy(props);
          const displayedCheckedKeysRef = computed(() => {
              return checkedStatusRef.value.checkedKeys;
          });
          const displayedIndeterminateKeysRef = computed(() => {
              const { indeterminateKeys } = props;
              if (indeterminateKeys !== undefined)
                  return indeterminateKeys;
              return checkedStatusRef.value.indeterminateKeys;
          });
          const uncontrolledSelectedKeysRef = ref([]);
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultSelectedKeys')) {
              watchEffect(() => {
                  uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
              });
          }
          else {
              uncontrolledSelectedKeysRef.value = props.defaultSelectedKeys;
          }
          const controlledSelectedKeysRef = toRef(props, 'selectedKeys');
          const mergedSelectedKeysRef = useMergedState(controlledSelectedKeysRef, uncontrolledSelectedKeysRef);
          const uncontrolledExpandedKeysRef = ref([]);
          const initUncontrolledExpandedKeys = (keys) => {
              uncontrolledExpandedKeysRef.value = props.defaultExpandAll
                  ? dataTreeMateRef.value.getNonLeafKeys()
                  : keys === undefined
                      ? props.defaultExpandedKeys
                      : keys;
          };
          if (watchProps === null || watchProps === void 0 ? void 0 : watchProps.includes('defaultExpandedKeys')) {
              // if watching defaultExpandedKeys, we use access props.defaultExpandedKeys inside initiator
              watchEffect(() => {
                  initUncontrolledExpandedKeys(undefined);
              });
          }
          else {
              // We by default watchEffect since if defaultExpandAll is true, we should remain tree expand if data changes
              watchEffect(() => {
                  initUncontrolledExpandedKeys(props.defaultExpandedKeys);
              });
          }
          const controlledExpandedKeysRef = toRef(props, 'expandedKeys');
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const fNodesRef = computed(() => displayTreeMateRef.value.getFlattenedNodes(mergedExpandedKeysRef.value));
          const { pendingNodeKeyRef, handleKeydown } = useKeyboard({
              props,
              mergedSelectedKeysRef,
              fNodesRef,
              mergedExpandedKeysRef,
              handleSelect,
              handleSwitcherClick
          });
          let expandTimerId = null;
          let nodeKeyToBeExpanded = null;
          const uncontrolledHighlightKeySetRef = ref(new Set());
          const controlledHighlightKeySetRef = computed(() => {
              return (props.internalHighlightKeySet ||
                  filteredTreeInfoRef.value.highlightKeySet);
          });
          const mergedHighlightKeySetRef = useMergedState(controlledHighlightKeySetRef, uncontrolledHighlightKeySetRef);
          const loadingKeysRef = ref(new Set());
          const expandedNonLoadingKeysRef = computed(() => {
              return mergedExpandedKeysRef.value.filter((key) => !loadingKeysRef.value.has(key));
          });
          let dragStartX = 0;
          const draggingNodeRef = ref(null);
          const droppingNodeRef = ref(null);
          const droppingMouseNodeRef = ref(null);
          const droppingPositionRef = ref(null);
          const droppingOffsetLevelRef = ref(0);
          const droppingNodeParentRef = computed(() => {
              const { value: droppingNode } = droppingNodeRef;
              if (!droppingNode)
                  return null;
              // May avoid overlap between line mark of first child & rect mark of parent
              // if (droppingNode.isFirstChild && droppingPositionRef.value === 'before') {
              //   return null
              // }
              return droppingNode.parent;
          });
          // shallow watch data
          watch(toRef(props, 'data'), () => {
              loadingKeysRef.value.clear();
              pendingNodeKeyRef.value = null;
              resetDndState();
          }, {
              deep: false
          });
          let expandAnimationDisabled = false;
          const disableExpandAnimationForOneTick = () => {
              expandAnimationDisabled = true;
              void nextTick(() => {
                  expandAnimationDisabled = false;
              });
          };
          let memoizedExpandedKeys;
          watch(toRef(props, 'pattern'), (value, oldValue) => {
              if (props.showIrrelevantNodes) {
                  memoizedExpandedKeys = undefined;
                  if (value) {
                      const { expandedKeys: expandedKeysAfterChange, highlightKeySet } = keysWithFilter(props.data, props.pattern, props.keyField, props.childrenField, mergedFilterRef.value);
                      uncontrolledHighlightKeySetRef.value = highlightKeySet;
                      disableExpandAnimationForOneTick();
                      doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), { node: null, action: 'filter' });
                  }
                  else {
                      uncontrolledHighlightKeySetRef.value = new Set();
                  }
              }
              else {
                  if (!value.length) {
                      if (memoizedExpandedKeys !== undefined) {
                          disableExpandAnimationForOneTick();
                          doUpdateExpandedKeys(memoizedExpandedKeys, getOptionsByKeys(memoizedExpandedKeys), { node: null, action: 'filter' });
                      }
                  }
                  else {
                      if (!oldValue.length) {
                          memoizedExpandedKeys = mergedExpandedKeysRef.value;
                      }
                      const { expandedKeys } = filteredTreeInfoRef.value;
                      if (expandedKeys !== undefined) {
                          disableExpandAnimationForOneTick();
                          doUpdateExpandedKeys(expandedKeys, getOptionsByKeys(expandedKeys), {
                              node: null,
                              action: 'filter'
                          });
                      }
                  }
              }
          });
          function triggerLoading(node) {
              return __awaiter$2(this, void 0, void 0, function* () {
                  const { onLoad } = props;
                  if (!onLoad) {
                      yield Promise.resolve();
                      return;
                  }
                  const { value: loadingKeys } = loadingKeysRef;
                  if (!loadingKeys.has(node.key)) {
                      loadingKeys.add(node.key);
                      try {
                          const loadResult = yield onLoad(node.rawNode);
                          if (loadResult === false) {
                              resetDragExpandState();
                          }
                      }
                      catch (loadError) {
                          console.error(loadError);
                          resetDragExpandState();
                      }
                      loadingKeys.delete(node.key);
                  }
              });
          }
          watchEffect(() => {
              var _a;
              const { value: displayTreeMate } = displayTreeMateRef;
              if (!displayTreeMate)
                  return;
              const { getNode } = displayTreeMate;
              (_a = mergedExpandedKeysRef.value) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
                  const node = getNode(key);
                  if (node && !node.shallowLoaded) {
                      void triggerLoading(node);
                  }
              });
          });
          // animation in progress
          const aipRef = ref(false);
          // animation flattened nodes
          const afNodesRef = ref([]);
          // Note: Since the virtual list depends on min height, if there's a node
          // whose height starts from 0, the virtual list will have a wrong height
          // during animation. This will seldom cause wired scrollbar status. It is
          // fixable and need some changes in vueuc, I've no time so I just leave it
          // here. Maybe the bug won't be fixed during the life time of the project.
          watch(expandedNonLoadingKeysRef, (value, prevValue) => {
              if (!props.animated || expandAnimationDisabled) {
                  void nextTick(syncScrollbar);
                  return;
              }
              const nodeHeight = depx(themeRef.value.self.nodeHeight);
              const prevVSet = new Set(prevValue);
              let addedKey = null;
              let removedKey = null;
              for (const expandedKey of value) {
                  if (!prevVSet.has(expandedKey)) {
                      if (addedKey !== null)
                          return; // multi expand, not triggered by click
                      addedKey = expandedKey;
                  }
              }
              const currentVSet = new Set(value);
              for (const expandedKey of prevValue) {
                  if (!currentVSet.has(expandedKey)) {
                      if (removedKey !== null)
                          return; // multi collapse, not triggered by click
                      removedKey = expandedKey;
                  }
              }
              if (addedKey === null && removedKey === null) {
                  // 1. multi action, not triggered by click
                  // 2. no action, don't know what happened
                  return;
              }
              const { virtualScroll } = props;
              const viewportHeight = (virtualScroll ? virtualListInstRef.value.listElRef : selfElRef.value).offsetHeight;
              const viewportItemCount = Math.ceil(viewportHeight / nodeHeight) + 1;
              // play add animation
              let baseExpandedKeys;
              if (addedKey !== null) {
                  baseExpandedKeys = prevValue;
              }
              if (removedKey !== null) {
                  if (baseExpandedKeys === undefined) {
                      baseExpandedKeys = value;
                  }
                  else {
                      baseExpandedKeys = baseExpandedKeys.filter((key) => key !== removedKey);
                  }
              }
              aipRef.value = true;
              afNodesRef.value =
                  displayTreeMateRef.value.getFlattenedNodes(baseExpandedKeys);
              if (addedKey !== null) {
                  const expandedNodeIndex = afNodesRef.value.findIndex((node) => node.key === addedKey);
                  if (~expandedNodeIndex) {
                      const children = // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                       afNodesRef.value[expandedNodeIndex].children;
                      // sometimes user will pass leaf keys in
                      if (children) {
                          const expandedChildren = flatten$1(children, value);
                          afNodesRef.value.splice(expandedNodeIndex + 1, 0, {
                              __motion: true,
                              mode: 'expand',
                              height: virtualScroll
                                  ? expandedChildren.length * nodeHeight
                                  : undefined,
                              nodes: virtualScroll
                                  ? expandedChildren.slice(0, viewportItemCount)
                                  : expandedChildren
                          });
                      }
                  }
              }
              if (removedKey !== null) {
                  const collapsedNodeIndex = afNodesRef.value.findIndex((node) => node.key === removedKey);
                  if (~collapsedNodeIndex) {
                      const collapsedNodeChildren = afNodesRef.value[collapsedNodeIndex].children;
                      // Sometime the whole tree is change, remove a key doesn't mean it is collapsed,
                      // but maybe children removed
                      if (!collapsedNodeChildren)
                          return;
                      // play remove animation
                      aipRef.value = true;
                      const collapsedChildren = flatten$1(collapsedNodeChildren, value);
                      afNodesRef.value.splice(collapsedNodeIndex + 1, 0, {
                          __motion: true,
                          mode: 'collapse',
                          height: virtualScroll
                              ? collapsedChildren.length * nodeHeight
                              : undefined,
                          nodes: virtualScroll
                              ? collapsedChildren.slice(0, viewportItemCount)
                              : collapsedChildren
                      });
                  }
              }
          });
          const getFIndexRef = computed(() => {
              return createIndexGetter(fNodesRef.value);
          });
          const mergedFNodesRef = computed(() => {
              if (aipRef.value)
                  return afNodesRef.value;
              else
                  return fNodesRef.value;
          });
          function syncScrollbar() {
              const { value: scrollbarInst } = scrollbarInstRef;
              if (scrollbarInst)
                  scrollbarInst.sync();
          }
          function handleAfterEnter() {
              aipRef.value = false;
              if (props.virtualScroll) {
                  // If virtual scroll, we won't listen to resize during animation, so
                  // resize callback of virtual list won't be called and as a result
                  // scrollbar won't sync. We need to sync scrollbar manually.
                  void nextTick(syncScrollbar);
              }
          }
          function getOptionsByKeys(keys) {
              const { getNode } = dataTreeMateRef.value;
              return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });
          }
          function doUpdateExpandedKeys(value, option, meta) {
              const { 'onUpdate:expandedKeys': _onUpdateExpandedKeys, onUpdateExpandedKeys } = props;
              uncontrolledExpandedKeysRef.value = value;
              if (_onUpdateExpandedKeys) {
                  call(_onUpdateExpandedKeys, value, option, meta);
              }
              if (onUpdateExpandedKeys) {
                  call(onUpdateExpandedKeys, value, option, meta);
              }
          }
          function doUpdateCheckedKeys(value, option, meta) {
              const { 'onUpdate:checkedKeys': _onUpdateCheckedKeys, onUpdateCheckedKeys } = props;
              uncontrolledCheckedKeysRef.value = value;
              if (onUpdateCheckedKeys) {
                  call(onUpdateCheckedKeys, value, option, meta);
              }
              if (_onUpdateCheckedKeys) {
                  call(_onUpdateCheckedKeys, value, option, meta);
              }
          }
          function doUpdateIndeterminateKeys(value, option) {
              const { 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys, onUpdateIndeterminateKeys } = props;
              if (_onUpdateIndeterminateKeys) {
                  call(_onUpdateIndeterminateKeys, value, option);
              }
              if (onUpdateIndeterminateKeys) {
                  call(onUpdateIndeterminateKeys, value, option);
              }
          }
          function doUpdateSelectedKeys(value, option, meta) {
              const { 'onUpdate:selectedKeys': _onUpdateSelectedKeys, onUpdateSelectedKeys } = props;
              uncontrolledSelectedKeysRef.value = value;
              if (onUpdateSelectedKeys) {
                  call(onUpdateSelectedKeys, value, option, meta);
              }
              if (_onUpdateSelectedKeys) {
                  call(_onUpdateSelectedKeys, value, option, meta);
              }
          }
          // Drag & Drop
          function doDragEnter(info) {
              const { onDragenter } = props;
              if (onDragenter)
                  call(onDragenter, info);
          }
          function doDragLeave(info) {
              const { onDragleave } = props;
              if (onDragleave)
                  call(onDragleave, info);
          }
          function doDragEnd(info) {
              const { onDragend } = props;
              if (onDragend)
                  call(onDragend, info);
          }
          function doDragStart(info) {
              const { onDragstart } = props;
              if (onDragstart)
                  call(onDragstart, info);
          }
          function doDragOver(info) {
              const { onDragover } = props;
              if (onDragover)
                  call(onDragover, info);
          }
          function doDrop(info) {
              const { onDrop } = props;
              if (onDrop)
                  call(onDrop, info);
          }
          function resetDndState() {
              resetDragState();
              resetDropState();
          }
          function resetDragState() {
              draggingNodeRef.value = null;
          }
          function resetDropState() {
              droppingOffsetLevelRef.value = 0;
              droppingNodeRef.value = null;
              droppingMouseNodeRef.value = null;
              droppingPositionRef.value = null;
              resetDragExpandState();
          }
          function resetDragExpandState() {
              if (expandTimerId) {
                  window.clearTimeout(expandTimerId);
                  expandTimerId = null;
              }
              nodeKeyToBeExpanded = null;
          }
          function handleCheck(node, checked) {
              // We don't guard for leaf only since we have done it in view layer
              if (props.disabled || isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              if (props.internalUnifySelectCheck && !props.multiple) {
                  handleSelect(node);
                  return;
              }
              const checkedAction = checked ? 'check' : 'uncheck';
              const { checkedKeys, indeterminateKeys } = dataTreeMateRef.value[checkedAction](node.key, displayedCheckedKeysRef.value, {
                  cascade: props.cascade,
                  checkStrategy: mergedCheckStrategyRef.value,
                  allowNotLoaded: props.allowCheckingNotLoaded
              });
              doUpdateCheckedKeys(checkedKeys, getOptionsByKeys(checkedKeys), {
                  node: node.rawNode,
                  action: checkedAction
              });
              doUpdateIndeterminateKeys(indeterminateKeys, getOptionsByKeys(indeterminateKeys));
          }
          function toggleExpand(node) {
              if (props.disabled)
                  return;
              const { key } = node;
              const { value: mergedExpandedKeys } = mergedExpandedKeysRef;
              const index = mergedExpandedKeys.findIndex((expandNodeId) => expandNodeId === key);
              if (~index) {
                  const expandedKeysAfterChange = Array.from(mergedExpandedKeys);
                  expandedKeysAfterChange.splice(index, 1);
                  doUpdateExpandedKeys(expandedKeysAfterChange, getOptionsByKeys(expandedKeysAfterChange), {
                      node: node.rawNode,
                      action: 'collapse'
                  });
              }
              else {
                  const nodeToBeExpanded = displayTreeMateRef.value.getNode(key);
                  if (!nodeToBeExpanded || nodeToBeExpanded.isLeaf) {
                      return;
                  }
                  let nextKeys;
                  if (props.accordion) {
                      const siblingKeySet = new Set(node.siblings.map(({ key }) => key));
                      nextKeys = mergedExpandedKeys.filter((expandedKey) => {
                          return !siblingKeySet.has(expandedKey);
                      });
                      nextKeys.push(key);
                  }
                  else {
                      nextKeys = mergedExpandedKeys.concat(key);
                  }
                  doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
                      node: node.rawNode,
                      action: 'expand'
                  });
              }
          }
          function handleSwitcherClick(node) {
              if (props.disabled || aipRef.value)
                  return;
              toggleExpand(node);
          }
          function handleSelect(node) {
              if (props.disabled || !props.selectable) {
                  return;
              }
              pendingNodeKeyRef.value = node.key;
              if (props.internalUnifySelectCheck) {
                  const { value: { checkedKeys, indeterminateKeys } } = checkedStatusRef;
                  if (props.multiple) {
                      handleCheck(node, !(checkedKeys.includes(node.key) ||
                          indeterminateKeys.includes(node.key)));
                  }
                  else {
                      doUpdateCheckedKeys([node.key], getOptionsByKeys([node.key]), {
                          node: node.rawNode,
                          action: 'check'
                      });
                  }
              }
              if (props.multiple) {
                  const selectedKeys = Array.from(mergedSelectedKeysRef.value);
                  const index = selectedKeys.findIndex((key) => key === node.key);
                  if (~index) {
                      if (props.cancelable) {
                          selectedKeys.splice(index, 1);
                      }
                  }
                  else if (!~index) {
                      selectedKeys.push(node.key);
                  }
                  doUpdateSelectedKeys(selectedKeys, getOptionsByKeys(selectedKeys), {
                      node: node.rawNode,
                      action: ~index ? 'unselect' : 'select'
                  });
              }
              else {
                  const selectedKeys = mergedSelectedKeysRef.value;
                  if (selectedKeys.includes(node.key)) {
                      if (props.cancelable) {
                          doUpdateSelectedKeys([], [], {
                              node: node.rawNode,
                              action: 'unselect'
                          });
                      }
                  }
                  else {
                      doUpdateSelectedKeys([node.key], getOptionsByKeys([node.key]), {
                          node: node.rawNode,
                          action: 'select'
                      });
                  }
              }
          }
          function expandDragEnterNode(node) {
              if (expandTimerId) {
                  window.clearTimeout(expandTimerId);
                  expandTimerId = null;
              }
              // Don't expand leaf node.
              if (node.isLeaf)
                  return;
              nodeKeyToBeExpanded = node.key;
              const expand = () => {
                  if (nodeKeyToBeExpanded !== node.key)
                      return;
                  const { value: droppingMouseNode } = droppingMouseNodeRef;
                  if (droppingMouseNode &&
                      droppingMouseNode.key === node.key &&
                      !mergedExpandedKeysRef.value.includes(node.key)) {
                      const nextKeys = mergedExpandedKeysRef.value.concat(node.key);
                      doUpdateExpandedKeys(nextKeys, getOptionsByKeys(nextKeys), {
                          node: node.rawNode,
                          action: 'expand'
                      });
                  }
                  expandTimerId = null;
                  nodeKeyToBeExpanded = null;
              };
              if (!node.shallowLoaded) {
                  expandTimerId = window.setTimeout(() => {
                      void triggerLoading(node).then(() => {
                          expand();
                      });
                  }, 1000);
              }
              else {
                  expandTimerId = window.setTimeout(() => {
                      expand();
                  }, 1000);
              }
          }
          // Dnd
          function handleDragEnter({ event, node }) {
              // node should be a tmNode
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              handleDragOver({ event, node }, false);
              doDragEnter({ event, node: node.rawNode });
          }
          function handleDragLeave({ event, node }) {
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              doDragLeave({ event, node: node.rawNode });
          }
          function handleDragLeaveTree(e) {
              if (e.target !== e.currentTarget)
                  return;
              resetDropState();
          }
          // Dragend is ok, we don't need to add global listener to reset drag status
          function handleDragEnd({ event, node }) {
              resetDndState();
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              doDragEnd({ event, node: node.rawNode });
          }
          function handleDragStart({ event, node }) {
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              dragStartX = event.clientX;
              draggingNodeRef.value = node;
              doDragStart({ event, node: node.rawNode });
          }
          function handleDragOver({ event, node }, emit = true) {
              var _a;
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              const { value: draggingNode } = draggingNodeRef;
              if (!draggingNode)
                  return;
              const { allowDrop, indent } = props;
              if (emit)
                  doDragOver({ event, node: node.rawNode });
              // Update dropping node
              const el = event.currentTarget;
              const { height: elOffsetHeight, top: elClientTop } = el.getBoundingClientRect();
              const eventOffsetY = event.clientY - elClientTop;
              let mousePosition;
              const allowDropInside = allowDrop({
                  node: node.rawNode,
                  dropPosition: 'inside',
                  phase: 'drag'
              });
              if (allowDropInside) {
                  if (eventOffsetY <= 8) {
                      mousePosition = 'before';
                  }
                  else if (eventOffsetY >= elOffsetHeight - 8) {
                      mousePosition = 'after';
                  }
                  else {
                      mousePosition = 'inside';
                  }
              }
              else {
                  if (eventOffsetY <= elOffsetHeight / 2) {
                      mousePosition = 'before';
                  }
                  else {
                      mousePosition = 'after';
                  }
              }
              const { value: getFindex } = getFIndexRef;
              /** determine the drop position and drop node */
              /** the dropping node needn't to be the mouse hovering node! */
              /**
               * if there is something i've learned from implementing a complex
               * drag & drop. that is never write unit test before you really figure
               * out what behavior is exactly you want.
               */
              let finalDropNode;
              let finalDropPosition;
              const hoverNodeFIndex = getFindex(node.key);
              if (hoverNodeFIndex === null) {
                  resetDropState();
                  return;
              }
              let mouseAtExpandedNonLeafNode = false;
              if (mousePosition === 'inside') {
                  finalDropNode = node;
                  finalDropPosition = 'inside';
              }
              else {
                  if (mousePosition === 'before') {
                      if (node.isFirstChild) {
                          finalDropNode = node;
                          finalDropPosition = 'before';
                      }
                      else {
                          finalDropNode = fNodesRef.value[hoverNodeFIndex - 1];
                          finalDropPosition = 'after';
                      }
                  }
                  else {
                      finalDropNode = node;
                      finalDropPosition = 'after';
                  }
              }
              // If the node is non-leaf and it is expanded, we don't allow it to
              // drop after it and change it to drop before its next view sibling
              if (!finalDropNode.isLeaf &&
                  mergedExpandedKeysRef.value.includes(finalDropNode.key)) {
                  mouseAtExpandedNonLeafNode = true;
                  if (finalDropPosition === 'after') {
                      finalDropNode = fNodesRef.value[hoverNodeFIndex + 1];
                      if (!finalDropNode) {
                          // maybe there is no next view sibling when non-leaf node has no
                          // children and it is the last node in the tree
                          finalDropNode = node;
                          finalDropPosition = 'inside';
                      }
                      else {
                          finalDropPosition = 'before';
                      }
                  }
              }
              const droppingMouseNode = finalDropNode;
              droppingMouseNodeRef.value = droppingMouseNode;
              // This is a speacial case, user is dragging a last child itself, so we
              // only view it as they are trying to drop after it.
              // There are some relevant codes in bailout 1's child branch.
              // Also, the expand bailout should have a high priority. If it's non-leaf
              // node and expanded, keep its origin drop position
              if (!mouseAtExpandedNonLeafNode &&
                  draggingNode.isLastChild &&
                  draggingNode.key === finalDropNode.key) {
                  finalDropPosition = 'after';
              }
              if (finalDropPosition === 'after') {
                  let offset = dragStartX - event.clientX; // drag left => > 0
                  let offsetLevel = 0;
                  while (offset >= indent / 2 && // divide by 2 to make it easier to trigger
                      finalDropNode.parent !== null &&
                      finalDropNode.isLastChild &&
                      offsetLevel < 1) {
                      offset -= indent;
                      offsetLevel += 1;
                      finalDropNode = finalDropNode.parent;
                  }
                  droppingOffsetLevelRef.value = offsetLevel;
              }
              else {
                  droppingOffsetLevelRef.value = 0;
              }
              // Bailout 1
              // Drag self into self
              // Drag it into direct parent
              if (draggingNode.contains(finalDropNode) ||
                  (finalDropPosition === 'inside' &&
                      ((_a = draggingNode.parent) === null || _a === void 0 ? void 0 : _a.key) === finalDropNode.key)) {
                  if (draggingNode.key === droppingMouseNode.key &&
                      draggingNode.key === finalDropNode.key) ;
                  else {
                      resetDropState();
                      return;
                  }
              }
              // Bailout 3
              if (!allowDrop({
                  node: finalDropNode.rawNode,
                  dropPosition: finalDropPosition,
                  phase: 'drag'
              })) {
                  resetDropState();
                  return;
              }
              if (draggingNode.key === finalDropNode.key) {
                  // don't expand when drag on itself
                  resetDragExpandState();
              }
              else {
                  if (nodeKeyToBeExpanded !== finalDropNode.key) {
                      if (finalDropPosition === 'inside') {
                          if (props.expandOnDragenter) {
                              expandDragEnterNode(finalDropNode);
                              // Bailout 4
                              // not try to loading
                              if (!finalDropNode.shallowLoaded &&
                                  nodeKeyToBeExpanded !== finalDropNode.key) {
                                  resetDndState();
                                  return;
                              }
                          }
                          else {
                              // Bailout 5
                              // never expands on drag
                              if (!finalDropNode.shallowLoaded) {
                                  resetDndState();
                                  return;
                              }
                          }
                      }
                      else {
                          resetDragExpandState();
                      }
                  }
                  else {
                      if (finalDropPosition !== 'inside') {
                          resetDragExpandState();
                      }
                  }
              }
              droppingPositionRef.value = finalDropPosition;
              droppingNodeRef.value = finalDropNode;
          }
          function handleDrop({ event, node, dropPosition }) {
              if (!props.draggable ||
                  props.disabled ||
                  isNodeDisabled(node, props.disabledField)) {
                  return;
              }
              const { value: draggingNode } = draggingNodeRef;
              const { value: droppingNode } = droppingNodeRef;
              const { value: droppingPosition } = droppingPositionRef;
              if (!draggingNode || !droppingNode || !droppingPosition) {
                  return;
              }
              // Bailout 1
              if (!props.allowDrop({
                  node: droppingNode.rawNode,
                  dropPosition: droppingPosition,
                  phase: 'drag'
              })) {
                  return;
              }
              // Bailout 2
              // This is a special case to guard since we want ui to show the status
              // but not to emit a event
              if (draggingNode.key === droppingNode.key) {
                  return;
              }
              // Bailout 3
              // insert before its next node
              // insert after its prev node
              if (droppingPosition === 'before') {
                  const nextNode = draggingNode.getNext({ includeDisabled: true });
                  if (nextNode) {
                      if (nextNode.key === droppingNode.key) {
                          resetDropState();
                          return;
                      }
                  }
              }
              if (droppingPosition === 'after') {
                  const prevNode = draggingNode.getPrev({ includeDisabled: true });
                  if (prevNode) {
                      if (prevNode.key === droppingNode.key) {
                          resetDropState();
                          return;
                      }
                  }
              }
              doDrop({
                  event,
                  node: droppingNode.rawNode,
                  dragNode: draggingNode.rawNode,
                  dropPosition
              });
              resetDndState();
          }
          function handleScroll() {
              syncScrollbar();
          }
          function handleResize() {
              syncScrollbar();
          }
          function handleFocusout(e) {
              var _a;
              if (props.virtualScroll || props.internalScrollable) {
                  const { value: scrollbarInst } = scrollbarInstRef;
                  if ((_a = scrollbarInst === null || scrollbarInst === void 0 ? void 0 : scrollbarInst.containerRef) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) {
                      return;
                  }
                  pendingNodeKeyRef.value = null;
              }
              else {
                  const { value: selfEl } = selfElRef;
                  if (selfEl === null || selfEl === void 0 ? void 0 : selfEl.contains(e.relatedTarget))
                      return;
                  pendingNodeKeyRef.value = null;
              }
          }
          watch(pendingNodeKeyRef, (value) => {
              var _a, _b;
              if (value === null)
                  return;
              if (props.virtualScroll) {
                  (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({ key: value });
              }
              else if (props.internalScrollable) {
                  const { value: scrollbarInst } = scrollbarInstRef;
                  if (scrollbarInst === null)
                      return;
                  const targetEl = (_b = scrollbarInst.contentRef) === null || _b === void 0 ? void 0 : _b.querySelector(`[data-key="${createDataKey(value)}"]`);
                  if (!targetEl)
                      return;
                  scrollbarInst.scrollTo({
                      el: targetEl
                  });
              }
          });
          provide(treeInjectionKey, {
              loadingKeysRef,
              highlightKeySetRef: mergedHighlightKeySetRef,
              displayedCheckedKeysRef,
              displayedIndeterminateKeysRef,
              mergedSelectedKeysRef,
              mergedExpandedKeysRef,
              mergedThemeRef: themeRef,
              mergedCheckStrategyRef,
              nodePropsRef: toRef(props, 'nodeProps'),
              disabledRef: toRef(props, 'disabled'),
              checkableRef: toRef(props, 'checkable'),
              selectableRef: toRef(props, 'selectable'),
              expandOnClickRef: toRef(props, 'expandOnClick'),
              onLoadRef: toRef(props, 'onLoad'),
              draggableRef: toRef(props, 'draggable'),
              blockLineRef: toRef(props, 'blockLine'),
              indentRef: toRef(props, 'indent'),
              cascadeRef: toRef(props, 'cascade'),
              checkOnClickRef: toRef(props, 'checkOnClick'),
              checkboxPlacementRef: props.checkboxPlacement,
              droppingMouseNodeRef,
              droppingNodeParentRef,
              draggingNodeRef,
              droppingPositionRef,
              droppingOffsetLevelRef,
              fNodesRef,
              pendingNodeKeyRef,
              showLineRef: toRef(props, 'showLine'),
              disabledFieldRef: toRef(props, 'disabledField'),
              internalScrollableRef: toRef(props, 'internalScrollable'),
              internalCheckboxFocusableRef: toRef(props, 'internalCheckboxFocusable'),
              internalTreeSelect: props.internalTreeSelect,
              renderLabelRef: toRef(props, 'renderLabel'),
              renderPrefixRef: toRef(props, 'renderPrefix'),
              renderSuffixRef: toRef(props, 'renderSuffix'),
              renderSwitcherIconRef: toRef(props, 'renderSwitcherIcon'),
              labelFieldRef: toRef(props, 'labelField'),
              multipleRef: toRef(props, 'multiple'),
              handleSwitcherClick,
              handleDragEnd,
              handleDragEnter,
              handleDragLeave,
              handleDragStart,
              handleDrop,
              handleDragOver,
              handleSelect,
              handleCheck
          });
          function scrollTo(options) {
              var _a;
              (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options);
          }
          const exposedMethods = {
              handleKeydown,
              scrollTo,
              getCheckedData: () => {
                  if (!props.checkable)
                      return { keys: [], options: [] };
                  const { checkedKeys } = checkedStatusRef.value;
                  return {
                      keys: checkedKeys,
                      options: getOptionsByKeys(checkedKeys)
                  };
              },
              getIndeterminateData: () => {
                  if (!props.checkable)
                      return { keys: [], options: [] };
                  const { indeterminateKeys } = checkedStatusRef.value;
                  return {
                      keys: indeterminateKeys,
                      options: getOptionsByKeys(indeterminateKeys)
                  };
              }
          };
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { fontSize, nodeBorderRadius, nodeColorHover, nodeColorPressed, nodeColorActive, arrowColor, loadingColor, nodeTextColor, nodeTextColorDisabled, dropMarkColor, nodeWrapperPadding, nodeHeight, lineHeight, lineColor } } = themeRef.value;
              const lineOffsetTop = getMargin(nodeWrapperPadding, 'top');
              const lineOffsetBottom = getMargin(nodeWrapperPadding, 'bottom');
              const nodeContentHeight = pxfy(depx(nodeHeight) - depx(lineOffsetTop) - depx(lineOffsetBottom));
              return {
                  '--n-arrow-color': arrowColor,
                  '--n-loading-color': loadingColor,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-node-border-radius': nodeBorderRadius,
                  '--n-node-color-active': nodeColorActive,
                  '--n-node-color-hover': nodeColorHover,
                  '--n-node-color-pressed': nodeColorPressed,
                  '--n-node-text-color': nodeTextColor,
                  '--n-node-text-color-disabled': nodeTextColorDisabled,
                  '--n-drop-mark-color': dropMarkColor,
                  '--n-node-wrapper-padding': nodeWrapperPadding,
                  '--n-line-offset-top': `-${lineOffsetTop}`,
                  '--n-line-offset-bottom': `-${lineOffsetBottom}`,
                  '--n-node-content-height': nodeContentHeight,
                  '--n-line-height': lineHeight,
                  '--n-line-color': lineColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('tree', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedMethods), { mergedClsPrefix: mergedClsPrefixRef, mergedTheme: themeRef, rtlEnabled: rtlEnabledRef, fNodes: mergedFNodesRef, aip: aipRef, selfElRef,
              virtualListInstRef,
              scrollbarInstRef,
              handleFocusout,
              handleDragLeaveTree,
              handleScroll,
              getScrollContainer,
              getScrollContent,
              handleAfterEnter,
              handleResize, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          var _a;
          const { fNodes, internalRenderEmpty } = this;
          if (!fNodes.length && internalRenderEmpty) {
              return internalRenderEmpty();
          }
          const { mergedClsPrefix, blockNode, blockLine, draggable, disabled, internalFocusable, checkable, handleKeydown, rtlEnabled, handleFocusout, scrollbarProps } = this;
          const mergedFocusable = internalFocusable && !disabled;
          const tabindex = mergedFocusable ? '0' : undefined;
          const treeClass = [
              `${mergedClsPrefix}-tree`,
              rtlEnabled && `${mergedClsPrefix}-tree--rtl`,
              checkable && `${mergedClsPrefix}-tree--checkable`,
              (blockLine || blockNode) && `${mergedClsPrefix}-tree--block-node`,
              blockLine && `${mergedClsPrefix}-tree--block-line`
          ];
          const createNode = (tmNode) => {
              return '__motion' in tmNode ? (h(MotionWrapper, { height: tmNode.height, nodes: tmNode.nodes, clsPrefix: mergedClsPrefix, mode: tmNode.mode, onAfterEnter: this.handleAfterEnter })) : (h(NTreeNode, { key: tmNode.key, tmNode: tmNode, clsPrefix: mergedClsPrefix }));
          };
          if (this.virtualScroll) {
              const { mergedTheme, internalScrollablePadding } = this;
              const padding = getMargin(internalScrollablePadding || '0');
              return (h(XScrollbar, Object.assign({}, scrollbarProps, { ref: "scrollbarInstRef", onDragleave: draggable ? this.handleDragLeaveTree : undefined, container: this.getScrollContainer, content: this.getScrollContent, class: treeClass, theme: mergedTheme.peers.Scrollbar, themeOverrides: mergedTheme.peerOverrides.Scrollbar, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined }), {
                  default: () => {
                      var _a;
                      (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                      return !fNodes.length ? (resolveSlot(this.$slots.empty, () => [
                          h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
                      ])) : (h(VVirtualList, { ref: "virtualListInstRef", items: this.fNodes, itemSize: depx(mergedTheme.self.nodeHeight), ignoreItemResize: this.aip, paddingTop: padding.top, paddingBottom: padding.bottom, class: this.themeClass, style: [
                              this.cssVars,
                              {
                                  paddingLeft: padding.left,
                                  paddingRight: padding.right
                              }
                          ], onScroll: this.handleScroll, onResize: this.handleResize, showScrollbar: false, itemResizable: true }, {
                          default: ({ item }) => createNode(item)
                      }));
                  }
              }));
          }
          const { internalScrollable } = this;
          treeClass.push(this.themeClass);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          if (internalScrollable) {
              return (h(XScrollbar, Object.assign({}, scrollbarProps, { class: treeClass, tabindex: tabindex, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, style: this.cssVars, contentStyle: { padding: this.internalScrollablePadding } }), {
                  default: () => (h("div", { onDragleave: draggable ? this.handleDragLeaveTree : undefined, ref: "selfElRef" }, this.fNodes.map(createNode)))
              }));
          }
          else {
              return (h("div", { class: treeClass, tabindex: tabindex, ref: "selfElRef", style: this.cssVars, onKeydown: mergedFocusable ? handleKeydown : undefined, onFocusout: mergedFocusable ? handleFocusout : undefined, onDragleave: draggable ? this.handleDragLeaveTree : undefined }, !fNodes.length
                  ? resolveSlot(this.$slots.empty, () => [
                      h(NEmpty, { class: `${mergedClsPrefix}-tree__empty`, theme: this.mergedTheme.peers.Empty, themeOverrides: this.mergedTheme.peerOverrides.Empty })
                  ])
                  : fNodes.map(createNode)));
          }
      }
  });

  function treeOption2SelectOption(tmNode, labelField) {
      const { rawNode } = tmNode;
      return Object.assign(Object.assign({}, rawNode), { label: rawNode[labelField], value: tmNode.key });
  }
  function treeOption2SelectOptionWithPath(tmNode, path, separator, labelField) {
      const { rawNode } = tmNode;
      return Object.assign(Object.assign({}, rawNode), { value: tmNode.key, label: path.map((v) => v.rawNode[labelField]).join(separator) });
  }

  // vars:
  // --n-bezier
  // --n-menu-height
  // --n-menu-border-radius
  // --n-menu-box-shadow
  // --n-menu-color
  // --n-action-padding
  // --n-action-text-color
  // --n-action-divider-color
  var style$9 = c$1([cB('tree-select', `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 `), cB('tree-select-menu', `
 position: relative;
 overflow: hidden;
 margin: 4px 0;
 transition: box-shadow .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-menu-border-radius);
 box-shadow: var(--n-menu-box-shadow);
 background-color: var(--n-menu-color);
 outline: none;
 `, [cB('tree', 'max-height: var(--n-menu-height);'), cE('empty', `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE('action', `
 padding: var(--n-action-padding);
 transition: 
 color .3s var(--n-bezier);
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), fadeInScaleUpTransition()])]);

  const treeSelectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), { bordered: {
          type: Boolean,
          default: true
      }, cascade: Boolean, checkable: Boolean, clearable: Boolean, clearFilterAfterSelect: {
          type: Boolean,
          default: true
      }, consistentMenuWidth: {
          type: Boolean,
          default: true
      }, defaultShow: Boolean, defaultValue: {
          type: [String, Number, Array],
          default: null
      }, disabled: {
          type: Boolean,
          default: undefined
      }, filterable: Boolean, checkStrategy: {
          type: String,
          default: 'all'
      }, loading: Boolean, maxTagCount: [String, Number], multiple: Boolean, showPath: Boolean, separator: {
          type: String,
          default: ' / '
      }, options: {
          type: Array,
          default: () => []
      }, placeholder: String, placement: {
          type: String,
          default: 'bottom-start'
      }, show: {
          type: Boolean,
          default: undefined
      }, size: String, value: [String, Number, Array], to: useAdjustedTo.propTo, menuProps: Object, virtualScroll: {
          type: Boolean,
          default: true
      }, status: String, renderTag: Function }), treeSharedProps), { renderLabel: Function, renderPrefix: Function, renderSuffix: Function, nodeProps: Function, watchProps: Array, onBlur: Function, onFocus: Function, onLoad: Function, onUpdateShow: [Function, Array], onUpdateValue: [Function, Array], 'onUpdate:value': [Function, Array], 'onUpdate:show': [Function, Array], 
      /**
       * @deprecated
       */
      leafOnly: Boolean });
  var TreeSelect = defineComponent({
      name: 'TreeSelect',
      props: treeSelectProps,
      setup(props) {
          const followerInstRef = ref(null);
          const triggerInstRef = ref(null);
          const treeInstRef = ref(null);
          const menuElRef = ref(null);
          const { mergedClsPrefixRef, namespaceRef, inlineThemeDisabled } = useConfig(props);
          const { localeRef } = useLocale('Select');
          const { mergedSizeRef, mergedDisabledRef, mergedStatusRef, nTriggerFormBlur, nTriggerFormChange, nTriggerFormFocus, nTriggerFormInput } = useFormItem(props);
          const uncontrolledValueRef = ref(props.defaultValue);
          const controlledValueRef = toRef(props, 'value');
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const uncontrolledShowRef = ref(props.defaultShow);
          const controlledShowRef = toRef(props, 'show');
          const mergedShowRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const patternRef = ref('');
          const mergedFilterRef = computed(() => {
              const { filter } = props;
              if (filter)
                  return filter;
              const { labelField } = props;
              return (pattern, node) => {
                  if (!pattern.length)
                      return true;
                  return node[labelField]
                      .toLowerCase()
                      .includes(pattern.toLowerCase());
              };
          });
          // used to resolve selected options
          const dataTreeMateRef = computed(() => createTreeMate(props.options, createTreeMateOptions(props.keyField, props.childrenField, props.disabledField, undefined)));
          const { value: initMergedValue } = mergedValueRef;
          const pendingNodeKeyRef = ref(props.checkable
              ? null
              : Array.isArray(initMergedValue) && initMergedValue.length
                  ? initMergedValue[initMergedValue.length - 1]
                  : null);
          const mergedCascadeRef = computed(() => {
              return props.multiple && props.cascade && props.checkable;
          });
          // The same logic as tree, now it's not that complex so I don't extract a
          // function to reuse it.
          const uncontrolledExpandedKeysRef = ref(props.defaultExpandAll
              ? undefined // leave it, n-tree will handle it
              : props.defaultExpandedKeys || props.expandedKeys);
          const controlledExpandedKeysRef = toRef(props, 'expandedKeys');
          const mergedExpandedKeysRef = useMergedState(controlledExpandedKeysRef, uncontrolledExpandedKeysRef);
          const focusedRef = ref(false);
          const mergedPlaceholderRef = computed(() => {
              const { placeholder } = props;
              if (placeholder !== undefined)
                  return placeholder;
              return localeRef.value.placeholder;
          });
          const treeSelectedKeysRef = computed(() => {
              if (props.checkable)
                  return [];
              return treeCheckedKeysRef.value;
          });
          const treeCheckedKeysRef = computed(() => {
              const { value: mergedValue } = mergedValueRef;
              if (props.multiple) {
                  if (Array.isArray(mergedValue))
                      return mergedValue;
                  else
                      return [];
              }
              else {
                  if (mergedValue === null || Array.isArray(mergedValue))
                      return [];
                  else
                      return [mergedValue];
              }
          });
          const selectedOptionRef = computed(() => {
              const { multiple, showPath, separator, labelField } = props;
              if (multiple)
                  return null;
              const { value: mergedValue } = mergedValueRef;
              if (!Array.isArray(mergedValue) && mergedValue !== null) {
                  const { value: treeMate } = dataTreeMateRef;
                  const tmNode = treeMate.getNode(mergedValue);
                  if (tmNode !== null) {
                      return showPath
                          ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(mergedValue).treeNodePath, separator, labelField)
                          : treeOption2SelectOption(tmNode, labelField);
                  }
              }
              return null;
          });
          const selectedOptionsRef = computed(() => {
              const { multiple, showPath, separator } = props;
              if (!multiple)
                  return null;
              const { value: mergedValue } = mergedValueRef;
              if (Array.isArray(mergedValue)) {
                  const res = [];
                  const { value: treeMate } = dataTreeMateRef;
                  const { checkedKeys } = treeMate.getCheckedKeys(mergedValue, {
                      checkStrategy: props.checkStrategy,
                      cascade: mergedCascadeRef.value,
                      allowNotLoaded: props.allowCheckingNotLoaded
                  });
                  const { labelField } = props;
                  checkedKeys.forEach((value) => {
                      const tmNode = treeMate.getNode(value);
                      if (tmNode !== null) {
                          res.push(showPath
                              ? treeOption2SelectOptionWithPath(tmNode, treeMate.getPath(value).treeNodePath, separator, labelField)
                              : treeOption2SelectOption(tmNode, labelField));
                      }
                  });
                  return res;
              }
              return [];
          });
          const menuPaddingRef = computed(() => {
              const { self: { menuPadding } } = themeRef.value;
              return menuPadding;
          });
          function focusSelection() {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function focusSelectionInput() {
              var _a;
              (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function doUpdateShow(value) {
              const { onUpdateShow, 'onUpdate:show': _onUpdateShow } = props;
              if (onUpdateShow)
                  call(onUpdateShow, value);
              if (_onUpdateShow)
                  call(_onUpdateShow, value);
              uncontrolledShowRef.value = value;
          }
          function doUpdateValue(value, option, meta) {
              const { onUpdateValue, 'onUpdate:value': _onUpdateValue } = props;
              if (onUpdateValue) {
                  call(onUpdateValue, value, option, meta);
              }
              if (_onUpdateValue) {
                  call(_onUpdateValue, value, option, meta);
              }
              uncontrolledValueRef.value = value;
              nTriggerFormInput();
              nTriggerFormChange();
          }
          function doUpdateIndeterminateKeys(value, option) {
              const { onUpdateIndeterminateKeys, 'onUpdate:indeterminateKeys': _onUpdateIndeterminateKeys } = props;
              if (onUpdateIndeterminateKeys) {
                  call(onUpdateIndeterminateKeys, value, option);
              }
              if (_onUpdateIndeterminateKeys) {
                  call(_onUpdateIndeterminateKeys, value, option);
              }
          }
          function doUpdateExpandedKeys(keys, option, meta) {
              const { onUpdateExpandedKeys, 'onUpdate:expandedKeys': _onUpdateExpandedKeys } = props;
              if (onUpdateExpandedKeys) {
                  call(onUpdateExpandedKeys, keys, option, meta);
              }
              if (_onUpdateExpandedKeys) {
                  call(_onUpdateExpandedKeys, keys, option, meta);
              }
              uncontrolledExpandedKeysRef.value = keys;
          }
          function doFocus(e) {
              const { onFocus } = props;
              if (onFocus)
                  onFocus(e);
              nTriggerFormFocus();
          }
          function doBlur(e) {
              closeMenu();
              const { onBlur } = props;
              if (onBlur)
                  onBlur(e);
              nTriggerFormBlur();
          }
          function closeMenu() {
              doUpdateShow(false);
          }
          function openMenu() {
              if (!mergedDisabledRef.value) {
                  patternRef.value = '';
                  doUpdateShow(true);
                  if (props.filterable) {
                      focusSelectionInput();
                  }
              }
          }
          function handleMenuLeave() {
              patternRef.value = '';
          }
          function handleMenuClickoutside(e) {
              var _a;
              if (mergedShowRef.value) {
                  if (!((_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                      // outside select, don't need to return focus
                      closeMenu();
                  }
              }
          }
          function handleTriggerClick() {
              if (mergedDisabledRef.value)
                  return;
              if (!mergedShowRef.value) {
                  openMenu();
              }
              else {
                  if (!props.filterable) {
                      // already focused, don't need to return focus
                      closeMenu();
                  }
              }
          }
          function getOptionsByKeys(keys) {
              const { value: { getNode } } = dataTreeMateRef;
              return keys.map((key) => { var _a; return ((_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode) || null; });
          }
          function handleUpdateCheckedKeys(keys, _, meta) {
              const options = getOptionsByKeys(keys);
              const action = meta.action === 'check' ? 'select' : 'unselect';
              const node = meta.node;
              if (props.multiple) {
                  doUpdateValue(keys, options, { node, action });
                  if (props.filterable) {
                      focusSelectionInput();
                      if (props.clearFilterAfterSelect)
                          patternRef.value = '';
                  }
              }
              else {
                  keys.length
                      ? doUpdateValue(keys[0], options[0] || null, {
                          node,
                          action
                      })
                      : doUpdateValue(null, null, { node, action });
                  closeMenu();
                  // Currently it is not necessary. However if there is an action slot,
                  // it will be useful. So just leave it here.
                  focusSelection();
              }
          }
          function handleUpdateIndeterminateKeys(keys) {
              if (props.checkable) {
                  doUpdateIndeterminateKeys(keys, getOptionsByKeys(keys));
              }
          }
          function handleTriggerFocus(e) {
              var _a;
              if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
                  return;
              focusedRef.value = true;
              doFocus(e);
          }
          function handleTriggerBlur(e) {
              var _a;
              if ((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))
                  return;
              focusedRef.value = false;
              doBlur(e);
          }
          function handleMenuFocusin(e) {
              var _a, _b, _c;
              if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) ||
                  ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
                  return;
              }
              focusedRef.value = true;
              doFocus(e);
          }
          function handleMenuFocusout(e) {
              var _a, _b, _c;
              if (((_a = menuElRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) ||
                  ((_c = (_b = triggerInstRef.value) === null || _b === void 0 ? void 0 : _b.$el) === null || _c === void 0 ? void 0 : _c.contains(e.relatedTarget))) {
                  return;
              }
              focusedRef.value = false;
              doBlur(e);
          }
          function handleClear(e) {
              e.stopPropagation();
              const { multiple } = props;
              if (!multiple && props.filterable) {
                  closeMenu();
              }
              if (multiple) {
                  doUpdateValue([], [], { node: null, action: 'clear' });
              }
              else {
                  doUpdateValue(null, null, { node: null, action: 'clear' });
              }
          }
          function handleDeleteOption(option) {
              // only work for multiple mode
              const { value: mergedValue } = mergedValueRef;
              if (Array.isArray(mergedValue)) {
                  const { value: treeMate } = dataTreeMateRef;
                  // all visible checked keys
                  const { checkedKeys: checkedKeysValue } = treeMate.getCheckedKeys(mergedValue, {
                      cascade: mergedCascadeRef.value,
                      allowNotLoaded: props.allowCheckingNotLoaded
                  });
                  const index = checkedKeysValue.findIndex((key) => key === option.value);
                  if (~index) {
                      const checkedKeyToBeRemoved = checkedKeysValue[index];
                      const checkOptionToBeRemoved = getOptionsByKeys([
                          checkedKeyToBeRemoved
                      ])[0];
                      if (props.checkable) {
                          const { checkedKeys } = treeMate.uncheck(option.value, checkedKeysValue, {
                              checkStrategy: props.checkStrategy,
                              cascade: mergedCascadeRef.value,
                              allowNotLoaded: props.allowCheckingNotLoaded
                          });
                          doUpdateValue(checkedKeys, getOptionsByKeys(checkedKeys), {
                              node: checkOptionToBeRemoved,
                              action: 'delete'
                          });
                      }
                      else {
                          const nextValue = Array.from(checkedKeysValue);
                          nextValue.splice(index, 1);
                          doUpdateValue(nextValue, getOptionsByKeys(nextValue), {
                              node: checkOptionToBeRemoved,
                              action: 'delete'
                          });
                      }
                  }
              }
          }
          function handlePatternInput(e) {
              const { value } = e.target;
              patternRef.value = value;
          }
          function treeHandleKeydown(e) {
              const { value: treeInst } = treeInstRef;
              if (treeInst) {
                  treeInst.handleKeydown(e);
              }
          }
          function handleKeydown(e) {
              if (e.key === 'Enter') {
                  if (mergedShowRef.value) {
                      treeHandleKeydown(e);
                      if (!props.multiple) {
                          closeMenu();
                          focusSelection();
                      }
                  }
                  else {
                      openMenu();
                  }
                  e.preventDefault();
              }
              else if (e.key === 'Escape') {
                  if (mergedShowRef.value) {
                      markEventEffectPerformed(e);
                      closeMenu();
                      focusSelection();
                  }
              }
              else {
                  if (mergedShowRef.value) {
                      treeHandleKeydown(e);
                  }
                  else if (e.key === 'ArrowDown') {
                      openMenu();
                  }
              }
          }
          function handleTabOut() {
              closeMenu();
              focusSelection();
          }
          function handleMenuMousedown(e) {
              // If there's an action slot later, we need to check if mousedown happens
              // in action panel
              if (!happensIn(e, 'action'))
                  e.preventDefault();
          }
          const selectionRenderTagRef = computed(() => {
              const { renderTag } = props;
              if (!renderTag)
                  return undefined;
              return function selectionRenderTag({ option, handleClose }) {
                  const { value } = option;
                  if (value !== undefined) {
                      const treeOption = dataTreeMateRef.value.getNode(value);
                      if (treeOption) {
                          return renderTag({ option: treeOption.rawNode, handleClose });
                      }
                  }
                  return value;
              };
          });
          provide(treeSelectInjectionKey, {
              pendingNodeKeyRef,
              dataTreeMate: dataTreeMateRef
          });
          function handleTriggerOrMenuResize() {
              var _a;
              if (!mergedShowRef.value)
                  return;
              (_a = followerInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          useOnResize(menuElRef, handleTriggerOrMenuResize);
          const mergedCheckStrategyRef = useMergedCheckStrategy(props);
          const exposedCheckedStatusRef = computed(() => {
              if (props.checkable) {
                  const mergedValue = mergedValueRef.value;
                  if (props.multiple && Array.isArray(mergedValue)) {
                      return dataTreeMateRef.value.getCheckedKeys(mergedValue, {
                          cascade: props.cascade,
                          checkStrategy: mergedCheckStrategyRef.value,
                          allowNotLoaded: props.allowCheckingNotLoaded
                      });
                  }
                  else {
                      return {
                          checkedKeys: Array.isArray(mergedValue) || mergedValue === null
                              ? []
                              : [mergedValue],
                          indeterminateKeys: []
                      };
                  }
              }
              return {
                  checkedKeys: [],
                  indeterminateKeys: []
              };
          });
          const exposedMethods = {
              getCheckedData: () => {
                  const { checkedKeys } = exposedCheckedStatusRef.value;
                  return { keys: checkedKeys, options: getOptionsByKeys(checkedKeys) };
              },
              getIndeterminateData: () => {
                  const { indeterminateKeys } = exposedCheckedStatusRef.value;
                  return {
                      keys: indeterminateKeys,
                      options: getOptionsByKeys(indeterminateKeys)
                  };
              },
              focus: () => { var _a; return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focus(); },
              focusInput: () => { var _a; return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.focusInput(); },
              blur: () => { var _a; return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blur(); },
              blurInput: () => { var _a; return (_a = triggerInstRef.value) === null || _a === void 0 ? void 0 : _a.blurInput(); }
          };
          const themeRef = useTheme('TreeSelect', '-tree-select', style$9, treeSelectLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { menuBoxShadow, menuBorderRadius, menuColor, menuHeight, actionPadding, actionDividerColor, actionTextColor } } = themeRef.value;
              return {
                  '--n-menu-box-shadow': menuBoxShadow,
                  '--n-menu-border-radius': menuBorderRadius,
                  '--n-menu-color': menuColor,
                  '--n-menu-height': menuHeight,
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-action-padding': actionPadding,
                  '--n-action-text-color': actionTextColor,
                  '--n-action-divider-color': actionDividerColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('tree-select', undefined, cssVarsRef, props)
              : undefined;
          return Object.assign(Object.assign({}, exposedMethods), { menuElRef, mergedStatus: mergedStatusRef, triggerInstRef,
              followerInstRef,
              treeInstRef, mergedClsPrefix: mergedClsPrefixRef, mergedValue: mergedValueRef, mergedShow: mergedShowRef, namespace: namespaceRef, adjustedTo: useAdjustedTo(props), isMounted: isMounted(), focused: focusedRef, menuPadding: menuPaddingRef, mergedPlaceholder: mergedPlaceholderRef, mergedExpandedKeys: mergedExpandedKeysRef, treeSelectedKeys: treeSelectedKeysRef, treeCheckedKeys: treeCheckedKeysRef, mergedSize: mergedSizeRef, mergedDisabled: mergedDisabledRef, selectedOption: selectedOptionRef, selectedOptions: selectedOptionsRef, pattern: patternRef, pendingNodeKey: pendingNodeKeyRef, mergedCascade: mergedCascadeRef, mergedFilter: mergedFilterRef, selectionRenderTag: selectionRenderTagRef, handleTriggerOrMenuResize,
              doUpdateExpandedKeys,
              handleMenuLeave,
              handleTriggerClick,
              handleMenuClickoutside,
              handleUpdateCheckedKeys,
              handleUpdateIndeterminateKeys,
              handleTriggerFocus,
              handleTriggerBlur,
              handleMenuFocusin,
              handleMenuFocusout,
              handleClear,
              handleDeleteOption,
              handlePatternInput,
              handleKeydown,
              handleTabOut,
              handleMenuMousedown, mergedTheme: themeRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender });
      },
      render() {
          const { mergedTheme, mergedClsPrefix, $slots } = this;
          return (h("div", { class: `${mergedClsPrefix}-tree-select` },
              h(VBinder, null, {
                  default: () => [
                      h(VTarget, null, {
                          default: () => (h(NInternalSelection, { ref: "triggerInstRef", onResize: this.handleTriggerOrMenuResize, status: this.mergedStatus, focused: this.focused, clsPrefix: mergedClsPrefix, theme: mergedTheme.peers.InternalSelection, themeOverrides: mergedTheme.peerOverrides.InternalSelection, renderTag: this.selectionRenderTag, selectedOption: this.selectedOption, selectedOptions: this.selectedOptions, size: this.mergedSize, bordered: this.bordered, placeholder: this.mergedPlaceholder, disabled: this.mergedDisabled, active: this.mergedShow, loading: this.loading, multiple: this.multiple, maxTagCount: this.maxTagCount, showArrow: true, filterable: this.filterable, clearable: this.clearable, pattern: this.pattern, onPatternInput: this.handlePatternInput, onClear: this.handleClear, onClick: this.handleTriggerClick, onFocus: this.handleTriggerFocus, onBlur: this.handleTriggerBlur, onDeleteOption: this.handleDeleteOption, onKeydown: this.handleKeydown }, {
                              arrow: () => { var _a, _b; return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)]; }
                          }))
                      }),
                      h(VFollower, { ref: "followerInstRef", show: this.mergedShow, placement: this.placement, to: this.adjustedTo, teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey, containerClass: this.namespace, width: this.consistentMenuWidth ? 'target' : undefined, minWidth: "target" }, {
                          default: () => (h(Transition, { name: "fade-in-scale-up-transition", appear: this.isMounted, onLeave: this.handleMenuLeave }, {
                              default: () => {
                                  var _a;
                                  if (!this.mergedShow)
                                      return null;
                                  const { mergedClsPrefix, checkable, multiple, menuProps, options } = this;
                                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                                  return withDirectives(h("div", Object.assign({}, menuProps, { class: [
                                          `${mergedClsPrefix}-tree-select-menu`,
                                          menuProps === null || menuProps === void 0 ? void 0 : menuProps.class,
                                          this.themeClass
                                      ], ref: "menuElRef", style: [
                                          (menuProps === null || menuProps === void 0 ? void 0 : menuProps.style) || '',
                                          this.cssVars
                                      ], tabindex: 0, onMousedown: this.handleMenuMousedown, onKeydown: this.handleKeydown, onFocusin: this.handleMenuFocusin, onFocusout: this.handleMenuFocusout }),
                                      h(NTree, { ref: "treeInstRef", blockLine: true, allowCheckingNotLoaded: this.allowCheckingNotLoaded, showIrrelevantNodes: false, animated: false, pattern: this.pattern, filter: this.mergedFilter, data: options, cancelable: multiple, labelField: this.labelField, keyField: this.keyField, disabledField: this.disabledField, childrenField: this.childrenField, theme: mergedTheme.peers.Tree, themeOverrides: mergedTheme.peerOverrides.Tree, defaultExpandAll: this.defaultExpandAll, defaultExpandedKeys: this.defaultExpandedKeys, expandedKeys: this.mergedExpandedKeys, checkedKeys: this.treeCheckedKeys, selectedKeys: this.treeSelectedKeys, checkable: checkable, checkStrategy: this.checkStrategy, cascade: this.mergedCascade, leafOnly: this.leafOnly, multiple: this.multiple, renderLabel: this.renderLabel, renderPrefix: this.renderPrefix, renderSuffix: this.renderSuffix, renderSwitcherIcon: this.renderSwitcherIcon, nodeProps: this.nodeProps, watchProps: this.watchProps, virtualScroll: this.consistentMenuWidth && this.virtualScroll, internalTreeSelect: true, internalUnifySelectCheck: true, internalScrollable: true, internalScrollablePadding: this.menuPadding, internalFocusable: false, internalCheckboxFocusable: false, internalRenderEmpty: () => (h("div", { class: `${mergedClsPrefix}-tree-select-menu__empty` }, resolveSlot($slots.empty, () => [
                                              h(NEmpty, { theme: mergedTheme.peers.Empty, themeOverrides: mergedTheme.peerOverrides.Empty })
                                          ]))), onLoad: this.onLoad, onUpdateCheckedKeys: this.handleUpdateCheckedKeys, onUpdateIndeterminateKeys: this.handleUpdateIndeterminateKeys, onUpdateExpandedKeys: this.doUpdateExpandedKeys }),
                                      resolveWrappedSlot($slots.action, (children) => {
                                          return children ? (h("div", { class: `${mergedClsPrefix}-tree-select-menu__action`, "data-action": true }, children)) : null;
                                      }),
                                      h(FocusDetector, { onFocus: this.handleTabOut })), [
                                      [
                                          clickoutside$1,
                                          this.handleMenuClickoutside,
                                          undefined,
                                          { capture: true }
                                      ]
                                  ]);
                              }
                          }))
                      })
                  ]
              })));
      }
  });

  // vars:
  // --n-bezier
  // --n-font-size
  // --n-margin
  // --n-bar-color
  // --n-bar-width
  // --n-font-weight
  // --n-text-color
  // --n-prefix-width
  var style$8 = cB('h', `
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 margin: var(--n-margin);
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [c$1('&:first-child', {
    marginTop: 0
  }), cM('prefix-bar', {
    position: 'relative',
    paddingLeft: 'var(--n-prefix-width)'
  }, [cM('align-text', {
    paddingLeft: 0
  }, [c$1('&::before', {
    left: 'calc(-1 * var(--n-prefix-width))'
  })]), c$1('&::before', `
 content: "";
 width: var(--n-bar-width);
 border-radius: calc(var(--n-bar-width) / 2);
 transition: background-color .3s var(--n-bezier);
 left: 0;
 top: 0;
 bottom: 0;
 position: absolute;
 `), c$1('&::before', {
    backgroundColor: 'var(--n-bar-color)'
  })])]);

  const headerProps = Object.assign(Object.assign({}, useTheme.props), { type: {
          type: String,
          default: 'default'
      }, prefix: String, alignText: Boolean });
  // eslint-disable-next-line @typescript-eslint/explicit-function-return-type
  var createHeader = (level) => defineComponent({
      name: `H${level}`,
      props: headerProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-h', style$8, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { type } = props;
              const { common: { cubicBezierEaseInOut }, self: { headerFontWeight, headerTextColor, [createKey('headerPrefixWidth', level)]: prefixWidth, [createKey('headerFontSize', level)]: fontSize, [createKey('headerMargin', level)]: margin, [createKey('headerBarWidth', level)]: barWidth, [createKey('headerBarColor', type)]: barColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': fontSize,
                  '--n-margin': margin,
                  '--n-bar-color': barColor,
                  '--n-bar-width': barWidth,
                  '--n-font-weight': headerFontWeight,
                  '--n-text-color': headerTextColor,
                  '--n-prefix-width': prefixWidth
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass(`h${level}`, computed(() => props.type[0]), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { prefix, alignText, mergedClsPrefix, cssVars, $slots } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return h(`h${level}`, {
              class: [
                  `${mergedClsPrefix}-h`,
                  `${mergedClsPrefix}-h${level}`,
                  this.themeClass,
                  {
                      [`${mergedClsPrefix}-h--prefix-bar`]: prefix,
                      [`${mergedClsPrefix}-h--align-text`]: alignText
                  }
              ],
              style: cssVars
          }, $slots);
      }
  });

  const NH1 = createHeader('1');
  const NH2 = createHeader('2');
  const NH3 = createHeader('3');
  const NH4 = createHeader('4');
  const NH5 = createHeader('5');
  const NH6 = createHeader('6');

  // vars:
  // --n-text-color
  // --n-bezier
  var style$7 = cB('a', `
 cursor: pointer;
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 text-decoration-color: var(--n-text-color);
 color: var(--n-text-color);
`);

  const aProps = Object.assign({}, useTheme.props);
  var a = defineComponent({
      name: 'A',
      props: aProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-a', style$7, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { aTextColor } } = themeRef.value;
              return {
                  '--n-text-color': aTextColor,
                  '--n-bezier': cubicBezierEaseInOut
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('a', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("a", { class: [`${this.mergedClsPrefix}-a`, this.themeClass], style: this.cssVars }, this.$slots));
      }
  });

  // vars:
  // --n-bezier
  // --n-font-size
  // --n-line-height
  // --n-margin
  // --n-text-color
  var style$6 = cB('p', `
 box-sizing: border-box;
 transition: color .3s var(--n-bezier);
 margin: var(--n-margin);
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 color: var(--n-text-color);
`, [c$1('&:first-child', 'margin-top: 0;'), c$1('&:last-child', 'margin-bottom: 0;')]);

  const pProps = Object.assign(Object.assign({}, useTheme.props), { depth: [String, Number] });
  var p = defineComponent({
      name: 'P',
      props: pProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-p', style$6, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { depth } = props;
              const typeSafeDepth = depth || '1';
              const { common: { cubicBezierEaseInOut }, self: { pFontSize, pLineHeight, pMargin, pTextColor, [`pTextColor${typeSafeDepth}Depth`]: depthTextColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': pFontSize,
                  '--n-line-height': pLineHeight,
                  '--n-margin': pMargin,
                  '--n-text-color': depth === undefined ? pTextColor : depthTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('p', computed(() => `${props.depth || ''}`), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("p", { class: [`${this.mergedClsPrefix}-p`, this.themeClass], style: this.cssVars }, this.$slots));
      }
  });

  // vars:
  // --n-bezier
  // --n-font-size
  // --n-line-height
  // --n-prefix-color
  // --n-text-color
  var style$5 = cB('blockquote', `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 margin: 0;
 margin-top: 12px;
 margin-bottom: 12px;
 box-sizing: border-box;
 padding-left: 12px;
 border-left: 4px solid var(--n-prefix-color);
 color: var(--n-text-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [c$1('&:first-child', {
    marginTop: 0
  }), c$1('&:last-child', {
    marginBottom: 0
  }), cM('align-text', {
    marginLeft: '-16px'
  })]);

  const blockquoteProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
  var blockquote = defineComponent({
      name: 'Blockquote',
      props: blockquoteProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-blockquote', style$5, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { blockquoteTextColor, blockquotePrefixColor, blockquoteLineHeight, blockquoteFontSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': blockquoteFontSize,
                  '--n-line-height': blockquoteLineHeight,
                  '--n-prefix-color': blockquotePrefixColor,
                  '--n-text-color': blockquoteTextColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('blockquote', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("blockquote", { class: [
                  `${mergedClsPrefix}-blockquote`,
                  this.themeClass,
                  this.alignText && `${mergedClsPrefix}-blockquote--align-text`
              ], style: this.cssVars }, this.$slots));
      }
  });

  // vars:
  // --n-color
  var style$4 = cB('hr', `
 margin: 12px 0;
 transition: border-color .3s var(--n-bezier);
 border-left: none;
 border-right: none;
 border-bottom: none;
 border-top: 1px solid var(--n-color);
`);

  var hr = defineComponent({
      name: 'Hr',
      props: Object.assign({}, useTheme.props),
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-hr', style$4, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { hrColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-color': hrColor
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('hr', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("hr", { class: [`${this.mergedClsPrefix}-hr`, this.themeClass], style: this.cssVars }));
      }
  });

  const liStyle = c$1('li', {
    transition: 'color .3s var(--n-bezier)',
    lineHeight: 'var(--n-line-height)',
    margin: 'var(--n-li-margin)',
    marginBottom: 0,
    color: 'var(--n-text-color)'
  });
  const childStyle = [c$1('&:first-child', `
 margin-top: 0;
 `), c$1('&:last-child', `
 margin-bottom: 0;
 `)];
  // vars:
  // --n-bezier
  // --n-font-size
  // --n-line-height
  // --n-text-color
  // --n-li-margin
  // --n-ol-padding
  // --n-ul-padding
  var style$3 = c$1([cB('ol', {
    fontSize: 'var(--n-font-size)',
    padding: 'var(--n-ol-padding)'
  }, [cM('align-text', {
    paddingLeft: 0
  }), liStyle, childStyle]), cB('ul', {
    fontSize: 'var(--n-font-size)',
    padding: 'var(--n-ul-padding)'
  }, [cM('align-text', {
    paddingLeft: 0
  }), liStyle, childStyle])]);

  const ulProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
  var ul = defineComponent({
      name: 'Ul',
      props: ulProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-xl', style$3, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { olPadding, ulPadding, liMargin, liTextColor, liLineHeight, liFontSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': liFontSize,
                  '--n-line-height': liLineHeight,
                  '--n-text-color': liTextColor,
                  '--n-li-margin': liMargin,
                  '--n-ol-padding': olPadding,
                  '--n-ul-padding': ulPadding
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('ul', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("ul", { class: [
                  `${mergedClsPrefix}-ul`,
                  this.themeClass,
                  this.alignText && `${mergedClsPrefix}-ul--align-text`
              ], style: this.cssVars }, this.$slots));
      }
  });

  const olProps = Object.assign(Object.assign({}, useTheme.props), { alignText: Boolean });
  var ol = defineComponent({
      name: 'Ol',
      props: olProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-xl', style$3, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { olPadding, ulPadding, liMargin, liTextColor, liLineHeight, liFontSize } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-font-size': liFontSize,
                  '--n-line-height': liLineHeight,
                  '--n-text-color': liTextColor,
                  '--n-li-margin': liMargin,
                  '--n-ol-padding': olPadding,
                  '--n-ul-padding': ulPadding
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('ol', undefined, cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return (h("ol", { class: [
                  `${mergedClsPrefix}-ol`,
                  this.themeClass,
                  this.alignText && `${mergedClsPrefix}-ol--align-text`
              ], style: this.cssVars }, this.$slots));
      }
  });

  var li = defineComponent({
      name: 'Li',
      render() {
          return h("li", null, this.$slots);
      }
  });

  // vars:
  // --n-text-color
  // --n-font-weight-strong
  // --n-font-famliy-mono
  // --n-code-border-radius
  // --n-code-text-color
  // --n-code-color
  // --n-code-border
  var style$2 = cB('text', `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
`, [cM('strong', `
 font-weight: var(--n-font-weight-strong);
 `), cM('italic', {
    fontStyle: 'italic'
  }), cM('underline', {
    textDecoration: 'underline'
  }), cM('code', `
 line-height: 1.4;
 display: inline-block;
 font-family: var(--n-font-famliy-mono);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 box-sizing: border-box;
 padding: .05em .35em 0 .35em;
 border-radius: var(--n-code-border-radius);
 font-size: .9em;
 color: var(--n-code-text-color);
 background-color: var(--n-code-color);
 border: var(--n-code-border);
 `)]);

  const textProps = Object.assign(Object.assign({}, useTheme.props), { code: Boolean, type: {
          type: String,
          default: 'default'
      }, delete: Boolean, strong: Boolean, italic: Boolean, underline: Boolean, depth: [String, Number], tag: String, 
      // deprecated
      as: {
          type: String,
          validator: () => {
              return true;
          },
          default: undefined
      } });
  var text = defineComponent({
      name: 'Text',
      props: textProps,
      setup(props) {
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Typography', '-text', style$2, typographyLight$1, props, mergedClsPrefixRef);
          const cssVarsRef = computed(() => {
              const { depth, type } = props;
              const textColorKey = type === 'default'
                  ? depth === undefined
                      ? 'textColor'
                      : `textColor${depth}Depth`
                  : createKey('textColor', type);
              const { common: { fontWeightStrong, fontFamilyMono, cubicBezierEaseInOut }, self: { codeTextColor, codeBorderRadius, codeColor, codeBorder, [textColorKey]: textColor } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-text-color': textColor,
                  '--n-font-weight-strong': fontWeightStrong,
                  '--n-font-famliy-mono': fontFamilyMono,
                  '--n-code-border-radius': codeBorderRadius,
                  '--n-code-text-color': codeTextColor,
                  '--n-code-color': codeColor,
                  '--n-code-border': codeBorder
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('text', computed(() => `${props.type[0]}${props.depth || ''}`), cssVarsRef, props)
              : undefined;
          return {
              mergedClsPrefix: mergedClsPrefixRef,
              compitableTag: useCompitable(props, ['as', 'tag']),
              cssVars: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
      },
      render() {
          var _a, _b, _c;
          const { mergedClsPrefix } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const textClass = [
              `${mergedClsPrefix}-text`,
              this.themeClass,
              {
                  [`${mergedClsPrefix}-text--code`]: this.code,
                  [`${mergedClsPrefix}-text--delete`]: this.delete,
                  [`${mergedClsPrefix}-text--strong`]: this.strong,
                  [`${mergedClsPrefix}-text--italic`]: this.italic,
                  [`${mergedClsPrefix}-text--underline`]: this.underline
              }
          ];
          const children = (_c = (_b = this.$slots).default) === null || _c === void 0 ? void 0 : _c.call(_b);
          return this.code ? (h("code", { class: textClass, style: this.cssVars }, this.delete ? h("del", null, children) : children)) : this.delete ? (h("del", { class: textClass, style: this.cssVars }, children)) : (h(this.compitableTag || 'span', { class: textClass, style: this.cssVars }, children));
      }
  });

  const uploadInjectionKey = createInjectionKey('n-upload');

  const uploadDraggerKey = '__UPLOAD_DRAGGER__';
  var NUploadDragger = defineComponent({
      name: 'UploadDragger',
      [uploadDraggerKey]: true,
      setup(_, { slots }) {
          const NUpload = inject(uploadInjectionKey, null);
          if (!NUpload) {
              throwError('upload-dragger', '`n-upload-dragger` must be placed inside `n-upload`.');
          }
          return () => {
              const { mergedClsPrefixRef: { value: mergedClsPrefix }, mergedDisabledRef: { value: mergedDisabled }, maxReachedRef: { value: maxReached } } = NUpload;
              return (h("div", { class: [
                      `${mergedClsPrefix}-upload-dragger`,
                      (mergedDisabled || maxReached) && `${mergedClsPrefix}-upload-dragger--disabled`
                  ] }, slots));
          };
      }
  });

  var NUploadTrigger = defineComponent({
      name: 'UploadTrigger',
      props: {
          abstract: Boolean
      },
      setup(props, { slots }) {
          const NUpload = inject(uploadInjectionKey, null);
          if (!NUpload) {
              throwError('upload-trigger', '`n-upload-trigger` must be placed inside `n-upload`.');
          }
          const { mergedClsPrefixRef, mergedDisabledRef, maxReachedRef, listTypeRef, dragOverRef, openOpenFileDialog, draggerInsideRef, handleFileAddition, mergedDirectoryDndRef, triggerClassRef, triggerStyleRef } = NUpload;
          const isImageCardTypeRef = computed(() => listTypeRef.value === 'image-card');
          function handleTriggerClick() {
              if (mergedDisabledRef.value || maxReachedRef.value)
                  return;
              openOpenFileDialog();
          }
          function handleTriggerDragOver(e) {
              e.preventDefault();
              dragOverRef.value = true;
          }
          function handleTriggerDragEnter(e) {
              e.preventDefault();
              dragOverRef.value = true;
          }
          function handleTriggerDragLeave(e) {
              e.preventDefault();
              dragOverRef.value = false;
          }
          function handleTriggerDrop(e) {
              var _a;
              e.preventDefault();
              if (!draggerInsideRef.value ||
                  mergedDisabledRef.value ||
                  maxReachedRef.value) {
                  dragOverRef.value = false;
                  return;
              }
              const dataTransferItems = (_a = e.dataTransfer) === null || _a === void 0 ? void 0 : _a.items;
              if (dataTransferItems === null || dataTransferItems === void 0 ? void 0 : dataTransferItems.length) {
                  void getFilesFromEntries(Array.from(dataTransferItems).map((item) => item.webkitGetAsEntry()), mergedDirectoryDndRef.value)
                      .then((files) => {
                      handleFileAddition(files);
                  })
                      .finally(() => {
                      dragOverRef.value = false;
                  });
              }
              else {
                  dragOverRef.value = false;
              }
          }
          return () => {
              var _a;
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              return props.abstract ? ((_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots, {
                  handleClick: handleTriggerClick,
                  handleDrop: handleTriggerDrop,
                  handleDragOver: handleTriggerDragOver,
                  handleDragEnter: handleTriggerDragEnter,
                  handleDragLeave: handleTriggerDragLeave
              })) : (h("div", { class: [
                      `${mergedClsPrefix}-upload-trigger`,
                      (mergedDisabledRef.value || maxReachedRef.value) &&
                          `${mergedClsPrefix}-upload-trigger--disabled`,
                      isImageCardTypeRef.value &&
                          `${mergedClsPrefix}-upload-trigger--image-card`,
                      triggerClassRef.value
                  ], style: triggerStyleRef.value, onClick: handleTriggerClick, onDrop: handleTriggerDrop, onDragover: handleTriggerDragOver, onDragenter: handleTriggerDragEnter, onDragleave: handleTriggerDragLeave }, isImageCardTypeRef.value ? (h(NUploadDragger, null, {
                  default: () => resolveSlot(slots.default, () => [
                      h(NBaseIcon, { clsPrefix: mergedClsPrefix }, { default: () => h(AddIcon, null) })
                  ])
              })) : (slots)));
          };
      }
  });

  var NUploadProgress = defineComponent({
      name: 'UploadProgress',
      props: {
          show: Boolean,
          percentage: {
              type: Number,
              required: true
          },
          status: {
              type: String,
              required: true
          }
      },
      setup() {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NUpload = inject(uploadInjectionKey);
          return {
              mergedTheme: NUpload.mergedThemeRef
          };
      },
      render() {
          return (h(NFadeInExpandTransition, null, {
              default: () => this.show ? (h(NProgress, { type: "line", showIndicator: false, percentage: this.percentage, status: this.status, height: 2, theme: this.mergedTheme.peers.Progress, themeOverrides: this.mergedTheme.peerOverrides.Progress })) : null
          }));
      }
  });

  /**
   * Since image is too large compared with normal icons, we keep it inside upload
   * now.
   */
  const imageIcon = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" },
      h("g", { fill: "none" },
          h("path", { d: "M21.75 3A3.25 3.25 0 0 1 25 6.25v15.5A3.25 3.25 0 0 1 21.75 25H6.25A3.25 3.25 0 0 1 3 21.75V6.25A3.25 3.25 0 0 1 6.25 3h15.5zm.583 20.4l-7.807-7.68a.75.75 0 0 0-.968-.07l-.084.07l-7.808 7.68c.183.065.38.1.584.1h15.5c.204 0 .4-.035.583-.1l-7.807-7.68l7.807 7.68zM21.75 4.5H6.25A1.75 1.75 0 0 0 4.5 6.25v15.5c0 .208.036.408.103.593l7.82-7.692a2.25 2.25 0 0 1 3.026-.117l.129.117l7.82 7.692c.066-.185.102-.385.102-.593V6.25a1.75 1.75 0 0 0-1.75-1.75zm-3.25 3a2.5 2.5 0 1 1 0 5a2.5 2.5 0 0 1 0-5zm0 1.5a1 1 0 1 0 0 2a1 1 0 0 0 0-2z", fill: "currentColor" }))));
  const documentIcon = (h("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 28 28" },
      h("g", { fill: "none" },
          h("path", { d: "M6.4 2A2.4 2.4 0 0 0 4 4.4v19.2A2.4 2.4 0 0 0 6.4 26h15.2a2.4 2.4 0 0 0 2.4-2.4V11.578c0-.729-.29-1.428-.805-1.944l-6.931-6.931A2.4 2.4 0 0 0 14.567 2H6.4zm-.9 2.4a.9.9 0 0 1 .9-.9H14V10a2 2 0 0 0 2 2h6.5v11.6a.9.9 0 0 1-.9.9H6.4a.9.9 0 0 1-.9-.9V4.4zm16.44 6.1H16a.5.5 0 0 1-.5-.5V4.06l6.44 6.44z", fill: "currentColor" }))));

  var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  const buttonThemeOverrides = {
      paddingMedium: '0 3px',
      heightMedium: '24px',
      iconSizeMedium: '18px'
  };
  var NUploadFile = defineComponent({
      name: 'UploadFile',
      props: {
          clsPrefix: {
              type: String,
              required: true
          },
          file: {
              type: Object,
              required: true
          },
          listType: {
              type: String,
              required: true
          }
      },
      setup(props) {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          const NUpload = inject(uploadInjectionKey);
          const imageRef = ref(null);
          const thumbnailUrlRef = ref('');
          const progressStatusRef = computed(() => {
              const { file } = props;
              if (file.status === 'finished')
                  return 'success';
              if (file.status === 'error')
                  return 'error';
              return 'info';
          });
          const buttonTypeRef = computed(() => {
              const { file } = props;
              if (file.status === 'error')
                  return 'error';
              return undefined;
          });
          const showProgressRef = computed(() => {
              const { file } = props;
              return file.status === 'uploading';
          });
          const showCancelButtonRef = computed(() => {
              if (!NUpload.showCancelButtonRef.value)
                  return false;
              const { file } = props;
              return ['uploading', 'pending', 'error'].includes(file.status);
          });
          const showRemoveButtonRef = computed(() => {
              if (!NUpload.showRemoveButtonRef.value)
                  return false;
              const { file } = props;
              return ['finished'].includes(file.status);
          });
          const showDownloadButtonRef = computed(() => {
              if (!NUpload.showDownloadButtonRef.value)
                  return false;
              const { file } = props;
              return ['finished'].includes(file.status);
          });
          const showRetryButtonRef = computed(() => {
              if (!NUpload.showRetryButtonRef.value)
                  return false;
              const { file } = props;
              return ['error'].includes(file.status);
          });
          const mergedThumbnailUrlRef = useMemo(() => {
              return thumbnailUrlRef.value || props.file.thumbnailUrl || props.file.url;
          });
          const showPreviewButtonRef = computed(() => {
              if (!NUpload.showPreviewButtonRef.value)
                  return false;
              const { file: { status }, listType } = props;
              return (['finished'].includes(status) &&
                  mergedThumbnailUrlRef.value &&
                  listType === 'image-card');
          });
          function handleRetryClick() {
              NUpload.submit(props.file.id);
          }
          function handleRemoveOrCancelClick(e) {
              e.preventDefault();
              const { file } = props;
              if (['finished', 'pending', 'error'].includes(file.status)) {
                  handleRemove(file);
              }
              else if (['uploading'].includes(file.status)) {
                  handleAbort(file);
              }
              else {
                  warn$2('upload', 'The button clicked type is unknown.');
              }
          }
          function handleDownloadClick(e) {
              e.preventDefault();
              handleDownload(props.file);
          }
          function handleRemove(file) {
              const { xhrMap, doChange, onRemoveRef: { value: onRemove }, mergedFileListRef: { value: mergedFileList } } = NUpload;
              void Promise.resolve(onRemove
                  ? onRemove({
                      file: Object.assign({}, file),
                      fileList: mergedFileList
                  })
                  : true).then((result) => {
                  if (result === false)
                      return;
                  const fileAfterChange = Object.assign({}, file, {
                      status: 'removed'
                  });
                  xhrMap.delete(file.id);
                  doChange(fileAfterChange, undefined, {
                      remove: true
                  });
              });
          }
          function handleDownload(file) {
              const { onDownloadRef: { value: onDownload } } = NUpload;
              void Promise.resolve(onDownload ? onDownload(Object.assign({}, file)) : true).then((res) => {
                  if (res !== false) {
                      download(file.url, file.name);
                  }
              });
          }
          function handleAbort(file) {
              const { xhrMap } = NUpload;
              const xhr = xhrMap.get(file.id);
              xhr === null || xhr === void 0 ? void 0 : xhr.abort();
              handleRemove(Object.assign({}, file));
          }
          function handlePreviewClick() {
              const { onPreviewRef: { value: onPreview } } = NUpload;
              if (onPreview) {
                  onPreview(props.file);
              }
              else if (props.listType === 'image-card') {
                  const { value } = imageRef;
                  if (!value)
                      return;
                  value.click();
              }
          }
          const deriveFileThumbnailUrl = () => __awaiter$1(this, void 0, void 0, function* () {
              const { listType } = props;
              if (listType !== 'image' && listType !== 'image-card') {
                  return;
              }
              if (NUpload.shouldUseThumbnailUrlRef.value(props.file)) {
                  thumbnailUrlRef.value = yield NUpload.getFileThumbnailUrlResolver(props.file);
              }
          });
          watchEffect(() => {
              void deriveFileThumbnailUrl();
          });
          return {
              mergedTheme: NUpload.mergedThemeRef,
              progressStatus: progressStatusRef,
              buttonType: buttonTypeRef,
              showProgress: showProgressRef,
              disabled: NUpload.mergedDisabledRef,
              showCancelButton: showCancelButtonRef,
              showRemoveButton: showRemoveButtonRef,
              showDownloadButton: showDownloadButtonRef,
              showRetryButton: showRetryButtonRef,
              showPreviewButton: showPreviewButtonRef,
              mergedThumbnailUrl: mergedThumbnailUrlRef,
              shouldUseThumbnailUrl: NUpload.shouldUseThumbnailUrlRef,
              renderIcon: NUpload.renderIconRef,
              imageRef,
              handleRemoveOrCancelClick,
              handleDownloadClick,
              handleRetryClick,
              handlePreviewClick
          };
      },
      render() {
          const { clsPrefix, mergedTheme, listType, file, renderIcon } = this;
          // if there is text list type, show file icon
          let icon;
          const isImageType = listType === 'image';
          const isImageCardType = listType === 'image-card';
          if (isImageType || isImageCardType) {
              icon =
                  !this.shouldUseThumbnailUrl(file) || !this.mergedThumbnailUrl ? (h("span", { class: `${clsPrefix}-upload-file-info__thumbnail` }, renderIcon ? (renderIcon(file)) : isImageFile(file) ? (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => imageIcon })) : (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => documentIcon })))) : (h("a", { rel: "noopener noreferer", target: "_blank", href: file.url || undefined, class: `${clsPrefix}-upload-file-info__thumbnail`, onClick: this.handlePreviewClick }, listType === 'image-card' ? (h(NImage, { src: this.mergedThumbnailUrl || undefined, previewSrc: file.url || undefined, alt: file.name, ref: "imageRef" })) : (h("img", { src: this.mergedThumbnailUrl || undefined, alt: file.name }))));
          }
          else {
              icon = (h("span", { class: `${clsPrefix}-upload-file-info__thumbnail` }, renderIcon ? (renderIcon(file)) : (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => h(AttachIcon, null) }))));
          }
          const progress = (h(NUploadProgress, { show: this.showProgress, percentage: file.percentage || 0, status: this.progressStatus }));
          const showName = listType === 'text' || listType === 'image';
          return (h("div", { class: [
                  `${clsPrefix}-upload-file`,
                  `${clsPrefix}-upload-file--${this.progressStatus}-status`,
                  file.url &&
                      file.status !== 'error' &&
                      listType !== 'image-card' &&
                      `${clsPrefix}-upload-file--with-url`,
                  `${clsPrefix}-upload-file--${listType}-type`
              ] },
              h("div", { class: `${clsPrefix}-upload-file-info` },
                  icon,
                  h("div", { class: `${clsPrefix}-upload-file-info__name` },
                      showName &&
                          (file.url && file.status !== 'error' ? (h("a", { rel: "noopener noreferer", target: "_blank", href: file.url || undefined, onClick: this.handlePreviewClick }, file.name)) : (h("span", { onClick: this.handlePreviewClick }, file.name))),
                      isImageType && progress),
                  h("div", { class: [
                          `${clsPrefix}-upload-file-info__action`,
                          `${clsPrefix}-upload-file-info__action--${listType}-type`
                      ] },
                      this.showPreviewButton ? (h(NButton, { key: "preview", quaternary: true, type: this.buttonType, onClick: this.handlePreviewClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                          icon: () => (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => h(EyeIcon, null) }))
                      })) : null,
                      (this.showRemoveButton || this.showCancelButton) &&
                          !this.disabled && (h(NButton, { key: "cancelOrTrash", theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, quaternary: true, builtinThemeOverrides: buttonThemeOverrides, type: this.buttonType, onClick: this.handleRemoveOrCancelClick }, {
                          icon: () => (h(NIconSwitchTransition, null, {
                              default: () => this.showRemoveButton ? (h(NBaseIcon, { clsPrefix: clsPrefix, key: "trash" }, { default: () => h(TrashIcon, null) })) : (h(NBaseIcon, { clsPrefix: clsPrefix, key: "cancel" }, { default: () => h(CancelIcon, null) }))
                          }))
                      })),
                      this.showRetryButton && !this.disabled && (h(NButton, { key: "retry", quaternary: true, type: this.buttonType, onClick: this.handleRetryClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                          icon: () => (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => h(RetryIcon, null) }))
                      })),
                      this.showDownloadButton ? (h(NButton, { key: "download", quaternary: true, type: this.buttonType, onClick: this.handleDownloadClick, theme: mergedTheme.peers.Button, themeOverrides: mergedTheme.peerOverrides.Button, builtinThemeOverrides: buttonThemeOverrides }, {
                          icon: () => (h(NBaseIcon, { clsPrefix: clsPrefix }, { default: () => h(DownloadIcon, null) }))
                      })) : null)),
              !isImageType && progress));
      }
  });

  var NUploadFileList = defineComponent({
      name: 'UploadFileList',
      setup(_, { slots }) {
          const NUpload = inject(uploadInjectionKey, null);
          if (!NUpload) {
              throwError('upload-file-list', '`n-upload-file-list` must be placed inside `n-upload`.');
          }
          const { abstractRef, mergedClsPrefixRef, listTypeRef, mergedFileListRef, fileListClassRef, fileListStyleRef, cssVarsRef, themeClassRef, maxReachedRef, showTriggerRef, imageGroupPropsRef } = NUpload;
          const isImageCardTypeRef = computed(() => listTypeRef.value === 'image-card');
          const renderFileList = () => mergedFileListRef.value.map((file) => (h(NUploadFile, { clsPrefix: mergedClsPrefixRef.value, key: file.id, file: file, listType: listTypeRef.value })));
          const renderUploadFileList = () => isImageCardTypeRef.value ? (h(NImageGroup, Object.assign({}, imageGroupPropsRef.value), { default: renderFileList })) : (h(NFadeInExpandTransition, { group: true }, {
              default: renderFileList
          }));
          return () => {
              const { value: mergedClsPrefix } = mergedClsPrefixRef;
              const { value: abstract } = abstractRef;
              return (h("div", { class: [
                      `${mergedClsPrefix}-upload-file-list`,
                      isImageCardTypeRef.value &&
                          `${mergedClsPrefix}-upload-file-list--grid`,
                      abstract ? themeClassRef === null || themeClassRef === void 0 ? void 0 : themeClassRef.value : undefined,
                      fileListClassRef.value
                  ], style: [
                      abstract && cssVarsRef ? cssVarsRef.value : '',
                      fileListStyleRef.value
                  ] },
                  renderUploadFileList(),
                  showTriggerRef.value &&
                      !maxReachedRef.value &&
                      isImageCardTypeRef.value && (h(NUploadTrigger, null, slots))));
          };
      }
  });

  var style$1 = c$1([cB('upload', 'width: 100%;', [cM('dragger-inside', [cB('upload-trigger', `
 display: block;
 `)]), cM('drag-over', [cB('upload-dragger', `
 border: var(--n-dragger-border-hover);
 `)])]), cB('upload-dragger', `
 cursor: pointer;
 box-sizing: border-box;
 width: 100%;
 text-align: center;
 border-radius: var(--n-border-radius);
 padding: 24px;
 opacity: 1;
 transition:
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 background-color: var(--n-dragger-color);
 border: var(--n-dragger-border);
 `, [c$1('&:hover', `
 border: var(--n-dragger-border-hover);
 `), cM('disabled', `
 cursor: not-allowed;
 `)]), cB('upload-trigger', `
 display: inline-block;
 box-sizing: border-box;
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1('+', [cB('upload-file-list', 'margin-top: 8px;')]), cM('disabled', `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `), cM('image-card', `
 width: 96px;
 height: 96px;
 `, [cB('base-icon', `
 font-size: 24px;
 `), cB('upload-dragger', `
 padding: 0;
 height: 100%;
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `)])]), cB('upload-file-list', `
 line-height: var(--n-line-height);
 opacity: 1;
 transition: opacity .3s var(--n-bezier);
 `, [c$1('a, img', 'outline: none;'), cM('disabled', `
 opacity: var(--n-item-disabled-opacity);
 cursor: not-allowed;
 `, [cB('upload-file', 'cursor: not-allowed;')]), cM('grid', `
 display: grid;
 grid-template-columns: repeat(auto-fill, 96px);
 grid-gap: 8px;
 margin-top: 0;
 `), cB('upload-file', `
 display: block;
 box-sizing: border-box;
 cursor: default;
 padding: 0px 12px 0 6px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `, [fadeInHeightExpandTransition(), cB('progress', [fadeInHeightExpandTransition({
    foldPadding: true
  })]), c$1('&:hover', `
 background-color: var(--n-item-color-hover);
 `, [cB('upload-file-info', [cE('action', `
 opacity: 1;
 `)])]), cM('image-type', `
 border-radius: var(--n-border-radius);
 text-decoration: underline;
 text-decoration-color: #0000;
 `, [cB('upload-file-info', `
 padding-top: 0px;
 padding-bottom: 0px;
 width: 100%;
 height: 100%;
 display: flex;
 justify-content: space-between;
 align-items: center;
 padding: 6px 0;
 `, [cB('progress', `
 padding: 2px 0;
 margin-bottom: 0;
 `), cE('name', `
 padding: 0 8px;
 `), cE('thumbnail', `
 width: 32px;
 height: 32px;
 font-size: 28px;
 display: flex;
 justify-content: center;
 align-items: center;
 `, [c$1('img', `
 width: 100%;
 `)])])]), cM('text-type', [cB('progress', `
 box-sizing: border-box;
 padding-bottom: 6px;
 margin-bottom: 6px;
 `)]), cM('image-card-type', `
 position: relative;
 width: 96px;
 height: 96px;
 border: var(--n-item-border-image-card);
 border-radius: var(--n-border-radius);
 padding: 0;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: border-color .3s var(--n-bezier), background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 overflow: hidden;
 `, [cB('progress', `
 position: absolute;
 left: 8px;
 bottom: 8px;
 right: 8px;
 width: unset;
 `), cB('upload-file-info', `
 padding: 0;
 width: 100%;
 height: 100%;
 `, [cE('thumbnail', `
 width: 100%;
 height: 100%;
 display: flex;
 flex-direction: column;
 align-items: center;
 justify-content: center;
 font-size: 36px;
 `, [c$1('img', `
 width: 100%;
 `)])]), c$1('&::before', `
 position: absolute;
 z-index: 1;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 opacity: 0;
 transition: opacity .2s var(--n-bezier);
 content: "";
 `), c$1('&:hover', [c$1('&::before', 'opacity: 1;'), cB('upload-file-info', [cE('thumbnail', 'opacity: .12;')])])]), cM('error-status', [c$1('&:hover', `
 background-color: var(--n-item-color-hover-error);
 `), cB('upload-file-info', [cE('name', 'color: var(--n-item-text-color-error);'), cE('thumbnail', 'color: var(--n-item-text-color-error);')]), cM('image-card-type', `
 border: var(--n-item-border-image-card-error);
 `)]), cM('with-url', `
 cursor: pointer;
 `, [cB('upload-file-info', [cE('name', `
 color: var(--n-item-text-color-success);
 text-decoration-color: var(--n-item-text-color-success);
 `, [c$1('a', `
 text-decoration: underline;
 `)])])]), cB('upload-file-info', `
 position: relative;
 padding-top: 6px;
 padding-bottom: 6px;
 display: flex;
 flex-wrap: nowrap;
 `, [cE('thumbnail', `
 font-size: 18px;
 opacity: 1;
 transition: opacity .2s var(--n-bezier);
 color: var(--n-item-icon-color);
 `, [cB('base-icon', `
 margin-right: 2px;
 vertical-align: middle;
 transition: color .3s var(--n-bezier);
 `)]), cE('action', `
 padding-top: inherit;
 padding-bottom: inherit;
 position: absolute;
 right: 0;
 top: 0;
 bottom: 0;
 width: 80px;
 display: flex;
 align-items: center;
 transition: opacity .2s var(--n-bezier);
 justify-content: flex-end;
 opacity: 0;
 `, [cB('button', [c$1('&:not(:last-child)', {
    marginRight: '4px'
  }), cB('base-icon', [c$1('svg', [iconSwitchTransition()])])]), cM('image-type', `
 position: relative;
 max-width: 80px;
 width: auto;
 `), cM('image-card-type', `
 z-index: 2;
 position: absolute;
 width: 100%;
 height: 100%;
 left: 0;
 right: 0;
 bottom: 0;
 top: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 `)]), cE('name', `
 color: var(--n-item-text-color);
 flex: 1;
 display: flex;
 justify-content: center;
 text-overflow: ellipsis;
 overflow: hidden;
 flex-direction: column;
 text-decoration-color: #0000;
 font-size: var(--n-font-size);
 transition:
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier); 
 `, [c$1('a', `
 color: inherit;
 text-decoration: underline;
 `)])])])]), cB('upload-file-input', `
 display: block;
 width: 0;
 height: 0;
 opacity: 0;
 `)]);

  var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  /**
   * fils status ['pending', 'uploading', 'finished', 'removed', 'error']
   */
  function createXhrHandlers(inst, file, xhr) {
      const { doChange, xhrMap } = inst;
      let percentage = 0;
      function handleXHRError(e) {
          var _a;
          let fileAfterChange = Object.assign({}, file, {
              status: 'error',
              percentage
          });
          xhrMap.delete(file.id);
          fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange, event: e })) || fileAfterChange);
          doChange(fileAfterChange, e);
      }
      function handleXHRLoad(e) {
          var _a;
          if (inst.isErrorState) {
              if (inst.isErrorState(xhr)) {
                  handleXHRError(e);
                  return;
              }
          }
          else {
              if (xhr.status < 200 || xhr.status >= 300) {
                  handleXHRError(e);
                  return;
              }
          }
          let fileAfterChange = Object.assign({}, file, {
              status: 'finished',
              percentage
          });
          xhrMap.delete(file.id);
          fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange, event: e })) || fileAfterChange);
          doChange(fileAfterChange, e);
      }
      return {
          handleXHRLoad,
          handleXHRError,
          handleXHRAbort(e) {
              const fileAfterChange = Object.assign({}, file, {
                  status: 'removed',
                  file: null,
                  percentage
              });
              xhrMap.delete(file.id);
              doChange(fileAfterChange, e);
          },
          handleXHRProgress(e) {
              const fileAfterChange = Object.assign({}, file, {
                  status: 'uploading'
              });
              if (e.lengthComputable) {
                  const progress = Math.ceil((e.loaded / e.total) * 100);
                  fileAfterChange.percentage = progress;
                  percentage = progress;
              }
              doChange(fileAfterChange, e);
          }
      };
  }
  function customSubmitImpl(options) {
      const { inst, file, data, headers, withCredentials, action, customRequest } = options;
      const { doChange } = options.inst;
      let percentage = 0;
      customRequest({
          file,
          data,
          headers,
          withCredentials,
          action,
          onProgress(event) {
              const fileAfterChange = Object.assign({}, file, {
                  status: 'uploading'
              });
              const progress = event.percent;
              fileAfterChange.percentage = progress;
              percentage = progress;
              doChange(fileAfterChange);
          },
          onFinish() {
              var _a;
              let fileAfterChange = Object.assign({}, file, {
                  status: 'finished',
                  percentage
              });
              fileAfterChange = createSettledFileInfo(((_a = inst.onFinish) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange })) || fileAfterChange);
              doChange(fileAfterChange);
          },
          onError() {
              var _a;
              let fileAfterChange = Object.assign({}, file, {
                  status: 'error',
                  percentage
              });
              fileAfterChange = createSettledFileInfo(((_a = inst.onError) === null || _a === void 0 ? void 0 : _a.call(inst, { file: fileAfterChange })) || fileAfterChange);
              doChange(fileAfterChange);
          }
      });
  }
  function registerHandler(inst, file, request) {
      const handlers = createXhrHandlers(inst, file, request);
      request.onabort = handlers.handleXHRAbort;
      request.onerror = handlers.handleXHRError;
      request.onload = handlers.handleXHRLoad;
      if (request.upload) {
          request.upload.onprogress = handlers.handleXHRProgress;
      }
  }
  function unwrapFunctionValue(data, file) {
      if (typeof data === 'function') {
          return data({ file });
      }
      if (data)
          return data;
      return {};
  }
  function setHeaders(request, headers, file) {
      const headersObject = unwrapFunctionValue(headers, file);
      if (!headersObject)
          return;
      Object.keys(headersObject).forEach((key) => {
          request.setRequestHeader(key, headersObject[key]);
      });
  }
  function appendData(formData, data, file) {
      const dataObject = unwrapFunctionValue(data, file);
      if (!dataObject)
          return;
      Object.keys(dataObject).forEach((key) => {
          formData.append(key, dataObject[key]);
      });
  }
  function submitImpl(inst, fieldName, file, { method, action, withCredentials, responseType, headers, data }) {
      const request = new XMLHttpRequest();
      request.responseType = responseType;
      inst.xhrMap.set(file.id, request);
      request.withCredentials = withCredentials;
      const formData = new FormData();
      appendData(formData, data, file);
      if (file.file !== null) {
          formData.append(fieldName, file.file);
      }
      registerHandler(inst, file, request);
      if (action !== undefined) {
          request.open(method.toUpperCase(), action);
          setHeaders(request, headers, file);
          request.send(formData);
          const fileAfterChange = Object.assign({}, file, {
              status: 'uploading'
          });
          inst.doChange(fileAfterChange);
      }
  }
  const uploadProps = Object.assign(Object.assign({}, useTheme.props), { name: {
          type: String,
          default: 'file'
      }, accept: String, action: String, customRequest: Function, directory: Boolean, directoryDnd: { type: Boolean, default: undefined }, method: {
          type: String,
          default: 'POST'
      }, multiple: Boolean, showFileList: {
          type: Boolean,
          default: true
      }, data: [Object, Function], headers: [Object, Function], withCredentials: Boolean, responseType: {
          type: String,
          default: ''
      }, disabled: {
          type: Boolean,
          default: undefined
      }, onChange: Function, onRemove: Function, onFinish: Function, onError: Function, onBeforeUpload: Function, isErrorState: Function, 
      /** currently not used */
      onDownload: Function, defaultUpload: {
          type: Boolean,
          default: true
      }, fileList: Array, 'onUpdate:fileList': [Function, Array], onUpdateFileList: [Function, Array], fileListClass: String, fileListStyle: [String, Object], defaultFileList: {
          type: Array,
          default: () => []
      }, showCancelButton: {
          type: Boolean,
          default: true
      }, showRemoveButton: {
          type: Boolean,
          default: true
      }, showDownloadButton: Boolean, showRetryButton: {
          type: Boolean,
          default: true
      }, showPreviewButton: {
          type: Boolean,
          default: true
      }, listType: {
          type: String,
          default: 'text'
      }, onPreview: Function, shouldUseThumbnailUrl: {
          type: Function,
          default: (file) => {
              if (!environmentSupportFile)
                  return false;
              return isImageFile(file);
          }
      }, createThumbnailUrl: Function, abstract: Boolean, max: Number, showTrigger: {
          type: Boolean,
          default: true
      }, imageGroupProps: Object, inputProps: Object, triggerClass: String, triggerStyle: [String, Object], renderIcon: Function });
  var Upload = defineComponent({
      name: 'Upload',
      props: uploadProps,
      setup(props) {
          if (props.abstract && props.listType === 'image-card') {
              throwError('upload', 'when the list-type is image-card, abstract is not supported.');
          }
          const { mergedClsPrefixRef, inlineThemeDisabled } = useConfig(props);
          const themeRef = useTheme('Upload', '-upload', style$1, uploadLight$1, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const maxReachedRef = computed(() => {
              const { max } = props;
              if (max !== undefined) {
                  return mergedFileListRef.value.length >= max;
              }
              return false;
          });
          const uncontrolledFileListRef = ref(props.defaultFileList);
          const controlledFileListRef = toRef(props, 'fileList');
          const inputElRef = ref(null);
          const draggerInsideRef = {
              value: false
          };
          const dragOverRef = ref(false);
          const xhrMap = new Map();
          const _mergedFileListRef = useMergedState(controlledFileListRef, uncontrolledFileListRef);
          const mergedFileListRef = computed(() => _mergedFileListRef.value.map(createSettledFileInfo));
          function openOpenFileDialog() {
              var _a;
              (_a = inputElRef.value) === null || _a === void 0 ? void 0 : _a.click();
          }
          function handleFileInputChange(e) {
              const target = e.target;
              handleFileAddition(target.files
                  ? Array.from(target.files).map((file) => ({
                      file,
                      entry: null,
                      source: 'input'
                  }))
                  : null, e);
              // May have bug! set to null?
              target.value = '';
          }
          function doUpdateFileList(files) {
              const { 'onUpdate:fileList': _onUpdateFileList, onUpdateFileList } = props;
              if (_onUpdateFileList)
                  call(_onUpdateFileList, files);
              if (onUpdateFileList)
                  call(onUpdateFileList, files);
              uncontrolledFileListRef.value = files;
          }
          const mergedMultipleRef = computed(() => props.multiple || props.directory);
          function handleFileAddition(fileAndEntries, e) {
              if (!fileAndEntries || fileAndEntries.length === 0)
                  return;
              const { onBeforeUpload } = props;
              fileAndEntries = mergedMultipleRef.value
                  ? fileAndEntries
                  : [fileAndEntries[0]];
              const { max, accept } = props;
              fileAndEntries = fileAndEntries.filter(({ file, source }) => {
                  if (source === 'dnd' && (accept === null || accept === void 0 ? void 0 : accept.trim())) {
                      return matchType(file.name, file.type, accept);
                  }
                  else {
                      return true;
                  }
              });
              if (max) {
                  fileAndEntries = fileAndEntries.slice(0, max - mergedFileListRef.value.length);
              }
              const batchId = createId();
              void Promise.all(fileAndEntries.map(({ file, entry }) => __awaiter(this, void 0, void 0, function* () {
                  var _a;
                  const fileInfo = {
                      id: createId(),
                      batchId,
                      name: file.name,
                      status: 'pending',
                      percentage: 0,
                      file,
                      url: null,
                      type: file.type,
                      thumbnailUrl: null,
                      fullPath: (_a = entry === null || entry === void 0 ? void 0 : entry.fullPath) !== null && _a !== void 0 ? _a : `/${file.webkitRelativePath || file.name}`
                  };
                  if (!onBeforeUpload ||
                      (yield onBeforeUpload({
                          file: fileInfo,
                          fileList: mergedFileListRef.value
                      })) !== false) {
                      return fileInfo;
                  }
                  return null;
              })))
                  .then((fileInfos) => __awaiter(this, void 0, void 0, function* () {
                  let nextTickChain = Promise.resolve();
                  fileInfos.forEach((fileInfo) => {
                      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                      nextTickChain = nextTickChain.then(nextTick).then(() => {
                          fileInfo &&
                              doChange(fileInfo, e, {
                                  append: true
                              });
                      });
                  });
                  yield nextTickChain;
              }))
                  .then(() => {
                  if (props.defaultUpload) {
                      submit();
                  }
              });
          }
          function submit(fileId) {
              const { method, action, withCredentials, headers, data, name: fieldName } = props;
              const filesToUpload = fileId !== undefined
                  ? mergedFileListRef.value.filter((file) => file.id === fileId)
                  : mergedFileListRef.value;
              const shouldReupload = fileId !== undefined;
              filesToUpload.forEach((file) => {
                  const { status } = file;
                  if (status === 'pending' || (status === 'error' && shouldReupload)) {
                      if (props.customRequest) {
                          customSubmitImpl({
                              inst: {
                                  doChange,
                                  xhrMap,
                                  onFinish: props.onFinish,
                                  onError: props.onError
                              },
                              file,
                              action,
                              withCredentials,
                              headers,
                              data,
                              customRequest: props.customRequest
                          });
                      }
                      else {
                          submitImpl({
                              doChange,
                              xhrMap,
                              onFinish: props.onFinish,
                              onError: props.onError,
                              isErrorState: props.isErrorState
                          }, fieldName, file, {
                              method,
                              action,
                              withCredentials,
                              responseType: props.responseType,
                              headers,
                              data
                          });
                      }
                  }
              });
          }
          const doChange = (fileAfterChange, event, options = {
              append: false,
              remove: false
          }) => {
              const { append, remove } = options;
              const fileListAfterChange = Array.from(mergedFileListRef.value);
              const fileIndex = fileListAfterChange.findIndex((file) => file.id === fileAfterChange.id);
              if (append || remove || ~fileIndex) {
                  if (append) {
                      fileListAfterChange.push(fileAfterChange);
                  }
                  else if (remove) {
                      fileListAfterChange.splice(fileIndex, 1);
                  }
                  else {
                      fileListAfterChange.splice(fileIndex, 1, fileAfterChange);
                  }
                  const { onChange } = props;
                  if (onChange) {
                      onChange({
                          file: fileAfterChange,
                          fileList: fileListAfterChange,
                          event
                      });
                  }
                  doUpdateFileList(fileListAfterChange);
              }
          };
          function getFileThumbnailUrlResolver(file) {
              var _a;
              if (file.thumbnailUrl)
                  return file.thumbnailUrl;
              const { createThumbnailUrl } = props;
              if (createThumbnailUrl) {
                  return (_a = createThumbnailUrl(file.file, file)) !== null && _a !== void 0 ? _a : (file.url || '');
              }
              if (file.url) {
                  return file.url;
              }
              else if (file.file) {
                  return createImageDataUrl(file.file);
              }
              return '';
          }
          const cssVarsRef = computed(() => {
              const { common: { cubicBezierEaseInOut }, self: { draggerColor, draggerBorder, draggerBorderHover, itemColorHover, itemColorHoverError, itemTextColorError, itemTextColorSuccess, itemTextColor, itemIconColor, itemDisabledOpacity, lineHeight, borderRadius, fontSize, itemBorderImageCardError, itemBorderImageCard } } = themeRef.value;
              return {
                  '--n-bezier': cubicBezierEaseInOut,
                  '--n-border-radius': borderRadius,
                  '--n-dragger-border': draggerBorder,
                  '--n-dragger-border-hover': draggerBorderHover,
                  '--n-dragger-color': draggerColor,
                  '--n-font-size': fontSize,
                  '--n-item-color-hover': itemColorHover,
                  '--n-item-color-hover-error': itemColorHoverError,
                  '--n-item-disabled-opacity': itemDisabledOpacity,
                  '--n-item-icon-color': itemIconColor,
                  '--n-item-text-color': itemTextColor,
                  '--n-item-text-color-error': itemTextColorError,
                  '--n-item-text-color-success': itemTextColorSuccess,
                  '--n-line-height': lineHeight,
                  '--n-item-border-image-card-error': itemBorderImageCardError,
                  '--n-item-border-image-card': itemBorderImageCard
              };
          });
          const themeClassHandle = inlineThemeDisabled
              ? useThemeClass('upload', undefined, cssVarsRef, props)
              : undefined;
          provide(uploadInjectionKey, {
              mergedClsPrefixRef,
              mergedThemeRef: themeRef,
              showCancelButtonRef: toRef(props, 'showCancelButton'),
              showDownloadButtonRef: toRef(props, 'showDownloadButton'),
              showRemoveButtonRef: toRef(props, 'showRemoveButton'),
              showRetryButtonRef: toRef(props, 'showRetryButton'),
              onRemoveRef: toRef(props, 'onRemove'),
              onDownloadRef: toRef(props, 'onDownload'),
              mergedFileListRef,
              triggerClassRef: toRef(props, 'triggerClass'),
              triggerStyleRef: toRef(props, 'triggerStyle'),
              shouldUseThumbnailUrlRef: toRef(props, 'shouldUseThumbnailUrl'),
              renderIconRef: toRef(props, 'renderIcon'),
              xhrMap,
              submit,
              doChange,
              showPreviewButtonRef: toRef(props, 'showPreviewButton'),
              onPreviewRef: toRef(props, 'onPreview'),
              getFileThumbnailUrlResolver,
              listTypeRef: toRef(props, 'listType'),
              dragOverRef,
              openOpenFileDialog,
              draggerInsideRef,
              handleFileAddition,
              mergedDisabledRef: formItem.mergedDisabledRef,
              maxReachedRef,
              fileListClassRef: toRef(props, 'fileListClass'),
              fileListStyleRef: toRef(props, 'fileListStyle'),
              abstractRef: toRef(props, 'abstract'),
              acceptRef: toRef(props, 'accept'),
              cssVarsRef: inlineThemeDisabled ? undefined : cssVarsRef,
              themeClassRef: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
              onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
              showTriggerRef: toRef(props, 'showTrigger'),
              imageGroupPropsRef: toRef(props, 'imageGroupProps'),
              mergedDirectoryDndRef: computed(() => {
                  var _a;
                  return (_a = props.directoryDnd) !== null && _a !== void 0 ? _a : props.directory;
              })
          });
          const exposedMethods = {
              clear: () => {
                  uncontrolledFileListRef.value = [];
              },
              submit,
              openOpenFileDialog
          };
          return Object.assign({ mergedClsPrefix: mergedClsPrefixRef, draggerInsideRef,
              inputElRef, mergedTheme: themeRef, dragOver: dragOverRef, mergedMultiple: mergedMultipleRef, cssVars: inlineThemeDisabled ? undefined : cssVarsRef, themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass, onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender, handleFileInputChange }, exposedMethods);
      },
      render() {
          var _a, _b;
          const { draggerInsideRef, mergedClsPrefix, $slots, directory, onRender } = this;
          if ($slots.default && !this.abstract) {
              const firstChild = $slots.default()[0];
              if ((_a = firstChild === null || firstChild === void 0 ? void 0 : firstChild.type) === null || _a === void 0 ? void 0 : _a[uploadDraggerKey]) {
                  draggerInsideRef.value = true;
              }
          }
          const inputNode = (h("input", Object.assign({}, this.inputProps, { ref: "inputElRef", type: "file", class: `${mergedClsPrefix}-upload-file-input`, accept: this.accept, multiple: this.mergedMultiple, onChange: this.handleFileInputChange, 
              // @ts-expect-error // seems vue-tsc will add the prop, so we can't use expect-error
              webkitdirectory: directory || undefined, directory: directory || undefined })));
          if (this.abstract) {
              return (h(Fragment, null, (_b = $slots.default) === null || _b === void 0 ? void 0 :
                  _b.call($slots),
                  h(Teleport, { to: "body" }, inputNode)));
          }
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return (h("div", { class: [
                  `${mergedClsPrefix}-upload`,
                  draggerInsideRef.value && `${mergedClsPrefix}-upload--dragger-inside`,
                  this.dragOver && `${mergedClsPrefix}-upload--drag-over`,
                  this.themeClass
              ], style: this.cssVars },
              inputNode,
              this.showTrigger && this.listType !== 'image-card' && (h(NUploadTrigger, null, $slots)),
              this.showFileList && h(NUploadFileList, null, $slots)));
      }
  });

  const virtualListProps = {
      scrollbarProps: Object,
      items: {
          type: Array,
          default: () => []
      },
      itemSize: {
          type: Number,
          required: true
      },
      itemResizable: Boolean,
      itemsStyle: [String, Object],
      visibleItemsTag: {
          type: [String, Object],
          default: 'div'
      },
      visibleItemsProps: Object,
      ignoreItemResize: Boolean,
      onScroll: Function,
      onWheel: Function,
      onResize: Function,
      defaultScrollKey: [Number, String],
      defaultScrollIndex: Number,
      keyField: {
          type: String,
          default: 'key'
      },
      paddingTop: {
          type: [Number, String],
          default: 0
      },
      paddingBottom: {
          type: [Number, String],
          default: 0
      }
  };
  var VirtualList = defineComponent({
      name: 'VirtualList',
      props: virtualListProps,
      setup(props) {
          const scrollbarInstRef = ref(null);
          const virtualListInstRef = ref(null);
          function syncScrollbar() {
              const { value: scrollbarInst } = scrollbarInstRef;
              if (scrollbarInst)
                  scrollbarInst.sync();
          }
          function handleScroll(e) {
              var _a;
              syncScrollbar();
              (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleResize(e) {
              var _a;
              syncScrollbar();
              (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleWheel(e) {
              var _a;
              (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function scrollTo(options, y) {
              var _a, _b;
              if (typeof options === 'number') {
                  (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(options, y !== null && y !== void 0 ? y : 0);
              }
              else {
                  (_b = virtualListInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(options);
              }
          }
          function getScrollContainer() {
              var _a;
              return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.listElRef;
          }
          function getScrollContent() {
              var _a;
              return (_a = virtualListInstRef.value) === null || _a === void 0 ? void 0 : _a.itemsElRef;
          }
          return {
              scrollTo,
              scrollbarInstRef,
              virtualListInstRef,
              getScrollContainer,
              getScrollContent,
              handleScroll,
              handleResize,
              handleWheel
          };
      },
      render() {
          return (h(XScrollbar, Object.assign({}, this.scrollbarProps, { ref: "scrollbarInstRef", container: this.getScrollContainer, content: this.getScrollContent }), {
              default: () => {
                  return (h(VVirtualList, { ref: "virtualListInstRef", showScrollbar: false, items: this.items, itemSize: this.itemSize, itemResizable: this.itemResizable, itemsStyle: this.itemsStyle, visibleItemsTag: this.visibleItemsTag, visibleItemsProps: this.visibleItemsProps, ignoreItemResize: this.ignoreItemResize, keyField: this.keyField, defaultScrollKey: this.defaultScrollKey, defaultScrollIndex: this.defaultScrollIndex, paddingTop: this.paddingTop, paddingBottom: this.paddingBottom, onScroll: this.handleScroll, onResize: this.handleResize, onWheel: this.handleWheel }, {
                      default: ({ item, index }) => { var _a, _b; return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a, { item, index }); }
                  }));
              }
          }));
      }
  });

  var style = c$1([cB('watermark-container', `
 position: relative;
 `, [cNotM('selectable', `
 user-select: none;
 -webkit-user-select: none;
 `), cM('global-rotate', `
 overflow: hidden;
 `), cM('fullscreen', `
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 position: fixed;
 `)]), cB('watermark', `
 position: absolute;
 top: 0;
 left: 0;
 width: 100%;
 height: 100%;
 pointer-events: none;
 background-repeat: repeat;
 `, [cM('fullscreen', `
 position: fixed;
 `), cM('global-rotate', `
 position: absolute;
 height: max(284vh, 284vw);
 width: max(284vh, 284vw);
 `)])]);

  function getRatio(context) {
      if (!context) {
          return 1;
      }
      const backingStore = context.backingStorePixelRatio ||
          context.webkitBackingStorePixelRatio ||
          context.mozBackingStorePixelRatio ||
          context.msBackingStorePixelRatio ||
          context.oBackingStorePixelRatio ||
          context.backingStorePixelRatio ||
          1;
      return (window.devicePixelRatio || 1) / backingStore;
  }
  const watermarkProps = Object.assign(Object.assign({}, useTheme.props), { debug: Boolean, cross: Boolean, fullscreen: Boolean, width: {
          type: Number,
          default: 32
      }, height: {
          type: Number,
          default: 32
      }, zIndex: {
          type: Number,
          default: 10
      }, xGap: {
          type: Number,
          default: 0
      }, yGap: {
          type: Number,
          default: 0
      }, yOffset: {
          type: Number,
          default: 0
      }, xOffset: {
          type: Number,
          default: 0
      }, rotate: {
          type: Number,
          default: 0
      }, image: String, imageOpacity: { type: Number, default: 1 }, imageHeight: Number, imageWidth: Number, content: String, selectable: {
          type: Boolean,
          default: true
      }, fontSize: {
          type: Number,
          default: 14
      }, fontFamily: String, fontStyle: {
          type: String,
          default: 'normal'
      }, fontVariant: {
          type: String,
          default: ''
      }, fontWeight: {
          type: Number,
          default: 400
      }, fontColor: {
          type: String,
          default: 'rgba(128, 128, 128, .3)'
      }, fontStretch: {
          type: String,
          default: ''
      }, lineHeight: {
          type: Number,
          default: 14
      }, globalRotate: {
          type: Number,
          default: 0
      } });
  var Watermark = defineComponent({
      name: 'Watermark',
      props: watermarkProps,
      setup(props, { slots }) {
          const { mergedClsPrefixRef } = useConfig(props);
          const themeRef = useTheme('Watermark', '-watermark', style, watermarkLight$1, props, mergedClsPrefixRef);
          const base64UrlRef = ref('');
          const canvas = isBrowser$2 ? document.createElement('canvas') : null;
          const ctx = canvas ? canvas.getContext('2d') : null;
          const fontsReadyRef = ref(false);
          onFontsReady(() => (fontsReadyRef.value = true));
          watchEffect(() => {
              if (!canvas)
                  return;
              void fontsReadyRef.value;
              const ratio = getRatio(ctx);
              const { xGap, yGap, width, height, yOffset, xOffset, rotate, image, content, fontColor, fontStyle, fontVariant, fontStretch, fontWeight, fontFamily, fontSize, lineHeight, debug } = props;
              const canvasWidth = (xGap + width) * ratio;
              const canvasHeight = (yGap + height) * ratio;
              const canvasOffsetLeft = xOffset * ratio;
              const canvasOffsetTop = yOffset * ratio;
              canvas.width = canvasWidth;
              canvas.height = canvasHeight;
              if (ctx) {
                  ctx.translate(0, 0);
                  const markWidth = width * ratio;
                  const markHeight = height * ratio;
                  if (debug) {
                      ctx.strokeStyle = 'grey';
                      ctx.strokeRect(0, 0, markWidth, markHeight);
                  }
                  ctx.rotate(rotate * (Math.PI / 180));
                  if (image) {
                      const img = new Image();
                      img.crossOrigin = 'anonymous';
                      img.referrerPolicy = 'no-referrer';
                      img.src = image;
                      img.onload = () => {
                          ctx.globalAlpha = props.imageOpacity;
                          const { imageWidth, imageHeight } = props;
                          ctx.drawImage(img, canvasOffsetLeft, canvasOffsetTop, (props.imageWidth ||
                              (imageHeight
                                  ? (img.width * imageHeight) / img.height
                                  : img.width)) * ratio, (props.imageHeight ||
                              (imageWidth
                                  ? (img.height * imageWidth) / img.width
                                  : img.height)) * ratio);
                          base64UrlRef.value = canvas.toDataURL();
                      };
                  }
                  else if (content) {
                      if (debug) {
                          ctx.strokeStyle = 'green';
                          ctx.strokeRect(0, 0, markWidth, markHeight);
                      }
                      ctx.font = `${fontStyle} ${fontVariant} ${fontWeight} ${fontStretch} ${fontSize * ratio}px/${lineHeight * ratio}px ${fontFamily || themeRef.value.self.fontFamily}`;
                      ctx.fillStyle = fontColor;
                      ctx.fillText(content, canvasOffsetLeft, canvasOffsetTop + lineHeight * ratio);
                      base64UrlRef.value = canvas.toDataURL();
                  }
                  else if (!content) {
                      // For example, you are using the input box to customize the watermark
                      // content, but after clearing the input box, the content is empty,
                      // and the canvas content is empty. Clear canvas when content is empty
                      ctx.clearRect(0, 0, canvas.width, canvas.height);
                      base64UrlRef.value = canvas.toDataURL();
                  }
              }
              else {
                  warnOnce('watermark', 'Canvas is not supported in the browser.');
              }
          });
          return () => {
              var _a;
              const { globalRotate, fullscreen, zIndex } = props;
              const mergedClsPrefix = mergedClsPrefixRef.value;
              const isFullScreenGlobalRotate = globalRotate !== 0 && fullscreen;
              const rotatedImageOffset = 'max(142vh, 142vw)';
              const watermarkNode = (h("div", { class: [
                      `${mergedClsPrefix}-watermark`,
                      globalRotate !== 0 && `${mergedClsPrefix}-watermark--global-rotate`,
                      fullscreen && `${mergedClsPrefix}-watermark--fullscreen`
                  ], style: {
                      transform: globalRotate
                          ? `translateX(-50%) translateY(-50%) rotate(${globalRotate}deg)`
                          : undefined,
                      zIndex: isFullScreenGlobalRotate ? undefined : zIndex,
                      backgroundSize: `${props.xGap + props.width}px`,
                      backgroundPosition: globalRotate === 0
                          ? props.cross
                              ? `${props.width / 2}px ${props.height / 2}px, 0 0`
                              : ''
                          : props.cross
                              ? `calc(${rotatedImageOffset} + ${props.width / 2}px) calc(${rotatedImageOffset} + ${props.height / 2}px), ${rotatedImageOffset} ${rotatedImageOffset}`
                              : rotatedImageOffset,
                      backgroundImage: props.cross
                          ? `url(${base64UrlRef.value}), url(${base64UrlRef.value})`
                          : `url(${base64UrlRef.value})`
                  } }));
              if (props.fullscreen && !globalRotate)
                  return watermarkNode;
              return (h("div", { class: [
                      `${mergedClsPrefix}-watermark-container`,
                      globalRotate !== 0 &&
                          `${mergedClsPrefix}-watermark-container--global-rotate`,
                      fullscreen && `${mergedClsPrefix}-watermark-container--fullscreen`,
                      props.selectable &&
                          `${mergedClsPrefix}-watermark-container--selectable`
                  ], style: {
                      zIndex: isFullScreenGlobalRotate ? zIndex : undefined
                  } }, (_a = slots.default) === null || _a === void 0 ? void 0 :
                  _a.call(slots),
                  watermarkNode));
          };
      }
  });

  const NInjectionExtractor = defineComponent({
      name: 'InjectionExtractor',
      props: {
          onSetup: Function
      },
      setup(props, { slots }) {
          var _a;
          (_a = props.onSetup) === null || _a === void 0 ? void 0 : _a.call(props);
          return () => { var _a; return (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots); };
      }
  });

  const injectionFactoryMap = {
      message: useMessage,
      notification: useNotification,
      loadingBar: useLoadingBar,
      dialog: useDialog
  };
  function createDiscreteApp({ providersAndProps, configProviderProps }) {
      const App = () => {
          return h(NConfigProvider, unref(configProviderProps), {
              default: () => providersAndProps.map(({ type, Provider, props }) => {
                  return h(Provider, unref(props), {
                      default: () => h(NInjectionExtractor, {
                          onSetup: () => (extractedApi[type] = injectionFactoryMap[type]())
                      })
                  });
              })
          });
      };
      let app = createApp(App);
      const extractedApi = {
          app
      };
      let hostEl;
      if (isBrowser$2) {
          hostEl = document.createElement('div');
          document.body.appendChild(hostEl);
          app.mount(hostEl);
      }
      const unmount = () => {
          var _a;
          if (app === null || hostEl === null) {
              warn$2('discrete', 'unmount call no need because discrete app has been unmounted');
              return;
          }
          app.unmount();
          (_a = hostEl.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(hostEl);
          hostEl = null;
          app = null;
      };
      return Object.assign({ unmount }, extractedApi);
  }

  function createDiscreteApi(includes, { configProviderProps, messageProviderProps, dialogProviderProps, notificationProviderProps, loadingBarProviderProps } = {}) {
      const providersAndProps = [];
      includes.forEach((type) => {
          switch (type) {
              case 'message':
                  providersAndProps.push({
                      type,
                      Provider: NMessageProvider,
                      props: messageProviderProps
                  });
                  break;
              case 'notification':
                  providersAndProps.push({
                      type,
                      Provider: NNotificationProvider,
                      props: notificationProviderProps
                  });
                  break;
              case 'dialog':
                  providersAndProps.push({
                      type,
                      Provider: NDialogProvider,
                      props: dialogProviderProps
                  });
                  break;
              case 'loadingBar':
                  providersAndProps.push({
                      type,
                      Provider: NLoadingBarProvider,
                      props: loadingBarProviderProps
                  });
                  break;
          }
      });
      const discreteApp = createDiscreteApp({
          providersAndProps,
          configProviderProps
      });
      return discreteApp;
  }

  const equationProps = {
      value: String,
      katex: Object,
      katexOptions: Object
  };
  const Equation = defineComponent({
      name: 'Equation',
      props: equationProps,
      setup(props) {
          const configProviderContext = inject(configProviderInjectionKey);
          const extractedHtmlInfo = computed(() => {
              var _a;
              const outerHtml = ((_a = (props.katex || (configProviderContext === null || configProviderContext === void 0 ? void 0 : configProviderContext.mergedKatexRef.value))) === null || _a === void 0 ? void 0 : _a.renderToString(props.value || '', Object.assign({ throwOnError: false }, props.katexOptions))) || 'no katex provided';
              const matchResult = outerHtml.match(/^<([a-z]+)[^>]+class="([^"]+)"[^>]*>/);
              const wrapperTag = (matchResult === null || matchResult === void 0 ? void 0 : matchResult[1]) || 'span';
              const wrapperClass = matchResult === null || matchResult === void 0 ? void 0 : matchResult[2];
              const innerHtml = outerHtml
                  .replace(/^<[a-z]+[^>]*>/, '')
                  .replace(/<\/[a-z]+>$/, '');
              return { wrapperTag, innerHtml, wrapperClass };
          });
          return () => {
              const { innerHtml, wrapperClass, wrapperTag } = extractedHtmlInfo.value;
              return h(wrapperTag, { class: wrapperClass, innerHTML: innerHtml });
          };
      }
  });

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    NA: a,
    NAffix: NAffix,
    NAlert: Alert,
    NAnchor: AnchorAdapter,
    NAnchorLink: Link,
    NAutoComplete: AutoComplete,
    NAvatar: NAvatar,
    NAvatarGroup: AvatarGroup,
    NBackTop: BackTop,
    NBadge: Badge,
    NBlockquote: blockquote,
    NBreadcrumb: Breadcrumb,
    NBreadcrumbItem: BreadcrumbItem,
    NButton: NButton,
    NButtonGroup: NButtonGroup,
    NCalendar: Calendar,
    NCard: NCard,
    NCarousel: Carousel,
    NCarouselItem: NCarouselItem,
    NCascader: Cascader,
    NCheckbox: NCheckbox,
    NCheckboxGroup: NCheckboxGroup,
    NCode: NCode,
    NCol: NCol,
    NCollapse: NCollapse,
    NCollapseItem: NCollapseItem,
    NCollapseTransition: CollapseTransition,
    NColorPicker: NColorPicker,
    NConfigProvider: NConfigProvider,
    NCountdown: Countdown,
    NDataTable: DataTable,
    NDatePicker: DatePicker,
    NDescriptions: Descriptions,
    NDescriptionsItem: DescriptionsItem,
    NDialog: NDialog,
    NDialogProvider: NDialogProvider,
    NDivider: NDivider,
    NDrawer: Drawer,
    NDrawerContent: DrawerContent,
    NDropdown: NDropdown,
    NDynamicInput: DynamicInput,
    NDynamicTags: DynamicTags,
    NEl: NElement,
    NElement: NElement,
    NEllipsis: NEllipsis,
    NEmpty: NEmpty,
    NEquation: Equation,
    NForm: Form,
    NFormItem: NFormItem,
    NFormItemCol: NFormItemCol,
    NFormItemGi: FormItemGridItem,
    NFormItemGridItem: FormItemGridItem,
    NFormItemRow: FormItemRow,
    NGi: NGi,
    NGlobalStyle: GlobalStyle,
    NGradientText: GradientText,
    NGrid: NGrid,
    NGridItem: NGi,
    NH1: NH1,
    NH2: NH2,
    NH3: NH3,
    NH4: NH4,
    NH5: NH5,
    NH6: NH6,
    NHr: hr,
    NIcon: NIcon,
    NIconWrapper: NIconWrapper,
    NImage: NImage,
    NImageGroup: NImageGroup,
    NInput: NInput,
    NInputGroup: NInputGroup,
    NInputGroupLabel: InputGroupLabel,
    NInputNumber: InputNumber,
    NLayout: Layout,
    NLayoutContent: LayoutContent,
    NLayoutFooter: LayoutFooter,
    NLayoutHeader: LayoutHeader,
    NLayoutSider: LayoutSider,
    NLegacyTransfer: Transfer$1,
    NLi: li,
    NList: List,
    NListItem: ListItem,
    NLoadingBarProvider: NLoadingBarProvider,
    NLog: Log,
    NMention: Mention,
    NMenu: Menu,
    NMessageProvider: NMessageProvider,
    NModal: NModal,
    NNotificationProvider: NNotificationProvider,
    NNumberAnimation: NumberAnimation,
    NOl: ol,
    NP: p,
    NPageHeader: PageHeader,
    NPagination: NPagination,
    NPerformantEllipsis: NPerformantEllipsis,
    NPopconfirm: Popconfirm,
    NPopover: NPopover,
    NPopselect: NPopselect,
    NProgress: NProgress,
    NQrCode: QrCode,
    NRadio: NRadio,
    NRadioButton: RadioButton,
    NRadioGroup: NRadioGroup,
    NRate: Rate,
    NResult: Result,
    NRow: NRow,
    NScrollbar: Scrollbar$1,
    NSelect: NSelect,
    NSkeleton: Skeleton,
    NSlider: Slider,
    NSpace: NSpace,
    NSpin: Spin,
    NSplit: Split,
    NStatistic: Statistic,
    NStep: Step,
    NSteps: Steps,
    NSwitch: Switch,
    NTab: Tab,
    NTabPane: TabPane,
    NTable: Table,
    NTabs: Tabs,
    NTag: NTag,
    NTbody: Tbody,
    NTd: Td,
    NText: text,
    NTh: Th,
    NThead: Thead,
    NThing: Thing,
    NTime: Time,
    NTimePicker: NTimePicker,
    NTimeline: Timeline,
    NTimelineItem: TimelineItem,
    NTooltip: NTooltip,
    NTr: Tr,
    NTransfer: Transfer,
    NTree: NTree,
    NTreeSelect: TreeSelect,
    NUl: ul,
    NUpload: Upload,
    NUploadDragger: NUploadDragger,
    NUploadFileList: NUploadFileList,
    NUploadTrigger: NUploadTrigger,
    NVirtualList: VirtualList,
    NWatermark: Watermark,
    NxButton: XButton,
    aProps: aProps,
    affixProps: affixProps,
    alertProps: alertProps,
    anchorLinkProps: anchorLinkProps,
    anchorProps: anchorProps,
    autoCompleteProps: autoCompleteProps,
    avatarGroupProps: avatarGroupProps,
    avatarProps: avatarProps,
    backTopProps: backTopProps,
    badgeProps: badgeProps,
    blockquoteProps: blockquoteProps,
    breadcrumbItemProps: breadcrumbItemProps,
    breadcrumbProps: breadcrumbProps,
    buttonGroupProps: buttonGroupProps,
    buttonProps: buttonProps,
    calendarProps: calendarProps,
    cardProps: cardProps,
    carouselProps: carouselProps,
    cascaderProps: cascaderProps,
    checkboxGroupProps: checkboxGroupProps,
    checkboxProps: checkboxProps,
    codeProps: codeProps,
    colProps: colProps,
    collapseItemProps: collapseItemProps,
    collapseProps: collapseProps,
    collapseTransitionProps: collapseTransitionProps,
    colorPickerProps: colorPickerProps,
    configProviderProps: configProviderProps,
    countdownProps: countdownProps,
    createDiscreteApi: createDiscreteApi,
    dataTableProps: dataTableProps,
    datePickerProps: datePickerProps,
    descriptionsItemProps: descriptionsItemProps,
    descriptionsProps: descriptionsProps,
    dialogProps: dialogProps,
    dialogProviderProps: dialogProviderProps,
    dividerProps: dividerProps,
    drawerContentProps: drawerContentProps,
    drawerProps: drawerProps,
    dropdownProps: dropdownProps,
    dynamicInputProps: dynamicInputProps,
    dynamicTagsProps: dynamicTagsProps,
    elementProps: elementProps,
    ellipsisProps: ellipsisProps,
    emptyProps: emptyProps,
    equationProps: equationProps,
    formItemGiProps: formItemGiProps,
    formItemGridItemProps: formItemGiProps,
    formItemProps: formItemProps,
    formProps: formProps,
    giProps: gridItemProps,
    gradientTextProps: gradientTextProps,
    gridItemProps: gridItemProps,
    gridProps: gridProps,
    h1Props: headerProps,
    h2Props: headerProps,
    h3Props: headerProps,
    h4Props: headerProps,
    h5Props: headerProps,
    h6Props: headerProps,
    iconProps: iconProps,
    iconWrapperProps: iconWrapperProps,
    imageGroupProps: imageGroupProps,
    imageProps: imageProps,
    inputGroupLabelProps: inputGroupLabelProps,
    inputGroupProps: inputGroupProps,
    inputNumberProps: inputNumberProps,
    inputProps: inputProps,
    layoutContentProps: layoutProps,
    layoutFooterProps: layoutFooterProps,
    layoutHeaderProps: headerProps$1,
    layoutProps: layoutProps,
    layoutSiderProps: layoutSiderProps,
    legacyTransferProps: transferProps$1,
    listProps: listProps,
    loadingBarProviderProps: loadingBarProviderProps,
    logProps: logProps,
    mentionProps: mentionProps,
    menuProps: menuProps,
    messageProviderProps: messageProviderProps,
    modalProps: modalProps,
    notificationProviderProps: notificationProviderProps,
    numberAnimationProps: numberAnimationProps,
    olProps: olProps,
    pProps: pProps,
    pageHeaderProps: pageHeaderProps,
    paginationProps: paginationProps,
    popconfirmProps: popconfirmProps,
    popoverProps: popoverProps,
    popselectProps: popselectProps,
    progressProps: progressProps,
    qrCodeProps: qrCodeProps,
    radioButtonProps: radioButtonProps,
    radioGroupProps: radioGroupProps,
    radioProps: radioProps,
    rateProps: rateProps,
    resultProps: resultProps,
    rowProps: rowProps,
    scrollbarProps: scrollbarProps,
    selectProps: selectProps,
    skeletonProps: skeletonProps,
    sliderProps: sliderProps,
    spaceProps: spaceProps,
    spinProps: spinProps,
    splitProps: splitProps,
    statisticProps: statisticProps,
    stepProps: stepProps,
    stepsProps: stepsProps,
    switchProps: switchProps,
    tabPaneProps: tabPaneProps,
    tabProps: tabProps,
    tableProps: tableProps,
    tabsProps: tabsProps,
    tagProps: tagProps,
    textProps: textProps,
    thingProps: thingProps,
    timePickerProps: timePickerProps,
    timeProps: timeProps,
    timelineItemProps: timelineItemProps,
    timelineProps: timelineProps,
    tooltipProps: tooltipProps,
    transferProps: transferProps,
    treeGetClickTarget: treeGetClickTarget,
    treeProps: treeProps,
    treeSelectProps: treeSelectProps,
    ulProps: ulProps,
    uploadProps: uploadProps,
    useDialog: useDialog,
    useDialogReactiveList: useDialogReactiveList,
    useLoadingBar: useLoadingBar,
    useMessage: useMessage,
    useNotification: useNotification,
    virtualListProps: virtualListProps,
    watermarkProps: watermarkProps
  });

  var version = '2.36.0';

  function create({ componentPrefix = 'N', components = [] } = {}) {
      const installTargets = [];
      function registerComponent(app, name, component) {
          const registered = app.component(componentPrefix + name);
          if (!registered) {
              app.component(componentPrefix + name, component);
          }
      }
      function install(app) {
          if (installTargets.includes(app))
              return;
          installTargets.push(app);
          components.forEach((component) => {
              const { name, alias } = component;
              registerComponent(app, name, component);
              if (alias) {
                  alias.forEach((aliasName) => {
                      registerComponent(app, aliasName, component);
                  });
              }
          });
      }
      return {
          version,
          componentPrefix,
          install
      };
  }

  const naive = create({
      components: Object.keys(components).map((key) => components[key])
  });
  var naive$1 = naive;
  naive.install;

  var en = function localize_en(errors) {
    if (!(errors && errors.length)) return
    for (const e of errors) {
      let out;
      switch (e.keyword) {
        case "additionalItems":
        case "items":
          out = "";
          var n = e.params.limit;
          out += "must NOT have more than " + n + " item";
          if (n != 1) {
            out += "s";
          }
          break
        case "additionalProperties":
          out = "must NOT have additional properties";
          break
        case "anyOf":
          out = 'must match a schema in "anyOf"';
          break
        case "const":
          out = "must be equal to constant";
          break
        case "contains":
          out = "must contain a valid item";
          break
        case "dependencies":
        case "dependentRequired":
          out = "";
          var n = e.params.depsCount;
          out += "must have propert";
          if (n == 1) {
            out += "y";
          } else {
            out += "ies";
          }
          out +=
            " " +
            e.params.deps +
            " when property " +
            e.params.property +
            " is present";
          break
        case "discriminator":
          switch (e.params.error) {
            case "tag":
              out = 'tag "' + e.params.tag + '" must be string';
              break
            case "mapping":
              out = 'value of tag "' + e.params.tag + '" must be in oneOf';
              break
            default:
              out = 'must pass "' + e.keyword + '" keyword validation';
          }
          break
        case "enum":
          out = "must be equal to one of the allowed values";
          break
        case "false schema":
          out = "boolean schema is false";
          break
        case "format":
          out = 'must match format "' + e.params.format + '"';
          break
        case "formatMaximum":
        case "formatExclusiveMaximum":
          out = "";
          var cond = e.params.comparison + " " + e.params.limit;
          out += "must be " + cond;
          break
        case "formatMinimum":
        case "formatExclusiveMinimum":
          out = "";
          var cond = e.params.comparison + " " + e.params.limit;
          out += "must be " + cond;
          break
        case "if":
          out = 'must match "' + e.params.failingKeyword + '" schema';
          break
        case "maximum":
        case "exclusiveMaximum":
          out = "";
          var cond = e.params.comparison + " " + e.params.limit;
          out += "must be " + cond;
          break
        case "maxItems":
          out = "";
          var n = e.params.limit;
          out += "must NOT have more than " + n + " item";
          if (n != 1) {
            out += "s";
          }
          break
        case "maxLength":
          out = "";
          var n = e.params.limit;
          out += "must NOT be longer than " + n + " character";
          if (n != 1) {
            out += "s";
          }
          break
        case "maxProperties":
          out = "";
          var n = e.params.limit;
          out += "must NOT have more than " + n + " propert";
          if (n == 1) {
            out += "y";
          } else {
            out += "ies";
          }
          break
        case "minimum":
        case "exclusiveMinimum":
          out = "";
          var cond = e.params.comparison + " " + e.params.limit;
          out += "must be " + cond;
          break
        case "minItems":
          out = "";
          var n = e.params.limit;
          out += "must NOT have less than " + n + " item";
          if (n != 1) {
            out += "s";
          }
          break
        case "minLength":
          out = "";
          var n = e.params.limit;
          out += "must NOT be shorter than " + n + " character";
          if (n != 1) {
            out += "s";
          }
          break
        case "minProperties":
          out = "";
          var n = e.params.limit;
          out += "must NOT have less than " + n + " propert";
          if (n == 1) {
            out += "y";
          } else {
            out += "ies";
          }
          break
        case "multipleOf":
          out = "must be a multiple of " + e.params.multipleOf;
          break
        case "not":
          out = 'must NOT be valid according to schema in "not"';
          break
        case "oneOf":
          out = 'must match exactly one schema in "oneOf"';
          break
        case "pattern":
          out = 'must match pattern "' + e.params.pattern + '"';
          break
        case "patternRequired":
          out =
            'must have property matching pattern "' +
            e.params.missingPattern +
            '"';
          break
        case "propertyNames":
          out = "property name is invalid";
          break
        case "required":
          out = "must have required property " + e.params.missingProperty;
          break
        case "type":
          out = "must be " + e.params.type;
          break
        case "unevaluatedItems":
          out = "";
          var n = e.params.len;
          out += "must NOT have more than " + n + " item";
          if (n != 1) {
            out += "s";
          }
          break
        case "unevaluatedProperties":
          out = "must NOT have unevaluated properties";
          break
        case "uniqueItems":
          out =
            "must NOT have duplicate items (items ## " +
            e.params.j +
            " and " +
            e.params.i +
            " are identical)";
          break
        default:
          out = 'must pass "' + e.keyword + '" keyword validation';
      }
      e.message = out;
    }
  };

  var localizeEn = /*@__PURE__*/getDefaultExportFromCjs(en);

  function renderForm(element) {
    const schema = JSON.parse(element.dataset.schema);
    JSON.parse(element.dataset.uischema);
    const formData = JSON.parse(element.dataset.formdata);
    const inputTextArea = document.getElementById(`id_${element.dataset.name}`);
    nt.useLocal(localizeEn);
    const vueApp = createApp({
      render() {
        return h($a, {
          schema: schema,
          value: formData,
          "on-change": (value) => {
            console.log(value);
            inputTextArea.value = JSON.stringify(value);
          }
        })
      }
    });
    vueApp.use(naive$1);
    vueApp.mount(element);

  }

  document.addEventListener('DOMContentLoaded', () => {
    const forms = document.querySelectorAll('.structured-field-editor');
    for (let i = 0; i < forms.length; i++) {
      renderForm(forms[i]);
    }
  });

})();
